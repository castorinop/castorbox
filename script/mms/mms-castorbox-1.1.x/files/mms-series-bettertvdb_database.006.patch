=== modified file 'common.cpp'
--- old/common.cpp	2009-10-06 16:13:51 +0000
+++ new/common.cpp	2010-11-01 04:06:36 +0000
@@ -497,9 +497,14 @@
 
 string string_format::double_zero(int value)
 {
-  char buffer [512];
-  snprintf(buffer, 512, "%02d", value);
-  return buffer;
+	return string_format::custom_format("%02d", value);
+}
+
+string string_format::custom_format(string format, const int& value) 
+{
+	char buffer [512];
+	snprintf(buffer, 512, format.c_str(), value);
+	return buffer;
 }
 
 string string_format::get_line(const string& text, int &pos, int width, const string& font)

=== modified file 'common.hpp'
--- old/common.hpp	2009-10-06 16:13:51 +0000
+++ new/common.hpp	2010-11-01 04:06:36 +0000
@@ -124,8 +124,11 @@
   /* replaces mblen() for utf-8 strings. This does not depend on LC_CTYPE */
   int utflen(const char *s, size_t n);
 
- /* retunr a string with double zero */
+ /* return a string with double zero */
   std::string double_zero(int value);
+
+ /* return a string with custom format */
+  std::string custom_format(std::string format, const int& value);
 }
 
 namespace time_helper {

=== modified file 'plugins/feature/movie/series.cpp'
--- old/plugins/feature/movie/series.cpp	2010-07-24 02:52:46 +0000
+++ new/plugins/feature/movie/series.cpp	2010-11-02 00:13:33 +0000
@@ -320,14 +320,19 @@
     for (file_iterator<file_t, default_order> i (cur_dir); i != i.end (); i.advance(false)) {
 
       string cur_file = string_format::remove_doubles(i->getName());
-
+	  std::cout << "check_for_changes() checking " << cur_file << std::endl;
       if (isDirectory(cur_file)) {
+	  std::cout << "check_for_changes() dir queued " << cur_file << std::endl;
 	//insert_file_into_db(cur_file, cur_dir, db);
-	queued_dirs.push(cur_file);
-      } else if (!(check_type(cur_file, movie_conf->p_filetypes_m()) == emptyMyPair)) 
-		insert_file_into_db(cur_file);
-	else if (!(check_type(cur_file, movie_conf->p_filetypes_d()) == emptyMyPair))
-		parseXML(cur_file);
+		queued_dirs.push(cur_file);
+  	   } else {
+		std::cout << "check_for_changes() file " << cur_file << std::endl;
+		if (!(check_type(cur_file, movie_conf->p_filetypes_m()) == emptyMyPair)) 
+			insert_file_into_db(cur_file);
+		else if (!(check_type(cur_file, movie_conf->p_filetypes_d()) == emptyMyPair))
+			S_BackgroundUpdater::get_instance()->run_once(boost::bind(&SerieDB::parseXML, this, cur_file));
+		//parseXML(cur_file);
+	  }
     }
   }
 }
@@ -499,11 +504,12 @@
 }
 
 void Series::updated_db() {
-  if (scanning || !visible)
+  if (scanning)
     return;
 
   string serie_str = vector_lookup(series, pos_serie).name;
   pos_serie = 0;
+  series.clear();
   series = getSeries();
   for (int i = 0; i < series.size(); ++i) {
    	if (serie_str == vector_lookup(series, i).name) {
@@ -536,7 +542,9 @@
     }
     show_serie();
   }
-  input_master->add_input(Input(), "");
+
+  if (visible)
+    input_master->add_input(Input(), "");
 }
 
 string Series::mainloop()
@@ -1127,7 +1135,7 @@
     ep.name = ep.name.substr(0, i);  
 
   std::vector<std::string> vec;
-  std::cout << "filename = " << ep.name << std::endl;
+  std::cout << "Series::extract_file_info filename = " << ep.name << std::endl;
 
   // case: serie name - 01x01 - title
   vec = regex_tools::regex_matches(ep.name, "^(.*?) - ([0-9]{1,2})x([0-9]{1,2}) - (.*?)$");
@@ -1223,7 +1231,7 @@
     std::cout << "can't extract season and episode" << std::endl;
   }
 
- std::cout << "serie = " << ep.serie 
+ std::cout << "Series::extract_file_info serie = " << ep.serie 
 		<< ", season = " << conv::itos(ep.season) 
 		<< ", episode = " << conv::itos(ep.episode) 
 		<< ", title = " << ep.title << std::endl;
@@ -1231,27 +1239,6 @@
   return ep;
 }
 
-void Series::check_db_consistency()
-{
-
-  if (!db.hasTable("Files")) {
-    return;
-  }
-
-  db_mutex.enterMutex();
-  SQLQuery *q = db.query("Files", "SELECT filename FROM %t WHERE present = 1");
-  db_mutex.leaveMutex();
-  if (q && q->numberOfTuples() >  0) { 
-    for (int i = 0; i < q->numberOfTuples(); ++i) {
-      string filename = (*q)[i]["filename"].c_str();
-      if (!filesystem::isFile(filename))
-	remove_file_into_db(filename);
-    }
-  } 
-  delete q;
-  db_mutex.leaveMutex();
-}
-
 int Series::files_size() 
 {
   return series.size();
@@ -1295,11 +1282,14 @@
       reload_dir(dir);
 
     // check if a xml file is created */
-    if ((type == NotifyUpdate::WRITE_CLOSE_FILE || type == NotifyUpdate::MOVE)) {
+    if ( type == NotifyUpdate::WRITE_CLOSE_FILE || type == NotifyUpdate::MOVE || 
+				(type == NotifyUpdate::CREATE_FILE && filesystem::getFileSize(path)) /* HARD Links */ ) {
 	if (!(check_type(path, movie_conf->p_filetypes_m()) == emptyMyPair)) 
 		insert_file_into_db(path);
 	else if (!(check_type(path, movie_conf->p_filetypes_d()) == emptyMyPair))
-		parseXML(path);
+		// on backgrond 
+		S_BackgroundUpdater::get_instance()->run_once(boost::bind(&SerieDB::parseXML, this, path));
+		//parseXML(path);
     }
 
 /*    bool reparsed_current_dir = false;

=== modified file 'plugins/feature/movie/series.hpp'
--- old/plugins/feature/movie/series.hpp	2010-02-23 17:18:14 +0000
+++ new/plugins/feature/movie/series.hpp	2010-11-02 00:13:33 +0000
@@ -82,8 +82,6 @@
 
   void startup_updater();
 
-  void check_db_consistency();
-
   std::string mainloop();
 
   int files_size(); // use for get series size

=== modified file 'plugins/feature/movie/series_db.cpp'
--- old/plugins/feature/movie/series_db.cpp	2010-05-27 00:22:41 +0000
+++ new/plugins/feature/movie/series_db.cpp	2010-11-03 00:47:29 +0000
@@ -26,7 +26,7 @@
 using string_format::str_printf;
 
 SerieDB::SerieDB(const string& filename, bool p)
-  : db((conf->p_var_data_dir() + filename).c_str())
+  : db((conf->p_var_data_dir() + filename).c_str()), db_version(2)
 {
   check_db();
 
@@ -56,7 +56,8 @@
   fields.push_back("version INTEGER NOT NULL");
   db.createTable("Schema", fields);
 
-  db.execute("INSERT INTO Schema VALUES('1')");
+  string query = "INSERT INTO Schema VALUES('" + conv::itos(db_version) + "')";
+  db.execute(query.c_str());
 
   fields.clear();
   fields.push_back("id INTEGER PRIMARY KEY");
@@ -97,6 +98,12 @@
   fields.push_back("id_serie INTEGER PRIMARY KEY"); // internal
   fields.push_back("name TEXT");
   fields.push_back("seriesid INTEGER");
+  fields.push_back("lastupdated DATE");
+  db.createTable("Series", fields);
+
+  fields.clear();
+  fields.push_back("name TEXT");
+  fields.push_back("seriesid INTEGER");
   fields.push_back("actors TEXT");
   fields.push_back("airday TEXT");
   fields.push_back("airtime TEXT");
@@ -110,8 +117,7 @@
   fields.push_back("runtime TEXT");
   fields.push_back("status TEXT");
   fields.push_back("lastupdated DATE");
-  db.createTable("Series", fields);
-
+  db.createTable("SerieDesc", fields);
   create_indexes();
 }
 
@@ -128,12 +134,17 @@
 
   db.execute("CREATE INDEX idx_series_name ON Series (name)");
   db.execute("CREATE INDEX idx_series_lname ON Series (lname)");
+
+  db.execute("CREATE INDEX idx_seriesdesc_seriesid ON SerieDesc (seriesid)");
+  db.execute("CREATE INDEX idx_seriesdesc_name ON Series (name)");
+
 }
 
 void SerieDB::check_db()
 {
-  const int chk_version = 2;
+
   int version = 0;
+  vector<string> fields;
 
   if (db.hasTable("Schema")) {
     // check for correct version
@@ -141,25 +152,222 @@
     if (q && q->numberOfTuples() > 0) {
       SQLRow &row = (*q)[0];
       version = conv::atoi(row["version"]);
-
-      if (version < chk_version) {
-        Print print(gettext("Upgrading serie database schema"), Print::INFO);
-
-        switch (version) {
+    }
+  }
+
+  if (version < db_version) {
+     Print print(gettext("Upgrading serie database schema"), Print::INFO);
+
+     switch (version) {
 		case 0:
-			create_db();
+			fields.push_back("version INTEGER NOT NULL");
+			db.createTable("Schema", fields);
+
+			fields.clear();
+			fields.push_back("id INTEGER PRIMARY KEY");
+			fields.push_back("name TEXT");
+			fields.push_back("lastupdated DATE");
+			db.createTable("Helper", fields);
+
+			fields.clear();
+			fields.push_back("id_episode INTEGER");
+			fields.push_back("filename TEXT");
+			fields.push_back("name TEXT");
+			fields.push_back("mtime DATE");
+			fields.push_back("present INTEGER"); // 1 is true
+			db.createTable("Files", fields);
+
+			fields.clear();
+			fields.push_back("id_episode INTEGER PRIMARY KEY"); // internal
+			fields.push_back("id_serie INTEGER"); // internal
+			fields.push_back("id_season INTEGER");
+			fields.push_back("season INTEGER");
+			fields.push_back("episode INTEGER");
+			fields.push_back("seriesid INTEGER");
+			fields.push_back("seasonid INTEGER");
+			fields.push_back("episodeid INTEGER");
+			fields.push_back("viewed INTEGER"); // 1 is true
+			fields.push_back("title TEXT");
+			fields.push_back("rating TEXT");
+			fields.push_back("overview TEXT");
+			fields.push_back("airdate DATE");
+			fields.push_back("guests TEXT");
+			fields.push_back("lang TEXT");
+			fields.push_back("director TEXT");
+			fields.push_back("writer TEXT");
+			fields.push_back("lastupdated DATE");
+			db.createTable("Episode", fields);
+
+			fields.clear();
+			fields.push_back("id_serie INTEGER PRIMARY KEY"); // internal
+			fields.push_back("name TEXT");
+			fields.push_back("seriesid INTEGER");
+			fields.push_back("actors TEXT");
+			fields.push_back("airday TEXT");
+			fields.push_back("airtime TEXT");
+			fields.push_back("airdate DATE");
+			fields.push_back("genre TEXT");
+			fields.push_back("imdbid TEXT");
+			fields.push_back("lang TEXT");
+			fields.push_back("network TEXT");
+			fields.push_back("overview TEXT");
+			fields.push_back("rating TEXT");
+			fields.push_back("runtime TEXT");
+			fields.push_back("status TEXT");
+			fields.push_back("lastupdated DATE");
+			db.createTable("Series", fields);
+
+			db.execute("CREATE INDEX idx_files_name ON Files (name)");
+			db.execute("CREATE INDEX idx_files_filename ON Files (filename)");
+			db.execute("CREATE INDEX idx_files_present ON Files (present)");
+			db.execute("CREATE INDEX idx_episode_title ON Episode (title)");
+			db.execute("CREATE INDEX idx_episode_season ON Episode (season)");
+			db.execute("CREATE INDEX idx_episode_episode ON Episode (episode)");
+			db.execute("CREATE INDEX idx_episode_viewed ON Episode (viewed)");
+			db.execute("CREATE INDEX idx_series_name ON Series (name)");
+
+			db.execute("INSERT INTO Schema VALUES('1')");
+
 		case 1:
 			db.execute("UPDATE Episode SET viewed = 0 WHERE viewed is NULL");
-		//default: check db consistency ?	
-        }
-
-        db.execute(("UPDATE Schema SET version=" + conv::itos(chk_version)).c_str());
-      } 
+
+		case 2:
+			db.execute("ALTER TABLE Series RENAME TO SeriesOLD");
+
+			fields.clear();
+			fields.push_back("id_serie INTEGER PRIMARY KEY"); // internal
+			fields.push_back("name TEXT");
+			fields.push_back("seriesid INTEGER");
+			db.createTable("Series", fields);
+
+			fields.clear();
+			fields.push_back("seriesid INTEGER INTEGER PRIMARY KEY");
+			fields.push_back("title TEXT");
+			fields.push_back("actors TEXT");
+			fields.push_back("airday TEXT");
+			fields.push_back("airtime TEXT");
+			fields.push_back("airdate DATE");
+			fields.push_back("genre TEXT");
+			fields.push_back("imdbid TEXT");
+			fields.push_back("lang TEXT");
+			fields.push_back("network TEXT");
+			fields.push_back("overview TEXT");
+			fields.push_back("rating TEXT");
+			fields.push_back("runtime TEXT");
+			fields.push_back("status TEXT");
+			fields.push_back("lastupdated DATE");
+			db.createTable("SerieDesc", fields);
+
+			// INSERT INTO t1_backup SELECT a,b FROM t1;
+			db.execute("INSERT INTO Series SELECT id_serie, name, seriesid FROM SeriesOLD");
+			db.execute("INSERT INTO SerieDesc SELECT seriesid, name, actors, airday, airtime, airdate, genre, imdbid, lang, network, overview, rating, runtime, status, lastupdated FROM SeriesOLD");
+
+			db.execute("CREATE INDEX idx_seriesdesc_seriesid ON SerieDesc (seriesid)");
+			db.execute("CREATE INDEX idx_seriesdesc_title ON SerieDesc (title)");
+
+			// CleanUP
+			db.execute("DELETE FROM SerieDesc WHERE seriesid IS NULL");
+			
+//		case 3:
+//			db.execute("ALTER TABLE Episode RENAME TO EpisodeOLD");
+
+//			fields.clear();
+//			fields.push_back("id_episode INTEGER PRIMARY KEY"); // internal
+//			fields.push_back("name TEXT");
+//			fields.push_back("epiodeid INTEGER");
+//			db.createTable("Episode", fields);
+
+//			fields.clear();
+//			fields.push_back("episodeid INTEGER INTEGER PRIMARY KEY");
+//			fields.push_back("season INTEGER");
+//			fields.push_back("episode INTEGER");
+//			fields.push_back("seriesid INTEGER");
+//			fields.push_back("seasonid INTEGER");
+//			fields.push_back("title TEXT");
+//			fields.push_back("rating TEXT");
+//			fields.push_back("overview TEXT");
+//			fields.push_back("airdate DATE");
+//			fields.push_back("guests TEXT");
+//			fields.push_back("lang TEXT");
+//			fields.push_back("director TEXT");
+//			fields.push_back("writer TEXT");
+//			fields.push_back("lastupdated DATE");
+//			db.createTable("EpisodeDesc", fields);
+
+//			db.execute("CREATE INDEX idx_episodesdesc_episodeid ON EpisodeDesc (episodeid)");
+//			db.execute("CREATE INDEX idx_episodesdesc_seriesid ON EpisodeDesc (seriesid)");
+//			db.execute("CREATE INDEX idx_episodedesc_title ON EpisodeDesc (title)");
+
+
+
+    } 
+    db.execute(("UPDATE Schema SET version=" + conv::itos(db_version)).c_str());
+  }
+}
+
+void SerieDB::check_db_consistency()
+{
+
+  if (!db.hasTable("Files")) {
+    return;
+  }
+
+  db_mutex.enterMutex();
+  SQLQuery *q = db.query("Files", "SELECT filename FROM %t WHERE present = 1");
+  db_mutex.leaveMutex();
+  if (q && q->numberOfTuples() >  0) { 
+    for (int i = 0; i < q->numberOfTuples(); ++i) {
+      string filename = (*q)[i]["filename"].c_str();
+	  std::cout << "isFile(" << filename << ") = " << filesystem::isFile(filename) << std::endl;
+      if (filesystem::isFile(filename) == false)
+	remove_file_into_db(filename);
     }
-  } else {
-    // create the whole db
-    create_db();
-  }
+  } 
+  delete q;
+
+  // CLEANUP BAD
+  db_mutex.enterMutex();
+  SQLQuery *q2 = db.query("Series", "DELETE FROM %t WHERE name IS NULL or name = '' ");
+  db_mutex.leaveMutex();
+  delete q2;
+
+  db_mutex.enterMutex();
+  SQLQuery *q3 = db.query("Series", "SELECT name FROM %t WHERE seriesid IS NULL");
+  db_mutex.leaveMutex();
+  if (q3 && q3->numberOfTuples() >  0) { 
+	string name;
+    for (int i = 0; i < q3->numberOfTuples(); ++i) {
+		name = (*q3)[i]["name"];
+		std::cout << "Series::check_db_consistency() missing seriesid for "<< name << ", run in background" <<std::endl;
+	  S_BackgroundUpdater::get_instance()->run_once(boost::bind(&SerieDB::fetch_info, this, name));
+	}
+	
+  }
+  delete q3;
+
+  db_mutex.enterMutex();
+  SQLQuery *q4 = db.query("Series", "SELECT Series.seriesid, Series.name, Episode.id_episode, Episode.season, Episode.episode FROM Episode JOIN Series ON Episode.id_serie = Series.id_serie WHERE Episode.seriesid IS NULL OR Episode.title IS NULL OR Episode.title ='' OR Episode.title = 'TBA'");
+  db_mutex.leaveMutex();
+  if (q4 && q4->numberOfTuples() >  0) { 
+	string name;
+	Episode ep;
+	int seriesid, season, episode, id;
+    for (int i = 0; i < q4->numberOfTuples(); ++i) {
+		seriesid = conv::atoi((*q4)[i]["seriesid"]);
+		if (seriesid == 0) 
+			continue;
+		season = conv::atoi((*q4)[i]["season"]);
+		episode = conv::atoi((*q4)[i]["episode"]);
+		id = conv::atoi((*q4)[i]["id_episode"]);
+		ep = tvdb.getEpisode(seriesid, season, episode);
+		ep.id = id;
+		store(ep);
+	  	// S_BackgroundUpdater::get_instance()->run_once(boost::bind(&SerieDB::fetch_infoEpisode, this, ep));
+	}
+	
+  }
+  delete q4;
+
 }
 
 vector<Episode> SerieDB::getEpisodes(int& id_serie, string filter) 
@@ -168,10 +376,21 @@
 
   db_mutex.enterMutex();
 
-  string query = "SELECT * FROM Episode JOIN Files ON Episode.id_episode = Files.id_episode WHERE id_serie = '" + conv::itos(id_serie) + "' AND present = 1"
-	 + (filter.size() > 0 ? " AND " + filter : "")
-	 + " ORDER BY season,episode;";
-  //std::cout << "getEpisodes " << query << std::endl;
+  /* string query = "SELECT * FROM Episode JOIN Files ON Episode.id_episode = Files.id_episode WHERE id_serie = '" + conv::itos(id_serie) + "' AND present = 1"
+	+ " ORDER BY season,episode;"; */
+
+	string query = "SELECT * FROM Episode JOIN Files ON Episode.id_episode = Files.id_episode "
+		"WHERE id_serie IN "
+			"(SELECT id_serie FROM Series "
+				"JOIN SerieDesc ON Series.seriesid = SerieDesc.seriesid "
+				"WHERE imdbid = (SELECT imdbid FROM SerieDesc "
+					"JOIN Series ON Series.seriesid = SerieDesc.seriesid "
+					"WHERE id_serie = '" + conv::itos(id_serie) + "') "
+				"OR id_serie = '" + conv::itos(id_serie) + "') "
+			"AND present = 1"
+	 	+ (filter.size() > 0 ? " AND " + filter : "")
+		 + " ORDER BY season,episode;";
+  std::cout << "getEpisodes " << query << std::endl;
 
   SQLQuery *q = db.query("Episode", query.c_str());
   if (q) {
@@ -202,8 +421,13 @@
   seasons.push_back(Season (dgettext("mms-movie", "all"), list_font));
 
   db_mutex.enterMutex();
-
-  string query = "SELECT season FROM Episode JOIN Files ON Episode.id_episode = Files.id_episode WHERE id_serie = '" + conv::itos(id_serie) + "' AND present = 1 GROUP BY season";
+  string query = "SELECT season FROM Episode "
+		" JOIN Series ON Episode.id_serie = Series.id_serie" 
+		" LEFT JOIN SerieDesc ON Series.seriesid = SerieDesc.seriesid"
+		" JOIN Files ON Episode.id_episode = Files.id_episode"
+		" WHERE Episode.id_serie = '" + conv::itos(id_serie) + "' AND present = 1 GROUP BY season";
+  
+  std::cout << "SerieDB::getSeasons " << query << std::endl;
   SQLQuery *q = db.query("Episode", query.c_str());
   if (q) {
     for (int i = 0; i < q->numberOfTuples(); ++i) {
@@ -228,8 +452,17 @@
   vector<Serie> names;
 
   db_mutex.enterMutex();
-
-  string query = "SELECT Series.id_serie, Series.name, COUNT(Series.id_serie) as episodes, COUNT(Series.id_serie) as episodes, COUNT(case when Episode.viewed = '0' then 1 end) as unviewed FROM Episode JOIN Series ON Episode.id_serie = Series.id_serie JOIN Files ON Episode.id_episode = Files.id_episode WHERE Files.present = 1 GROUP By Series.id_serie ORDER BY Series.name";
+  
+/*	string query = "SELECT Series.id_serie, Series.name, COUNT(Series.id_serie) as episodes, COUNT(Series.id_serie) as episodes, COUNT(case when Episode.viewed = '0' then 1 end) as unviewed FROM Episode JOIN Series ON Episode.id_serie = Series.id_serie JOIN Files ON Episode.id_episode = Files.id_episode WHERE Files.present = 1 GROUP By Series.id_serie ORDER BY Series.name"; */
+	
+	string query = " SELECT Series.id_serie, Series.name, COUNT(Series.id_serie) as episodes, "
+			"COUNT(Series.id_serie) as episodes, COUNT(case when Episode.viewed = '0' then 1 end) as unviewed, "
+			"(CASE imdbid IS NULL WHEN 1 THEN ('noid'||Series.id_serie) ELSE imdbid END) AS imdb "
+		"FROM Episode "
+			"JOIN Series ON Episode.id_serie = Series.id_serie "
+			"LEFT JOIN SerieDesc ON Series.seriesid = SerieDesc.seriesid "
+			"JOIN Files ON Episode.id_episode = Files.id_episode "
+		"WHERE Files.present = 1  GROUP By imdb ORDER BY Series.name"; 
   SQLQuery *q = db.query("Episode", query.c_str());
   if (q) {
     for (int i = 0; i < q->numberOfTuples(); ++i) {
@@ -238,7 +471,7 @@
          Serie ns = Serie();
          ns.id = conv::atoi(row["id_serie"]);
          ns.episodes = conv::atoi(row["episodes"]);
-	 ns.unviewed = conv::atoi(row["unviewed"]);
+	 	 ns.unviewed = conv::atoi(row["unviewed"]);
          ns.name = row["name"];
          ns.seriesid = conv::atoi(row["seriesid"]);
          names.push_back(ns);
@@ -256,20 +489,22 @@
 int SerieDB::find_idSerie(const string& name)
 {
 
-  int id = 0;
-  db_mutex.enterMutex();
+  if (!name.size()) return 0;
 
+  int id = 0;  
   // check if already exists
-  string query = "SELECT id_serie FROM Series WHERE name LIKE '" + name + "'";
-  //std::cout << "query " << query << std::endl;
+  string query = "SELECT id_serie FROM Series WHERE name LIKE '" +  string_format::escape_db_string(name) + "'";
+  std::cout << "SerieDB::find_idSerie query " << query << std::endl;
+  db_mutex.enterMutex();
   SQLQuery *q = db.query("Series", query.c_str());
+  db_mutex.leaveMutex();
   if (q && q->numberOfTuples() > 0) {
     SQLRow &row = (*q)[0];
     id = conv::atoi(row["id_serie"]);
   }
   delete q;
 
-  db_mutex.leaveMutex();
+  std::cout << "SerieDB::find_idSerie id " << id << std::endl;
   return id;
 }
 
@@ -293,6 +528,26 @@
   return finded_id;
 }
 
+int SerieDB::find_idSerieDesc(const int& id)
+{
+
+  int finded_id = 0;
+  db_mutex.enterMutex();
+
+  // check if already exists
+  string query = "SELECT seriesid FROM SerieDesc WHERE seriesid = '" + conv::itos(id) + "'";
+  std::cout << "query " << query << std::endl;
+  SQLQuery *q = db.query("Series", query.c_str());
+  if (q && q->numberOfTuples() > 0) {
+    SQLRow &row = (*q)[0];
+    finded_id = conv::atoi(row["seriesid"]);
+  }
+  delete q;
+
+  db_mutex.leaveMutex();
+  return finded_id;
+}
+
 int SerieDB::find_idEpisode(const int& idSerie, const int& season, const int& episode)
 {
 
@@ -300,7 +555,10 @@
   db_mutex.enterMutex();
 
   // check if already exists
-  string query = "SELECT id_episode FROM Episode WHERE   id_serie = " + conv::itos(idSerie) + " AND episode = " + conv::itos(episode) + " AND season = " + conv::itos(season)+ ""; 
+  string query = "SELECT id_episode FROM Episode WHERE"
+		"( (seriesid = (SELECT seriesid FROM Series WHERE id_serie = " + conv::itos(idSerie) + ") AND id_serie = '0')"
+		" OR id_serie = " + conv::itos(idSerie) + ") "
+		" AND episode = " + conv::itos(episode) + " AND season = " + conv::itos(season)+ ""; 
   //std::cout << "query " << query << std::endl;
   SQLQuery *q = db.query("Episode", query.c_str());
   if (q && q->numberOfTuples() > 0) {
@@ -313,6 +571,25 @@
   return id;
 }
 
+int SerieDB::find_idEpisodeDesc(const int& episodeid)
+{
+
+  int id = 0;
+  db_mutex.enterMutex();
+
+  // check if already exists
+  string query = "SELECT episodeid FROM Episode WHERE episodeid = '" + conv::itos(episodeid) + "'"; 
+  //std::cout << "query " << query << std::endl;
+  SQLQuery *q = db.query("Episode", query.c_str());
+  if (q && q->numberOfTuples() > 0) {
+    SQLRow &row = (*q)[0];
+    id = conv::atoi(row["episodeid"]);
+  }
+  delete q;
+
+  db_mutex.leaveMutex();
+  return id;
+}
 
 int SerieDB::idSerie(const string& name)
 {
@@ -330,6 +607,24 @@
    return id;
 }
 
+int SerieDB::idSerieDesc(const int& seriesid)
+{
+   int id = find_idSerieDesc(seriesid);
+   if (id == 0 && seriesid > 0) {
+     db_mutex.enterMutex();
+     char *tmp_insert = sqlite3_mprintf("INSERT INTO SerieDesc (seriesid) VALUES ('%q')", conv::itos(seriesid).c_str());
+	std::cout << "SerieDB::idSerieDesc SQL "  << tmp_insert << std::endl;
+     db.execute(tmp_insert);
+     sqlite3_free(tmp_insert);
+     id = find_idSerieDesc(seriesid);
+     db_mutex.leaveMutex();
+
+     updated_db();
+   }
+   return id;
+}
+
+
 int SerieDB::idEpisode(const int& idSerie, const int& season, const int& episode)
 {
    int id = find_idEpisode(idSerie, season, episode);
@@ -366,11 +661,23 @@
 
 Serie SerieDB::getSerie(const int& id) 
 {
+  bool present = false;
   Serie ns;
 
+	std::cout << "Serie SerieDB::getSerie(" << id << ")" << std::endl;
   db_mutex.enterMutex();
 
-  string query = "SELECT Series.*, COUNT(Series.id_serie) as episodes FROM Episode JOIN Series ON Episode.id_serie = Series.id_serie JOIN Files ON Episode.id_episode = Files.id_episode WHERE Files.present = 1 AND Series.id_serie = '"+ conv::itos(id) + "' GROUP By Series.id_serie ORDER BY Series.name";
+  string query = "SELECT Series.*, SerieDesc.*, COUNT(Series.id_serie) as episodes "
+				 "FROM Episode "
+				"JOIN Series ON Episode.id_serie = Series.id_serie "
+				"LEFT JOIN SerieDesc ON Series.seriesid = SerieDesc.seriesid "
+				"JOIN Files ON Episode.id_episode = Files.id_episode "
+				"WHERE Series.id_serie = '" + conv::itos(id) + "' "
+				+ (present ? "AND Files.present = 1 " : "") +
+				"GROUP By Series.id_serie ORDER BY Series.name";
+
+  std::cout << "Serie SerieDB::getSerie(" << id << ") query " << query << std::endl;
+
   SQLQuery *q = db.query("Serie", query.c_str());
   if (q && q->numberOfTuples() > 0) {
        SQLRow &row = (*q)[0];
@@ -378,6 +685,7 @@
        ns.seriesid = conv::atoi(row["seriesid"]);
        ns.episodes = conv::atoi(row["episodes"]);
        ns.name = row["name"];
+       ns.title = row["title"];
        ns.actors = row["actors"];
        ns.airdate = row["airdate"];
        ns.airtime = row["airtime"];
@@ -398,12 +706,11 @@
 
 }
 
-bool SerieDB::store(const Serie& se)
+
+bool SerieDB::store(const SerieDesc& se)
 {
-/*	int id; // internal
-	int episodes;
-	int serieid; // website
-	std::string name;
+/*	int serieid; // website
+	std::string title;
 	std::string actors;
 	std::string airdate;
 	std::string airtime;
@@ -422,33 +729,74 @@
 	std::string fanart; */
 	
 //   char *query_sql;
+	std::cout << "SerieDB::store(SerieDesc) " << se.title << " - seriesid = " << se.seriesid << std::endl;
+   int idsd = idSerieDesc(se.seriesid);
+   if (idsd > 0) {
+	   char *query_sql = sqlite3_mprintf("UPDATE SerieDesc SET title = '%q', imdbid='%q', actors = '%q', airdate = '%q', airtime = '%q', genre = '%q', overview = '%q', status = '%q', lastupdated = '%q' WHERE seriesid = '%q'",
+			se.title.c_str(),
+			se.imdbid.c_str(),
+			se.actors.c_str(), 
+			se.airdate.c_str(), 
+			se.airtime.c_str(), 
+			se.genre.c_str(), 
+			se.overview.c_str(), 
+			se.status.c_str(),
+			se.lastupdated.c_str(),
+			conv::itos(idsd).c_str());
+		db_mutex.enterMutex();
+		db.execute(query_sql);
+		std::cout << "SerieDB::store(SerieDesc) " << se.title << " - SQL " << query_sql << std::endl;
+		sqlite3_free(query_sql);
+		db_mutex.leaveMutex();
+  	} else 
+	std::cout << "SerieDB::store(SerieDesc) " << se.title << " - seriesid = 0 :(" << std::endl;
+
+	return true;
+
+};
+
+
+bool SerieDB::store(const Serie& se)
+{
+/*	int id; // internal
+	std::string name;
+	int serieid; */
+	
+//   char *query_sql;
+
+	// Description
+	SerieDesc tmp = static_cast<SerieDesc>(se);
+	tmp.seriesid = se.seriesid;
+	store(tmp);
+
+	if (!se.name.size()) return true;
+
+	// Serie
+	std::cout << "SerieDB::store(Serie) " << se.name << " - id = " << se.id << std::endl;
    int id = idSerie(se.name);
-   if (id > 0) {
-   db_mutex.enterMutex();
-   char *query_sql = sqlite3_mprintf("UPDATE Series SET  SET name = '%q', seriesid = '%q', imdbid='%q', actors = '%q', airdate = '%q', airtime = '%q', genre = '%q', overview = '%q', status = '%q', lastupdated = '%q' WHERE id_serie = '%q'",
-		se.name.c_str(),
-		conv::itos(se.seriesid).c_str(), 
-		se.imdbid.c_str(),
-		se.actors.c_str(), 
-		se.airdate.c_str(), 
-		se.airtime.c_str(), 
-		se.genre.c_str(), 
-		se.overview.c_str(), 
-		se.status.c_str(),
-		se.lastupdated.c_str(),
-		conv::itos(id).c_str());
-
-  db.execute(query_sql);
-  //std::cout << "SQL " << query_sql << std::endl;
-  sqlite3_free(query_sql);
-  db_mutex.leaveMutex();
-  }
-
-  foreach (Episode ep, se.episodes_info) {
-    ep.id_serie = se.id;
-    store(ep);
-  }
-  return true;
+	std::cout << "SerieDB::store(Serie) " << se.name << " g id = " << id << std::endl;
+   if (id > 0 && se.seriesid > 0) {
+	   char *query_sql = sqlite3_mprintf("UPDATE Series SET seriesid='%q' WHERE id_serie = '%q'",
+			conv::itos(se.seriesid).c_str(),
+			conv::itos(id).c_str());
+		db_mutex.enterMutex();
+		db.execute(query_sql);
+		std::cout << "SQL " << query_sql << std::endl;
+		sqlite3_free(query_sql);
+		db_mutex.leaveMutex();
+  
+	  	foreach (Episode ep, se.episodes_info) {
+	    	ep.id_serie = id;
+			ep.seriesid = se.seriesid;
+	    	store(ep);
+	  	}
+	}
+ 
+/*  SQLQuery *q = db.query("Schema", "SELECT seriesid FROM %t");
+    if (q && q->numberOfTuples() > 0) { */
+	
+	return true;
+
 };
 
 
@@ -483,7 +831,7 @@
 
   return ep;
 
-}
+};
 
 bool SerieDB::store(const Episode& se)
 {
@@ -513,7 +861,18 @@
 	int seriesid; */
 	
 //   char *query_sql;
-   int id = idEpisode(se.id_serie, se.season, se.episode);
+
+	
+	if (se.id_serie == 0) {
+		std::cout << "SerieDB::Store(Episode) bad id_serie. try with =" << se.serie << std::endl;
+		return false;
+	}
+   // CHECK IF EXIST
+   Episode tmp;
+   if (se.id)
+	   tmp = getEpisode(se.id);
+
+   int id = (tmp.id > 0 ? tmp.id : idEpisode(se.id_serie, se.season, se.episode));
    {
 
     char *query_sql = sqlite3_mprintf("UPDATE Episode SET seriesid = '%q', seasonid = '%q', episodeid = '%q', title = '%q', airdate = '%q', guests = '%q', lang = '%q', overview = '%q', rating = '%q', director = '%q', writer = '%q', lastupdated = '%q' WHERE id_episode = '%q'",
@@ -533,30 +892,59 @@
 
   db_mutex.enterMutex();
   db.execute(query_sql);
-  //std::cout << "SQL " << query_sql << std::endl;
+  std::cout << "SQL " << query_sql << std::endl;
   sqlite3_free(query_sql);
   db_mutex.leaveMutex();
   }
   return true;
 };
 
-void SerieDB::fetch_info(const Episode& ep)
-{
-	//std::cout << "SerieDB::fetch_info(" << ep.serie << ") " << std::endl;
-
-	Serie sl = getSerie(ep.serie);
-
+void SerieDB::fetch_infoEpisode(const Episode& ep)
+{
+	std::cout << "SerieDB::fetch_infoEpisode find by name" << std::endl;
+	Serie s = getSerie(ep.serie);
+	if (s.seriesid <= 0) { // fetch full serie
+		std::cout << "SerieDB::fetch_infoEpisode fetch serie by name" << std::endl;
+		fetch_info(ep.serie);
+		return;
+	}
+	Episode e = getEpisode(ep.id);
+	if (e.episodeid <= 0) {
+		std::cout << "SerieDB::fetch_infoEpisode fetch single episode" << std::endl;
+		// single episode.
+		Episode tvep = tvdb.getEpisode(s.seriesid, ep.season, ep.episode);
+		tvep.id = ep.id; // copy id episode
+		store (tvep);
+	}
+
+}
+
+void SerieDB::fetch_info(const string& serie_name)
+{
+	if (!serie_name.size()) {
+		std::cout << "SerieDB::fetch_info(" << serie_name << ") bad usage" << std::endl;
+		return;
+	}
+	string query = "SELECT seriesid FROM Series WHERE name = '" + serie_name + "'";
+
+	std::cout << "SerieDB::fetch_info(" << serie_name << ") start" << std::endl;
+	Serie sl = getSerie(serie_name);
 	// detect if retrived web info 
 	if (sl.seriesid <= 0) {
 		//std::cout << "retriving " << ep.serie << std::endl;
-		Serie tvdbs = tvdb.getSerie(ep.serie);
+		Serie tvdbs = tvdb.getSerie(serie_name);
 		tvdbs.id = sl.id;
 		tvdbs.name = sl.name; // keep the original title
+		std::cout << "SerieDB::fetch_info(" << serie_name << ") name=" << sl.name << std::endl;
 		if (tvdbs.seriesid > 0) {
 			store(tvdbs);
 			fetch_info_imgs(tvdbs);
 		}
+	} else {
+
+		
 	}
+	std::cout << "SerieDB::fetch_info(" << serie_name << ") ends" << std::endl;
 }
 
 void SerieDB::fetch_info_imgs(const Serie& tvdbs, bool force)
@@ -596,7 +984,7 @@
   if (q && q->numberOfTuples() > 0) {
     delete q;
     char *query_sql = sqlite3_mprintf("UPDATE Files SET present = 1 WHERE filename LIKE '%q%';", 
-		string_format::escape_db_string(good_filename).c_str());
+		good_filename.c_str());
      //std::cout << "SQL " << query_sql << std::endl;
      db.execute(query_sql);
      sqlite3_free(query_sql);
@@ -617,9 +1005,10 @@
 
   int id_serie = idSerie(ep.serie);
   int id_episode = idEpisode(id_serie, ep.season, ep.episode);
+  ep.id = id_episode;
 
   Episode dbep = getEpisode(id_episode);
- 
+
   if (dbep.title.size() == 0 && ep.title.size() > 0) {
 	dbep.title = ep.title;
 	store(dbep);
@@ -639,7 +1028,7 @@
   db_mutex.leaveMutex();
 
   updated_db();
-  S_BackgroundUpdater::get_instance()->run_once(boost::bind(&SerieDB::fetch_info, this, ep));
+  S_BackgroundUpdater::get_instance()->run_once(boost::bind(&SerieDB::fetch_infoEpisode, this, ep));
 
 }
 
@@ -660,7 +1049,7 @@
 
   db_mutex.enterMutex();
   char *query_sql = sqlite3_mprintf("UPDATE Files SET present = 0 WHERE filename LIKE '%q%%';", 
-		string_format::escape_db_string(good_filename).c_str());
+		good_filename.c_str());
   //std::cout << "SQL " << query_sql << std::endl;
   db.execute(query_sql);
   sqlite3_free(query_sql);
@@ -719,23 +1108,31 @@
 {
 
   Serie updSerie;
+  Episode updEpisode;
+  int localstamp = getServerTime("tvdb");
+  int servestamp = tvdb.getLastUpdate();
 
-  int timestamp = getServerTime("tvdb");
-  if (timestamp != 0) {
-    std::vector<int> series = tvdb.getUpdates(timestamp);
+  if (localstamp != 0) {
+    std::vector<int> series = tvdb.getUpdates(localstamp, "series");
     foreach(int& serieid, series) {
-	if (find_idSerie(serieid) > 0) { // check if exist serie
-	  updSerie = tvdb.getSerie(serieid);
-	  store(updSerie);
-	  tvdb.getBanner(updSerie, serie_dir);
-	  tvdb.getFanart(updSerie, serie_dir);
-	}
-    }
-  
-  } else {
-    timestamp = tvdb.getLastUpdate();
+		if (find_idSerieDesc(serieid) > 0) { // check if exist serie
+		  std::cout << "SerieDB::getUpdates() update serieid=" << serieid << std::endl;
+		  updSerie = tvdb.getSerie(serieid);
+		  store(updSerie);
+		  tvdb.getBanner(updSerie, serie_dir);
+		  tvdb.getFanart(updSerie, serie_dir);
+		}
+  	}
+	std::vector<int> episodes = tvdb.getUpdates(localstamp, "episode");
+    foreach(int& episodeid, series) {
+		if (find_idEpisodeDesc(episodeid) > 0) { // check if exist episode
+		  std::cout << "SerieDB::getUpdates() update episodeid=" << episodeid << std::endl;
+		  updEpisode = tvdb.getEpisode(episodeid);
+		  store(updEpisode);
+		}
+  	}	
   }
-  setServerTime("tvdb", timestamp);
+  setServerTime("tvdb", servestamp);
 }
 
 void SerieDB::parseXML(const std::string& path)
@@ -759,40 +1156,66 @@
   }
 
   TiXmlHandle myhandle(&doc);
-  int id;
-  string buff;
+  string id, buff;
 
   // Try get title and id from imdbXML 
   if ((text = myhandle.FirstChild("imdbXML").FirstChild("imdbID").FirstChild().Text()) != NULL)  {
-	id = conv::atoi(text->Value()); 
-        if ((text = myhandle.FirstChild("imdbXML").FirstChild("title").FirstChild().Text()) != NULL) {
-		buff = string_format::ConvertHTMLToAnsi(text->Value());
-
-		std::cout << "SerieDB::parseXML: finded with id = " << conv::itos(id) << std::endl;
-
-		std::string query = " SELECT id_serie "
-			"FROM Series "
-			"WHERE imdbid = '" + conv::itos(id) + "'";
-       		std::cout << "SerieDB::parseXML: query " << query << std::endl;
-
-		db_mutex.enterMutex();
-		SQLQuery *q = db.query("Episode", query.c_str());
-		db_mutex.leaveMutex();
-
-        	if (q && q->numberOfTuples() == 0 ) {
-        		std::cout << "SerieDB::parseXML: need fetch from Helper..." << std::endl;
-		        Serie s = tvdb.getSerie(buff,id);
-			s.name = buff; // FORCE IMDB title;
-        		std::cout << "SerieDB::parseXML: serie: " << s.name << std::endl;
-        		store(s);
-			S_BackgroundUpdater::get_instance()->run_once(boost::bind(&SerieDB::fetch_info_imgs, this, s, true));
-       		}
-		delete q;
-
-     	} else 
-		std::cout << "SerieDB::parseXML: missing imdbXML title" << std::endl;
+		id = text->Value(); 
+    if ((text = myhandle.FirstChild("imdbXML").FirstChild("title").FirstChild().Text()) != NULL) {
+			buff = string_format::ConvertHTMLToAnsi(text->Value());
+			
+			// std::cout << "SerieDB::parseXML: " << buff << " - finded with imdbid = " << id << std::endl;
+
+			// Checking if exist Description
+			std::string query = " SELECT seriesid "
+				"FROM SerieDesc "
+				"WHERE imdbid = '" + (id) + "'";
+
+			//std::cout << "SerieDB::parseXML: " << buff << " - SQL " << query << std::endl;
+			db_mutex.enterMutex();
+			SQLQuery *q = db.query("Episode", query.c_str());
+			db_mutex.leaveMutex();
+
+			// std::cout << "SerieDB::parseXML: "<< buff << " RS " << q->numberOfTuples() << std::endl;
+			if (q && q->numberOfTuples() == 0 ) {
+				std::cout << "SerieDB::parseXML: " << buff << " - finded with imdbid = " << id << std::endl;
+  	 			std::cout << "SerieDB::parseXML: need fetch from Helper..." << std::endl;
+				Serie s = tvdb.getSerieByImdb(conv::atoi(id));
+				s.name = buff; // FORCE IMDB title;
+        		std::cout << "SerieDB::parseXML: serie: " << s.name << ", "<< s.seriesid << std::endl;
+		        store(s);
+				S_BackgroundUpdater::get_instance()->run_once(boost::bind(&SerieDB::fetch_info_imgs, this, s, true));
+			} else {
+
+				// Checking if exist relation Serie <==> Description
+				SQLRow &row = (*q)[0];
+  	 			
+				query = " SELECT id_serie, seriesid "
+					"FROM Series "
+					"WHERE name = '" + string_format::escape_db_string(buff) + "' AND seriesid = '" + row["seriesid"] + "'";
+
+				//std::cout << "SerieDB::parseXML: " << buff << " - SQL " << query << std::endl;
+				db_mutex.enterMutex();
+				SQLQuery *q2 = db.query("Series", query.c_str());
+				db_mutex.leaveMutex();
+
+				if (q2 && q2->numberOfTuples() == 0 ) {
+					std::cout << "SerieDB::parseXML: need fetch from Helper..." << std::endl;
+					Serie se = Serie();
+					se.seriesid = conv::atoi(row["seriesid"]);
+					se.id = conv::atoi(row["id_serie"]);
+					se.name = buff; // FORCE IMDB title;
+		    		std::cout << "SerieDB::parseXML: serie: " << se.name << ", "<< se.seriesid << std::endl;
+				    store(se);
+				}
+				delete q2; 
+			}
+			delete q;
+			
+
+		} else 
+			std::cout << "SerieDB::parseXML: missing imdbXML title" << std::endl;
   } else 
 	std::cout << "SerieDB::parseXML: missing imdbXML id" << std::endl;
 
 }
-

=== modified file 'plugins/feature/movie/series_db.hpp'
--- old/plugins/feature/movie/series_db.hpp	2010-05-26 23:21:11 +0000
+++ new/plugins/feature/movie/series_db.hpp	2010-11-02 00:13:33 +0000
@@ -16,10 +16,15 @@
 
 class SerieDB : public MovieTemplate<Multifile>
 {
+
 private:
+  const int db_version;
+
   int find_idSerie(const std::string& name);
   int find_idSerie(const int& id);
+  int find_idSerieDesc(const int& id);
   int find_idEpisode(const int& idSerie, const int& season, const int& episode);
+  int find_idEpisodeDesc(const int& episodeid);
   tvdbcom::helper tvdb;
 
 protected:
@@ -28,6 +33,7 @@
   virtual Episode extract_file_info(const std::string& filename) = 0;
   virtual void updated_db() = 0;
 
+  void check_db_consistency();
   void insert_file_into_db(const std::string& filename);
   void remove_file_into_db(const std::string& filename);
 
@@ -41,6 +47,7 @@
   void create_indexes();
 
   int idSerie(const std::string& name);
+  int idSerieDesc(const int& seriesid);
   int idEpisode(const int& idSerie, const int& season, const int& episode);
 
   std::vector<Episode> getEpisodes(int& id_serie, std::string season_filter = NULL);
@@ -52,6 +59,7 @@
   Episode getEpisode(const int& id);
 
   bool store(const Serie& se);
+  bool store(const SerieDesc& se);
   bool store(const Episode& ee);
 
   int getServerTime(const std::string name);
@@ -70,7 +78,8 @@
   SerieDB(const std::string& filename, bool physical);
 
   void fetch_info_imgs(const Serie& sl, bool force = false);
-  void fetch_info(const Episode& ep);
+  void fetch_infoEpisode(const Episode& ep);
+  void fetch_info(const std::string& serie_name);
 
   void parseXML(const std::string& path);
 

=== modified file 'plugins/feature/movie/series_element.hpp'
--- old/plugins/feature/movie/series_element.hpp	2010-03-03 22:49:22 +0000
+++ new/plugins/feature/movie/series_element.hpp	2010-11-02 00:13:33 +0000
@@ -34,7 +34,7 @@
 	int seasonid;
 	int seriesid;
 
-	Episode() : id(0), season(0), episode(0), viewed(false), episodeid(0), seasonid(0), seriesid(0), title("") {}
+	Episode() : id(0), id_serie(0), season(0), episode(0), viewed(false), episodeid(0), seasonid(0), seriesid(0), title("") {}
 
 	bool operator==(const Episode& rhs) const
 	{
@@ -44,14 +44,12 @@
 
 typedef std::vector<Episode> listEpisodes;
 
-class Serie
+
+class SerieDesc
 {
 public:
-	int id; // internal
-	int episodes;
-	int unviewed;
 	int seriesid; // website
-	std::string name;
+	std::string title;
 	std::string actors;
 	std::string airdate;
 	std::string airtime;
@@ -70,12 +68,30 @@
 	std::string fanart;
 	listEpisodes episodes_info;
 
-	Serie() : id(0), episodes(0), seriesid(0), unviewed(0) {}
+	SerieDesc() : seriesid(0) {}
+
+	bool operator==(const SerieDesc& rhs) const
+	{
+		  return seriesid == rhs.seriesid;
+	}
+};
+
+class Serie : public SerieDesc
+{
+public:
+	int id; // internal
+	std::string name;
+	int episodes;
+	int unviewed;	
+	int seriesid; // website
+
+	Serie() : SerieDesc(), episodes(0), seriesid(0), unviewed(0) {}
 
 	bool operator==(const Serie& rhs) const
 	{
 		  return id == rhs.id;
 	}
+
 };
 
 class Season

=== modified file 'plugins/feature/movie/series_helper.hpp'
--- old/plugins/feature/movie/series_helper.hpp	2010-05-26 23:11:11 +0000
+++ new/plugins/feature/movie/series_helper.hpp	2010-11-02 00:13:33 +0000
@@ -12,7 +12,8 @@
         ost::Mutex web_mutex;
 
 	virtual Serie getSerie(const int& id) = 0;
-	virtual Serie getSerie(const std::string& name, const int imdb) = 0;
+	virtual Serie getSerie(const std::string& name) = 0;
+	virtual Serie getSerieByImdb(const int& imdb) = 0;
 	virtual Episode getEpisode(const int& id) = 0;
 	virtual Episode getEpisode(const int& idSerie, const int& season, const int& episode) = 0;
 	//virtual Episode getEpisode(const int& serie, const int& episode) = 0;
@@ -20,6 +21,10 @@
 	virtual void getFanart(const Serie& sr, const std::string path, bool force) = 0;
 	virtual void getCover(const Episode& sr, const std::string path, bool force) = 0;
 
+	std::string fixImdbid(const int& id) 
+	{
+	}
+
 	void download(const std::string& url, const std::string& filename, bool force = false)
 	{
 	  std::string filename_tmp =  filename + ".tmp";
@@ -62,7 +67,9 @@
 	void getMirrors();
 	std::string getMirror(const int mask = 7);
 	void getLanguages();
-        std::string getLang();
+	std::string getLang();
+
+	Episode fetchEpisode(const std::string& url);
 	Episode parseEpisode(TiXmlElement* item);
 	Serie parseSerie(TiXmlElement* item);
 
@@ -70,10 +77,11 @@
 	helper();
 
         int getLastUpdate();
-        std::vector<int> getUpdates(const int timestamp = 0);
+        std::vector<int> getUpdates(const int timestamp, const std::string type);
 
 	Serie getSerie(const int& id);
-	Serie getSerie(const std::string& name, const int imdbid = 0);
+	Serie getSerie(const std::string& name);
+	Serie getSerieByImdb(const int& imdbid);
 	Episode getEpisode(const int& id);
 	Episode getEpisode(const int& idSerie, const int& season, const int& episode);
 	//Episode getEpisode(const int& serie, const int& episode) {} 

=== modified file 'plugins/feature/movie/series_helper_tvdbcom.cpp'
--- old/plugins/feature/movie/series_helper_tvdbcom.cpp	2010-07-24 02:18:50 +0000
+++ new/plugins/feature/movie/series_helper_tvdbcom.cpp	2010-11-02 00:13:33 +0000
@@ -128,58 +128,60 @@
 }
 
 
-std::vector<int> tvdbcom::helper::getUpdates(const int timestamp)
+std::vector<int> tvdbcom::helper::getUpdates(const int timestamp, const string type)
 {
 
-        std::vector<int> upd_series;
+    std::vector<int> upd_series;
 
 	TiXmlDocument xmldoc;
 	TiXmlElement* item;
 	TiXmlText *text;
 
-	std::string buff;
+	std::string buff, typeTag;
 	int startpos = 0;
-        int tmp;
+    int tmp;
+	string typo = string_format::lowercase(type);
+	if ( typo == "series")
+		typeTag = "Series";
+	else
+		typeTag = "Episode";
 	
-
-	std:: string url = "http://www.thetvdb.com/api/Updates.php?type=series&time=" + conv::itos(timestamp);
+	std:: string url = "http://www.thetvdb.com/api/Updates.php?type=" + string_format::lowercase(typeTag) + "&time=" + conv::itos(timestamp);
 
 	if (!WgetWrapper::download(url, buff)) {
 		std::cout << "fetch failed!" << std::endl;
     		return upd_series;
         }
 
-	if((startpos = buff.find("<?xml")) != string::npos)
-	    {
+	if((startpos = buff.find("<?xml")) != string::npos) {
 		xmldoc.Parse(buff.substr(startpos).c_str(), 0, TIXML_ENCODING_UNKNOWN);
-		if (!xmldoc.Error())
-		{	
+		if (!xmldoc.Error()) {	
 		     TiXmlHandle myhandle(&xmldoc);
 		   /*  if ((text = myhandle.FirstChild("Items").FirstChild("Time").FirstChild().Text()) != NULL)  {
 					new_timestamp = conv::atoi(text->Value()); 
 					std::cout << "finded with Items.Time = " << conv::itos(new_timestamp) << std::endl;
 		     } else std::cout << "can't find Items.Time" << std::endl; */
 
-	          if (timestamp != 0) {
- 		    item = myhandle.FirstChild("Items").FirstChild("Series").Element();
-		    for ( item; item; item = item->NextSiblingElement("Series") ) {
-			tmp = conv::atoi(item->FirstChild()->Value());
-			//std::cout << "idSeries " << tmp << std::endl;
-			if (tmp > 0)
-			  upd_series.push_back(tmp);
-		    }
-                  }
+			if (timestamp != 0) {
+ 			    item = myhandle.FirstChild("Items").FirstChild( typeTag.c_str() ).Element();
+			    for ( item; item; item = item->NextSiblingElement( typeTag.c_str() ) ) {
+					tmp = conv::atoi(item->FirstChild()->Value());
+					//std::cout << "idSeries " << tmp << std::endl;
+					if (tmp > 0)
+					  upd_series.push_back(tmp);
+		    	}
+			}
 
 		} else std::cout << "can't parse Updates xml" << std::endl;
- 	    } else  std::cout << "bad Updates xml" << std::endl;
+	} else  std::cout << "bad Updates xml" << std::endl;
         
 	return upd_series;
 }
 
 
-Serie tvdbcom::helper::getSerie(const std::string& name, const int imdb)
+Serie tvdbcom::helper::getSerie(const std::string& name)
 {
-        std::cout << "tvdbcom::helper::getSerie ("<< name << ", " << imdb << ")" << std::endl;
+    std::cout << "tvdbcom::helper::getSerie ("<< name << ")" << std::endl;
 	TiXmlDocument xmldoc;
 	TiXmlElement* item;
 	TiXmlText *text;
@@ -218,33 +220,15 @@
 
 		if (!xmldoc.Error())
 		{	
-		     if ((item = xmldoc.RootElement()) != NULL ) {
-			     std::cout << "have root element!" <<  std::endl;
-                     }
-
-		     TiXmlHandle myhandle(&xmldoc);
-
-		    item = myhandle.FirstChild("Data").FirstChild("Series").Element();
-		    for ( item; item; item = item->NextSiblingElement("Series") ) {
-			tmp = 0;
-                	TiXmlHandle itemhd(item);
-			if ((text = itemhd.FirstChild("SeriesName").FirstChild().Text()) != NULL)
-				std::cout << "getSerie check title: " << text->Value() << std::endl; 
-			if ((text = itemhd.FirstChild("IMDB_ID").FirstChild().Text()) != NULL)  {
-				std::cout << "getSerie get IMDB: " << regex_tools::regex_replace(text->Value(), "", "t") << std::endl;
-				tmp = conv::atoi(regex_tools::regex_replace(text->Value(), "", "t"));
+		    if ((item = xmldoc.RootElement()) != NULL ) {
+				std::cout << "have root element!" <<  std::endl;
 			}
-			
-			std::cout << "getSerie check imdb: " << imdb << " == " << tmp << std::endl; 
-			if (imdb == 0 || imdb == tmp) {
-				if ((text = itemhd.FirstChild("seriesid").FirstChild().Text()) != NULL)  {
+
+		    TiXmlHandle myhandle(&xmldoc);
+			if ((text = myhandle.FirstChild("Data").FirstChild("Series").FirstChild("seriesid").FirstChild().Text()) != NULL)  {
 					id = conv::atoi(text->Value()); 
-					std::cout << "getSerie finded with id = " << conv::itos(id) << std::endl;
-					break;
-	     			} else std::cout << "can't find Data.Series.seriesid" << std::endl;
-				if (imdb == 0) break;
-			}
-		    }
+					std::cout << "finded with id = " << conv::itos(id) << std::endl;
+			} else std::cout << "can't find Data.Series.seriesid" << std::endl;
 
 		} else {
 			printf( "Error in %s: %s\n", xmldoc.Value(), xmldoc.ErrorDesc() );
@@ -295,7 +279,7 @@
 		       item = NULL;
 		       item = myhandle.FirstChild("Data").FirstChild("Episode").Element();
 		       Episode ep;
-		       std::cout << "first Episode ?! " << item << std::endl;  
+		    //   std::cout << "first Episode ?! " << item << std::endl;  
 
 		        for ( item; item; item = item->NextSiblingElement("Episode") ) {
 				ep = parseEpisode(item);
@@ -312,34 +296,110 @@
 
 }
 
+Serie tvdbcom::helper::getSerieByImdb(const int& imdb)
+{
+	std::cout << "tvdbcom::helper::getSerieByImdb (" << imdb << ")" << std::endl;
+	TiXmlDocument xmldoc;
+	TiXmlElement* item;
+	TiXmlText *text;
+
+	std::string strImdb = string_format::custom_format("tt%07d", imdb);
+	std::cout << "tvdbcom::helper::getSerieByImdb strImdb=" << strImdb << std::endl;
+
+	std:: string url = getMirror() + "/api/GetSeriesByRemoteID.php?imdbid=" + strImdb + "&language=" + getLang();
+	std::cout << "tvdbcom::helper::getSeriebyImdb(" << imdb << ") " << url << std::endl;
+	std::string buff;
+	int startpos = 0;
+        int id = 0;
+	int tmp = 0;
+
+	if (!WgetWrapper::download(url, buff)) {
+		std::cout << "cant download url!" << std::endl;
+		Serie tmp;
+    		return tmp;
+        }
+
+	buff = regex_tools::regex_replace(buff, "\n", "\r", true, true);
+	buff = regex_tools::regex_replace(buff, "\n", "\n\n", true, true);
+	
+
+	if((startpos = buff.find("<?xml")) != string::npos)
+	    {
+		if(xmldoc.Parse(buff.substr(startpos).c_str(), 0 , TIXML_ENCODING_UNKNOWN))
+		{	
+		     std::cout << "good for you! parsed !" <<  std::endl;
+		     TiXmlHandle myhandle(&xmldoc);
+		}
+	    } else  std::cout << "bad getSeries xml" << std::endl;
+
+	if((startpos = buff.find("<?xml")) != string::npos)
+	    {
+		if (!xmldoc.Parse(buff.substr(startpos).c_str(), 0, TIXML_ENCODING_UNKNOWN)) {
+		  std::cout << "Error: " << xmldoc.ErrorDesc() << " in: "<< xmldoc.ErrorRow() << ", " << xmldoc.ErrorCol() << std::endl;
+		}
+
+		if (!xmldoc.Error())
+		{	
+		     if ((item = xmldoc.RootElement()) != NULL ) {
+			     std::cout << "have root element!" <<  std::endl;
+                     }
+
+		     TiXmlHandle myhandle(&xmldoc);
+
+		    item = myhandle.FirstChild("Data").FirstChild("Series").Element();
+		    for ( item; item; item = item->NextSiblingElement("Series") ) {
+                TiXmlHandle itemhd(item);
+				if ((text = itemhd.FirstChild("seriesid").FirstChild().Text()) != NULL)  {
+					id = conv::atoi(text->Value()); 
+					std::cout << "getSerie finded with id = " << conv::itos(id) << std::endl;
+					break;
+	     		} else std::cout << "can't find Data.Series.seriesid" << std::endl;
+		    }
+
+		} else {
+			printf( "Error in %s: %s\n", xmldoc.Value(), xmldoc.ErrorDesc() );
+			
+			std::cout << "can't parse xml" << std::endl;
+		}
+ 	   } else  std::cout << "bad xml" << std::endl;
+	std::cout << "finded with id = " << conv::itos(id) << std::endl;
+	return getSerie(id);
+}
+
+
 Episode tvdbcom::helper::getEpisode(const int& id)
 {
-	std:: string mirrors_url = getMirror() + "/api/" + api_key + "/episodes/" + conv::itos(id) + "/" +  getLang() + ".xml";
+
+	std:: string url = getMirror() + "/api/" + api_key + "/episodes/" + conv::itos(id) + "/" +  getLang() + ".xml";
+	std::cout << "tvdbcom::helper::getEpisode URL = " << url << std::endl;
+	return fetchEpisode(url);
 }
 
 Episode tvdbcom::helper::getEpisode(const int& idSerie, const int& season, const int& episode)
 {
 
-	Episode tmp;
-
-	if (idSerie == 0)
-	  return tmp;
-
-	TiXmlDocument xmldoc;
-	TiXmlElement* item;
-	TiXmlText *text;
-
-	std::string buff;
-	int startpos = 0;
-
 	// example url: http://www.thetvdb.com/api/E13072066C2EF10D/series/80348/default/1/1/en.xml
 	std:: string url = getMirror() + "/api/" + api_key + "/series/" + conv::itos(idSerie) + "/default/" +  
 					conv::itos(season) + "/" +  conv::itos(episode) + "/" + getLang() + ".xml";
 	std::cout << "tvdbcom::helper::getEpisode(" << conv::itos(idSerie) << "," << conv::itos(season) << "," << conv::itos(episode) << ") " << url << std::endl;
-
+	return fetchEpisode(url);
+}
+
+
+Episode tvdbcom::helper::fetchEpisode(const std::string& url)
+{
+
+	Episode tmp;
+
+	TiXmlDocument xmldoc;
+	TiXmlElement* item;
+	TiXmlText *text;
+
+	std::string buff;
+	int startpos = 0;
 
 	if (!WgetWrapper::download(url, buff)) {
-		std::cout << "fetch failed!" << std::endl;
+		std::cout << "tvdbcom::helper::fetchEpisode - fetch failed! = " << url << std::endl;
     		return tmp;
         }
 
@@ -348,13 +408,13 @@
 		xmldoc.Parse(buff.substr(startpos).c_str(), 0, TIXML_ENCODING_UNKNOWN);
 		if (!xmldoc.Error())
 		{	
-		     std::cout << "startup parsing Episode.xml" << std::endl;
+		     std::cout << "tvdbcom::helper::fetchEpisode - startup parsing Episode.xml" << std::endl;
 		     TiXmlHandle myhandle(&xmldoc);
-	             item = myhandle.FirstChild("Data").FirstChild("Episode").Element();
+	         item = myhandle.FirstChild("Data").FirstChild("Episode").Element();
 		     tmp = parseEpisode(item);
-		     std::cout << "ending parsing Episode.xml" << std::endl;
-		} else std::cout << "can't parse episode xml" << std::endl;
- 	    } else  std::cout << "bad episode xml" << std::endl;
+		     std::cout << "tvdbcom::helper::fetchEpisode - ending parsing Episode.xml" << std::endl;
+		} else std::cout << "tvdbcom::helper::fetchEpisode - can't parse episode xml" << std::endl;
+ 	    } else  std::cout << "tvdbcom::helper::fetchEpisode - bad episode xml" << std::endl;
 
 	return tmp;
 
@@ -436,7 +496,7 @@
 	//   <SeriesID>75146</SeriesID> IGNORED!!!!
 	//   <SeriesName>Fringe</SeriesName>
 	if ((text = handle.FirstChild("SeriesName").FirstChild().Text()) != NULL)
-		tmp.name = string_format::ConvertHTMLToAnsi(text->Value());
+		tmp.title = string_format::ConvertHTMLToAnsi(text->Value());
 	//   <Status>Continuing</Status>
 	if ((text = handle.FirstChild("Status").FirstChild().Text()) != NULL)
 		tmp.status = string_format::ConvertHTMLToAnsi(text->Value());

