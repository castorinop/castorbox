diff --speed-large-files --minimal -Nru tmp/Torch3/core/.deps_Linux_OPT_FLOAT work/main.d/Torch3/core/.deps_Linux_OPT_FLOAT
--- tmp/Torch3/core/.deps_Linux_OPT_FLOAT	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch3/core/.deps_Linux_OPT_FLOAT	2008-02-07 11:32:36.000000000 -0200
@@ -0,0 +1,116 @@
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Allocator.o: Allocator.cc Allocator.h general.h Object.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Bagging.o: Bagging.cc Bagging.h Trainer.h Object.h general.h Allocator.h \
+  Machine.h DataSet.h Sequence.h List.h PreProcessing.h Stack.h \
+  Measurer.h XFile.h WeightedSumMachine.h Random.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Boosting.o: Boosting.cc Boosting.h Trainer.h Object.h general.h \
+  Allocator.h Machine.h DataSet.h Sequence.h List.h PreProcessing.h \
+  Stack.h Measurer.h XFile.h WeightedSumMachine.h ClassFormat.h \
+  BoostingMeasurer.h Random.h NullXFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/BoostingMeasurer.o: BoostingMeasurer.cc BoostingMeasurer.h Measurer.h \
+  Object.h general.h Allocator.h Machine.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h XFile.h ClassFormat.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassFormat.o: ClassFormat.cc ClassFormat.h Object.h general.h \
+  Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassFormatDataSet.o: ClassFormatDataSet.cc ClassFormatDataSet.h \
+  DataSet.h Object.h general.h Allocator.h Sequence.h List.h \
+  PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassMeasurer.o: ClassMeasurer.cc ClassMeasurer.h Measurer.h Object.h \
+  general.h Allocator.h Machine.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h XFile.h ClassFormat.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassNLLMeasurer.o: ClassNLLMeasurer.cc ClassNLLMeasurer.h Measurer.h \
+  Object.h general.h Allocator.h Machine.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h XFile.h ClassFormat.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/CmdLine.o: CmdLine.cc CmdLine.h Object.h general.h Allocator.h \
+  CmdOption.h DiskXFile.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/CmdOption.o: CmdOption.cc CmdOption.h Object.h general.h Allocator.h \
+  XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/DataSet.o: DataSet.cc DataSet.h Object.h general.h Allocator.h Sequence.h \
+  List.h PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/DiskDataSet.o: DiskDataSet.cc DiskDataSet.h DataSet.h Object.h general.h \
+  Allocator.h Sequence.h List.h PreProcessing.h Stack.h IOSequence.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/DiskMatDataSet.o: DiskMatDataSet.cc DiskMatDataSet.h DiskDataSet.h \
+  DataSet.h Object.h general.h Allocator.h Sequence.h List.h \
+  PreProcessing.h Stack.h IOSequence.h IOBufferize.h IOAscii.h \
+  DiskXFile.h XFile.h IOMulti.h IOBin.h IOSub.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/DiskXFile.o: DiskXFile.cc DiskXFile.h XFile.h Object.h general.h \
+  Allocator.h string_utils.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/FileListCmdOption.o: FileListCmdOption.cc FileListCmdOption.h CmdOption.h \
+  Object.h general.h Allocator.h DiskXFile.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/FrameSelectorDataSet.o: FrameSelectorDataSet.cc FrameSelectorDataSet.h \
+  DataSet.h Object.h general.h Allocator.h Sequence.h List.h \
+  PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/general.o: general.cc general.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOAscii.o: IOAscii.cc IOAscii.h IOSequence.h Sequence.h Object.h \
+  general.h Allocator.h List.h DiskXFile.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOBin.o: IOBin.cc IOBin.h IOSequence.h Sequence.h Object.h general.h \
+  Allocator.h List.h DiskXFile.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOBufferize.o: IOBufferize.cc IOBufferize.h IOSequence.h Sequence.h \
+  Object.h general.h Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOMulti.o: IOMulti.cc IOMulti.h IOSequence.h Sequence.h Object.h \
+  general.h Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOSequenceArray.o: IOSequenceArray.cc IOSequenceArray.h Object.h \
+  general.h Allocator.h Sequence.h List.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOSequence.o: IOSequence.cc IOSequence.h Sequence.h Object.h general.h \
+  Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOSub.o: IOSub.cc IOSub.h IOBufferize.h IOSequence.h Sequence.h Object.h \
+  general.h Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/KFold.o: KFold.cc KFold.h Trainer.h Object.h general.h Allocator.h \
+  Machine.h DataSet.h Sequence.h List.h PreProcessing.h Stack.h \
+  Measurer.h XFile.h Random.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/log_add.o: log_add.cc log_add.h general.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Machine.o: Machine.cc Machine.h Object.h general.h Allocator.h DataSet.h \
+  Sequence.h List.h PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MatDataSet.o: MatDataSet.cc IOBufferize.h IOSequence.h Sequence.h \
+  Object.h general.h Allocator.h List.h MatDataSet.h MemoryDataSet.h \
+  DataSet.h PreProcessing.h Stack.h IOAscii.h DiskXFile.h XFile.h \
+  IOMulti.h IOBin.h IOSub.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MeanVarNorm.o: MeanVarNorm.cc MeanVarNorm.h PreProcessing.h Sequence.h \
+  Object.h general.h Allocator.h List.h DataSet.h Stack.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Measurer.o: Measurer.cc Measurer.h Object.h general.h Allocator.h \
+  Machine.h DataSet.h Sequence.h List.h PreProcessing.h Stack.h XFile.h \
+  DiskXFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MemoryDataSet.o: MemoryDataSet.cc MemoryDataSet.h DataSet.h Object.h \
+  general.h Allocator.h Sequence.h List.h PreProcessing.h Stack.h \
+  IOSequence.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MemoryXFile.o: MemoryXFile.cc MemoryXFile.h XFile.h Object.h general.h \
+  Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MSEMeasurer.o: MSEMeasurer.cc MSEMeasurer.h Measurer.h Object.h general.h \
+  Allocator.h Machine.h DataSet.h Sequence.h List.h PreProcessing.h \
+  Stack.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MultiClassFormat.o: MultiClassFormat.cc MultiClassFormat.h ClassFormat.h \
+  Object.h general.h Allocator.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/NullXFile.o: NullXFile.cc NullXFile.h XFile.h Object.h general.h \
+  Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Object.o: Object.cc Object.h general.h Allocator.h DiskXFile.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/OneHotClassFormat.o: OneHotClassFormat.cc OneHotClassFormat.h \
+  ClassFormat.h Object.h general.h Allocator.h DataSet.h Sequence.h \
+  List.h PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/OutputMeasurer.o: OutputMeasurer.cc OutputMeasurer.h Measurer.h Object.h \
+  general.h Allocator.h Machine.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Parameters.o: Parameters.cc Parameters.h Object.h general.h Allocator.h \
+  XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/PipeXFile.o: PipeXFile.cc PipeXFile.h DiskXFile.h XFile.h Object.h \
+  general.h Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/PreProcessing.o: PreProcessing.cc PreProcessing.h Sequence.h Object.h \
+  general.h Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Random.o: Random.cc Random.h general.h Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Sequence.o: Sequence.cc Sequence.h Object.h general.h Allocator.h List.h \
+  XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Stack.o: Stack.cc Stack.h Object.h general.h Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/string_utils.o: string_utils.cc general.h string_utils.h Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/TimeMeasurer.o: TimeMeasurer.cc TimeMeasurer.h Measurer.h Object.h \
+  general.h Allocator.h Machine.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h XFile.h Timer.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Timer.o: Timer.cc Timer.h Object.h general.h Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Trainer.o: Trainer.cc Trainer.h Object.h general.h Allocator.h Machine.h \
+  DataSet.h Sequence.h List.h PreProcessing.h Stack.h Measurer.h XFile.h \
+  Random.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/TwoClassFormat.o: TwoClassFormat.cc TwoClassFormat.h ClassFormat.h \
+  Object.h general.h Allocator.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/WeightedSumMachine.o: WeightedSumMachine.cc WeightedSumMachine.h \
+  Trainer.h Object.h general.h Allocator.h Machine.h DataSet.h Sequence.h \
+  List.h PreProcessing.h Stack.h Measurer.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/XFile.o: XFile.cc XFile.h Object.h general.h Allocator.h
diff --speed-large-files --minimal -Nru tmp/Torch3/Makefile work/main.d/Torch3/Makefile
--- tmp/Torch3/Makefile	2004-08-11 12:34:36.000000000 -0400
+++ work/main.d/Torch3/Makefile	2008-02-07 11:35:14.000000000 -0200
@@ -5,7 +5,7 @@
 SUBDIRS := core
 SUBDIRS += $(PACKAGES)
 
-all:
+all: depend
 	@echo ">>> Try to compile Torch <<<"
 	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@) || exit 10 ; done
 	@echo ">> !!! Ok !!! <<<"
diff --speed-large-files --minimal -Nru tmp/Torch3/Makefile~ work/main.d/Torch3/Makefile~
--- tmp/Torch3/Makefile~	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch3/Makefile~	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,36 @@
+OS := $(shell uname -s)
+TORCHDIR := $(shell pwd)
+include Makefile_options_$(OS)
+
+SUBDIRS := core
+SUBDIRS += $(PACKAGES)
+
+all:
+	@echo ">>> Try to compile Torch <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@) || exit 10 ; done
+	@echo ">> !!! Ok !!! <<<"
+
+clean:
+	@echo ">>> Atomise all <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@ ) || exit 10 ; done
+	@\rm -Rf $(LIBTORCHXX)
+	@\rm -Rf $(OBJS_DIR)
+	@\rm -Rf $(LIBS_DIR)
+	@echo ">> !!! Ok !!! <<<"
+
+distclean:
+	@echo ">>> Thermonuclearise all <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@ ) || exit 10 ; done
+	@\rm -Rf lib
+	@\rm -Rf objs
+	@echo ">> !!! Ok !!! <<<"
+
+depend:
+	@echo ">>> Dependencies <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@ ) || exit 10 ; done
+	@\mkdir -p $(OBJS_DIR)
+	@\mkdir -p $(LIBS_DIR)
+	@echo ">> !!! Ok !!! <<<"
+
+Makefile_options_$(OS):
+	@echo "**** PLEASE CHECK YOUR MAKEFILE_OPTIONS for >>" $(OS) "<< ****"
diff --speed-large-files --minimal -Nru tmp/Torch3/Makefile_options_Linux work/main.d/Torch3/Makefile_options_Linux
--- tmp/Torch3/Makefile_options_Linux	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch3/Makefile_options_Linux	2008-02-07 11:35:35.000000000 -0200
@@ -0,0 +1,64 @@
+#
+# What you have to check...
+#
+
+# Packages you want to use
+PACKAGES = 
+
+# Magik key if you have several makefile
+# for the same platform
+MAGIK_KEY = 
+
+# Compiler, linker and archiver
+#CC = g++
+#LD = g++
+AR := $(AR) -rus
+
+# Command for creating dependencies
+DEP = $(CC) -MM
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+MYLIBS = 
+
+# Your includes
+# (for example -I/usr/local/special)
+MYINCS = 
+
+# optimize mode
+DEBUG = OPT
+# debug mode
+#DEBUG = DBG
+
+# double version
+#FLOATING = DOUBLE
+# floating version
+FLOATING = FLOAT
+
+# Debug double mode
+CFLAGS_DBG_DOUBLE = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+CFLAGS_DBG_FLOAT = -g -Wall -DDEBUG
+
+# Optimized double mode
+CFLAGS_OPT_DOUBLE = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double -DUSE_DOUBLE
+
+# Optimized float mode
+CFLAGS_OPT_FLOAT = $(CFLAGS)
+
+#
+#
+# Variables that you may find useful inside your Makefile
+# Do not touch.
+#
+#
+
+MODE = $(DEBUG)_$(FLOATING)
+VERSION_KEY = $(MAGIK_KEY)$(OS)_$(MODE)
+LIBS_DIR = $(TORCHDIR)/lib/$(VERSION_KEY)
+OBJS_DIR = $(TORCHDIR)/objs/$(VERSION_KEY)
+LIBTORCH = $(LIBS_DIR)/libtorch.a
+LIBS = -L$(TORCHDIR)/lib/$(VERSION_KEY) -ltorch $(MYLIBS)
+INCS := -I$(TORCHDIR)/core $(MYINCS)
+INCS += $(foreach f,$(PACKAGES),-I$(TORCHDIR)/$(f))
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Allocator.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Allocator.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Bagging.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Bagging.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/BoostingMeasurer.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/BoostingMeasurer.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Boosting.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Boosting.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/ClassFormatDataSet.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassFormatDataSet.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/ClassFormat.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassFormat.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/ClassMeasurer.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassMeasurer.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/ClassNLLMeasurer.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassNLLMeasurer.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/CmdLine.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/CmdLine.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/CmdOption.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/CmdOption.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/DataSet.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/DataSet.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/DiskDataSet.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/DiskDataSet.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/DiskMatDataSet.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/DiskMatDataSet.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/DiskXFile.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/DiskXFile.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/FileListCmdOption.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/FileListCmdOption.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/FrameSelectorDataSet.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/FrameSelectorDataSet.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/general.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/general.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/IOAscii.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOAscii.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/IOBin.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOBin.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/IOBufferize.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOBufferize.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/IOMulti.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOMulti.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/IOSequenceArray.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOSequenceArray.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/IOSequence.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOSequence.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/IOSub.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOSub.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/KFold.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/KFold.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/log_add.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/log_add.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Machine.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Machine.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/MatDataSet.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/MatDataSet.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/MeanVarNorm.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/MeanVarNorm.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Measurer.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Measurer.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/MemoryDataSet.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/MemoryDataSet.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/MemoryXFile.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/MemoryXFile.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/MSEMeasurer.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/MSEMeasurer.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/MultiClassFormat.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/MultiClassFormat.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/NullXFile.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/NullXFile.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Object.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Object.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/OneHotClassFormat.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/OneHotClassFormat.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/OutputMeasurer.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/OutputMeasurer.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Parameters.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Parameters.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/PipeXFile.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/PipeXFile.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/PreProcessing.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/PreProcessing.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Random.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Random.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Sequence.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Sequence.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Stack.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Stack.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/string_utils.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/string_utils.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/TimeMeasurer.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/TimeMeasurer.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Timer.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Timer.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/Trainer.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/Trainer.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/TwoClassFormat.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/TwoClassFormat.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/WeightedSumMachine.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/WeightedSumMachine.o differ
Binary files tmp/Torch3/objs/Linux_OPT_FLOAT/XFile.o and work/main.d/Torch3/objs/Linux_OPT_FLOAT/XFile.o differ
diff --speed-large-files --minimal -Nru tmp/Torch-3/ChangeLog work/main.d/Torch-3/ChangeLog
--- tmp/Torch-3/ChangeLog	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/ChangeLog	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,149 @@
+===============================================================================
+	Torch 3.1
+===============================================================================
+	
+core
+====
+        * Bagging.cc
+                - Initialize "is_selected_examples" to NULL.
+
+        * ClassFormatDataSet.cc
+                - Convert all the frames of targets, and not only the
+                first one.
+
+        * ClassMeasurer.cc
+                - Scan all the frames of inputs to compute classification
+                error, and not only the first one.
+                - The confusion matrix computation option at the end of
+		the training as been removed. The confusion matrix is still
+		available at each iteration.
+
+        * CmdOption.cc
+                - When calling loadXFile(), a string not always allocated
+                was freed.
+
+        * DiskDataSet.cc
+                - The number of examples was computed using io_inputs, even
+                if it was NULL.
+
+        * KFold.cc
+                - The size of the folds is more balanced for small folds.
+
+	* MemoryDataSet.cc
+                - The number of examples was computed using io_inputs, even
+                if it was NULL.
+
+	* MemoryXFile.cc
+	        - The EOF flag was not updated when reaching the end of file
+		while reading with the scanf method.
+
+        * MultiClassFormat.cc
+                - Serious bug when auto-detecting classes corrected.
+
+        * Random.cc
+                - Using now memmove instead of memcopy (possibility of
+		overlapping source and destination).
+
+matrix
+======
+        * Mat.cc and Mat.h
+                - Initializing a matrix from a "real *" now possible.
+
+gradients
+=========
+
+        * SumMachine.cc
+                - The gradient is now well back-propagated.
+
+kernels
+=======
+        * QCTrainer.cc
+                - Bug when updating alpha corrected. Note: very rare
+                case in practice. Thanks to Stephen Schiller for the
+                report of this tricky bug.
+
+distributions
+=============
+       * DiagonalGMM.cc
+                - log_probabilities are now correctely computed for the viterbi case
+                - frameExpectation becomes frameDecision
+                - keep the best gaussian for the current frame
+
+       * Distribution.cc
+                - resize the output of the machine correctely
+                - added decision and frameDecision method
+
+       * HMM.cc
+                - added states shared parameters
+
+       * MAPDiagonalGMM.cc
+                - adapt the parameters only if the gaussian have "seen" at
+                  least one frame
+
+       * Multinomial.cc
+                - added equal initialization option
+                - added check that the log weights are number
+                - frameExpectation becomes frameDecision
+
+       * NLLCriterion.cc
+                - correct the beta and outputs resize
+
+       * ParzenDistribution.cc
+                - correct the resize of the log_probablities
+                - added frameExpectation method
+
+       * TableLookupDistribution.cc
+                - correction of some bugs to calculate the log probablity
+
+       * ViterbiTrainer.cc ,ViterbiTrainer.h
+                - this class is suppressed, it was already included in EMTrainer
+
+
+datasets
+========
+
+      * IOHTK.cc
+               - correction of some major bugs when reading the HTK files on
+                 disk on unsequential mode
+               - correction of major bug on double mode
+
+      * IOHTKTarget.cc
+               - space followed by tabulation allowed instead of space only
+               - added some check
+
+      * IOHTKTarget.h
+               - make saveSequence static
+
+      * Vocabulary.cc
+               - bound check corrected for the number of words
+
+speech
+======
+
+      * EditDistance.{cc,h} and EditDistanceMeasurer.{cc,h}
+               - Add a constructor option to print a confusion matrix as well
+
+      * WordSeg.{cc,h} and FrameSeg.{cc,h}
+               - Two new class to keep the word and frame segmentations found
+                 by viterbi decoding. These are kept separate so as to be
+                 compatible with any new subclass of SpeechHMM.
+
+      * WordSegMeasurer.{cc,h} and FrameSegMeasurer.{cc,h}
+               - Measurers that outputs information related to the number
+                 of errors in terms of word error rate (WordSegMeasurer) or
+                 frame error rate (FrameSegMeasurer), using the EditDistance
+                 class to compute the error.
+
+      * SimpleDecoderSpeechHMM.{cc,h}
+               - Modifications to take into account the new WordSeg and FrameSeg
+                 classes
+               - added a structure (previous_states[] and n_previous_states)
+                 to speedup the decoding process by only looping on existing
+                 transitions and not all possible transitions
+               - Added an option to be able to decode using "forced alignment",
+                 hence instead of decoding on the whole grammar, decoding on
+                 a given (true) sentence
+
+      * SpeechHMM.cc
+               - bug corrections related to initialization
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/CC.cfg work/main.d/Torch-3/config/CC.cfg
--- tmp/Torch-3/config/CC.cfg	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/CC.cfg	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,46 @@
+[torch]
+
+# Need more verbosity ?
+#verbose = 1
+
+# Packages you want to use
+packages = 
+
+# Magik key if you want several libraries
+# for the same platform
+#magic_key = 
+
+# Compiler, linker and archiver
+compiler = CC
+linker = CC
+archiver = ar -rus
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+libraries = 
+
+# Your includes
+# (for example -I/usr/local/special)
+includes = 
+
+# optimize mode
+debug = opt
+# debug mode
+#debug = dbg
+
+# double version
+#floating = double
+# float version
+floating = float
+
+# Debug double mode
+dbg_double = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+dbg_float = -g -Wall -DDEBUG
+
+# Optimized double mode
+opt_double = -fast -xO5 -xarch=native -DUSE_DOUBLE
+
+# Optimized float mode
+opt_float = -fast -xO5 -xarch=native
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/Darwin.cfg work/main.d/Torch-3/config/Darwin.cfg
--- tmp/Torch-3/config/Darwin.cfg	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/Darwin.cfg	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,46 @@
+[torch]
+
+# Need more verbosity ?
+#verbose = 1
+
+# Packages you want to use
+packages = 
+
+# Magik key if you want several libraries
+# for the same platform
+#magic_key = 
+
+# Compiler, linker and archiver
+compiler = g++
+linker = g++
+archiver = ar -rus
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+libraries = 
+
+# Your includes
+# (for example -I/usr/local/special)
+includes = 
+
+# optimize mode
+debug = opt
+# debug mode
+#debug = dbg
+
+# double version
+#floating = double
+# float version
+floating = float
+
+# Debug double mode
+dbg_double = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+dbg_float = -g -Wall -DDEBUG
+
+# Optimized double mode
+opt_double = -Wall -O2 -ffast-math -DUSE_DOUBLE
+
+# Optimized float mode
+opt_float = -Wall -O2 -ffast-math
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/FreeBSD.cfg work/main.d/Torch-3/config/FreeBSD.cfg
--- tmp/Torch-3/config/FreeBSD.cfg	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/FreeBSD.cfg	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,51 @@
+[torch]
+
+# Need more verbosity ?
+#verbose = 1
+
+# Packages you want to use
+packages = 
+
+# Magik key if you want several libraries
+# for the same platform
+#magic_key = 
+
+# Compiler, linker and archiver
+compiler = g++
+linker = g++
+#archiver = g++ -shared -o
+archiver = ar -rus
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+libraries = 
+
+# Your includes
+# (for example -I/usr/local/special)
+includes = 
+
+# optimize mode
+debug = opt
+# debug mode
+#debug = dbg
+
+# double version
+#floating = double
+# float version
+floating = float
+
+# Debug double mode
+dbg_double = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+dbg_float = -g -Wall -DDEBUG
+
+# Optimized double mode
+opt_double = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double -DUSE_DOUBLE
+#opt_double = -Wall -O2 -ffast-math -mtune=i686 -march=i686 -malign-double -DUSE_DOUBLE
+
+# Optimized float mode
+opt_float = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double
+#opt_float = -Wall -O2 -ffast-math -mtune=i686 -march=i686 -malign-double
+
+# Note: gcc 3.4 does not support mcpu (replaced by mtune)
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/g++.cfg work/main.d/Torch-3/config/g++.cfg
--- tmp/Torch-3/config/g++.cfg	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/g++.cfg	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,47 @@
+[torch]
+
+# Need more verbosity ?
+#verbose = 1
+
+# Packages you want to use
+packages = 
+
+# Magik key if you want several libraries
+# for the same platform
+#magic_key = 
+
+# Compiler, linker and archiver
+compiler = g++
+linker = g++
+#archiver = g++ -shared -o
+archiver = ar -rus
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+libraries = 
+
+# Your includes
+# (for example -I/usr/local/special)
+includes = 
+
+# optimize mode
+debug = opt
+# debug mode
+#debug = dbg
+
+# double version
+#floating = double
+# float version
+floating = float
+
+# Debug double mode
+dbg_double = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+dbg_float = -g -Wall -DDEBUG
+
+# Optimized double mode
+opt_double = -Wall -O2 -ffast-math -DUSE_DOUBLE
+
+# Optimized float mode
+opt_float = -Wall -O2 -ffast-math
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/Linux.cfg work/main.d/Torch-3/config/Linux.cfg
--- tmp/Torch-3/config/Linux.cfg	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/Linux.cfg	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,51 @@
+[torch]
+
+# Need more verbosity ?
+#verbose = 1
+
+# Packages you want to use
+packages = 
+
+# Magik key if you want several libraries
+# for the same platform
+#magic_key = 
+
+# Compiler, linker and archiver
+compiler = g++
+linker = g++
+#archiver = g++ -shared -o
+archiver = ar -rus
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+libraries = 
+
+# Your includes
+# (for example -I/usr/local/special)
+includes = 
+
+# optimize mode
+debug = opt
+# debug mode
+#debug = dbg
+
+# double version
+#floating = double
+# float version
+floating = float
+
+# Debug double mode
+dbg_double = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+dbg_float = -g -Wall -DDEBUG
+
+# Optimized double mode
+opt_double = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double -DUSE_DOUBLE
+#opt_double = -Wall -O2 -ffast-math -mtune=i686 -march=i686 -malign-double -DUSE_DOUBLE
+
+# Optimized float mode
+opt_float = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double
+#opt_float = -Wall -O2 -ffast-math -mtune=i686 -march=i686 -malign-double
+
+# Note: gcc 3.4 does not support mcpu (replaced by mtune)
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/Makefile work/main.d/Torch-3/config/Makefile
--- tmp/Torch-3/config/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/Makefile	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,20 @@
+#
+# Torch user Makefile example
+#
+
+# Torch location.
+# Make sure to specify correct location...
+
+TORCHDIR := $(shell cd ..; pwd)
+
+#
+# All that follows you can probably keep as is...
+#
+
+OS := $(shell uname -s)
+include $(TORCHDIR)/Makefile_options_$(OS)
+
+%: %.cc
+	cd $(TORCHDIR); ${MAKE}
+	mkdir -p $(VERSION_KEY)
+	$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $(VERSION_KEY)/$@ $< $(LIBS)
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/Makefile_options_CC work/main.d/Torch-3/config/Makefile_options_CC
--- tmp/Torch-3/config/Makefile_options_CC	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/Makefile_options_CC	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,64 @@
+#
+# What you have to check...
+#
+
+# Packages you want to use
+PACKAGES = 
+
+# Magik key if you have several makefile
+# for the same platform
+MAGIK_KEY = CC_
+
+# Compiler, linker and archiver
+CC = CC
+LD = CC
+AR = ar -rus
+
+# Command for creating dependencies
+DEP = CC -xM1
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+MYLIBS = 
+
+# Your includes
+# (for example -I/usr/local/special)
+MYINCS = 
+
+# optimize mode
+DEBUG = OPT
+# debug mode
+#DEBUG = DBG
+
+# double version
+#FLOATING = DOUBLE
+# floating version
+FLOATING = FLOAT
+
+# Debug double mode
+CFLAGS_DBG_DOUBLE = -g -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+CFLAGS_DBG_FLOAT = -g -DDEBUG
+
+# Optimized double mode
+CFLAGS_OPT_DOUBLE = -fast -xO5 -xarch=native -DUSE_DOUBLE
+
+# Optimized float mode
+CFLAGS_OPT_FLOAT = -fast -xO5 -xarch=native
+
+#
+#
+# Variables that you may find useful inside your Makefile
+# Do not touch.
+#
+#
+
+MODE = $(DEBUG)_$(FLOATING)
+VERSION_KEY = $(MAGIK_KEY)$(OS)_$(MODE)
+LIBS_DIR = $(TORCHDIR)/lib/$(VERSION_KEY)
+OBJS_DIR = $(TORCHDIR)/objs/$(VERSION_KEY)
+LIBTORCH = $(LIBS_DIR)/libtorch.a
+LIBS = -L$(TORCHDIR)/lib/$(VERSION_KEY) -ltorch $(MYLIBS)
+INCS := -I$(TORCHDIR)/core $(MYINCS)
+INCS += $(foreach f,$(PACKAGES),-I$(TORCHDIR)/$(f))
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/Makefile_options_Darwin work/main.d/Torch-3/config/Makefile_options_Darwin
--- tmp/Torch-3/config/Makefile_options_Darwin	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/Makefile_options_Darwin	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,69 @@
+#
+# What you have to check...
+#
+
+# Packages you want to use
+PACKAGES = 
+
+# Magik key if you have several makefile
+# for the same platform
+MAGIK_KEY = 
+
+# Compiler, linker and archiver
+CC = c++
+LD = c++
+AR = ar ru
+
+# Command for creating dependencies
+DEP = c++ -MM
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+MYLIBS = 
+
+# Your includes
+# (for example -I/usr/local/special)
+MYINCS = 
+
+# optimize mode
+DEBUG = OPT
+# debug mode
+#DEBUG = DBG
+
+# double version
+#FLOATING = DOUBLE
+# floating version
+FLOATING = FLOAT
+
+# Debug double mode
+CFLAGS_DBG_DOUBLE = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+CFLAGS_DBG_FLOAT = -g -Wall -DDEBUG
+
+# Optimized double mode
+CFLAGS_OPT_DOUBLE = -Wall -O2 -ffast-math -DUSE_DOUBLE
+
+# Optimized float mode
+CFLAGS_OPT_FLOAT = -Wall -O2 -ffast-math
+
+#
+#
+# Variables that you may find useful inside your Makefile
+# Do not touch.
+#
+#
+
+MODE = $(DEBUG)_$(FLOATING)
+VERSION_KEY = $(MAGIK_KEY)$(OS)_$(MODE)
+LIBS_DIR = $(TORCHDIR)/lib/$(VERSION_KEY)
+OBJS_DIR = $(TORCHDIR)/objs/$(VERSION_KEY)
+LIBTORCH = $(LIBS_DIR)/libtorch.a
+LIBS = -L$(TORCHDIR)/lib/$(VERSION_KEY) -ltorch $(MYLIBS)
+INCS := -I$(TORCHDIR)/core $(MYINCS)
+INCS += $(foreach f,$(PACKAGES),-I$(TORCHDIR)/$(f))
+
+lib:	all
+	@echo ">> ...do a ranlib... <<"
+	@ranlib $(LIBTORCH)
+	@echo ">> ... ok !!! <<"
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/Makefile_options_FreeBSD work/main.d/Torch-3/config/Makefile_options_FreeBSD
--- tmp/Torch-3/config/Makefile_options_FreeBSD	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/Makefile_options_FreeBSD	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,64 @@
+#
+# What you have to check...
+#
+
+# Packages you want to use
+PACKAGES = 
+
+# Magik key if you have several makefile
+# for the same platform
+MAGIK_KEY = 
+
+# Compiler, linker and archiver
+CC = g++
+LD = g++
+AR = ar -rus
+
+# Command for creating dependencies
+DEP = g++ -MM
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+MYLIBS = 
+
+# Your includes
+# (for example -I/usr/local/special)
+MYINCS = 
+
+# optimize mode
+DEBUG = OPT
+# debug mode
+#DEBUG = DBG
+
+# double version
+#FLOATING = DOUBLE
+# floating version
+FLOATING = FLOAT
+
+# Debug double mode
+CFLAGS_DBG_DOUBLE = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+CFLAGS_DBG_FLOAT = -g -Wall -DDEBUG
+
+# Optimized double mode
+CFLAGS_OPT_DOUBLE = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double -DUSE_DOUBLE
+
+# Optimized float mode
+CFLAGS_OPT_FLOAT = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double
+
+#
+#
+# Variables that you may find useful inside your Makefile
+# Do not touch.
+#
+#
+
+MODE = $(DEBUG)_$(FLOATING)
+VERSION_KEY = $(MAGIK_KEY)$(OS)_$(MODE)
+LIBS_DIR = $(TORCHDIR)/lib/$(VERSION_KEY)
+OBJS_DIR = $(TORCHDIR)/objs/$(VERSION_KEY)
+LIBTORCH = $(LIBS_DIR)/libtorch.a
+LIBS = -L$(TORCHDIR)/lib/$(VERSION_KEY) -ltorch $(MYLIBS)
+INCS := -I$(TORCHDIR)/core $(MYINCS)
+INCS += $(foreach f,$(PACKAGES),-I$(TORCHDIR)/$(f))
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/Makefile_options_g++ work/main.d/Torch-3/config/Makefile_options_g++
--- tmp/Torch-3/config/Makefile_options_g++	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/Makefile_options_g++	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,64 @@
+#
+# What you have to check...
+#
+
+# Packages you want to use
+PACKAGES = 
+
+# Magik key if you have several makefile
+# for the same platform
+MAGIK_KEY = 
+
+# Compiler, linker and archiver
+CC = g++
+LD = g++
+AR = ar -rus
+
+# Command for creating dependencies
+DEP = g++ -MM
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+MYLIBS = 
+
+# Your includes
+# (for example -I/usr/local/special)
+MYINCS = 
+
+# optimize mode
+DEBUG = OPT
+# debug mode
+#DEBUG = DBG
+
+# double version
+#FLOATING = DOUBLE
+# floating version
+FLOATING = FLOAT
+
+# Debug double mode
+CFLAGS_DBG_DOUBLE = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+CFLAGS_DBG_FLOAT = -g -Wall -DDEBUG
+
+# Optimized double mode
+CFLAGS_OPT_DOUBLE = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double -DUSE_DOUBLE
+
+# Optimized float mode
+CFLAGS_OPT_FLOAT = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double
+
+#
+#
+# Variables that you may find useful inside your Makefile
+# Do not touch.
+#
+#
+
+MODE = $(DEBUG)_$(FLOATING)
+VERSION_KEY = $(MAGIK_KEY)$(OS)_$(MODE)
+LIBS_DIR = $(TORCHDIR)/lib/$(VERSION_KEY)
+OBJS_DIR = $(TORCHDIR)/objs/$(VERSION_KEY)
+LIBTORCH = $(LIBS_DIR)/libtorch.a
+LIBS = -L$(TORCHDIR)/lib/$(VERSION_KEY) -ltorch $(MYLIBS)
+INCS := -I$(TORCHDIR)/core $(MYINCS)
+INCS += $(foreach f,$(PACKAGES),-I$(TORCHDIR)/$(f))
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/Makefile_options_Linux work/main.d/Torch-3/config/Makefile_options_Linux
--- tmp/Torch-3/config/Makefile_options_Linux	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/Makefile_options_Linux	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,64 @@
+#
+# What you have to check...
+#
+
+# Packages you want to use
+PACKAGES = 
+
+# Magik key if you have several makefile
+# for the same platform
+MAGIK_KEY = 
+
+# Compiler, linker and archiver
+CC = g++
+LD = g++
+AR = ar -rus
+
+# Command for creating dependencies
+DEP = g++ -MM
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+MYLIBS = 
+
+# Your includes
+# (for example -I/usr/local/special)
+MYINCS = 
+
+# optimize mode
+DEBUG = OPT
+# debug mode
+#DEBUG = DBG
+
+# double version
+#FLOATING = DOUBLE
+# floating version
+FLOATING = FLOAT
+
+# Debug double mode
+CFLAGS_DBG_DOUBLE = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+CFLAGS_DBG_FLOAT = -g -Wall -DDEBUG
+
+# Optimized double mode
+CFLAGS_OPT_DOUBLE = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double -DUSE_DOUBLE
+
+# Optimized float mode
+CFLAGS_OPT_FLOAT = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double
+
+#
+#
+# Variables that you may find useful inside your Makefile
+# Do not touch.
+#
+#
+
+MODE = $(DEBUG)_$(FLOATING)
+VERSION_KEY = $(MAGIK_KEY)$(OS)_$(MODE)
+LIBS_DIR = $(TORCHDIR)/lib/$(VERSION_KEY)
+OBJS_DIR = $(TORCHDIR)/objs/$(VERSION_KEY)
+LIBTORCH = $(LIBS_DIR)/libtorch.a
+LIBS = -L$(TORCHDIR)/lib/$(VERSION_KEY) -ltorch $(MYLIBS)
+INCS := -I$(TORCHDIR)/core $(MYINCS)
+INCS += $(foreach f,$(PACKAGES),-I$(TORCHDIR)/$(f))
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/Makefile_options_OSF1 work/main.d/Torch-3/config/Makefile_options_OSF1
--- tmp/Torch-3/config/Makefile_options_OSF1	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/Makefile_options_OSF1	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,64 @@
+#
+# What you have to check...
+#
+
+# Packages you want to use
+PACKAGES = 
+
+# Magik key if you have several makefile
+# for the same platform
+MAGIK_KEY = 
+
+# Compiler, linker and archiver
+CC = cxx
+LD = cxx
+AR = ar -rus
+
+# Command for creating dependencies
+DEP = cxx -M
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+MYLIBS = -lm
+
+# Your includes
+# (for example -I/usr/local/special)
+MYINCS = 
+
+# optimize mode
+DEBUG = OPT
+# debug mode
+#DEBUG = DBG
+
+# double version
+#FLOATING = DOUBLE
+# floating version
+FLOATING = FLOAT
+
+# Debug double mode
+CFLAGS_DBG_DOUBLE = -g -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+CFLAGS_DBG_FLOAT = -g -DDEBUG
+
+# Optimized double mode
+CFLAGS_OPT_DOUBLE = -arch host -O5 -DUSE_DOUBLE
+
+# Optimized float mode
+CFLAGS_OPT_FLOAT = -arch host -O5
+
+#
+#
+# Variables that you may find useful inside your Makefile
+# Do not touch.
+#
+#
+
+MODE = $(DEBUG)_$(FLOATING)
+VERSION_KEY = $(MAGIK_KEY)$(OS)_$(MODE)
+LIBS_DIR = $(TORCHDIR)/lib/$(VERSION_KEY)
+OBJS_DIR = $(TORCHDIR)/objs/$(VERSION_KEY)
+LIBTORCH = $(LIBS_DIR)/libtorch.a
+LIBS = -L$(TORCHDIR)/lib/$(VERSION_KEY) -ltorch $(MYLIBS)
+INCS := -I$(TORCHDIR)/core $(MYINCS)
+INCS += $(foreach f,$(PACKAGES),-I$(TORCHDIR)/$(f))
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/Makefile_options_SunOS work/main.d/Torch-3/config/Makefile_options_SunOS
--- tmp/Torch-3/config/Makefile_options_SunOS	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/Makefile_options_SunOS	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,64 @@
+#
+# What you have to check...
+#
+
+# Packages you want to use
+PACKAGES = 
+
+# Magik key if you have several makefile
+# for the same platform
+MAGIK_KEY = CC_
+
+# Compiler, linker and archiver
+CC = CC
+LD = CC
+AR = ar -rus
+
+# Command for creating dependencies
+DEP = CC -xM1
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+MYLIBS = 
+
+# Your includes
+# (for example -I/usr/local/special)
+MYINCS = 
+
+# optimize mode
+DEBUG = OPT
+# debug mode
+#DEBUG = DBG
+
+# double version
+#FLOATING = DOUBLE
+# floating version
+FLOATING = FLOAT
+
+# Debug double mode
+CFLAGS_DBG_DOUBLE = -g -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+CFLAGS_DBG_FLOAT = -g -DDEBUG
+
+# Optimized double mode
+CFLAGS_OPT_DOUBLE = -fast -xO5 -xarch=native -DUSE_DOUBLE
+
+# Optimized float mode
+CFLAGS_OPT_FLOAT = -fast -xO5 -xarch=native
+
+#
+#
+# Variables that you may find useful inside your Makefile
+# Do not touch.
+#
+#
+
+MODE = $(DEBUG)_$(FLOATING)
+VERSION_KEY = $(MAGIK_KEY)$(OS)_$(MODE)
+LIBS_DIR = $(TORCHDIR)/lib/$(VERSION_KEY)
+OBJS_DIR = $(TORCHDIR)/objs/$(VERSION_KEY)
+LIBTORCH = $(LIBS_DIR)/libtorch.a
+LIBS = -L$(TORCHDIR)/lib/$(VERSION_KEY) -ltorch $(MYLIBS)
+INCS := -I$(TORCHDIR)/core $(MYINCS)
+INCS += $(foreach f,$(PACKAGES),-I$(TORCHDIR)/$(f))
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/Makefile_options_SunOS_purify work/main.d/Torch-3/config/Makefile_options_SunOS_purify
--- tmp/Torch-3/config/Makefile_options_SunOS_purify	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/Makefile_options_SunOS_purify	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,64 @@
+#
+# What you have to check...
+#
+
+# Packages you want to use
+PACKAGES = 
+
+# Magik key if you have several makefile
+# for the same platform
+MAGIK_KEY = 
+
+# Compiler, linker and archiver
+CC = purify g++
+LD = purify g++
+AR = ar -rus
+
+# Command for creating dependencies
+DEP = g++ -MM
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+MYLIBS = 
+
+# Your includes
+# (for example -I/usr/local/special)
+MYINCS = 
+
+# optimize mode
+#DEBUG = OPT
+# debug mode
+DEBUG = DBG
+
+# double version
+#FLOATING = DOUBLE
+# floating version
+FLOATING = FLOAT
+
+# Debug double mode
+CFLAGS_DBG_DOUBLE = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+CFLAGS_DBG_FLOAT = -g -Wall -DDEBUG
+
+# Optimized double mode
+CFLAGS_OPT_DOUBLE = -Wall -O2 -ffast-math -malign-double -DUSE_DOUBLE
+
+# Optimized float mode
+CFLAGS_OPT_FLOAT = -Wall -O2 -ffast-math -malign-double
+
+#
+#
+# Variables that you may find useful inside your Makefile
+# Do not touch.
+#
+#
+
+MODE = $(DEBUG)_$(FLOATING)
+VERSION_KEY = $(MAGIK_KEY)$(OS)_$(MODE)
+LIBS_DIR = $(TORCHDIR)/lib/$(VERSION_KEY)
+OBJS_DIR = $(TORCHDIR)/objs/$(VERSION_KEY)
+LIBTORCH = $(LIBS_DIR)/libtorch.a
+LIBS = -L$(TORCHDIR)/lib/$(VERSION_KEY) -ltorch $(MYLIBS)
+INCS := -I$(TORCHDIR)/core $(MYINCS)
+INCS += $(foreach f,$(PACKAGES),-I$(TORCHDIR)/$(f))
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/OSF1.cfg work/main.d/Torch-3/config/OSF1.cfg
--- tmp/Torch-3/config/OSF1.cfg	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/OSF1.cfg	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,46 @@
+[torch]
+
+# Need more verbosity ?
+#verbose = 1
+
+# Packages you want to use
+packages = 
+
+# Magik key if you want several libraries
+# for the same platform
+#magic_key = 
+
+# Compiler, linker and archiver
+compiler = cxx
+linker = cxx
+archiver = ar -rus
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+libraries = -lm
+
+# Your includes
+# (for example -I/usr/local/special)
+includes = 
+
+# optimize mode
+debug = opt
+# debug mode
+#debug = dbg
+
+# double version
+#floating = double
+# float version
+floating = float
+
+# Debug double mode
+dbg_double = -g -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+dbg_float = -g -DDEBUG
+
+# Optimized double mode
+opt_double = -arch host -O5 -DUSE_DOUBLE
+
+# Optimized float mode
+opt_float = -arch host -O5
diff --speed-large-files --minimal -Nru tmp/Torch-3/config/SunOS.cfg work/main.d/Torch-3/config/SunOS.cfg
--- tmp/Torch-3/config/SunOS.cfg	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/config/SunOS.cfg	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,46 @@
+[torch]
+
+# Need more verbosity ?
+#verbose = 1
+
+# Packages you want to use
+packages = 
+
+# Magik key if you want several libraries
+# for the same platform
+#magic_key = 
+
+# Compiler, linker and archiver
+compiler = CC
+linker = CC
+archiver = ar -rus
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+libraries = 
+
+# Your includes
+# (for example -I/usr/local/special)
+includes = 
+
+# optimize mode
+debug = opt
+# debug mode
+#debug = dbg
+
+# double version
+#floating = double
+# float version
+floating = float
+
+# Debug double mode
+dbg_double = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+dbg_float = -g -Wall -DDEBUG
+
+# Optimized double mode
+opt_double = -fast -xO5 -xarch=native -DUSE_DOUBLE
+
+# Optimized float mode
+opt_float = -fast -xO5 -xarch=native
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/LICENSE work/main.d/Torch-3/convolutions/LICENSE
--- tmp/Torch-3/convolutions/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/LICENSE	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,28 @@
+
+Copyright (c) 2003--2004 Ronan Collobert
+Copyright (c) 2003--2004 Samy Bengio
+Copyright (c) 2003--2004 Johnny Mariéthoz
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/Makefile work/main.d/Torch-3/convolutions/Makefile
--- tmp/Torch-3/convolutions/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/Makefile	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,42 @@
+# get user and architecture specific options
+OS := $(shell uname -s)
+TORCHDIR := $(shell cd ..; pwd)
+include ../Makefile_options_$(OS)
+
+CC_FILES := $(wildcard *.cc)
+OBJS := $(foreach f,$(CC_FILES),$(OBJS_DIR)/$(patsubst %.cc,%.o,$(f)))
+
+all:	$(LIBTORCH)
+
+$(LIBTORCH): $(OBJS)
+	@echo "Archiving..."
+	@$(AR) $(LIBTORCH) $(OBJS)
+
+$(OBJS_DIR)/%.o: %.cc
+	@echo $<
+	@$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $@ -c $<
+
+distclean:
+	@\rm -f .deps_*
+
+clean:
+	@echo "Remove objects file and dependencies..."
+	@\rm -Rf $(OBJS) $(LIBTORCH)
+	@\rm -f .deps_$(VERSION_KEY)
+
+depend:
+	@echo "Tracking dependencies..."
+	@\rm -f .deps_$(VERSION_KEY)
+	@for file in *.cc ; do printf "$(OBJS_DIR)/" >> .deps_$(VERSION_KEY); $(DEP) $(CFLAGS_$(MODE)) $(INCS) $$file >> .deps_$(VERSION_KEY); done
+
+.deps_$(VERSION_KEY):
+	@echo ">>> Please do a 'make depend' <<<"
+	exit 10
+
+ifneq ($(MAKECMDGOALS),distclean)
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),depend)
+include .deps_$(VERSION_KEY)
+endif
+endif
+endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/SpatialConvolution.cc work/main.d/Torch-3/convolutions/SpatialConvolution.cc
--- tmp/Torch-3/convolutions/SpatialConvolution.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/SpatialConvolution.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,227 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "SpatialConvolution.h"
+#include "Random.h"
+
+namespace Torch {
+
+/* Bon. Pour info, j'ai essaye de coder une premiere version degeulasse, ou
+   j'essayais de prendre en compte le cache de la becane. Ca m'a pris une demi
+   journee, plus quelques heures de debuggage, et c'etait du code horrible.
+   J'ai recode ce truc en 10 minutes. Ca a marche du premier coup. Et c'est
+   plus rapide! Bordel! Alors vous prenez pas la tete...
+*/
+
+SpatialConvolution::SpatialConvolution(int n_input_planes_, int n_output_planes_, int width_, int height_, int k_w_, int d_x_, int d_y_)
+  : GradientMachine(0, 0)
+{
+  n_input_planes = n_input_planes_;
+  n_output_planes = n_output_planes_;
+  input_width = width_;
+  input_height = height_;
+  k_w = k_w_;
+  d_x = d_x_;
+  d_y = d_y_;
+
+  n_inputs = n_input_planes * input_height * input_width;
+  output_height = (input_height - k_w) / d_y + 1;
+  output_width = (input_width - k_w) / d_x + 1;
+  n_outputs = n_output_planes * output_height * output_width;
+
+  if(input_height < k_w)
+    error("SpatialConvolution: input image height is too small (height = %d < k_w = %d) ", input_height, k_w);
+  if(input_width < k_w)
+    error("SpatialConvolution: input image width is too small (width = %d < k_w = %d) ", input_width, k_w);
+
+  outputs = new(allocator) Sequence(1, n_outputs);
+  beta = new(allocator) Sequence(1, n_inputs);
+
+  int n_params_ = k_w*k_w*n_input_planes*n_output_planes+n_output_planes;
+  params = new(allocator) Parameters(n_params_);
+  der_params = new(allocator) Parameters(n_params_);
+
+  weights = (real **)allocator->alloc(sizeof(real *)*n_output_planes);
+  for(int i = 0; i < n_output_planes; i++)
+    weights[i] = params->data[0] + i*k_w*k_w*n_input_planes;
+  biases = params->data[0] + k_w*k_w*n_input_planes*n_output_planes;
+
+  der_weights = (real **)allocator->alloc(sizeof(real *)*n_output_planes);
+  for(int i = 0; i < n_output_planes; i++)
+    der_weights[i] = der_params->data[0] + i*k_w*k_w*n_input_planes;
+  der_biases = der_params->data[0] + k_w*k_w*n_input_planes*n_output_planes;
+
+  message("SpatialConvolution: output image is <%d x %d>", output_width, output_height);
+
+  reset_();
+}
+
+void SpatialConvolution::reset_()
+{
+  real bound = 1./sqrt((real)(k_w*k_w*n_input_planes));
+
+  real *params_ = params->data[0];
+  for(int i = 0; i < params->n_params; i++)
+    params_[i] = Random::boundedUniform(-bound, bound);
+}
+
+void SpatialConvolution::reset()
+{
+  reset_();
+}
+
+void SpatialConvolution::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  for(int k = 0; k < n_output_planes; k++)
+  {
+    // Initialize to the bias
+    real z = biases[k];
+    for(int i = 0; i < output_width*output_height; i++)
+      f_outputs[i] = z;
+
+    // Go!
+
+    for(int i = 0; i < n_input_planes; i++)
+    {
+      // Get the good mask for (k,i) (k out, i in)
+      real *ptr_w = weights[k]+i*k_w*k_w;
+      
+      // Get the input image
+      real *ptr_img_in = f_inputs+i*input_width*input_height;
+      
+      // For all output pixels...
+      real *outputs_ = f_outputs;
+      for(int yy = 0; yy < output_height; yy++)
+      {
+        for(int xx = 0; xx < output_width; xx++)
+        {
+          // Dot product in two dimensions... (between input image and the mask)
+          real *ptr_img_in_ = ptr_img_in+yy*d_y*input_width+xx*d_x;
+          real *ptr_w_ = ptr_w;
+          real sum = 0;
+          for(int ky = 0; ky < k_w; ky++)
+          {
+            for(int kx = 0; kx < k_w; kx++)
+              sum += ptr_img_in_[kx]*ptr_w_[kx];
+            ptr_img_in_ += input_width; // next input line
+            ptr_w_ += k_w; // next mask line
+          }
+          
+          // Update output
+          *outputs_++ += sum;
+        }
+      }
+    }
+
+    // Next output plane
+    f_outputs += output_width*output_height;
+  }
+}
+
+void SpatialConvolution::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  //NOTE: boucle *necessaire* avec "partial backprop"
+
+  real *alpha__ = alpha_;
+  for(int k = 0; k < n_output_planes; k++)
+  {
+    real sum = 0;
+    for(int i = 0; i < output_width*output_height; i++)
+      sum += alpha__[i];
+    der_biases[k] += sum;
+
+    for(int i = 0; i < n_input_planes; i++)
+    {
+      real *der_ptr_w = der_weights[k] + i*k_w*k_w;
+      real *ptr_img_in = f_inputs+i*input_width*input_height;
+      real *alpha___ = alpha__;
+      for(int yy = 0; yy < output_height; yy++)
+      {
+        for(int xx = 0; xx < output_width; xx++)
+        {
+          real *ptr_img_in_ = ptr_img_in+yy*d_y*input_width+xx*d_x;
+          real *der_ptr_w_ = der_ptr_w;
+
+          real z = *alpha___++;
+          for(int ky = 0; ky < k_w; ky++)
+          {
+            for(int kx = 0; kx < k_w; kx++)
+              der_ptr_w_[kx] += z * ptr_img_in_[kx];
+            ptr_img_in_ += input_width;
+            der_ptr_w_ += k_w;
+          }
+        }
+      }
+    }
+    alpha__ += output_width*output_height;
+  }
+
+
+  if(partial_backprop)
+    return;
+
+  // NOTE: boucle *non-necessaire* avec "partial backprop"
+
+  for(int k = 0; k < n_inputs; k++)
+    beta_[k] = 0;
+  
+  alpha__ = alpha_;
+  for(int k = 0; k < n_output_planes; k++)
+  {
+    for(int i = 0; i < n_input_planes; i++)
+    {
+      real *ptr_w = weights[k]+i*k_w*k_w;
+      real *beta__ = beta_+i*input_width*input_height;
+      real *alpha___ = alpha__;
+      for(int yy = 0; yy < output_height; yy++)
+      {
+        for(int xx = 0; xx < output_width; xx++)
+        {
+          real *beta___ = beta__+yy*d_y*input_width+xx*d_x;
+          real *ptr_w_ = ptr_w;
+
+          real z = *alpha___++;
+          for(int ky = 0; ky < k_w; ky++)
+          {
+            for(int kx = 0; kx < k_w; kx++)
+              beta___[kx] += z * ptr_w_[kx];
+            beta___ += input_width;
+            ptr_w_ += k_w;
+          }
+        }
+      }
+    }
+    alpha__ += output_width*output_height;
+  }
+}
+
+SpatialConvolution::~SpatialConvolution()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/SpatialConvolution.h work/main.d/Torch-3/convolutions/SpatialConvolution.h
--- tmp/Torch-3/convolutions/SpatialConvolution.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/SpatialConvolution.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,116 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SPATIAL_CONVOLUTION_INC
+#define SPATIAL_CONVOLUTION_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Class for doing convolution over images.
+    
+    Suppose you put #n_input_planes# images in each input frame.
+    The images are in one big vector: each input frame has a size of
+    #n_input_planes*input_height*input_width#. (image after image).
+    Thus, #n_inputs = n_input_planes*input_height*input_width#.
+
+    Then, for each output planes, it computes the convolution
+    of \emph{all} input image planes with a kernel of size #k_w*k_w*n_input_planes#.
+
+    The output image size is computed in the constructor and
+    put in #output_height# and #output_width#.
+    #n_outputs = n_output_planes*output_height*output_width#.
+
+    Note that, depending of the size of your kernel, several (last) columns
+    or rows of the input image could be lost.
+
+    Note also that \emph{no} non-linearity is applied in this layer.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class SpatialConvolution : public GradientMachine
+{
+  public:
+    /// Kernel size (height and width).
+    int k_w;
+
+    /// 'x' translation \emph{in the input image} after each application of the kernel.
+    int d_x;
+
+    /// 'y' translation \emph{in the input image} after each application of the kernel.
+    int d_y;
+
+    /// Number of input images.
+    int n_input_planes;
+
+    /// Number of output images.
+    int n_output_planes;
+
+    /// Height of each input image.
+    int input_height;
+
+    /// Width of each input image.
+    int input_width;
+
+    /// Height of each output image.
+    int output_height;
+
+    /// Width of each output image.
+    int output_width;
+    
+    /** #weights[i]# means kernel-weights for output plane #i#.
+        #weights[i]# contains #n_input_planes# times #k_w*k_w# weights.
+    */
+    real **weights;
+
+    /// Derivatives associated to #weights#.
+    real **der_weights;
+
+    /// #biases[i]# is the bias for output plane #i#.
+    real *biases;
+
+    /// Derivatives associated to #biases#.
+    real *der_biases;
+    
+    /// Create a convolution layer...
+    SpatialConvolution(int n_input_planes_, int n_output_planes_, int width_, int height_, int k_w_=5, int d_x_=1, int d_y_=1);
+
+    //-----
+    
+    void reset_();
+    virtual void reset();
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~SpatialConvolution();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/SpatialSubSampling.cc work/main.d/Torch-3/convolutions/SpatialSubSampling.cc
--- tmp/Torch-3/convolutions/SpatialSubSampling.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/SpatialSubSampling.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,196 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "SpatialSubSampling.h"
+#include "Random.h"
+
+namespace Torch {
+
+SpatialSubSampling::SpatialSubSampling(int n_input_planes_, int width_, int height_, int k_w_, int d_x_, int d_y_)
+  : GradientMachine(0, 0)
+{
+  n_input_planes = n_input_planes_;
+  input_width = width_;
+  input_height = height_;
+  k_w = k_w_;
+  d_x = d_x_;
+  d_y = d_y_;
+
+  n_inputs = n_input_planes * input_height * input_width;
+  output_height = (input_height - k_w) / d_y + 1;
+  output_width = (input_width - k_w) / d_x + 1;
+  n_outputs = n_input_planes * output_height * output_width;
+
+  if(input_height < k_w)
+    error("SpatialConvolution: input image height is too small (height = %d < k_w = %d) ", input_height, k_w);
+  if(input_width < k_w)
+    error("SpatialConvolution: input image width is too small (width = %d < k_w = %d) ", input_width, k_w);
+
+  outputs = new(allocator) Sequence(1, n_outputs);
+  beta = new(allocator) Sequence(1, n_inputs);
+
+  int n_params_ = 2*n_input_planes;
+  params = new(allocator) Parameters(n_params_);
+  der_params = new(allocator) Parameters(n_params_);
+
+  weights = params->data[0];
+  biases = params->data[0] + n_input_planes;
+
+  der_weights = der_params->data[0];
+  der_biases = der_params->data[0] + n_input_planes;
+
+  message("SpatialSubSampling: output image is <%d x %d>", output_width, output_height);
+
+  reset_();
+}
+
+void SpatialSubSampling::reset_()
+{
+  real bound = 1./sqrt((real)(k_w*k_w));
+
+  real *params_ = params->data[0];
+  for(int i = 0; i < params->n_params; i++)
+    params_[i] = Random::boundedUniform(-bound, bound);
+}
+
+void SpatialSubSampling::reset()
+{
+  reset_();
+}
+
+void SpatialSubSampling::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  for(int k = 0; k < n_input_planes; k++)
+  {
+    // Initialize to the bias
+    real z = biases[k];
+    for(int i = 0; i < output_width*output_height; i++)
+      f_outputs[i] = z;
+
+    // Go!
+
+    // Get the good mask for (k,i) (k out, i in)
+    real the_weight = weights[k];
+      
+    // For all output pixels...
+    real *outputs_ = f_outputs;
+    for(int yy = 0; yy < output_height; yy++)
+    {
+      for(int xx = 0; xx < output_width; xx++)
+      {
+        // Compute the mean of the input image...
+        real *ptr_img_in = f_inputs+yy*d_y*input_width+xx*d_x;
+        real sum = 0;
+        for(int ky = 0; ky < k_w; ky++)
+        {
+          for(int kx = 0; kx < k_w; kx++)
+            sum += ptr_img_in[kx];
+          ptr_img_in += input_width; // next input line
+        }
+        
+        // Update output
+        *outputs_++ += the_weight*sum;
+      }
+    }
+
+    // Next input/output plane
+    f_outputs += output_width*output_height;
+    f_inputs += input_width*input_height;
+  }
+}
+
+void SpatialSubSampling::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  // NOTE: boucle *necessaire* avec "partial backprop"
+
+  real *alpha__ = alpha_;
+  for(int k = 0; k < n_input_planes; k++)
+  {
+    real sum = 0;
+    for(int i = 0; i < output_width*output_height; i++)
+      sum += alpha__[i];
+    der_biases[k] += sum;
+
+    real *alpha___ = alpha__;
+    sum = 0;
+    for(int yy = 0; yy < output_height; yy++)
+    {
+      for(int xx = 0; xx < output_width; xx++)
+      {
+        real *ptr_img_in = f_inputs+yy*d_y*input_width+xx*d_x;
+        real z = *alpha___++;
+        for(int ky = 0; ky < k_w; ky++)
+        {
+          for(int kx = 0; kx < k_w; kx++)
+            sum += z * ptr_img_in[kx];
+          ptr_img_in += input_width;
+        }    
+      }
+    }
+    der_weights[k] += sum;
+    alpha__ += output_width*output_height;
+    f_inputs += input_width*input_height;
+  }
+
+  if(partial_backprop)
+    return;
+
+  // NOTE: boucle *non-necessaire* avec "partial backprop"
+
+  for(int k = 0; k < n_inputs; k++)
+    beta_[k] = 0;
+  
+  alpha__ = alpha_;
+  for(int k = 0; k < n_input_planes; k++)
+  {
+    real the_weight = weights[k];
+    real *alpha___ = alpha__;
+    for(int yy = 0; yy < output_height; yy++)
+    {
+      for(int xx = 0; xx < output_width; xx++)
+      {
+        real *beta__ = beta_+yy*d_y*input_width+xx*d_x;
+        real z = *alpha___++ * the_weight;
+        for(int ky = 0; ky < k_w; ky++)
+        {
+          for(int kx = 0; kx < k_w; kx++)
+            beta__[kx] += z;
+          beta__ += input_width;
+        }    
+      }
+    }
+    alpha__ += output_width*output_height;
+    beta_ += input_width*input_height;
+  }
+}
+
+SpatialSubSampling::~SpatialSubSampling()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/SpatialSubSampling.h work/main.d/Torch-3/convolutions/SpatialSubSampling.h
--- tmp/Torch-3/convolutions/SpatialSubSampling.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/SpatialSubSampling.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,114 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SPATIAL_SUB_SAMPLING_INC
+#define SPATIAL_SUB_SAMPLING_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Class for doing sub-sampling over images.
+    
+    Suppose you put #n_input_planes# images in each input frame.
+    The images are in one big vector: each input frame has a size of
+    #n_input_planes*input_height*input_width#. (image after image).
+    Thus, #n_inputs = n_input_planes*input_height*input_width#.
+
+    Then, for each output planes, it takes its associated input plane
+    and it computes the convolution of the input image with a kernel
+    of size #k_w*k_w#, where the weights of the kernel are equals.
+
+    The output image size is computed in the constructor and
+    put in #output_height# and #output_width#.
+    #n_outputs = n_input_planes*output_height*output_width#.
+
+    Note that, depending of the size of your kernel, several (last) input columns
+    or rows of the image could be lost.
+
+    Note also that \emph{no} non-linearity is applied in this layer.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class SpatialSubSampling : public GradientMachine
+{
+  public:
+    /// Kernel size (height and width).
+    int k_w;
+
+    /// 'x' translation \emph{in the input image} after each application of the kernel.
+    int d_x;
+
+    /// 'y' translation \emph{in the input image} after each application of the kernel.
+    int d_y;
+
+    /// Number of input images. The number of output images in sub-sampling is the same.
+    int n_input_planes;
+
+    /// Height of each input image.
+    int input_height;
+
+    /// Width of each input image.
+    int input_width;
+
+    /// Height of each output image.
+    int output_height;
+
+    /// Width of each output image.
+    int output_width;
+
+    /** #weights[i]# means kernel-weight for output plane #i#.
+        #weights[i]# contains only one weight.
+    */
+    real *weights;
+
+    /// Derivatives associated to #weights#.
+    real *der_weights;
+
+    /// #biases[i]# is the bias for output plane #i#.
+    real *biases;
+
+    /// Derivatives associated to #biases#.
+    real *der_biases;
+
+    /// Create a sub-sampling layer...
+    SpatialSubSampling(int n_input_planes_, int width_, int height_, int k_w_=2, int d_x_=2, int d_y_=2);
+
+    //-----
+
+    void reset_();
+    virtual void reset();
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~SpatialSubSampling();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/TemporalConvolution.cc work/main.d/Torch-3/convolutions/TemporalConvolution.cc
--- tmp/Torch-3/convolutions/TemporalConvolution.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/TemporalConvolution.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,167 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "TemporalConvolution.h"
+#include "Random.h"
+
+namespace Torch {
+
+TemporalConvolution::TemporalConvolution(int input_frame_size, int output_frame_size, int k_w_, int d_t_)
+  : GradientMachine(input_frame_size, output_frame_size, (k_w_*input_frame_size+1)*output_frame_size)
+{
+  k_w = k_w_;
+  d_t = d_t_;
+
+  weights = (real **)allocator->alloc(sizeof(real *)*n_outputs);
+  for(int i = 0; i < n_outputs; i++)
+    weights[i] = params->data[0] + i*k_w*n_inputs;
+  biases = params->data[0] + k_w*n_inputs*n_outputs;
+
+  der_weights = (real **)allocator->alloc(sizeof(real *)*n_outputs);
+  for(int i = 0; i < n_outputs; i++)
+    der_weights[i] = der_params->data[0] + i*k_w*n_inputs;
+  der_biases = der_params->data[0] + k_w*n_inputs*n_outputs;
+
+  reset_();
+}
+
+void TemporalConvolution::reset_()
+{
+  real bound = 1./sqrt((real)(k_w*n_inputs));
+
+  real *params_ = params->data[0];
+  for(int i = 0; i < params->n_params; i++)
+    params_[i] = Random::boundedUniform(-bound, bound);
+}
+
+void TemporalConvolution::reset()
+{
+  reset_();
+}
+
+void TemporalConvolution::forward(Sequence *inputs)
+{
+  if(inputs->n_frames < k_w)
+    error("TemporalSubSampling: input sequence too small! (n_frames = %d < k_w = %d)", inputs->n_frames, k_w);
+
+  int n_output_frames = (inputs->n_frames - k_w) / d_t + 1;
+  outputs->resize(n_output_frames);
+
+  int current_input_frame = 0;
+  for(int i = 0; i < n_output_frames; i++)
+  {
+    real *output_frame_ = outputs->frames[i];
+    for(int j = 0; j < n_outputs; j++)
+      output_frame_[j] = biases[j];
+
+    // Sur le noyau...
+    for(int j = 0; j < k_w; j++)
+    {
+      // Sur tous les "neurones" de sorties
+      for(int k = 0; k < n_outputs; k++)
+      {
+        real *weights_ = weights[k]+j*n_inputs;
+        real *input_frame_ = inputs->frames[current_input_frame+j];
+
+        real sum = 0;
+        for(int l = 0; l < n_inputs; l++)
+          sum += weights_[l]*input_frame_[l];
+
+        output_frame_[k] += sum;
+      }
+    }
+    current_input_frame += d_t;
+  }
+}
+
+void TemporalConvolution::backward(Sequence *inputs, Sequence *alpha)
+{
+  int n_output_frames = alpha->n_frames;
+
+  // NOTE: boucle *necessaire* avec "partial backprop"
+
+  int current_input_frame = 0;
+  for(int i = 0; i < n_output_frames; i++)
+  {
+    real *alpha_frame_ = alpha->frames[i];
+    for(int j = 0; j < n_outputs; j++)
+      der_biases[j] += alpha_frame_[j];
+    
+    for(int j = 0; j < k_w; j++)
+    {
+      for(int k = 0; k < n_outputs; k++)
+      {
+        real *der_weights_ = der_weights[k]+j*n_inputs;
+        real *input_frame_ = inputs->frames[current_input_frame+j];
+
+        real alpha_ = alpha_frame_[k];
+        for(int l = 0; l < n_inputs; l++)
+          der_weights_[l] += alpha_*input_frame_[l];
+      }
+    }
+    current_input_frame += d_t;
+  }
+
+  if(partial_backprop)
+    return;
+
+  // NOTE: boucle *non-necessaire* avec "partial backprop"
+
+  beta->resize(inputs->n_frames);
+  for(int i = 0; i < beta->n_frames; i++)
+  {
+    real *beta_frame_ = beta->frames[i];
+    for(int j = 0; j < n_inputs; j++)
+      beta_frame_[j] = 0;
+  }
+
+  int current_beta_frame = 0;
+  for(int i = 0; i < n_output_frames; i++)
+  {
+    real *alpha_frame_ = alpha->frames[i];
+    for(int j = 0; j < k_w; j++)
+    {
+      for(int k = 0; k < n_outputs; k++)
+      {
+        real *weights_ = weights[k]+j*n_inputs;
+        real *beta_frame_ = beta->frames[current_beta_frame+j];
+
+        real alpha_ = alpha_frame_[k];
+        for(int l = 0; l < n_inputs; l++)
+           beta_frame_[l] += weights_[l]*alpha_;
+      }
+    }
+    current_beta_frame += d_t;
+  }
+}
+
+TemporalConvolution::~TemporalConvolution()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/TemporalConvolution.h work/main.d/Torch-3/convolutions/TemporalConvolution.h
--- tmp/Torch-3/convolutions/TemporalConvolution.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/TemporalConvolution.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,86 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef TEMPORAL_CONVOLUTION_INC
+#define TEMPORAL_CONVOLUTION_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Class for doing a convolution over a sequence.
+    
+    For each component of output frames, it computes the convolution
+    of the input sequence with a kernel of size #k_w# (over the time).
+
+    Note that, depending of the size of your kernel, several (last) frames
+    of the input sequence could be lost.
+
+    Note also that \emph{no} non-linearity is applied in this layer.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class TemporalConvolution : public GradientMachine
+{
+  public:
+    /// Kernel size.
+    int k_w;
+
+    /// Time translation after one application of the kernel.
+    int d_t;
+    
+    /** #weights[i]# means kernel-weights for the #i#-th component of output frames.
+        #weights[i]# contains #input_frame_size# times #k_w# weights.
+    */
+    real **weights;
+
+    /// Derivatives associated to #weights#.
+    real **der_weights;
+
+    /// #biases[i]# is the bias for the #i#-th component of output frames.
+    real *biases;
+
+    /// Derivatives associated to #biases#.
+    real *der_biases;
+    
+    /// Create a convolution layer...
+    TemporalConvolution(int input_frame_size, int output_frame_size, int k_w_=5, int d_t_=1);
+
+    //-----
+    
+    void reset_();
+    virtual void reset();
+    virtual void forward(Sequence *inputs);
+    virtual void backward(Sequence *inputs, Sequence *alpha);
+
+    virtual ~TemporalConvolution();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/TemporalMean.cc work/main.d/Torch-3/convolutions/TemporalMean.cc
--- tmp/Torch-3/convolutions/TemporalMean.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/TemporalMean.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,79 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "TemporalMean.h"
+#include "Random.h"
+
+namespace Torch {
+
+TemporalMean::TemporalMean(int input_frame_size)
+  : GradientMachine(input_frame_size, input_frame_size)
+{
+  outputs->resize(1);
+}
+
+void TemporalMean::forward(Sequence *inputs)
+{
+  real *outputs_ = outputs->frames[0];
+  for(int i = 0; i < n_outputs; i++)
+    outputs_[i] = 0;
+
+  for(int i = 0; i < inputs->n_frames; i++)
+  {
+    real *input_frame_ = inputs->frames[i];
+    for(int j = 0; j < n_outputs; j++)
+      outputs_[j] += input_frame_[j];
+  }
+
+  real z = 1./((real)inputs->n_frames);
+  for(int i = 0; i < n_outputs; i++)
+    outputs_[i] *= z;
+}
+
+void TemporalMean::backward(Sequence *inputs, Sequence *alpha)
+{
+  if(partial_backprop)
+    return;
+  
+  beta->resize(inputs->n_frames);
+  real *alpha_ = alpha->frames[0];
+
+  real z = 1./((real)inputs->n_frames);
+  for(int i = 0; i < beta->n_frames; i++)
+  {
+    real *beta_frame_ = beta->frames[i];
+    for(int j = 0; j < n_outputs; j++)
+      beta_frame_[j] = alpha_[j]*z;
+  }
+}
+
+TemporalMean::~TemporalMean()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/TemporalMean.h work/main.d/Torch-3/convolutions/TemporalMean.h
--- tmp/Torch-3/convolutions/TemporalMean.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/TemporalMean.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,58 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef TEMPORAL_MEAN_INC
+#define TEMPORAL_MEAN_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Given an input sequence, it does the mean over all
+    input frames. Thus, the output sequence will have only
+    one frame, which has the same size than input frames.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class TemporalMean : public GradientMachine
+{
+  public:
+    ///
+    TemporalMean(int input_frame_size);
+
+    //-----
+    
+    virtual void forward(Sequence *inputs);
+    virtual void backward(Sequence *inputs, Sequence *alpha);
+
+    virtual ~TemporalMean();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/TemporalSubSampling.cc work/main.d/Torch-3/convolutions/TemporalSubSampling.cc
--- tmp/Torch-3/convolutions/TemporalSubSampling.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/TemporalSubSampling.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,161 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "TemporalSubSampling.h"
+#include "Random.h"
+
+namespace Torch {
+
+TemporalSubSampling::TemporalSubSampling(int input_frame_size, int k_w_, int d_t_)
+  : GradientMachine(input_frame_size, input_frame_size, 2*input_frame_size)
+{
+  k_w = k_w_;
+  d_t = d_t_;
+
+  weights = params->data[0];
+  biases = params->data[0] + n_inputs;
+
+  der_weights = der_params->data[0];
+  der_biases = der_params->data[0] + n_inputs;
+
+  reset_();
+}
+
+void TemporalSubSampling::reset_()
+{
+  real bound = 1./sqrt((real)(k_w));
+
+  real *params_ = params->data[0];
+  for(int i = 0; i < params->n_params; i++)
+    params_[i] = Random::boundedUniform(-bound, bound);
+}
+
+void TemporalSubSampling::reset()
+{
+  reset_();
+}
+
+void TemporalSubSampling::forward(Sequence *inputs)
+{
+  if(inputs->n_frames < k_w)
+    error("TemporalSubSampling: input sequence too small! (n_frames = %d < k_w = %d)", inputs->n_frames, k_w);
+
+  int n_output_frames = (inputs->n_frames - k_w) / d_t + 1;
+  outputs->resize(n_output_frames);
+
+  int current_input_frame = 0;
+  for(int i = 0; i < n_output_frames; i++)
+  {
+    real *output_frame_ = outputs->frames[i];
+    for(int j = 0; j < n_outputs; j++)
+      output_frame_[j] = biases[j];
+
+    // Sur le noyau...
+    for(int j = 0; j < k_w; j++)
+    {
+      // Sur tous les "neurones" de sorties
+      for(int k = 0; k < n_outputs; k++)
+      {
+        real *input_frame_ = inputs->frames[current_input_frame+j];
+
+        real sum = 0;
+        for(int l = 0; l < n_inputs; l++)
+          sum += input_frame_[l];
+
+        output_frame_[k] += weights[k]*sum;
+      }
+    }
+    current_input_frame += d_t;
+  }
+}
+
+void TemporalSubSampling::backward(Sequence *inputs, Sequence *alpha)
+{
+  int n_output_frames = alpha->n_frames;
+
+  // NOTE: boucle *necessaire* avec "partial backprop"
+
+  int current_input_frame = 0;
+  for(int i = 0; i < n_output_frames; i++)
+  {
+    real *alpha_frame_ = alpha->frames[i];
+    for(int j = 0; j < n_outputs; j++)
+      der_biases[j] += alpha_frame_[j];
+    
+    for(int j = 0; j < k_w; j++)
+    {
+      for(int k = 0; k < n_outputs; k++)
+      {
+        real *input_frame_ = inputs->frames[current_input_frame+j];
+
+        real alpha_ = alpha_frame_[k];
+        real sum = 0;
+        for(int l = 0; l < n_inputs; l++)
+          sum += alpha_*input_frame_[l];
+        der_weights[k] += sum;
+      }
+    }
+    current_input_frame += d_t;
+  }
+
+  if(partial_backprop)
+    return;
+
+  // NOTE: boucle *non-necessaire* avec "partial backprop"
+
+  beta->resize(inputs->n_frames);
+  for(int i = 0; i < beta->n_frames; i++)
+  {
+    real *beta_frame_ = beta->frames[i];
+    for(int j = 0; j < n_inputs; j++)
+      beta_frame_[j] = 0;
+  }
+
+  int current_beta_frame = 0;
+  for(int i = 0; i < n_output_frames; i++)
+  {
+    real *alpha_frame_ = alpha->frames[i];
+    for(int j = 0; j < k_w; j++)
+    {
+      for(int k = 0; k < n_outputs; k++)
+      {
+        real *beta_frame_ = beta->frames[current_beta_frame+j];
+        real alpha_mul_weight_ = alpha_frame_[k]*weights[k];
+        for(int l = 0; l < n_inputs; l++)
+           beta_frame_[l] += alpha_mul_weight_;
+      }
+    }
+    current_beta_frame += d_t;
+  }
+}
+
+TemporalSubSampling::~TemporalSubSampling()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/convolutions/TemporalSubSampling.h work/main.d/Torch-3/convolutions/TemporalSubSampling.h
--- tmp/Torch-3/convolutions/TemporalSubSampling.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/convolutions/TemporalSubSampling.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,87 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef TEMPORAL_SUB_SAMPLING_INC
+#define TEMPORAL_SUB_SAMPLING_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Class for doing sub-sampling over a sequence.
+    
+    Then, for each component of output frames, it takes its associated input component
+    and it computes the convolution of the input sequence with a kernel
+    of size #k_w#, over the time, where the weights of the kernel are equals.
+
+    Note that, depending of the size of your kernel, several (last) frames
+    of the input seqience could be lost.
+
+    Note also that \emph{no} non-linearity is applied in this layer.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class TemporalSubSampling : public GradientMachine
+{
+  public:
+    /// Kernel size.
+    int k_w;
+
+    /// Time translation after one application of the kernel.
+    int d_t;
+    
+    /** #weights[i]# means kernel-weights for the #i#-th component of output frames.
+        #weights[i]# contains only one weight.
+    */
+    real *weights;
+
+    /// Derivatives associated to #weights#.
+    real *der_weights;
+
+    /// #biases[i]# is the bias for the #i#-th component of output frames.
+    real *biases;
+
+    /// Derivatives associated to #biases#.
+    real *der_biases;
+    
+    /// Create a sub-sampling layer...
+    TemporalSubSampling(int input_frame_size, int k_w_=2, int d_t_=2);
+
+    //-----
+    
+    void reset_();
+    virtual void reset();
+    virtual void forward(Sequence *inputs);
+    virtual void backward(Sequence *inputs, Sequence *alpha);
+
+    virtual ~TemporalSubSampling();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Allocator.cc work/main.d/Torch-3/core/Allocator.cc
--- tmp/Torch-3/core/Allocator.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Allocator.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,251 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "Object.h"
+
+namespace Torch {
+
+Allocator::Allocator()
+{
+  ptrs = NULL;
+}
+
+void *Allocator::alloc(size_t size, int object_style)
+{
+  // Are you stupid ?
+  if(size <= 0)
+    return(NULL);
+
+  // Allocate what you need
+  void *ptr = sysAlloc(size);
+  if(!ptr)
+    error("Allocator: not enough memory. Buy new ram.");
+
+  // Save the pointer
+  retain(ptr, object_style);
+  return(ptr);
+}
+
+void *Allocator::realloc(void *ptr, size_t size)
+{
+  // Free it ?
+  if(size <= 0)
+  {
+    Allocator::free(ptr);
+    return NULL;
+  }
+  
+  // Find the node
+  bool is_mine = false;
+  AllocatorNode *ptrs_ = ptrs;
+  
+  if(ptr == NULL)
+    is_mine = true;
+  else
+  {    
+    while(ptrs_)
+    {
+      if(ptrs_->ptr == ptr)
+      {
+        is_mine = true;
+        break;
+      }
+      ptrs_ = ptrs_->next;
+    }
+  }
+
+  if(!is_mine)
+    error("Allocator: cannot realloc a pointer which is not mine.");
+
+  if(ptr)
+  {
+    // Reallocate (Here, size > 0 for sure)
+    void *ptrx = sysRealloc(ptr, size);
+    if(!ptrx)
+      error("Allocator: not enough memory. Buy new ram.");
+    
+    // Save the new pointer
+    ptrs_->ptr = ptrx;
+    return(ptrx);
+  }
+  else
+  {
+    // Forcement pas un objet
+    return(this->alloc(size, 0));
+  }
+}
+
+void Allocator::free(void *ptr)
+{
+  // Gni?
+  if(!ptr)
+    return;
+  
+  // Release the pointer
+  int object_style = release(ptr);
+
+  // Free it
+//  message("Allocator [%p] free %p mode %d", this, ptr, object_style);
+  if(object_style == 0)
+    ::free(ptr);
+  else
+  {
+    if(object_style == 1)
+      delete (Object *)ptr;
+    else
+      ((Object *)ptr)->~Object();
+  }
+}
+
+void Allocator::retain(void *ptr, int object_style)
+{
+#ifdef DEBUG
+  AllocatorNode *dbg_ptr = isMine(ptr);
+  if(dbg_ptr)
+  {
+    if(object_style != 2)
+      error("Allocator [debug mode]: try to retain a previously retained pointer! You'll destruct an inexistant object.");    
+    if(object_style == dbg_ptr->object_style)
+      error("Allocator [debug mode]: try to retain a previously retained pointer with same mode [%d]!", object_style);
+  }
+#endif
+
+  // Create a new node to be placed *before* the root
+  AllocatorNode *ptrs_ = (AllocatorNode *)sysAlloc(sizeof(AllocatorNode));
+  if(!ptrs_)
+    error("Allocator: not enough memory. Buy new ram.");
+  ptrs_->prev = NULL;
+  ptrs_->next = ptrs;
+  if(ptrs)
+    ptrs->prev = ptrs_;
+  
+  // Save the root
+  ptrs = ptrs_;
+
+  // Save the pointer
+  ptrs->ptr = ptr;
+  ptrs->object_style = object_style;
+}
+
+int Allocator::release(void *ptr)
+{
+  // Find the node (Note: Start with the beginning... recent is faster!)
+  bool is_mine = false;
+  AllocatorNode *ptrs_ = ptrs;
+  while(ptrs_)
+  {
+    if(ptrs_->ptr == ptr)
+    {
+      is_mine = true;
+      break;
+    }
+    ptrs_ = ptrs_->next;
+  }
+
+  if(!is_mine)
+    error("Allocator: cannot release a pointer which is not mine.");
+
+  // Check the links
+  if(ptrs_->next)
+    ptrs_->next->prev = ptrs_->prev;
+
+  if(ptrs_->prev)
+    ptrs_->prev->next = ptrs_->next;
+  else
+    // Viens-t-on de scrapper le root ?
+    ptrs = ptrs_->next;
+
+  // Free the node and return if object or not
+  int object_style = ptrs_->object_style;
+  ::free(ptrs_);
+  return(object_style);
+}
+
+void Allocator::steal(void *ptr, Allocator *allocator)
+{
+  int object_style = allocator->release(ptr);
+  retain(ptr, object_style);
+}
+
+void Allocator::steal(Allocator *allocator)
+{
+  while(allocator->ptrs)
+    steal(allocator->ptrs->ptr, allocator);
+}
+
+AllocatorNode *Allocator::isMine(void *ptr)
+{
+  AllocatorNode *ptrs_ = ptrs;
+  while(ptrs_)
+  {
+    if(ptrs_->ptr == ptr)
+      return ptrs_;
+    ptrs_ = ptrs_->next;
+  }
+
+  return NULL;
+}
+
+void Allocator::freeAll()
+{
+  while(ptrs)
+    this->free(ptrs->ptr);
+}
+
+
+void *Allocator::sysAlloc(int size)
+{
+  if(size <= 0)
+    return(NULL);
+  void *ptr = malloc(size);
+  if(!ptr)
+    error("Allocator: not enough memory. Buy new ram");
+  return(ptr);
+}
+
+void *Allocator::sysRealloc(void *ptr, int size)
+{
+  void *ptr_ = NULL;
+  if(size <= 0)
+    ::free(ptr);
+  else
+  {
+    ptr_ = ::realloc(ptr, size);
+    if(!ptr_)
+      error("Allocator: not enough memory. Buy new ram");
+  }
+  return(ptr_);
+}
+
+Allocator::~Allocator()
+{
+  freeAll();
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Allocator.h work/main.d/Torch-3/core/Allocator.h
--- tmp/Torch-3/core/Allocator.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Allocator.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,126 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef ALLOCATOR_INC
+#define ALLOCATOR_INC
+
+#include "general.h"
+
+namespace Torch {
+
+struct AllocatorNode
+{
+    void *ptr;
+    int object_style;
+    AllocatorNode *prev;
+    AllocatorNode *next;
+};
+
+/** Class do easily allocate/deallocate memory in Torch.
+    The memory allocated by an allocator will be destroyed
+    when the allocator will be destroyed.
+
+    @see Object
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Allocator
+{
+  public:
+    AllocatorNode *ptrs;
+
+    /// Create a new allocator.
+    Allocator();
+
+    /** Returns #size# bytes of allocated memory.
+        \begin{itemize}
+          \item If #object_style# is 0, the allocated memory is
+          considered as if it wasn't for an object. At the destruction
+          of the allocator the memory will be freed, and that's all.
+          \item If 1, the #Object# destructor will be called
+          at the destruction and the memory will be freed.
+          \item If 2, the destructor will be called, but the memory
+          won't be freed.
+        \end{itemize}
+    */
+    void *alloc(size_t size, int object_style=0);
+
+    /** Reallocate a part of the memory which has been already
+        allocated with alloc (and #object_style#=0).
+        Same behaviour as the #realloc()# system function.
+    */
+    void *realloc(void *ptr, size_t size);
+
+    /** Force given pointer to memory to be freed now.
+        It considers the #object_style# given by #alloc()#
+        and calls the Object destructor, if needed.
+    */
+    void free(void *ptr);
+
+    /** Tells to the allocator that it should handle the memory
+        given by #ptr#. Take in account the #object_style#.
+    */
+    void retain(void *ptr, int object_style=0);
+
+    /** Tells to the allocator to stop taking in account the
+        memory given by #ptr#. The memory will not be released.
+     */
+    int release(void *ptr);
+
+    /** Handles the memory given by #ptr# which was previouly
+        handled by #allocator#. #allocator# looses the control
+        of this memory */
+    void steal(void *ptr, Allocator *allocator);
+
+    /// Steals all pointers contained in #allocator#.
+    void steal(Allocator *allocator);
+
+    /// Returns true iff ptr is handled by the allocator.
+    AllocatorNode *isMine(void *ptr);
+
+    /** Force all pointers contained in the allocator to be freed now.
+        It considers the #object_style# given by #alloc()#
+        and calls the Object destructor, if needed.
+    */
+    void freeAll();
+
+    /** System allocation.
+        As system malloc function, but do an error if there is no more memory.
+    */
+    static void *sysAlloc(int size);
+
+    /** System reallocation.
+        As system realloc function, but do an error if there is no more memory.
+    */
+    static void *sysRealloc(void *ptr, int size);
+
+    ~Allocator();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Bagging.cc work/main.d/Torch-3/core/Bagging.cc
--- tmp/Torch-3/core/Bagging.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Bagging.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,109 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Bagging.h"
+#include "Random.h"
+
+namespace Torch {
+
+Bagging::Bagging(WeightedSumMachine* w_machine_) : Trainer(w_machine_)
+{
+  w_machine = w_machine_;
+
+  n_trainers = w_machine->n_trainers;
+  n_unselected_examples = (int *)allocator->alloc(sizeof(int)*n_trainers);
+  unselected_examples = (int **)allocator->alloc(sizeof(int*)*n_trainers);
+  selected_examples = (int **)allocator->alloc(sizeof(int*)*n_trainers);
+  is_selected_examples = NULL;
+}
+
+void Bagging::bootstrapData(int* selected, int* is_selected, int n_examples)
+{
+  for (int j=0;j<n_examples;j++) {
+    selected[j] = (int)floor(Random::boundedUniform(0,n_examples));
+    is_selected[selected[j]] = 1;
+  }
+}
+
+void Bagging::train(DataSet *data, MeasurerList* measurers)
+{
+  // Misc Initializations
+  int n = data->n_examples;
+  is_selected_examples = (int *)allocator->realloc(is_selected_examples, sizeof(int)*n);
+  for (int i = 0; i < n_trainers; i++)
+  {
+    unselected_examples[i] = (int *)allocator->realloc(unselected_examples[i], sizeof(int)*n);
+    selected_examples[i] = (int *)allocator->realloc(selected_examples[i], sizeof(int)*n);
+  } 
+
+  for(int i = 0; i < n_trainers; i++)
+    w_machine->weights[i] = 1./((real)n_trainers);
+
+  message("Bagging: training");
+  w_machine->n_trainers_trained = 0;
+
+  for (int i=0;i<n_trainers;i++) {
+    // initialization
+    for (int j=0;j<n;j++) {
+      is_selected_examples[j]=0;
+    }
+
+    // select a bootstrap
+    bootstrapData(selected_examples[i],is_selected_examples,n);
+    data->pushSubset(selected_examples[i],n);
+
+    // keep in mind examples not used by trainers[i]
+    int k=0;
+    for (int j=0;j<n;j++) {
+      if (!is_selected_examples[j])
+        unselected_examples[i][k++] = j;
+    }
+    n_unselected_examples[i] = k;
+    
+
+    // train the trainer
+    w_machine->trainers[i]->machine->reset();
+    w_machine->trainers[i]->train(data, w_machine->trainers_measurers ? w_machine->trainers_measurers[i] : NULL);
+
+    // put back the selected_examples
+    data->popSubset();
+
+    w_machine->n_trainers_trained = i+1;
+
+    // if measurers is given, call the test method by fooling it
+    // with the number of trainers
+    if (measurers)
+      test(measurers);
+  }
+}
+
+Bagging::~Bagging()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Bagging.h work/main.d/Torch-3/core/Bagging.h
--- tmp/Torch-3/core/Bagging.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Bagging.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,83 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef BAGGING_INC
+#define BAGGING_INC
+
+#include "Trainer.h"
+#include "Measurer.h"
+#include "DataSet.h"
+#include "WeightedSumMachine.h"
+
+namespace Torch {
+
+/** This class represents a #Trainer# that implements the well-known
+    Bagging algorithm (Breiman, 1996). A "bagger" contains a series
+    of trainers, each trained on a bootstrap of the original dataset.
+    The output of the bagging is then the average of the output of
+    each trainer.
+
+    It is implemented using a #WeightedSumMachine# that performs the combination.
+
+    @author Samy Bengio (bengio@idiap.ch)
+    @see WeightedSumMachine
+*/
+class Bagging : public Trainer
+{
+  public:
+
+    /// This machine performs the combination. It contains many trainers.
+    WeightedSumMachine* w_machine;
+
+    /// The number of trainers in the bagging.
+    int n_trainers;
+
+    /// for each trainer, keep the indices of examples not used during training
+    int** unselected_examples;
+    /// for each trainer, keep the indices of examples used during training
+    int** selected_examples;
+    /// for each trainer, keep the number of examples not used during training
+    int* n_unselected_examples;
+    /// for each trainer, keep the number of examples used during training
+    int* is_selected_examples;
+ 
+    ///
+    Bagging(WeightedSumMachine *w_machine);
+
+    /// create a boostrap of the data and put in in selected
+    virtual void bootstrapData(int* selected, int* is_selected, int n_examples);
+
+    virtual void train(DataSet *data, MeasurerList* measurers);
+
+    virtual ~Bagging();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Boosting.cc work/main.d/Torch-3/core/Boosting.cc
--- tmp/Torch-3/core/Boosting.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Boosting.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,185 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Boosting.h"
+#include "BoostingMeasurer.h"
+#include "Random.h"
+#include "NullXFile.h"
+
+namespace Torch {
+
+static void randw(int *selected_examples, real *ex_weights, int n_examples)
+{
+  real *repartition = (real *)Allocator::sysAlloc(sizeof(real)*(n_examples+1));
+  repartition[0] = 0;
+  for(int i = 0; i < n_examples; i++)
+    repartition[i+1] = repartition[i]+ex_weights[i];
+
+  for(int i = 0; i < n_examples; i++)
+  {
+    real z = Random::uniform();
+    int gauche = 0;
+    int droite = n_examples;
+    while(gauche+1 != droite)
+    {
+      int centre = (gauche+droite)/2;
+      if(repartition[centre] < z)
+        gauche = centre;
+      else
+        droite = centre;
+    }
+    selected_examples[i] = gauche;
+//    printf("%g < %g < %g\n", repartition[gauche], z, repartition[gauche+1]);
+  }
+  free(repartition);
+}
+
+Boosting::Boosting(WeightedSumMachine* w_machine_, ClassFormat *class_format_) : Trainer(w_machine_)
+{
+  w_machine = w_machine_;
+  class_format = class_format_;
+
+  n_trainers = w_machine->n_trainers;
+  weights = w_machine->weights;
+}
+
+void Boosting::train(DataSet *data, MeasurerList* measurers)
+{
+  int n_examples = data->n_examples;
+  int *selected_examples = (int *)Allocator::sysAlloc(n_examples*sizeof(int));
+  real *ex_weights = (real *)Allocator::sysAlloc(n_examples*sizeof(real));
+  for(int t = 0; t < n_examples; t++)
+    ex_weights[t] = 1./((real)n_examples);
+
+  NullXFile null_xfile;
+  BoostingMeasurer *measurer = new BoostingMeasurer(class_format, &null_xfile);
+
+  measurer->setDataSet(data);
+  measurer->setWeights(ex_weights);
+
+  message("Boosting: training...");
+  w_machine->n_trainers_trained = 0;
+
+  MeasurerList the_boost_meas;
+  the_boost_meas.addNode(measurer);
+
+  // Initialise le boxon.
+  for(int i = 0; i < n_trainers; i++)
+    weights[i] = 0;
+
+  for(int i = 0; i < n_trainers; i++)
+  {
+    randw(selected_examples, ex_weights, n_examples);
+    data->pushSubset(selected_examples, n_examples);
+    w_machine->trainers[i]->machine->reset();
+    w_machine->trainers[i]->train(data, w_machine->trainers_measurers ? w_machine->trainers_measurers[i] : NULL);
+    data->popSubset();
+
+    // Calcule le nouveau 'beta'...
+    measurer->setInputs(w_machine->trainers[i]->machine->outputs);
+    w_machine->trainers[i]->test(&the_boost_meas);
+
+    // Ben on vient d'entrainer un truc tu sais...
+    w_machine->n_trainers_trained = i+1;
+
+    // Check if all is classified [cas limite 1]
+    if(measurer->beta == 0)
+    {
+      for(int j = 0; j < n_trainers; j++)
+        weights[j] = 0;
+      weights[i] = 1;
+      warning("Boosting: train stopped. All examples are well classified.");
+
+      // On teste quand meme...
+      if(measurers)
+        test(measurers);
+
+      break;
+    }
+
+    // Regarde si c'est la misere [cas limite 2]
+    if(measurer->beta >= 1)
+    {
+      w_machine->n_trainers_trained = i;
+      warning("Boosting: train stopped. Model %d too weak.", i);
+      break;
+    }
+
+    // Si tout va bien... ////////////////////////
+
+    // Compute new weights
+    int *ptr_status = measurer->status;
+    real mul_pos = exp( 0.5*log(measurer->beta));
+    real mul_neg = exp(-0.5*log(measurer->beta));
+    for(int t = 0; t < n_examples; t++)
+    {
+      if(ptr_status[t] > 0)
+        ex_weights[t] *= mul_pos;
+      else
+        ex_weights[t] *= mul_neg;
+    }
+
+    // Normalize les poids des exemples
+    real z = 0;
+    for(int t = 0; t < n_examples; t++)
+      z += ex_weights[t];
+    for(int t = 0; t < n_examples; t++)
+      ex_weights[t] /= z;
+
+    // Refourgue le bon poids a l'autre naze...
+    weights[i] = -0.5*log(measurer->beta);
+
+    // Teste pour voir ce que ca donne...
+    if(measurers)
+      test(measurers);
+
+    // Fin de si tout va bien... ////////////////
+  }
+
+  // Jarte la misere
+  free(selected_examples);
+  free(ex_weights);
+  delete measurer;
+
+  // Vraiment faible mon pote!
+  if(w_machine->n_trainers_trained == 0)
+    return;
+
+  // Normalize trainers weights...
+  real z = 0;
+  for(int i = 0; i < n_trainers; i++)
+    z += weights[i];
+  for(int i = 0; i < n_trainers; i++)
+    weights[i] /= z;  
+}
+
+Boosting::~Boosting()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Boosting.h work/main.d/Torch-3/core/Boosting.h
--- tmp/Torch-3/core/Boosting.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Boosting.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,79 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef BOOSTING_INC
+#define BOOSTING_INC
+
+#include "Trainer.h"
+#include "WeightedSumMachine.h"
+#include "ClassFormat.h"
+
+namespace Torch {
+
+/** Boosting implementation.
+    As the idea of boosting in regression hasn't been really well tested,
+    this is boosting for *classification* only.
+    
+    This trainer will "boost" the machine given by the #WeightedSumMachine#,
+    on the given #DataSet#.
+
+    You have to provide a #ClassFormat# to know how the classes are encoded.
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @see WeightedSumMachine
+*/
+class Boosting : public Trainer
+{
+  public:
+
+    /// This machine performs the combination. It contains many trainers.
+    WeightedSumMachine *w_machine;
+
+    /// #ClassFormat# to know how the classes are encoded.
+    ClassFormat *class_format;
+
+    /// The number of trainers in the boosting.
+    int n_trainers;
+
+    /// The weights of each machine in the boosting.
+    real *weights;
+
+    ///
+    Boosting(WeightedSumMachine *w_machine_, ClassFormat *class_format_);
+
+    //-----
+    
+    virtual void train(DataSet *data, MeasurerList *measurers);
+
+    virtual ~Boosting();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/BoostingMeasurer.cc work/main.d/Torch-3/core/BoostingMeasurer.cc
--- tmp/Torch-3/core/BoostingMeasurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/BoostingMeasurer.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,101 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "BoostingMeasurer.h"
+
+namespace Torch {
+
+BoostingMeasurer::BoostingMeasurer(ClassFormat *class_format_, XFile *file_) : Measurer(NULL, file_)
+{
+  weights = NULL;
+  inputs = NULL;
+  status = NULL;
+
+  class_format = class_format_;
+
+  internal_error = 0;
+  current_example = 0;
+}
+
+void BoostingMeasurer::setDataSet(DataSet *data_)
+{
+  data = data_;
+  status = (int *)allocator->realloc(status, sizeof(int)*data->n_examples);
+}
+
+void BoostingMeasurer::setWeights(real *weights_)
+{
+  weights = weights_;
+}
+
+void BoostingMeasurer::setInputs(Sequence *inputs_)
+{
+  inputs = inputs_;
+}
+
+void BoostingMeasurer::measureExample()
+{
+  int c_obs = class_format->getClass(inputs->frames[0]);
+  int c_des = class_format->getClass(data->targets->frames[0]);
+
+  if(c_obs != c_des)
+  {
+    internal_error += weights[current_example];
+    status[current_example++] = -1;
+  }
+  else
+    status[current_example++] = 1;
+}
+
+void BoostingMeasurer::measureIteration()
+{
+  beta = internal_error/(1. - internal_error);
+
+  if(binary_mode)
+  {
+    file->write(&internal_error, sizeof(real), 1);
+    file->write(&beta, sizeof(real), 1);
+  }
+  else
+    file->printf("%g ==> %g for beta\n", internal_error, beta);
+  file->flush();
+  reset();
+}
+
+void BoostingMeasurer::reset()
+{
+  internal_error = 0;
+  current_example = 0;
+}
+
+BoostingMeasurer::~BoostingMeasurer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/BoostingMeasurer.h work/main.d/Torch-3/core/BoostingMeasurer.h
--- tmp/Torch-3/core/BoostingMeasurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/BoostingMeasurer.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,89 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef BOOSTING_MEASURER_INC
+#define BOOSTING_MEASURER_INC
+
+#include "Measurer.h"
+#include "DataSet.h"
+#include "ClassFormat.h"
+
+namespace Torch {
+
+/** Compute the classification weighted error (in %) for #BoostingMachine#
+    of the #inputs# with respect to the #targets# of #data#.
+    The weights are given by #setWeights()#.
+
+    Needed by #Boosting#. (Designed just for it).
+
+    The format of the class is given with a #ClassFormat#.
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @author Samy Bengio (bengio@idiap.ch)
+    @see Boosting
+*/
+class BoostingMeasurer : public Measurer
+{
+  public:
+    // General
+    Sequence *inputs;
+    real *weights;
+    real beta;
+    int *status;
+
+    real internal_error;
+    int current_example;
+    ClassFormat *class_format;
+
+    ///
+    BoostingMeasurer(ClassFormat *class_format_, XFile *file_);
+
+    /// Set the current working dataset.
+    virtual void setDataSet(DataSet *data_);
+
+    /// Set the current weights of training examples.
+    virtual void setWeights(real *weights_);
+
+    /// Gives the pointer where the measure will be done.
+    virtual void setInputs(Sequence *inputs_);
+
+    //-----
+    
+    void init_();
+    virtual void reset();
+    virtual void measureExample();
+    virtual void measureIteration();
+
+    virtual ~BoostingMeasurer();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/ClassFormat.cc work/main.d/Torch-3/core/ClassFormat.cc
--- tmp/Torch-3/core/ClassFormat.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/ClassFormat.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,43 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "ClassFormat.h"
+
+namespace Torch {
+
+ClassFormat::ClassFormat()
+{
+  n_classes = 0;
+  class_labels = NULL;
+}
+
+ClassFormat::~ClassFormat()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/ClassFormatDataSet.cc work/main.d/Torch-3/core/ClassFormatDataSet.cc
--- tmp/Torch-3/core/ClassFormatDataSet.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/ClassFormatDataSet.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,136 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "ClassFormatDataSet.h"
+
+namespace Torch {
+
+ClassFormatDataSet::ClassFormatDataSet(DataSet *data_, Sequence *class_labels_)
+{
+  data = data_;
+  class_labels = class_labels_;
+
+  DataSet::init(data->n_examples, data->n_inputs, class_labels->frame_size);
+
+  inputs = NULL;
+  if(n_targets > 0)
+    targets = new(allocator) Sequence(0, n_targets);
+}
+
+ClassFormatDataSet::ClassFormatDataSet(DataSet *data_, int n_classes)
+{
+  data = data_;
+  
+  if(n_classes <= 0)
+  {
+    n_classes = 0;
+    for(int t = 0; t < data->n_examples; t++)
+    {
+      data->setExample(t, false, true);
+      for(int i = 0; i < data->targets->n_frames; i++)
+      {
+        int z = (int)data->targets->frames[i][0];
+        if(z > n_classes)
+          n_classes = z;
+      }
+    }
+    n_classes++;
+    message("ClassFormatDataSet: %d classes detected", n_classes);
+  }
+
+  class_labels = new(allocator) Sequence(n_classes, n_classes);
+  for(int cl = 0; cl < n_classes; cl++)
+  {
+    memset(class_labels->frames[cl], 0, sizeof(real)*n_classes);
+    class_labels->frames[cl][cl] = 1.;
+  }
+  
+  DataSet::init(data->n_examples, data->n_inputs, n_classes);
+
+  inputs = NULL;
+  if(n_targets > 0)
+    targets = new(allocator) Sequence(0, n_targets);
+}
+
+void ClassFormatDataSet::getNumberOfFrames(int t_, int *n_input_frames_, int *n_target_frames_)
+{
+  int t = selected_examples[t_];
+  if( (n_inputs > 0) && n_input_frames_ )
+    data->getNumberOfFrames(t, n_input_frames_, NULL);
+
+  if( (n_targets > 0) && n_target_frames_ )
+    data->getNumberOfFrames(t, NULL, n_target_frames_);
+}
+
+void ClassFormatDataSet::setRealExample(int t, bool set_inputs, bool set_targets)
+{
+  data->setExample(t, set_inputs, set_targets);
+  inputs = data->inputs;
+
+  if(set_targets)
+  {
+    targets->resize(data->targets->n_frames);
+    for(int i = 0; i < data->targets->n_frames; i++)
+    {
+      int cl = (int)data->targets->frames[i][0];
+      memcpy(targets->frames[i], class_labels->frames[cl], sizeof(real)*n_targets);
+    }
+  }
+  real_current_example_index = t;
+}
+
+void ClassFormatDataSet::preProcess(PreProcessing *pre_processing)
+{
+  error("ClassFormatDataSet: pre-processing not supported");
+}
+
+void ClassFormatDataSet::pushExample()
+{
+  data->pushExample();
+  pushed_examples->push(&inputs, sizeof(Sequence *));
+  pushed_examples->push(&targets, sizeof(Sequence *));
+  pushed_examples->push(&real_current_example_index, sizeof(int));
+  if(n_targets > 0)
+    targets = new(allocator) Sequence(0, n_targets);
+  real_current_example_index = -1;
+}
+
+void ClassFormatDataSet::popExample()
+{
+  allocator->free(targets);
+  pushed_examples->pop();
+  pushed_examples->pop();
+  pushed_examples->pop();
+  data->popExample();
+}
+
+ClassFormatDataSet::~ClassFormatDataSet()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/ClassFormatDataSet.h work/main.d/Torch-3/core/ClassFormatDataSet.h
--- tmp/Torch-3/core/ClassFormatDataSet.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/ClassFormatDataSet.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,79 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLASS_FORMAT_DATA_SET_INC
+#define CLASS_FORMAT_DATA_SET_INC
+
+#include "DataSet.h"
+
+namespace Torch {
+
+/** Given a DataSet, convert (on-the-fly) targets using a conversion table.
+
+    The targets of the given DataSet should be 0,1,2... for the class 0, class 1,
+    class 2, and so on. Note that is must START AT 0.
+
+    After a setExample(), the inputs of this DataSet will be the same as
+    the provided one. The targets will be #class_labels->frames[i]#, where #i#
+    is contained in the targets of the provided DataSet.
+
+    @author Ronan Collobert (collober@idiap.ch)
+ */
+class ClassFormatDataSet : public DataSet
+{
+  public:
+    /// The provided DataSet.
+    DataSet *data;
+
+    /// The class label translation table.
+    Sequence *class_labels;
+
+    /// Here you provide the translation table in #class_labels_#.
+    ClassFormatDataSet(DataSet *data_, Sequence *class_labels_);
+
+    /** We assume here that you want the one-hot encoding format.
+        The number of classes is given by #n_classes#, if positive.
+        Otherwise, the number of classes is guessed by taking the
+        maximum value of the targets of the provided DataSet.
+    */
+    ClassFormatDataSet(DataSet *data_, int n_classes=-1);
+    
+    virtual void getNumberOfFrames(int t_, int *n_input_frames_, int *n_target_frames_);
+    virtual void setRealExample(int t, bool set_inputs=true, bool set_targets=true);
+    virtual void preProcess(PreProcessing *pre_processing);
+    virtual void pushExample();
+    virtual void popExample();
+
+    //-----
+
+    virtual ~ClassFormatDataSet();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/ClassFormat.h work/main.d/Torch-3/core/ClassFormat.h
--- tmp/Torch-3/core/ClassFormat.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/ClassFormat.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,70 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLASS_FORMAT_INC
+#define CLASS_FORMAT_INC
+
+#include "Object.h"
+
+namespace Torch {
+
+/** Used to define a class code.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class ClassFormat : public Object
+{
+  public:
+
+    /// Number of classes that the object currently handles
+    int n_classes;
+
+    /// The label of each class
+    real **class_labels;
+    
+    ///
+    ClassFormat();
+
+    /// Returns the output size.
+    virtual int getOutputSize() = 0;
+
+    /// Transforms the output from a OneHot representation.
+    virtual void fromOneHot(real *outputs, real *one_hot_outputs) = 0;
+
+    /// Transforms the output to a OneHot representation.
+    virtual void toOneHot(real *outputs, real *one_hot_outputs) = 0;
+
+    /// Returns the class of #vector#.
+    virtual int getClass(real *vector) = 0;
+
+    virtual ~ClassFormat();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/ClassMeasurer.cc work/main.d/Torch-3/core/ClassMeasurer.cc
--- tmp/Torch-3/core/ClassMeasurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/ClassMeasurer.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,135 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "ClassMeasurer.h"
+
+namespace Torch {
+
+ClassMeasurer::ClassMeasurer(Sequence *inputs_, DataSet *data_, ClassFormat *class_format_, XFile *file_,
+                             bool calc_confusion_at_each_iter_) : Measurer(data_, file_)
+{
+  inputs = inputs_;
+  class_format = class_format_;
+  calc_confusion_at_each_iter = calc_confusion_at_each_iter_;
+  confusion = NULL;
+
+  n_classes = class_format->n_classes;
+  if(calc_confusion_at_each_iter)
+  {
+    confusion   = (int **)allocator->alloc(sizeof(int*)*n_classes);
+
+    for(int i = 0; i < n_classes; i++)
+      confusion[i]   = (int *)allocator->alloc(sizeof(int)*n_classes);
+  }
+  reset_();
+}
+
+void ClassMeasurer::measureExample()
+{
+  for(int i = 0; i < inputs->n_frames; i++)
+  {
+    int c_obs = class_format->getClass(inputs->frames[i]);
+    int c_des = class_format->getClass(data->targets->frames[i]);
+    
+    if(c_obs != c_des)
+      internal_error += 1.;
+    
+    if(calc_confusion_at_each_iter)
+      confusion[c_obs][c_des]++;
+    n_examples++;
+  }
+}
+
+void ClassMeasurer::measureIteration()
+{
+  internal_error /= n_examples;
+
+  if(binary_mode)
+    file->write(&internal_error, sizeof(real), 1);
+  else
+    file->printf("%g\n", internal_error);
+  file->flush();
+
+  if(calc_confusion_at_each_iter)
+    printConfusionMatrix();
+
+  reset();
+}
+
+void ClassMeasurer::printConfusionMatrix()
+{
+  if(binary_mode)
+  {
+    for(int i = 0; i < n_classes; i++)
+      file->write(confusion[i], sizeof(real), n_classes);
+  }
+  else
+  {
+    file->printf("# Labels of classes:\n");
+    for(int i = 0; i < n_classes; i++)
+    {
+      for(int j = 0; j < class_format->getOutputSize(); j++)
+        file->printf("%g ", class_format->class_labels[i][j]);
+      file->printf("\n");
+    }
+  
+    file->printf("# Confusion matrix [rows: observed, colums: desired]:\n");
+    for(int i = 0; i < n_classes; i++)
+    {
+      for(int j = 0; j < n_classes; j++)
+        file->printf("%d ", confusion[i][j]);
+      file->printf("\n");
+    }
+  }
+  file->flush();
+}
+
+void ClassMeasurer::reset_()
+{
+  n_examples = 0;
+  internal_error = 0;
+  if(calc_confusion_at_each_iter)
+  {
+    for(int i = 0; i < n_classes; i++)
+    {
+      for(int j = 0; j < n_classes; j++)
+        confusion[i][j] = 0;
+    }
+  }
+}
+
+void ClassMeasurer::reset()
+{
+  reset_();
+}
+
+ClassMeasurer::~ClassMeasurer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/ClassMeasurer.h work/main.d/Torch-3/core/ClassMeasurer.h
--- tmp/Torch-3/core/ClassMeasurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/ClassMeasurer.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,75 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLASS_MEASURER_INC
+#define CLASS_MEASURER_INC
+
+#include "Measurer.h"
+#include "ClassFormat.h"
+
+namespace Torch {
+
+/** Compute the classification error (in %)
+    of the #inputs# with respect to the #targets# of #data#.
+
+    The format of the class is given with a #ClassFormat#.
+    It can print the confusion matrix if specified.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class ClassMeasurer : public Measurer
+{
+  public:
+    real internal_error;
+    int **confusion;
+    Sequence *inputs;
+    ClassFormat *class_format;
+    bool calc_confusion_at_each_iter;
+    int n_classes;
+    int n_examples;
+
+    //-----
+
+    ///
+    ClassMeasurer(Sequence *inputs_, DataSet *data_, ClassFormat *class_format_, XFile *file_,
+                  bool calc_confusion_at_each_iter_=false);
+
+    //-----
+
+    void printConfusionMatrix();
+    virtual void reset();
+    virtual void measureExample();
+    virtual void measureIteration();
+    void reset_();
+
+    virtual ~ClassMeasurer();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/ClassNLLMeasurer.cc work/main.d/Torch-3/core/ClassNLLMeasurer.cc
--- tmp/Torch-3/core/ClassNLLMeasurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/ClassNLLMeasurer.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,79 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "ClassNLLMeasurer.h"
+
+namespace Torch {
+
+ClassNLLMeasurer::ClassNLLMeasurer(Sequence *inputs_, DataSet *data_, ClassFormat *class_format_, XFile *file_) : Measurer(data_, file_)
+{
+  class_format = class_format_;
+  inputs = inputs_;
+  internal_error = 0;
+
+  addBOption("average examples", &average_examples, true, "divided by the number of examples");
+  addBOption("average frames", &average_frames, true, "divided by the number of frames");
+}
+
+void ClassNLLMeasurer::measureExample()
+{
+  real sum = 0;
+  for(int i = 0; i < inputs->n_frames; i++)
+  {
+    int the_class = class_format->getClass(data->targets->frames[i]);
+    sum += inputs->frames[i][the_class];
+  }
+  if(average_frames)
+    sum /= inputs->n_frames;
+
+  internal_error -= sum;
+}
+
+void ClassNLLMeasurer::measureIteration()
+{
+  if(average_examples)
+    internal_error /= data->n_examples;
+
+  if(binary_mode)
+    file->write(&internal_error, sizeof(real), 1);
+  else
+    file->printf("%g\n", internal_error);
+  file->flush();
+  reset();
+}
+
+void ClassNLLMeasurer::reset()
+{
+  internal_error = 0;
+}
+
+ClassNLLMeasurer::~ClassNLLMeasurer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/ClassNLLMeasurer.h work/main.d/Torch-3/core/ClassNLLMeasurer.h
--- tmp/Torch-3/core/ClassNLLMeasurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/ClassNLLMeasurer.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,73 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLASS_NLL_MEASURER_INC
+#define CLASS_NLL_MEASURER_INC
+
+#include "Measurer.h"
+#include "DataSet.h"
+#include "ClassFormat.h"
+
+namespace Torch {
+
+/** This class measures the negative log likelihood. In fact, it supposes
+    that for each input frames, frames[i] is the log-probability for class $i$.
+    The given #class_format# gives the class format of the targets of the dataset.
+
+    By default, the measurer divides the log-probabilty by the number of examples
+    and the number of frames.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class ClassNLLMeasurer : public Measurer
+{
+  public:
+    ClassFormat *class_format;
+    bool average_examples;
+    bool average_frames;
+    real internal_error;
+    Sequence *inputs;
+    
+    //-----
+
+    ///
+    ClassNLLMeasurer(Sequence *inputs_, DataSet *data_, ClassFormat *class_format_, XFile *file_);
+
+    //-----
+
+    virtual void reset();
+    virtual void measureExample();
+    virtual void measureIteration();
+
+    virtual ~ClassNLLMeasurer();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/CmdLine.cc work/main.d/Torch-3/core/CmdLine.cc
--- tmp/Torch-3/core/CmdLine.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/CmdLine.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,537 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "CmdLine.h"
+#include <time.h>
+
+namespace Torch {
+
+// Oy. J'ai fait le menage dans c'te classe.
+// Pleins de features non documentees dans le tutorial!
+
+CmdLine::CmdLine()
+{
+  n_master_switches = 1; // the default!
+  n_cmd_options = (int *)allocator->alloc(sizeof(int));
+  cmd_options = (CmdOption ***)allocator->alloc(sizeof(CmdOption **));
+  n_cmd_options[0] = 0;
+  cmd_options[0] = NULL;
+  text_info = NULL;
+  working_directory = (char *)allocator->alloc(2);
+  strcpy(working_directory, ".");
+  associated_files = NULL;
+  n_associated_files = 0;
+  master_switch = -1;
+  program_name = (char *)allocator->alloc(1);
+  *program_name = '\0';
+
+  addBOption("write log", &write_log, true, "Should I output the cmd.log file ?");
+}
+
+void CmdLine::info(const char *text)
+{
+  if(text_info)
+    allocator->free(text_info);
+
+  text_info = (char *)allocator->alloc(strlen(text)+1);
+
+  strcpy(text_info, text);
+}
+
+void CmdLine::addCmdOption(CmdOption *option)
+{
+  if(option->isMasterSwitch())
+  {
+    n_cmd_options = (int *)allocator->realloc(n_cmd_options, sizeof(int)*(n_master_switches+1));
+    cmd_options = (CmdOption ***)allocator->realloc(cmd_options, sizeof(CmdOption **)*(n_master_switches+1));
+    n_cmd_options[n_master_switches] = 0;
+    cmd_options[n_master_switches] = NULL;
+    n_master_switches++;
+  }
+
+  int n = n_master_switches-1;
+  cmd_options[n] = (CmdOption **)allocator->realloc(cmd_options[n], (n_cmd_options[n]+1)*sizeof(CmdOption *));
+  cmd_options[n][n_cmd_options[n]] = option;
+  
+  n_cmd_options[n]++;
+}
+
+void CmdLine::addMasterSwitch(const char *text)
+{
+  CmdOption *option = new(allocator) CmdOption(text, "", "", false);
+  option->isMasterSwitch(true);
+  addCmdOption(option);
+}
+
+void CmdLine::addICmdOption(const char *name, int *ptr, int init_value, const char *help, bool save_it)
+{
+  IntCmdOption *option = new(allocator) IntCmdOption(name, ptr, init_value, help, save_it);
+  addCmdOption(option);
+}
+
+void CmdLine::addBCmdOption(const char *name, bool *ptr, bool init_value, const char *help, bool save_it)
+{
+  BoolCmdOption *option = new(allocator) BoolCmdOption(name, ptr, init_value, help, save_it);
+  addCmdOption(option);
+}
+
+void CmdLine::addRCmdOption(const char *name, real *ptr, real init_value, const char *help, bool save_it)
+{
+  RealCmdOption *option = new(allocator) RealCmdOption(name, ptr, init_value, help, save_it);
+  addCmdOption(option);
+}
+
+void CmdLine::addSCmdOption(const char *name, char **ptr, const char *init_value, const char *help, bool save_it)
+{
+  StringCmdOption *option = new(allocator) StringCmdOption(name, ptr, init_value, help, save_it);
+  addCmdOption(option);
+}
+
+void CmdLine::addICmdArg(const char *name, int *ptr, const char *help, bool save_it)
+{
+  IntCmdOption *option = new(allocator) IntCmdOption(name, ptr, 0, help, save_it);
+  option->isArgument(true);
+  addCmdOption(option);
+}
+
+void CmdLine::addBCmdArg(const char *name, bool *ptr, const char *help, bool save_it)
+{
+  BoolCmdOption *option = new(allocator) BoolCmdOption(name, ptr, false, help, save_it);
+  option->isArgument(true);
+  addCmdOption(option);
+}
+
+void CmdLine::addRCmdArg(const char *name, real *ptr, const char *help, bool save_it)
+{
+  RealCmdOption *option = new(allocator) RealCmdOption(name, ptr, 0., help, save_it);
+  option->isArgument(true);
+  addCmdOption(option);
+}
+
+void CmdLine::addSCmdArg(const char *name, char **ptr, const char *help, bool save_it)
+{
+  StringCmdOption *option = new(allocator) StringCmdOption(name, ptr, "", help, save_it);
+  option->isArgument(true);
+  addCmdOption(option);
+}
+
+void CmdLine::addText(const char *text)
+{
+  CmdOption *option = new(allocator) CmdOption(text, "", "", false);
+  option->isText(true);
+  addCmdOption(option);
+}
+
+int CmdLine::read(int argc_, char **argv_)
+{
+  allocator->free(program_name);
+  program_name = (char *)allocator->alloc(strlen(argv_[0])+1);
+  strcpy(program_name, argv_[0]);
+  argv = argv_+1;
+  argc = argc_-1;
+  
+  // Look for help request and the Master Switch
+  master_switch = 0;
+  if(argc >= 1)
+  {
+    if( ! (strcmp(argv[0], "-h") && strcmp(argv[0], "-help") && strcmp(argv[0], "--help")) )
+      help();
+
+    for(int i = 1; i < n_master_switches; i++)
+    {
+      if(cmd_options[i][0]->isCurrent(&argc, &argv))
+      {
+        master_switch = i;
+        break;
+      }
+    }
+  }
+  
+  CmdOption **cmd_options_ = cmd_options[master_switch];
+  int n_cmd_options_ = n_cmd_options[master_switch];
+
+  // Initialize the options.
+  for(int i = 0; i < n_cmd_options_; i++)
+    cmd_options_[i]->initValue();
+
+  while(argc > 0)
+  {
+    // First, check the option.
+    int current_option = -1;    
+    for(int i = 0; i < n_cmd_options_; i++)
+    {
+      if(cmd_options_[i]->isCurrent(&argc, &argv))
+      {
+        current_option = i;
+        break;
+      }
+    }
+
+    if(current_option >= 0)
+    {
+      if(cmd_options_[current_option]->is_setted)
+        error("CmdLine: option %s is setted twice", cmd_options_[current_option]->name);
+      cmd_options_[current_option]->read(&argc, &argv);
+      cmd_options_[current_option]->is_setted = true;
+    }
+    else
+    {
+      // Check for arguments
+      for(int i = 0; i < n_cmd_options_; i++)
+      {
+        if(cmd_options_[i]->isArgument() && (!cmd_options_[i]->is_setted))
+        {
+          current_option = i;
+          break;
+        }
+      }
+       
+      if(current_option >= 0)
+      {
+        cmd_options_[current_option]->read(&argc, &argv);
+        cmd_options_[current_option]->is_setted = true;        
+      }
+      else
+        error("CmdLine: parse error near <%s>. Too many arguments.", argv[0]);
+    }    
+  }
+
+  // Check for empty arguments
+  for(int i = 0; i < n_cmd_options_; i++)
+  {
+    if(cmd_options_[i]->isArgument() && (!cmd_options_[i]->is_setted))
+    {
+      message("CmdLine: not enough arguments!\n");
+      help();
+    }
+  }
+
+  if(write_log)
+  {
+    DiskXFile cmd_log("cmd.log", "w");
+    writeLog(&cmd_log, false);
+  }
+  return master_switch;
+}
+
+// RhhAHha AH AHa hha hahaAH Ha ha ha
+
+void CmdLine::help()
+{
+  if(text_info)
+    print("%s\n", text_info);
+
+  for(int master_switch_ = 0; master_switch_ < n_master_switches; master_switch_++)
+  {
+    int n_cmd_options_ = n_cmd_options[master_switch_];
+    CmdOption **cmd_options_ = cmd_options[master_switch_];
+
+    int n_real_options = 0;
+    for(int i = 0; i < n_cmd_options_; i++)
+    {
+      if(cmd_options_[i]->isOption())
+        n_real_options++;
+    }
+
+    if(master_switch_ == 0)
+    {
+      print("#\n");
+      print("# usage: %s", program_name);
+      if(n_real_options > 0)
+        print(" [options]");
+    }
+    else
+    {
+      print("\n#\n");
+      print("# or: %s %s", program_name, cmd_options_[0]->name);
+      if(n_real_options > 0)
+        print(" [options]");
+    }
+
+    for(int i = 0; i < n_cmd_options_; i++)
+    {
+      if(cmd_options_[i]->isArgument())
+        print(" <%s>", cmd_options_[i]->name);
+    }
+    print("\n#\n");
+
+    // Cherche la longueur max du param
+    int long_max = 0;
+    for(int i = 0; i < n_cmd_options_; i++)
+    {
+      int laurence = 0;
+      if(cmd_options_[i]->isArgument())
+        laurence = strlen(cmd_options_[i]->name)+2;
+
+      if(cmd_options_[i]->isOption())
+        laurence = strlen(cmd_options_[i]->name)+strlen(cmd_options_[i]->type_name)+1;
+      
+      if(long_max < laurence)
+        long_max = laurence;
+    }
+
+    for(int i = 0; i < n_cmd_options_; i++)
+    {
+      int z = 0;
+      if(cmd_options_[i]->isText())
+      {
+        z = -1;
+        print("%s", cmd_options_[i]->name);
+      }
+
+      if(cmd_options_[i]->isArgument())
+      {
+        z = strlen(cmd_options_[i]->name)+2;
+        print("  ");
+        print("<%s>", cmd_options_[i]->name);
+      }
+      
+      if(cmd_options_[i]->isOption())
+      {
+        z = strlen(cmd_options_[i]->name)+strlen(cmd_options_[i]->type_name)+1;
+        print("  ");
+        print("%s", cmd_options_[i]->name);
+        print(" %s", cmd_options_[i]->type_name);
+      }
+
+      if(z >= 0)
+      {
+        for(int i = 0; i < long_max+1-z; i++)
+          print(" ");
+      }
+      
+      if( cmd_options_[i]->isOption() || cmd_options_[i]->isArgument() )
+        print("-> %s", cmd_options_[i]->help);
+    
+      if(cmd_options_[i]->isArgument())
+        print(" (%s)", cmd_options_[i]->type_name);
+
+      if(cmd_options_[i]->isOption())
+      {
+        DiskXFile std_out(stdout);
+        print(" ");
+        cmd_options_[i]->printValue(&std_out);
+      }
+
+      if(!cmd_options_[i]->isMasterSwitch())
+        print("\n");
+    }
+  }  
+  exit(-1);
+}
+
+void CmdLine::setWorkingDirectory(const char* dirname)
+{
+  allocator->free(working_directory);
+  working_directory = (char *)allocator->alloc(strlen(dirname)+1);
+  strcpy(working_directory, dirname);
+}
+
+char *CmdLine::getPath(const char *filename)
+{
+  associated_files = (char **)allocator->realloc(associated_files, sizeof(char *)*(n_associated_files+1));
+  char *path_ = (char *)allocator->alloc(strlen(working_directory)+strlen(filename)+2);
+  strcpy(path_, working_directory);
+  strcat(path_, "/");
+  strcat(path_, filename);
+  associated_files[n_associated_files] = (char *)allocator->alloc(strlen(filename)+1);
+  strcpy(associated_files[n_associated_files], filename);
+  n_associated_files++;
+  return path_;
+}
+
+DiskXFile *CmdLine::getXFile(const char *filename)
+{
+  char *full_file_name = this->getPath(filename);
+  DiskXFile *file_ = new(allocator) DiskXFile(full_file_name, "w");
+  return file_;
+}
+
+void CmdLine::saveXFile(XFile *file)
+{
+  if(master_switch < 0)
+    error("CmdLine: nothing to save!");
+
+  writeLog(file, true);
+
+  file->taggedWrite(&master_switch, sizeof(int), 1, "MASTER_SWITCH");
+  CmdOption **cmd_options_ = cmd_options[master_switch];
+  int n_cmd_options_ = n_cmd_options[master_switch];
+  for(int i = 0; i < n_cmd_options_; i++)
+  {
+    if(cmd_options_[i]->save)
+      cmd_options_[i]->saveXFile(file);
+  }
+}
+
+void CmdLine::writeLog(XFile *file, bool write_associated_files)
+{
+  // Header
+  time_t time_ = time(NULL);
+  file->printf("# Date: %s", ctime(&time_));
+  file->printf("# Program: %s\n", program_name);
+  if(master_switch < 0)
+    file->printf("\n# CmdLine not read\n");
+  if(master_switch == 0)
+    file->printf("\n# Mode: default\n");
+  if(master_switch > 0)
+    file->printf("\n# Mode: <%s>\n", cmd_options[master_switch][0]->name);
+
+  CmdOption **cmd_options_ = cmd_options[master_switch];
+  int n_cmd_options_ = n_cmd_options[master_switch];
+
+  // Cherche la longueur max du param
+  int long_max = 0;
+  for(int i = 0; i < n_cmd_options_; i++)
+  {
+    int z = 0;
+    if(cmd_options_[i]->isArgument())
+      z = strlen(cmd_options_[i]->name)+2;
+    
+    if(cmd_options_[i]->isOption())
+      z = strlen(cmd_options_[i]->name)+strlen(cmd_options_[i]->type_name)+1;
+    
+    if(long_max < z)
+      long_max = z;
+  }
+
+  file->printf("\n# Arguments:\n");
+  for(int i = 0; i < n_cmd_options_; i++)
+  {
+    if(!cmd_options_[i]->isArgument())
+      continue;
+
+    int z = strlen(cmd_options_[i]->name)+2;
+    file->printf("    ");
+    file->printf("%s", cmd_options_[i]->name);
+
+    if(z >= 0)
+    {
+      for(int i = 0; i < long_max+1-z; i++)
+        file->printf(" ");
+    }
+
+    cmd_options_[i]->printValue(file);
+    file->printf("\n");
+  }  
+
+  file->printf("\n# Options:\n");
+  for(int i = 0; i < n_cmd_options_; i++)
+  {
+    if(!cmd_options_[i]->isOption())
+      continue;
+
+    int z = strlen(cmd_options_[i]->name)+2;
+    if(cmd_options_[i]->is_setted)
+      file->printf(" *  ");
+    else
+      file->printf("    ");
+    
+    file->printf("%s", cmd_options_[i]->name);
+
+    if(z >= 0)
+    {
+      for(int i = 0; i < long_max+1-z; i++)
+        file->printf(" ");
+    }
+
+    cmd_options_[i]->printValue(file);
+    file->printf("\n");
+  }  
+
+  if(write_associated_files)
+  {
+    file->printf("\n# Associated files:\n");
+    for(int i = 0; i < n_associated_files; i++)
+      file->printf("    %s\n", associated_files[i]);
+  }
+
+  file->printf("\n<#>\n\n");
+}
+
+
+void CmdLine::loadXFile(XFile *file)
+{
+  // Skip the header
+  int header_end = 0;
+  while( (header_end != 3) && (!file->eof()) )
+  {
+    char c;
+    file->scanf("%c", &c);
+    if(c == '<')
+      header_end = 1;
+    else
+    {
+      if(c == '#')
+      {
+        if(header_end == 1)
+          header_end = 2;
+        else
+          header_end = 0;
+      }
+      else
+      {
+        if(c == '>')
+        {
+          if(header_end == 2)
+          {
+            header_end = 3;
+            // the return-lines
+            file->scanf("%c", &c);
+            file->scanf("%c", &c);
+          }
+          else
+            header_end = 0;
+        }
+        else
+          header_end = 0;
+      }
+    }
+  }
+  
+  if(header_end != 3)
+    error("CmdLine: cannot find the end of the header!");
+
+  //////////////////
+
+  int old_master_switch;
+  file->taggedRead(&old_master_switch, sizeof(int), 1, "MASTER_SWITCH");
+  CmdOption **cmd_options_ = cmd_options[old_master_switch];
+  int n_cmd_options_ = n_cmd_options[old_master_switch];
+  for(int i = 0; i < n_cmd_options_; i++)
+  {
+    if(cmd_options_[i]->save)
+      cmd_options_[i]->loadXFile(file);
+  }
+}
+
+CmdLine::~CmdLine()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/CmdLine.h work/main.d/Torch-3/core/CmdLine.h
--- tmp/Torch-3/core/CmdLine.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/CmdLine.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,183 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CMD_LINE_INC
+#define CMD_LINE_INC
+
+#include "Object.h"
+#include "CmdOption.h"
+#include "DiskXFile.h"
+
+namespace Torch {
+
+/** This class provides a useful interface for the user,
+    to easily read some arguments/options from the command-line.
+    
+    Note that here, we make a difference between:
+    \begin{itemize}
+      \item {\bf options} which are not required.
+      \item {\bf arguments} which are required.
+    \end{itemize}
+
+    Options:
+    \begin{tabular}{lcll}
+      "write log"  &  bool  &  Should I output the cmd.log file ? & [true]
+    \end{tabular}
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @see CmdOption
+*/
+class CmdLine : public Object
+{
+  public:
+    char *program_name;
+    bool write_log;
+    int n_master_switches;
+    int *n_cmd_options;
+    CmdOption ***cmd_options;
+    char *text_info;
+
+    char *working_directory;
+    char **associated_files;
+    int n_associated_files;
+    int master_switch;
+
+    char **argv;
+    int argc;
+
+    // -----
+
+    ///
+    CmdLine();
+
+    /** Read the command-line.
+        Call this function {\bf after} adding options/arguments
+        that you need, with the help of the following functions.
+    */
+    int read(int argc_, char **argv_);
+
+    /** Print the help.
+        Call this function {\bf after} adding options/arguments
+        that you need, with the help of the following functions.
+    */
+    void help();
+
+    //-----
+
+    /** Functions for adding options.
+        The calling order of the following functions will
+        define the text order associated when you will call #help()#.
+        
+        Add an option (Int, Bool, Real, String).
+        \begin{itemize}
+          \item #name# the name of the option (must be unique).
+          \item #ptr# is the pointer on the optional variable.
+          \item #init_value# is the initialization value.
+          \item #help# is the help text for this option.
+        \end{itemize}
+        
+        The option will be setted to #value# in the command-line
+        by printing "#name# #value#"
+    */
+    ///
+    void addICmdOption(const char *name, int *ptr, int init_value, const char *help="", bool save_it=false);
+    ///
+    void addBCmdOption(const char *name, bool *ptr, bool init_value, const char *help="", bool save_it=false);
+    ///
+    void addRCmdOption(const char *name, real *ptr, real init_value, const char *help="", bool save_it=false);
+    ///
+    void addSCmdOption(const char *name, char **ptr, const char *init_value, const char *help="", bool save_it=false);
+
+    /** Functions for adding an argument.
+        The argument will be setted to #value# in the command-line
+        by writting "#value#" {\bf after} all the options.
+        If there are N arguments, you have to write
+        "#value1# #value2# #value3# ... #valueN#" to set them in the
+        command-line.
+    */
+    ///
+    void addICmdArg(const char *name, int *ptr, const char *help="", bool save_it=false);
+    ///
+    void addBCmdArg(const char *name, bool *ptr, const char *help="", bool save_it=false);
+    ///
+    void addRCmdArg(const char *name, real *ptr, const char *help="", bool save_it=false);
+    ///
+    void addSCmdArg(const char *name, char **ptr, const char *help="", bool save_it=false);
+
+    /// Add a text line in the help message.
+    void addText(const char *text);
+
+    /// Add a text at the beginnig of the help.
+    void info(const char *text);
+
+    /** Add a master switch.
+        It creates an another type of command line.
+        If the #text# is the first argument of the user command line,
+        only the options corresponding to this new command line will be considered.
+    */
+    void addMasterSwitch(const char *text);
+
+    /** Set the working directory.
+        Use it with #getPath()# and #getXFile()#.
+    */
+    void setWorkingDirectory(const char* dirname);
+
+    /** Get a full path.
+        It adds the #working_directory# before the #filename#.
+        This path will be deleted by CmdLine. */
+    char *getPath(const char *filename);
+
+    /** Get a DiskXFile.
+        It adds the #working_directory# before the #filename# and opens the file.
+        This XFile will be deleted by CmdLine. */
+    DiskXFile *getXFile(const char *filename);
+    
+    /// Load the object from a file pointer (\emph{not the options})
+    virtual void loadXFile(XFile *file);
+
+    /// Save the object to a file pointer (\emph{not the options})
+    virtual void saveXFile(XFile *file);
+
+    //-----
+
+    /** Add an option to the command line. Use this method
+        if the wrappers that are provided are not sufficient.
+    */
+    void addCmdOption(CmdOption *option);
+
+    /** Write a log in #file#.
+        If desired, the associated files can be printed.
+    */
+    void writeLog(XFile *file, bool write_associated_files);
+
+    virtual ~CmdLine();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/CmdOption.cc work/main.d/Torch-3/core/CmdOption.cc
--- tmp/Torch-3/core/CmdOption.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/CmdOption.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,332 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "CmdOption.h"
+#include "XFile.h"
+
+namespace Torch {
+
+CmdOption::CmdOption(const char *name_, const char *type_name_, const char *help_, bool save_)
+{
+  name = (char *)allocator->alloc(strlen(name_)+1);
+  strcpy(name, name_);
+  type_name = (char *)allocator->alloc(strlen(type_name_)+1);
+  strcpy(type_name, type_name_);
+  help = (char *)allocator->alloc(strlen(help_)+1);
+  strcpy(help, help_);
+  save = save_;
+  is_setted = false;
+
+  is_option = true;
+  is_argument = false;
+  is_text = false;
+  is_master_switch = false;
+}
+
+bool CmdOption::isOption(bool set_)
+{
+  if(set_)
+  {
+    is_option = true;
+    is_argument = false;
+    is_text = false;
+    is_master_switch = false;    
+  }
+  return is_option;
+}
+
+bool CmdOption::isArgument(bool set_)
+{
+  if(set_)
+  {
+    is_option = false;
+    is_argument = true;
+    is_text = false;
+    is_master_switch = false;    
+  }
+  return is_argument;
+}
+
+bool CmdOption::isText(bool set_)
+{
+  if(set_)
+  {
+    is_option = false;
+    is_argument = false;
+    is_text = true;
+    is_master_switch = false;    
+  }
+  return is_text;
+}
+
+bool CmdOption::isMasterSwitch(bool set_)
+{
+  if(set_)
+  {
+    is_option = false;
+    is_argument = false;
+    is_text = false;
+    is_master_switch = true;
+  }
+  return is_master_switch;
+}
+
+void CmdOption::initValue()
+{
+}
+
+void CmdOption::printValue(XFile *file_)
+{
+}
+
+void CmdOption::read(int *argc_, char ***argv_)
+{
+}
+
+bool CmdOption::isCurrent(int *argc_, char ***argv_)
+{
+  if(!is_option && !is_master_switch)
+    return false;
+
+  if(strcmp((*argv_)[0], name))
+    return false;
+  else
+  {
+    (*argc_)--;
+    (*argv_)++;
+    return true;
+  }
+}
+
+CmdOption::~CmdOption()
+{
+}
+
+//-------------------------- int
+
+IntCmdOption::IntCmdOption(const char *name_, int *ptr_, int init_value_, const char *help_, bool save_)
+  : CmdOption(name_, "<int>", help_, save_)
+{
+  ptr = ptr_;
+  init_value = init_value_;
+}
+
+void IntCmdOption::initValue()
+{
+  *ptr = init_value;
+}
+
+void IntCmdOption::printValue(XFile *file_)
+{
+  if(is_setted)
+    file_->printf("[%d]", *ptr);
+  else
+    file_->printf("[%d]", init_value);
+}
+
+
+void IntCmdOption::read(int *argc_, char ***argv_)
+{
+  char **argv = *argv_;
+  char *maryline;
+
+  if(*argc_ == 0)
+    error("IntCmdOption: cannot correctly set <%s>", name);
+
+  *ptr = strtol(argv[0], &maryline, 10);
+  if( *maryline != '\0' )
+    error("IntCmdOption: <%s> requires an integer", name);
+
+  (*argc_)--;
+  (*argv_)++;
+}
+
+void IntCmdOption::loadXFile(XFile *file)
+{
+  file->taggedRead(ptr, sizeof(int), 1, name);
+}
+
+void IntCmdOption::saveXFile(XFile *file)
+{
+  file->taggedWrite(ptr, sizeof(int), 1, name);
+}
+
+IntCmdOption::~IntCmdOption()
+{
+}
+
+
+//-------------------------- real
+
+RealCmdOption::RealCmdOption(const char *name_, real *ptr_, real init_value_, const char *help_, bool save_)
+  : CmdOption(name_, "<real>", help_, save_)
+{
+  ptr = ptr_;
+  init_value = init_value_;
+}
+
+void RealCmdOption::initValue()
+{
+  *ptr = init_value;
+}
+
+void RealCmdOption::printValue(XFile *file_)
+{
+  if(is_setted)
+    file_->printf("[%g]", *ptr);
+  else
+    file_->printf("[%g]", init_value);
+}
+
+
+void RealCmdOption::read(int *argc_, char ***argv_)
+{
+  char **argv = *argv_;
+  char *maryline;
+
+  if(*argc_ == 0)
+    error("RealCmdOption: cannot correctly set <%s>", name);
+
+  *ptr = strtod(argv[0], &maryline);
+  if( *maryline != '\0' )
+    error("RealCmdOption: <%s> requires a real", name);
+
+  (*argc_)--;
+  (*argv_)++;
+}
+
+void RealCmdOption::loadXFile(XFile *file)
+{
+  file->taggedRead(ptr, sizeof(real), 1, name);
+}
+
+void RealCmdOption::saveXFile(XFile *file)
+{
+  file->taggedWrite(ptr, sizeof(real), 1, name);
+}
+
+RealCmdOption::~RealCmdOption()
+{
+}
+
+//-------------------------- switch
+
+BoolCmdOption::BoolCmdOption(const char *name_, bool *ptr_, bool init_value_, const char *help_, bool save_)
+  : CmdOption(name_, "", help_, save_)
+{
+  ptr = ptr_;
+  init_value = init_value_;
+}
+
+void BoolCmdOption::initValue()
+{
+  *ptr = init_value;
+}
+
+void BoolCmdOption::read(int *argc_, char ***argv_)
+{
+  *ptr = !(*ptr);
+}
+
+void BoolCmdOption::loadXFile(XFile *file)
+{
+  int melanie;
+  file->taggedRead(&melanie, sizeof(int), 1, name);
+  *ptr = (melanie ? 1 : 0);
+}
+
+void BoolCmdOption::saveXFile(XFile *file)
+{
+  int melanie = (*ptr ? 1 : 0);
+  file->taggedWrite(&melanie, sizeof(int), 1, name);
+}
+
+BoolCmdOption::~BoolCmdOption()
+{
+}
+
+//-------------------------- string
+
+StringCmdOption::StringCmdOption(const char *name_, char **ptr_, const char *init_value_, const char *help_, bool save_)
+  : CmdOption(name_, "<string>", help_, save_)
+{
+  ptr = ptr_;  
+  init_value = (char *)allocator->alloc(strlen(init_value_)+1);
+  strcpy(init_value, init_value_);
+}
+
+void StringCmdOption::initValue()
+{
+  *ptr = (char *)allocator->alloc(strlen(init_value)+1);
+  strcpy(*ptr, init_value);
+}
+
+void StringCmdOption::printValue(XFile *file_)
+{
+  if(is_setted)
+    file_->printf("[%s]", *ptr);
+  else
+    file_->printf("[%s]", init_value);
+}
+
+
+void StringCmdOption::read(int *argc_, char ***argv_)
+{
+  char **argv = *argv_;
+
+  if(*argc_ == 0)
+    error("StringCmdOption: cannot correctly set <%s>", name);
+
+  allocator->free(*ptr);
+  *ptr = (char *)allocator->alloc(strlen(argv[0])+1);
+  strcpy(*ptr, argv[0]);
+
+  (*argc_)--;
+  (*argv_)++;
+}
+
+void StringCmdOption::loadXFile(XFile *file)
+{
+  int melanie;
+  file->taggedRead(&melanie, sizeof(int), 1, "SIZE");
+  *ptr = (char *)allocator->alloc(melanie);
+  file->taggedRead(*ptr, 1, melanie, name);
+}
+
+void StringCmdOption::saveXFile(XFile *file)
+{
+  int melanie = strlen(*ptr)+1;
+  file->taggedWrite(&melanie, sizeof(int), 1, "SIZE");
+  file->taggedWrite(*ptr, 1, melanie, name);
+}
+
+StringCmdOption::~StringCmdOption()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/CmdOption.h work/main.d/Torch-3/core/CmdOption.h
--- tmp/Torch-3/core/CmdOption.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/CmdOption.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,208 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CMD_OPTION_INC
+#define CMD_OPTION_INC
+
+#include "Object.h"
+
+namespace Torch {
+
+/** This class defines an option for the command line.
+    If you need special command line arguments/options,
+    you have to create a new children of this class.
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @see CmdLine
+*/
+class CmdOption : public Object
+{
+  private:
+    // Special flags.
+    bool is_option;
+    bool is_argument;
+    bool is_text;
+    bool is_master_switch;
+
+  public:
+    /// Name of the option.
+    char *name;
+
+    /// Type name of the option.
+    char *type_name;
+
+    /** An help string.
+        Cannot be NULL.
+    */
+    char *help;
+
+    /** True is the option has to be saved
+        when saving the command line.
+    */
+    bool save;
+
+    /** True is the option has been setted after
+        reading the command-line.
+    */
+    bool is_setted;
+
+    //////////////////////
+
+    ///
+    CmdOption(const char *name_, const char *type_name_, const char *help_="", bool save_=false);
+
+    /// Initialize the value of the option.
+    virtual void initValue();
+
+    /// If #is_setted# is true, print the current value, else the init value.
+    virtual void printValue(XFile *file_);
+
+    /** Read the option on the command line.
+        argv_ and argc_ have to point of the next
+        option after that.
+    */
+    virtual void read(int *argc_, char ***argv_);
+
+    /* Return true if the option is on the command line.
+       Decrements argc_ and increment argv_ if true.
+    */
+    bool isCurrent(int *argc_, char ***argv_);
+
+    /** Returns true if it's an optional argument.
+        If #set_# is true, set it to an optional argument.
+    */
+    bool isOption(bool set_=false);
+
+    /** Returns true if it's a required argument.
+        If #set_# is true, set it to a required argument.
+    */
+    bool isArgument(bool set_=false);
+
+    /** Returns true if it's just text to be displayed in the command line.
+        If #set_# is true, set it to text mode.
+    */
+    bool isText(bool set_=false);
+
+    /** Returns true if it's a master switch.
+        If #set_# is true, set it to a master switch.
+    */
+    bool isMasterSwitch(bool set_=false);
+    
+    ~CmdOption();
+};
+
+/** This class defines a integer command-line option.
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @see CmdLine
+*/
+class IntCmdOption : public CmdOption
+{
+  public:
+    int *ptr;
+    int init_value;
+
+    ///
+    IntCmdOption(const char *name_, int *ptr_, int init_value_, const char *help_="", bool save_=false);
+
+    virtual void initValue();
+    virtual void printValue(XFile *file_);
+    virtual void read(int *argc_, char ***argv_);
+    virtual void loadXFile(XFile *file);
+    virtual void saveXFile(XFile *file);
+    ~IntCmdOption();
+};
+
+/** This class defines a real command-line option.
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @see CmdLine
+*/
+class RealCmdOption : public CmdOption
+{
+  public:
+    real *ptr;
+    real init_value;
+
+    ///
+    RealCmdOption(const char *name_, real *ptr_, real init_value_, const char *help_="", bool save_=false);
+
+    virtual void initValue();
+    virtual void printValue(XFile *file_);
+    virtual void read(int *argc_, char ***argv_);
+    virtual void loadXFile(XFile *file);
+    virtual void saveXFile(XFile *file);
+    ~RealCmdOption();
+};
+
+/** This class defines a bool command-line option.
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @see CmdLine
+*/
+class BoolCmdOption : public CmdOption
+{
+  public:
+    bool *ptr;
+    bool init_value;
+
+    ///
+    BoolCmdOption(const char *name_, bool *ptr_, bool init_value_, const char *help_="", bool save_=false);
+
+    virtual void initValue();
+    virtual void read(int *argc_, char ***argv_);
+    virtual void loadXFile(XFile *file);
+    virtual void saveXFile(XFile *file);
+    ~BoolCmdOption();
+};
+
+/** This class defines a string command-line option.
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @see CmdLine
+*/
+class StringCmdOption : public CmdOption
+{
+  public:
+    char **ptr;
+    char *init_value;
+
+    ///
+    StringCmdOption(const char *name_, char **ptr_, const char *init_value_, const char *help_="", bool save_=false);
+
+    virtual void initValue();
+    virtual void printValue(XFile *file_);
+    virtual void read(int *argc_, char ***argv_);
+    virtual void loadXFile(XFile *file);
+    virtual void saveXFile(XFile *file);
+    ~StringCmdOption();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/DataSet.cc work/main.d/Torch-3/core/DataSet.cc
--- tmp/Torch-3/core/DataSet.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/DataSet.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,130 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "DataSet.h"
+
+namespace Torch {
+
+DataSet::DataSet()
+{
+  n_targets = 0;
+  targets = NULL;
+  n_inputs = 0;
+  inputs = NULL;
+  n_examples = 0;
+  n_real_examples = 0;
+  select_examples = false;  
+  selected_examples = NULL;
+  subsets = NULL;
+  n_examples_subsets = NULL;
+  n_subsets = 0;
+
+  // Indeterminated state...
+  real_current_example_index = -1;
+
+  // Pushed Examples...
+  pushed_examples = new(allocator) Stack;
+}
+
+void DataSet::init(int n_examples_, int n_inputs_, int n_targets_)
+{
+  n_examples = n_examples_;
+  n_real_examples = n_examples_;
+  n_inputs = n_inputs_;
+  n_targets = n_targets_;
+
+  select_examples = false;
+  selected_examples = (int *)allocator->alloc(sizeof(int)*n_examples);
+  for(int i = 0; i < n_examples; i++)
+    selected_examples[i] = i;
+}
+
+void DataSet::pushSubset(int *subset_, int n_examples_)
+{
+  subsets = (int **)allocator->realloc(subsets, sizeof(int *)*(n_subsets+1));
+  n_examples_subsets = (int *)allocator->realloc(n_examples_subsets, sizeof(int)*(n_subsets+1));
+  subsets[n_subsets] = subset_;
+  n_examples_subsets[n_subsets] = n_examples_;
+  n_subsets++;
+
+  selected_examples = (int *)allocator->realloc(selected_examples, sizeof(int)*n_examples_);
+  for(int t = 0; t < n_examples_; t++)
+  {
+    int index = subset_[t];
+    for(int s = n_subsets-2; s >= 0; s--)
+      index = subsets[s][index];
+    selected_examples[t] = index;
+  }
+
+  select_examples = true;
+  n_examples = n_examples_;  
+}
+
+void DataSet::popSubset()
+{
+  // Rq: realloc renvoie NULL si freed
+  subsets = (int **)allocator->realloc(subsets, sizeof(int *)*(n_subsets-1));
+  n_examples_subsets = (int *)allocator->realloc(n_examples_subsets, sizeof(int)*(n_subsets-1));
+  n_subsets--;
+    
+  if(n_subsets == 0)
+  {
+    select_examples = false;
+    n_examples = n_real_examples;
+
+    selected_examples = (int *)allocator->realloc(selected_examples, sizeof(int)*n_examples);
+    for(int i = 0; i < n_examples; i++)
+      selected_examples[i] = i;
+  }
+  else
+  {
+    int n_examples_ = n_examples_subsets[n_subsets-1];
+    int *subset_ = subsets[n_subsets-1];
+    selected_examples = (int *)allocator->realloc(selected_examples, sizeof(int)*n_examples_);
+    for(int t = 0; t < n_examples_; t++)
+    {
+      int index = subset_[t];
+      for(int s = n_subsets-2; s >= 0; s--)
+        index = subsets[s][index];
+      selected_examples[t] = index;
+    }
+    n_examples = n_examples_;
+  }
+}
+
+void DataSet::setExample(int t, bool set_inputs, bool set_targets)
+{  
+  int t_ = (select_examples ? selected_examples[t] : t);
+  setRealExample(t_, set_inputs, set_targets);
+}
+
+DataSet::~DataSet()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/DataSet.h work/main.d/Torch-3/core/DataSet.h
--- tmp/Torch-3/core/DataSet.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/DataSet.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,178 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DATA_SET_INC
+#define DATA_SET_INC
+
+#include "Object.h"
+#include "Sequence.h"
+#include "PreProcessing.h"
+#include "Stack.h"
+
+struct FrameSubsets
+{
+    int **subsets;
+    int *subsets_sizes;
+    int n_subsets;
+    int n_selected_frames;
+    int *selected_frames;
+};
+
+namespace Torch {
+
+/** Provides an interface to manipulate all kind of data.
+    A dataset contains two kind of things: inputs sequences
+    and targets sequences.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class DataSet : public Object
+{
+  public:
+    //--- internal ---
+    int **subsets;
+    int *n_examples_subsets;
+    int n_subsets;
+    Stack *pushed_examples;
+    //----------------
+    
+    // True if a subset of the examples is selected.
+    bool select_examples;
+
+    /** The indices of all selected examples.
+        When #select_examples# is false, it contains
+        the indices of all examples.
+    */
+    int *selected_examples;
+
+    /// Frame size of #inputs#.    
+    int n_inputs;
+
+    /// Frame size of #targets#.    
+    int n_targets;
+
+    /** Index of the current example.
+        Warning: it's the \emph{real} index and not the index
+        in the #selected_examples# table.
+    */
+    int real_current_example_index;
+
+    /// Pointer on the inputs of the current example.
+    Sequence *inputs;
+
+    /// Pointer to the targets of the current example.
+    Sequence *targets;
+
+    /** Number of examples in the dataset.
+        If you're using #select_examples#, it's
+        the number of selected examples.
+    */
+    int n_examples;
+    
+    /** Real number of examples in the dataset.
+        It's the number of examples in memory.
+        (= #n_examples# if #select_examples# is false)
+    */
+    int n_real_examples;
+
+    //-----
+
+    ///
+    DataSet();
+
+    /** Method which initializes some fields of the datasets.
+        It has to be called only in the constructor of your subclasses.
+        Just for developpers of new datasets.
+    */
+    void init(int n_examples_, int n_inputs_, int n_targets_);
+
+    /** Set #targets# and #inputs# to the targets and inputs
+        of the example with the index #selected_examples[t]#.
+        Warning: after a #setExample()# the previous selected example
+        is \emph{not} supposed to exist... for that, use #pushExample()#.
+    */
+    void setExample(int t, bool set_inputs=true, bool set_targets=true);
+
+    /** Set #targets# and #inputs# to the targets and inputs
+        of the example with the index #t#. If you create a new
+        dataset, you \emph{must} update inside #current_example_index#.
+        Warning: after a #setExample()# the previous selected example
+        is \emph{not} supposed to exist... for that, use #pushExample()#.
+    */
+    virtual void setRealExample(int t, bool set_inputs=true, bool set_targets=true) = 0;
+
+    /** Set a new subset.
+        \begin{itemize}
+          \item #subset_# (of size #n_examples_#) is a set
+          of indices which define a subset of #data#.
+          \item if a #pushSubset()# has been already called,
+          the next #pushSubset()# defines a subset of the
+          previous subset, and so on...
+          \item this function set #select_examples# to #true#
+          and set the read indices of the examples in
+          #selected_examples#.
+        \end{itemize}
+    */
+    virtual void pushSubset(int *subset_, int n_examples_);
+
+    /** Remove the last subset.
+        \begin{itemize}
+          \item recomputes "selected_examples".
+          \item if it was the last subset, set #select_examples#
+          to #false#.
+        \end{itemize}
+    */
+    virtual void popSubset();
+
+    /** Tells that the current example must be kept in memory
+        after next calls of #setExample()#. */
+    virtual void pushExample() = 0;
+
+    /** Tells that the last pushed example will be now the current
+        example, and therefore, will be forgeted after the next
+        call of #setExample()#. */
+    virtual void popExample() = 0;
+
+    /** Put in #n_input_frames# and #n_target_frames# the number
+        of input frames and target frames for example #t#.
+        This take subsets in account.
+        If one field is #NULL#, it will not be returned.
+    */
+    virtual void getNumberOfFrames(int t, int *n_input_frames, int *n_target_frames) = 0;
+
+    /// Perform some pre-processing on data.
+    virtual void preProcess(PreProcessing *pre_processing) = 0;
+
+    //-----
+
+    virtual ~DataSet();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/.deps_Linux_OPT_FLOAT work/main.d/Torch-3/core/.deps_Linux_OPT_FLOAT
--- tmp/Torch-3/core/.deps_Linux_OPT_FLOAT	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/.deps_Linux_OPT_FLOAT	2008-02-07 11:32:36.000000000 -0200
@@ -0,0 +1,116 @@
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Allocator.o: Allocator.cc Allocator.h general.h Object.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Bagging.o: Bagging.cc Bagging.h Trainer.h Object.h general.h Allocator.h \
+  Machine.h DataSet.h Sequence.h List.h PreProcessing.h Stack.h \
+  Measurer.h XFile.h WeightedSumMachine.h Random.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Boosting.o: Boosting.cc Boosting.h Trainer.h Object.h general.h \
+  Allocator.h Machine.h DataSet.h Sequence.h List.h PreProcessing.h \
+  Stack.h Measurer.h XFile.h WeightedSumMachine.h ClassFormat.h \
+  BoostingMeasurer.h Random.h NullXFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/BoostingMeasurer.o: BoostingMeasurer.cc BoostingMeasurer.h Measurer.h \
+  Object.h general.h Allocator.h Machine.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h XFile.h ClassFormat.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassFormat.o: ClassFormat.cc ClassFormat.h Object.h general.h \
+  Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassFormatDataSet.o: ClassFormatDataSet.cc ClassFormatDataSet.h \
+  DataSet.h Object.h general.h Allocator.h Sequence.h List.h \
+  PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassMeasurer.o: ClassMeasurer.cc ClassMeasurer.h Measurer.h Object.h \
+  general.h Allocator.h Machine.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h XFile.h ClassFormat.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/ClassNLLMeasurer.o: ClassNLLMeasurer.cc ClassNLLMeasurer.h Measurer.h \
+  Object.h general.h Allocator.h Machine.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h XFile.h ClassFormat.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/CmdLine.o: CmdLine.cc CmdLine.h Object.h general.h Allocator.h \
+  CmdOption.h DiskXFile.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/CmdOption.o: CmdOption.cc CmdOption.h Object.h general.h Allocator.h \
+  XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/DataSet.o: DataSet.cc DataSet.h Object.h general.h Allocator.h Sequence.h \
+  List.h PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/DiskDataSet.o: DiskDataSet.cc DiskDataSet.h DataSet.h Object.h general.h \
+  Allocator.h Sequence.h List.h PreProcessing.h Stack.h IOSequence.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/DiskMatDataSet.o: DiskMatDataSet.cc DiskMatDataSet.h DiskDataSet.h \
+  DataSet.h Object.h general.h Allocator.h Sequence.h List.h \
+  PreProcessing.h Stack.h IOSequence.h IOBufferize.h IOAscii.h \
+  DiskXFile.h XFile.h IOMulti.h IOBin.h IOSub.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/DiskXFile.o: DiskXFile.cc DiskXFile.h XFile.h Object.h general.h \
+  Allocator.h string_utils.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/FileListCmdOption.o: FileListCmdOption.cc FileListCmdOption.h CmdOption.h \
+  Object.h general.h Allocator.h DiskXFile.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/FrameSelectorDataSet.o: FrameSelectorDataSet.cc FrameSelectorDataSet.h \
+  DataSet.h Object.h general.h Allocator.h Sequence.h List.h \
+  PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/general.o: general.cc general.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOAscii.o: IOAscii.cc IOAscii.h IOSequence.h Sequence.h Object.h \
+  general.h Allocator.h List.h DiskXFile.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOBin.o: IOBin.cc IOBin.h IOSequence.h Sequence.h Object.h general.h \
+  Allocator.h List.h DiskXFile.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOBufferize.o: IOBufferize.cc IOBufferize.h IOSequence.h Sequence.h \
+  Object.h general.h Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOMulti.o: IOMulti.cc IOMulti.h IOSequence.h Sequence.h Object.h \
+  general.h Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOSequenceArray.o: IOSequenceArray.cc IOSequenceArray.h Object.h \
+  general.h Allocator.h Sequence.h List.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOSequence.o: IOSequence.cc IOSequence.h Sequence.h Object.h general.h \
+  Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/IOSub.o: IOSub.cc IOSub.h IOBufferize.h IOSequence.h Sequence.h Object.h \
+  general.h Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/KFold.o: KFold.cc KFold.h Trainer.h Object.h general.h Allocator.h \
+  Machine.h DataSet.h Sequence.h List.h PreProcessing.h Stack.h \
+  Measurer.h XFile.h Random.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/log_add.o: log_add.cc log_add.h general.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Machine.o: Machine.cc Machine.h Object.h general.h Allocator.h DataSet.h \
+  Sequence.h List.h PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MatDataSet.o: MatDataSet.cc IOBufferize.h IOSequence.h Sequence.h \
+  Object.h general.h Allocator.h List.h MatDataSet.h MemoryDataSet.h \
+  DataSet.h PreProcessing.h Stack.h IOAscii.h DiskXFile.h XFile.h \
+  IOMulti.h IOBin.h IOSub.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MeanVarNorm.o: MeanVarNorm.cc MeanVarNorm.h PreProcessing.h Sequence.h \
+  Object.h general.h Allocator.h List.h DataSet.h Stack.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Measurer.o: Measurer.cc Measurer.h Object.h general.h Allocator.h \
+  Machine.h DataSet.h Sequence.h List.h PreProcessing.h Stack.h XFile.h \
+  DiskXFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MemoryDataSet.o: MemoryDataSet.cc MemoryDataSet.h DataSet.h Object.h \
+  general.h Allocator.h Sequence.h List.h PreProcessing.h Stack.h \
+  IOSequence.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MemoryXFile.o: MemoryXFile.cc MemoryXFile.h XFile.h Object.h general.h \
+  Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MSEMeasurer.o: MSEMeasurer.cc MSEMeasurer.h Measurer.h Object.h general.h \
+  Allocator.h Machine.h DataSet.h Sequence.h List.h PreProcessing.h \
+  Stack.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/MultiClassFormat.o: MultiClassFormat.cc MultiClassFormat.h ClassFormat.h \
+  Object.h general.h Allocator.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/NullXFile.o: NullXFile.cc NullXFile.h XFile.h Object.h general.h \
+  Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Object.o: Object.cc Object.h general.h Allocator.h DiskXFile.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/OneHotClassFormat.o: OneHotClassFormat.cc OneHotClassFormat.h \
+  ClassFormat.h Object.h general.h Allocator.h DataSet.h Sequence.h \
+  List.h PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/OutputMeasurer.o: OutputMeasurer.cc OutputMeasurer.h Measurer.h Object.h \
+  general.h Allocator.h Machine.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Parameters.o: Parameters.cc Parameters.h Object.h general.h Allocator.h \
+  XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/PipeXFile.o: PipeXFile.cc PipeXFile.h DiskXFile.h XFile.h Object.h \
+  general.h Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/PreProcessing.o: PreProcessing.cc PreProcessing.h Sequence.h Object.h \
+  general.h Allocator.h List.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Random.o: Random.cc Random.h general.h Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Sequence.o: Sequence.cc Sequence.h Object.h general.h Allocator.h List.h \
+  XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Stack.o: Stack.cc Stack.h Object.h general.h Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/string_utils.o: string_utils.cc general.h string_utils.h Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/TimeMeasurer.o: TimeMeasurer.cc TimeMeasurer.h Measurer.h Object.h \
+  general.h Allocator.h Machine.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h XFile.h Timer.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Timer.o: Timer.cc Timer.h Object.h general.h Allocator.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/Trainer.o: Trainer.cc Trainer.h Object.h general.h Allocator.h Machine.h \
+  DataSet.h Sequence.h List.h PreProcessing.h Stack.h Measurer.h XFile.h \
+  Random.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/TwoClassFormat.o: TwoClassFormat.cc TwoClassFormat.h ClassFormat.h \
+  Object.h general.h Allocator.h DataSet.h Sequence.h List.h \
+  PreProcessing.h Stack.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/WeightedSumMachine.o: WeightedSumMachine.cc WeightedSumMachine.h \
+  Trainer.h Object.h general.h Allocator.h Machine.h DataSet.h Sequence.h \
+  List.h PreProcessing.h Stack.h Measurer.h XFile.h
+/home/pablo/gar-castorbox/script/testing/torch/work/main.d/Torch3/objs/Linux_OPT_FLOAT/XFile.o: XFile.cc XFile.h Object.h general.h Allocator.h
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/DiskDataSet.cc work/main.d/Torch-3/core/DiskDataSet.cc
--- tmp/Torch-3/core/DiskDataSet.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/DiskDataSet.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,142 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "DiskDataSet.h"
+
+namespace Torch {
+
+DiskDataSet::DiskDataSet()
+{
+  io_inputs = NULL;
+  io_targets = NULL;
+
+  pre_processes = new(allocator) PreProcessingList;
+}
+
+void DiskDataSet::init(IOSequence *io_inputs_, IOSequence *io_targets_)
+{
+  io_inputs = io_inputs_;
+  io_targets = io_targets_;
+
+  int n_examples_ = 0;
+  if(io_inputs)
+    n_examples_ = io_inputs->n_sequences;
+  if(io_targets)
+    n_examples_ = io_targets->n_sequences;
+
+  if(io_inputs && io_targets)
+  {
+    if(io_inputs->n_sequences != io_targets->n_sequences)
+      error("DiskDataSet: inputs IO and targets IO don't have the same number of sequences!");
+  }
+
+  DataSet::init(n_examples_, (io_inputs ? io_inputs->frame_size : 0), (io_targets ? io_targets->frame_size : 0));
+
+  if(n_inputs > 0)
+    inputs = new(allocator) Sequence(0, n_inputs);
+  if(n_targets > 0)
+    targets = new(allocator) Sequence(0, n_targets);
+}
+
+void DiskDataSet::setRealExample(int t, bool set_inputs, bool set_targets)
+{
+  // Rq: marche car dataset par avec un etat indetermine...
+  if(t == real_current_example_index)
+    return;
+
+  if( (n_inputs > 0) && set_inputs )
+  {
+    int n_frames = io_inputs->getNumberOfFrames(t);
+    inputs->resize(n_frames);
+    io_inputs->getSequence(t, inputs);
+
+    if(pre_processes)
+    {
+      for(int i = 0; i < pre_processes->n_nodes; i++)
+        pre_processes->nodes[i]->preProcessInputs(inputs);
+    }
+  }
+
+  if( (n_targets > 0) && set_targets )
+  {
+    int n_frames = io_targets->getNumberOfFrames(t);
+    targets->resize(n_frames);
+    io_targets->getSequence(t, targets);
+
+    if(pre_processes)
+    {
+      for(int i = 0; i < pre_processes->n_nodes; i++)
+        pre_processes->nodes[i]->preProcessTargets(targets);
+    }
+  }
+
+  real_current_example_index = t;
+}
+
+void DiskDataSet::pushExample()
+{
+  pushed_examples->push(&inputs, sizeof(Sequence *));
+  pushed_examples->push(&targets, sizeof(Sequence *));
+  pushed_examples->push(&real_current_example_index, sizeof(int));
+
+  if(n_inputs > 0)
+    inputs = new(allocator) Sequence(0, n_inputs);
+  if(n_targets > 0)
+    targets = new(allocator) Sequence(0, n_targets);
+
+  real_current_example_index = -1;
+}
+
+void DiskDataSet::popExample()
+{
+  allocator->free(inputs);
+  allocator->free(targets);
+
+  pushed_examples->pop();
+  pushed_examples->pop();
+  pushed_examples->pop();
+}
+
+void DiskDataSet::getNumberOfFrames(int t, int *n_input_frames, int *n_target_frames)
+{
+  if( (n_inputs > 0) && n_input_frames )
+    *n_input_frames = io_inputs->getNumberOfFrames(selected_examples[t]);
+  if( (n_targets > 0) && n_target_frames )
+    *n_target_frames = io_targets->getNumberOfFrames(selected_examples[t]);
+}
+
+void DiskDataSet::preProcess(PreProcessing *pre_processing)
+{
+  pre_processes->addNode(pre_processing);
+}
+
+DiskDataSet::~DiskDataSet()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/DiskDataSet.h work/main.d/Torch-3/core/DiskDataSet.h
--- tmp/Torch-3/core/DiskDataSet.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/DiskDataSet.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,83 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DISK_DATA_SET_INC
+#define DISK_DATA_SET_INC
+
+#include "DataSet.h"
+#include "IOSequence.h"
+#include "List.h"
+
+namespace Torch {
+
+/** Provides an interface to manipulate all kind of data which are
+    kept on disk, and not fully loaded in memory.
+    It uses #IOSequence#.
+    Usefull for large databases.
+    DiskMatDataSet is a good example if you plan to code a new DiskDataSet.
+
+    @see DiskMatDataSet
+    @see IOSequence
+    @author Ronan Collobert (collober@idiap.ch)
+ */
+class DiskDataSet : public DataSet
+{
+  public:
+    /// List if pre processes to do
+    PreProcessingList *pre_processes;
+
+    /// IOMatrix which provides inputs.
+    IOSequence *io_inputs;
+
+    /// IOMatrix which provides targets.
+    IOSequence *io_targets;
+
+    ///
+    DiskDataSet();
+
+    /** This function \emph{has to be called} by your sub-classes.
+        You give here the IOMatrix which handle the inputs
+        and the targets of your dataset.
+        Should be called in the constructor of all yoyr sub-classes.
+     */
+    void init(IOSequence *io_inputs_, IOSequence *io_targets_);
+
+    virtual void getNumberOfFrames(int t, int *n_input_frames, int *n_target_frames);
+    virtual void preProcess(PreProcessing *pre_processing);
+    virtual void setRealExample(int t, bool set_inputs=true, bool set_targets=true);
+    virtual void pushExample();
+    virtual void popExample();
+
+    //-----
+
+    virtual ~DiskDataSet();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/DiskMatDataSet.cc work/main.d/Torch-3/core/DiskMatDataSet.cc
--- tmp/Torch-3/core/DiskMatDataSet.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/DiskMatDataSet.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,216 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "DiskMatDataSet.h"
+#include "IOBufferize.h"
+#include "IOAscii.h"
+#include "IOMulti.h"
+#include "IOBin.h"
+#include "IOSub.h"
+
+namespace Torch {
+
+DiskMatDataSet::DiskMatDataSet(const char *filename, int n_inputs_, int n_targets_,
+                               bool one_file_is_one_sequence, int max_load, bool binary_mode)
+{
+  if( (n_inputs_ < 0) && (n_targets < 0) )
+    error("DiskMatDataSet: cannot guess n_inputs <and> n_targets!");
+
+  IOSequence *io_file = NULL;
+  if(binary_mode)
+    io_file = new(allocator) IOBin(filename, one_file_is_one_sequence, max_load, false);
+  else
+    io_file = new(allocator) IOAscii(filename, one_file_is_one_sequence, max_load);
+
+  init_(io_file, n_inputs_, n_targets_);
+}
+
+DiskMatDataSet::DiskMatDataSet(char **filenames, int n_files_, int n_inputs_, int n_targets_,
+                               bool one_file_is_one_sequence, int max_load, bool binary_mode)
+{
+  if(n_files_ <= 0)
+    error("DiskMatDataSet: check the number of files!");
+
+  IOSequence **io_files = (IOSequence **)allocator->alloc(sizeof(IOSequence *)*n_files_);
+  if(max_load > 0)
+  {
+    int i = 0;
+    while( (max_load > 0) && (i < n_files_) )
+    {
+      if(binary_mode)
+        io_files[i] = new(allocator) IOBin(filenames[i], one_file_is_one_sequence, max_load, false);
+      else
+        io_files[i] = new(allocator) IOAscii(filenames[i], one_file_is_one_sequence, max_load);
+      max_load -= io_files[i]->n_sequences;
+      i++;
+    }
+    n_files_ = i;
+  }
+  else
+  {
+    if(binary_mode)
+    {
+      for(int i = 0; i < n_files_; i++)
+        io_files[i] = new(allocator) IOBin(filenames[i], one_file_is_one_sequence, -1, false);
+    }
+    else
+    {
+      for(int i = 0; i < n_files_; i++)
+        io_files[i] = new(allocator) IOAscii(filenames[i], one_file_is_one_sequence, -1);
+    }
+  }
+
+  IOMulti *io_file = new(allocator) IOMulti(io_files, n_files_);
+  init_(io_file, n_inputs_, n_targets_);
+}
+
+DiskMatDataSet::DiskMatDataSet(char **input_filenames, char **target_filenames, int n_files_,
+                               int max_load, bool binary_mode)
+{
+  if(n_files_ <= 0)
+    error("DiskMatDataSet: check the number of files!");
+
+  if(input_filenames)
+  {
+    IOSequence **input_io_files = (IOSequence **)allocator->alloc(sizeof(IOSequence *)*n_files_);
+    int max_load_ = max_load;
+    int n_files__ = 0;
+    if(max_load_ > 0)
+    {
+      int i = 0;
+      while( (max_load_ > 0) && (i < n_files_) )
+      {
+        if(binary_mode)
+          input_io_files[i] = new(allocator) IOBin(input_filenames[i], true, max_load_);
+        else
+          input_io_files[i] = new(allocator) IOAscii(input_filenames[i], true, max_load_);
+        max_load_ -= input_io_files[i]->n_sequences;
+        i++;
+      }
+      n_files__ = i;
+    }
+    else
+    {
+      if(binary_mode)
+      {
+        for(int i = 0; i < n_files_; i++)
+          input_io_files[i] = new(allocator) IOBin(input_filenames[i], true, -1);
+      }
+      else
+      {
+        for(int i = 0; i < n_files_; i++)
+          input_io_files[i] = new(allocator) IOAscii(input_filenames[i], true, -1);
+      }
+      n_files__ = n_files_;
+    }
+    io_inputs = new(allocator) IOMulti(input_io_files, n_files__);
+  }
+
+  if(target_filenames)
+  {
+    IOSequence **target_io_files = (IOSequence **)allocator->alloc(sizeof(IOSequence *)*n_files_);
+    int max_load_ = max_load;
+    int n_files__ = 0;
+    if(max_load_ > 0)
+    {
+      int i = 0;
+      while( (max_load_ > 0) && (i < n_files_) )
+      {
+        if(binary_mode)
+          target_io_files[i] = new(allocator) IOBin(target_filenames[i], true, max_load_);
+        else
+          target_io_files[i] = new(allocator) IOAscii(target_filenames[i], true, max_load_);
+        max_load_ -= target_io_files[i]->n_sequences;
+        i++;
+      }
+      n_files__ = i;
+    }
+    else
+    {
+      if(binary_mode)
+      {
+        for(int i = 0; i < n_files_; i++)
+          target_io_files[i] = new(allocator) IOBin(target_filenames[i], true, -1);
+      }
+      else
+      {
+        for(int i = 0; i < n_files_; i++)
+          target_io_files[i] = new(allocator) IOAscii(target_filenames[i], true, -1);
+      }
+      n_files__ = n_files_;
+    }
+    io_targets = new(allocator) IOMulti(target_io_files, n_files__);
+  }
+
+  DiskDataSet::init(io_inputs, io_targets);
+  message("DiskMatDataSet: %d examples scanned [%d inputs and %d targets detected]", n_examples, n_inputs, n_targets);
+}
+
+void DiskMatDataSet::init_(IOSequence *io_file, int n_inputs_, int n_targets_)
+{
+  if( (n_inputs_ > io_file->frame_size) || (n_targets_ > io_file->frame_size) )
+    error("DiskMatDataSet: n_inputs (%d) or n_targets (%d) too large (> %d) !", n_inputs_, n_targets_, io_file->frame_size);
+
+  if(n_inputs_ < 0)
+    n_inputs_ = io_file->frame_size - n_targets_;
+
+  if(n_targets_ < 0)
+    n_targets_ = io_file->frame_size - n_inputs_;
+
+  if(io_file->frame_size != (n_inputs_ + n_targets_))
+    error("DiskMatDataSet: %d columns in the file != %d inputs + %d targets", io_file->frame_size, n_inputs_, n_targets_);
+
+  IOBufferize *io_buffer = NULL;
+  if( (n_inputs_ > 0) && (n_targets_ > 0) )
+    io_buffer = new(allocator) IOBufferize(io_file);
+
+  if(n_inputs_ > 0)
+  {
+    if(n_targets_ > 0)
+      io_inputs = new(allocator) IOSub(io_buffer, 0, n_inputs_);
+    else
+      io_inputs = io_file;
+  }
+  if(n_targets_ > 0)
+  {
+    if(n_inputs_ > 0)
+      io_targets = new(allocator) IOSub(io_buffer, n_inputs_, n_targets_);
+    else
+      io_targets = io_file;
+  }
+
+  DiskDataSet::init(io_inputs, io_targets);
+
+  message("DiskMatDataSet: %d examples scanned", n_examples);
+}
+
+DiskMatDataSet::~DiskMatDataSet()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/DiskMatDataSet.h work/main.d/Torch-3/core/DiskMatDataSet.h
--- tmp/Torch-3/core/DiskMatDataSet.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/DiskMatDataSet.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,79 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DISK_MAT_DATA_SET_INC
+#define DISK_MAT_DATA_SET_INC
+
+#include "DiskDataSet.h"
+
+namespace Torch {
+
+/** Matrix DataSet On Disk...
+    The standard dataset, with data not fully loaded in memory.
+    Usefull for large databases.
+
+    @see IOAscii
+    @see IOBin
+    @author Ronan Collobert (collober@idiap.ch)
+ */
+class DiskMatDataSet : public DiskDataSet
+{
+  private:
+    void init_(IOSequence *io_file, int n_inputs_, int n_targets_);
+
+  public:
+    /** Create a new dataset from the file #filename#. If the file contains only one sequence, set #one_file_is_one_sequence#
+        to true. If there is several sequences, and you want only to load the first #n# ones, set #max_load# to #n# (else #max_load#
+        should be a negative number). If #binary_mode# is true, the IOBin format will be used, else it will be the IOAscii format.
+        
+        Input and target sequence will have the same number of frames. For \emph{each} frame given by the dataset, the first #n_inputs_#
+        real are for the inputs and then the next #n_targets_# real are for the targets. (#n_inputs_# is the input frame size and
+        #n_targets_# is the target frame size).
+    */       
+    DiskMatDataSet(const char *filename, int n_inputs_, int n_targets_,
+                   bool one_file_is_one_sequence=false, int max_load=-1, bool binary_mode=false);
+
+    /** Same as the previous constructor, but for several files. If #one_file_is_one_sequence# is true, each files will be considered as they
+        had only one sequence.
+    */
+    DiskMatDataSet(char **filenames, int n_files_, int n_inputs_, int n_targets_,
+                   bool one_file_is_one_sequence=false, int max_load=-1, bool binary_mode=false);
+
+    /** Here the inputs and the targets are in separated files.
+        Input and target frame sizes are therefore auto-detected.
+        One file must correspond to one sequence.
+    */
+    DiskMatDataSet(char **input_filenames, char **target_filenames, int n_files_,
+                   int max_load=-1, bool binary_mode=false);
+
+    virtual ~DiskMatDataSet();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/DiskXFile.cc work/main.d/Torch-3/core/DiskXFile.cc
--- tmp/Torch-3/core/DiskXFile.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/DiskXFile.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,255 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "DiskXFile.h"
+#include "string_utils.h"
+#ifdef _MSC_VER
+#include <fcntl.h>
+#endif
+
+namespace Torch {
+
+bool DiskXFile::is_native_mode = true;
+
+DiskXFile::DiskXFile(const char *file_name, const char *open_flags)
+{
+#ifdef _MSC_VER
+  _fmode = _O_BINARY;
+#endif
+
+  its_a_pipe = false;
+  bool zipped_file = false;
+  if(!strcmp(open_flags, "r"))
+  {
+    if(strlen(file_name) > 3)
+    {
+      if(strcmp(file_name+strlen(file_name)-3, ".gz"))
+        zipped_file = false;
+      else
+        zipped_file = true;
+    }
+    else
+      zipped_file = false;
+
+    if(zipped_file)
+    {
+      char *cmd_buffer = strConcat(2, "zcat ", file_name);
+      file = fopen(file_name, "r");
+      if(!file)
+        error("DiskXFile: cannot open the file <%s> for reading", file_name);
+      fclose(file);
+
+      file = popen(cmd_buffer, open_flags);
+      if(!file)
+        error("DiskXFile: cannot execute the command <%s>", file_name, cmd_buffer);
+      free(cmd_buffer);
+    }
+  }
+
+  if(!zipped_file)
+  {
+    file = fopen(file_name, open_flags);
+    if(!file)
+      error("DiskXFile: cannot open <%s> in mode <%s>. Sorry.", file_name, open_flags);
+  }
+  is_opened = true;
+
+  // Buffer
+  buffer_block = NULL;
+  buffer_block_size = 0;
+}
+
+DiskXFile::DiskXFile(FILE *file_)
+{
+  file = file_;
+  is_opened = false;
+  its_a_pipe = false;
+
+  // Buffer
+  buffer_block = NULL;
+  buffer_block_size = 0;
+}
+
+int DiskXFile::read(void *ptr, int block_size, int n_blocks)
+{
+  int melanie = fread(ptr, block_size, n_blocks, file);
+
+  if(!is_native_mode)
+    reverseMemory(ptr, block_size, n_blocks);
+
+  return(melanie);
+}
+
+int DiskXFile::write(void *ptr, int block_size, int n_blocks)
+{
+  if(!is_native_mode)
+    reverseMemory(ptr, block_size, n_blocks);
+
+  int melanie = fwrite(ptr, block_size, n_blocks, file);
+
+  if(!is_native_mode)
+    reverseMemory(ptr, block_size, n_blocks);
+
+  return(melanie);
+}
+
+int DiskXFile::eof()
+{
+  return(feof(file));
+}
+
+int DiskXFile::flush()
+{
+  return(fflush(file));
+}
+
+int DiskXFile::seek(long offset, int whence)
+{
+  return(fseek(file, offset, whence));
+}
+
+long DiskXFile::tell()
+{
+  return(ftell(file));
+}
+
+void DiskXFile::rewind()
+{
+  ::rewind(file);
+}
+
+int DiskXFile::printf(const char *format, ...)
+{
+  va_list args;
+  va_start(args, format);
+  int res = vfprintf(file, format, args);
+  va_end(args);
+  return(res);
+}
+
+int DiskXFile::scanf(const char *format, void *ptr)
+{
+  int res = fscanf(file, format, ptr);
+  return(res);
+}
+
+char *DiskXFile::gets(char *dest, int size_)
+{
+  return(fgets(dest, size_, file));
+}
+
+//-----
+
+bool DiskXFile::isLittleEndianProcessor()
+{
+  int x = 7;
+  char *ptr = (char *)&x;
+
+  if(ptr[0] == 0)
+    return(false);
+  else
+    return(true);
+}
+
+bool DiskXFile::isBigEndianProcessor()
+{
+  return(!isLittleEndianProcessor());
+}
+
+bool DiskXFile::isNativeMode()
+{
+  return(is_native_mode);
+}
+
+void DiskXFile::setNativeMode()
+{
+  is_native_mode = true;
+}
+
+void DiskXFile::setLittleEndianMode()
+{
+  if(isLittleEndianProcessor())
+    is_native_mode = true;
+  else
+    is_native_mode = false;
+}
+
+void DiskXFile::setBigEndianMode()
+{
+  if(isBigEndianProcessor())
+    is_native_mode = true;
+  else
+    is_native_mode = false;
+}
+
+void DiskXFile::reverseMemory(void *ptr_, int block_size, int n_blocks)
+{
+  if(block_size == 1)
+    return;
+
+  char *ptr = (char *)ptr_;
+  char *ptrr, *ptrw;
+
+  if(block_size > buffer_block_size)
+  {
+    allocator->free(buffer_block);
+    buffer_block = (char *)allocator->alloc(block_size);
+  }
+
+  for(int i = 0; i < n_blocks; i++)
+  {
+    ptrr = ptr + ((i+1)*block_size);
+    ptrw = buffer_block;
+
+    for(int j = 0; j < block_size; j++)
+    {
+      ptrr--;
+      *ptrw++ = *ptrr;
+    }
+
+    ptrr = buffer_block;
+    ptrw = ptr + (i*block_size);
+    for(int j = 0; j < block_size; j++)
+      *ptrw++ = *ptrr++;
+  }
+}
+
+//-----
+
+DiskXFile::~DiskXFile()
+{
+  if(is_opened)
+  {
+    if(its_a_pipe)
+      pclose(file);
+    else
+      fclose(file);
+  }
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/DiskXFile.h work/main.d/Torch-3/core/DiskXFile.h
--- tmp/Torch-3/core/DiskXFile.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/DiskXFile.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,108 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DISK_X_FILE_INC
+#define DISK_X_FILE_INC
+
+#include "XFile.h"
+
+namespace Torch {
+
+/** A file on the disk.
+    
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class DiskXFile : public XFile
+{
+  private:
+    static bool is_native_mode;
+    char *buffer_block;
+    int buffer_block_size;
+    void reverseMemory(void *ptr_, int block_size, int n_blocks);
+    
+  public:
+    FILE *file;
+    bool is_opened;
+    bool its_a_pipe;
+
+    /// Open "file_name" with the flags #open_flags#
+    DiskXFile(const char *file_name, const char *open_flags);
+
+    /// Use the given file...
+    DiskXFile(FILE *file_);
+
+    //-----
+
+    /// Returns #true# if the processor uses the little endian coding format.
+    static bool isLittleEndianProcessor();
+
+    /// Returns #true# if the processor uses the big endian coding format.
+    static bool isBigEndianProcessor();
+
+    /// Returns #true# if we'll load/save using the native mode.
+    static bool isNativeMode();
+
+    /** We'll load/save using native mode.
+        We use little endian iff the computer uses little endian.
+        We use big endian iff the computer uses big endian.
+    */
+    static void setNativeMode();
+
+    /** We'll load/save using little endian mode.
+        It means that if the computer doesn't use Little Endian,
+        data will be converted.
+    */
+    static void setLittleEndianMode();
+
+    /** We'll load/save using big endian mode.
+        It means that if the computer doesn't use Big Endian,
+        data will be converted.
+    */
+    static void setBigEndianMode();
+
+    //-----
+    
+    virtual int read(void *ptr, int block_size, int n_blocks);
+    virtual int write(void *ptr, int block_size, int n_blocks);
+    virtual int eof();
+    virtual int flush();
+    virtual int seek(long offset, int whence);
+    virtual long tell();
+    virtual void rewind();
+    virtual int printf(const char *format, ...);
+    virtual int scanf(const char *format, void *ptr) ;
+    virtual char *gets(char *dest, int size_);
+
+    //-----
+
+    virtual ~DiskXFile();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/FileListCmdOption.cc work/main.d/Torch-3/core/FileListCmdOption.cc
--- tmp/Torch-3/core/FileListCmdOption.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/FileListCmdOption.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,137 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "FileListCmdOption.h"
+#include "DiskXFile.h"
+
+namespace Torch {
+
+FileListCmdOption::FileListCmdOption(const char *name_, const char *help_, bool save_)
+  : CmdOption(name_, "<[-one_file] file_name>", help_, save_)
+{
+  n_files = 0;
+  file_names = NULL;
+}
+
+void FileListCmdOption::read(int *argc_, char ***argv_)
+{
+  char **argv = *argv_;
+
+  if(*argc_ == 0)
+    error("FileListCmdOption: cannot correctly set <%s>", name);
+
+  // Special case...
+  if(!strcmp("-one_file", argv[0]))
+  {
+    (*argc_)--;
+    (*argv_)++;
+
+    argv = *argv_;
+    if(*argc_ == 0)
+      error("FileListCmdOption: cannot correctly set <%s>", name);
+    
+    n_files = 1;
+    file_names = (char **)allocator->alloc(sizeof(char *));
+    file_names[0] = (char *)allocator->alloc(strlen(argv[0])+1);
+    strcpy(file_names[0], argv[0]);
+
+    (*argc_)--;
+    (*argv_)++;
+    return;
+  }
+
+  /// Read the contents of the file...
+  DiskXFile file_(argv[0], "r");
+
+  char *melanie = (char *)allocator->alloc(1024);
+  file_.read(melanie, 1, 1024);
+  melanie[1023] = '\0';
+  file_.rewind();
+
+  char* endp_;
+  strtol(melanie, &endp_, 10);
+  if( (*endp_ != '\0') && (*endp_ != '\n') )
+  {
+    do
+    {
+      file_.gets(melanie, 1024);
+      n_files++;
+    } while (!file_.eof());
+    n_files--;
+    file_.rewind();
+  }
+  else
+    file_.scanf("%d", &n_files);
+
+  message("FileListCmdOption: %d files detected", n_files);
+
+  file_names = (char **)allocator->alloc(sizeof(char *)*n_files);
+  for(int i = 0; i < n_files; i++)
+  {
+    file_.scanf("%s", melanie);
+    file_names[i] = (char *)allocator->alloc(strlen(melanie)+1);
+    strcpy(file_names[i], melanie);
+  }
+
+  allocator->free(melanie);
+
+  ////////////////////////////////////
+
+  (*argc_)--;
+  (*argv_)++;
+}
+
+void FileListCmdOption::loadXFile(XFile *file)
+{
+  file->taggedRead(&n_files, sizeof(int), 1, "NFILES");
+  file_names = (char **)allocator->alloc(sizeof(char *)*n_files);  
+  for(int i = 0; i < n_files; i++)
+  {
+    int melanie;
+    file->taggedRead(&melanie, sizeof(int), 1, "SIZE");
+    file_names[i] = (char *)allocator->alloc(melanie);
+    file->taggedRead(file_names[i], 1, melanie, "FILE");
+  }
+}
+
+void FileListCmdOption::saveXFile(XFile *file)
+{
+  file->taggedWrite(&n_files, sizeof(int), 1, "NFILES");
+  for(int i = 0; i < n_files; i++)
+  {
+    int melanie = strlen(file_names[i])+1;
+    file->taggedWrite(&melanie, sizeof(int), 1, "SIZE");
+    file->taggedWrite(file_names[i], 1, melanie, "FILE");
+  }
+}
+
+FileListCmdOption::~FileListCmdOption()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/FileListCmdOption.h work/main.d/Torch-3/core/FileListCmdOption.h
--- tmp/Torch-3/core/FileListCmdOption.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/FileListCmdOption.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,68 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef FILE_LIST_CMD_OPTION_INC
+#define FILE_LIST_CMD_OPTION_INC
+
+#include "CmdOption.h"
+
+namespace Torch {
+
+/** This class take a file name in the command line,
+    and reads a list of files contained in this
+    file.
+
+    In fact, there is a special case: it checks first
+    if "-one_file" the current argument on the command
+    line. If true, then it reads the next argument which
+    will be the only file in the list.
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @see CmdLine
+*/
+class FileListCmdOption : public CmdOption
+{
+  public:
+    /// Contains the file names after reading the command line.
+    char **file_names;
+
+    /// Number of files that have been read.
+    int n_files;
+
+    ///
+    FileListCmdOption(const char *name_, const char *help_="", bool save_=false);
+
+    virtual void read(int *argc_, char ***argv_);
+    virtual void loadXFile(XFile *file);
+    virtual void saveXFile(XFile *file);
+    ~FileListCmdOption();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/FrameSelectorDataSet.cc work/main.d/Torch-3/core/FrameSelectorDataSet.cc
--- tmp/Torch-3/core/FrameSelectorDataSet.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/FrameSelectorDataSet.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,193 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "FrameSelectorDataSet.h"
+
+namespace Torch {
+
+FrameSelectorDataSet::FrameSelectorDataSet(DataSet *data_)
+{
+  data = data_;
+  if(data->n_examples == 0)
+    error("FrameSelectorDataSet: cannot handle DataSet with no examples");
+
+  n_selected_input_frames = (int *)allocator->alloc(sizeof(int)*data->n_examples);
+  n_selected_target_frames = (int *)allocator->alloc(sizeof(int)*data->n_examples);
+  input_frames_indices = (int **)allocator->alloc(sizeof(int *)*data->n_examples);
+  target_frames_indices = (int **)allocator->alloc(sizeof(int *)*data->n_examples);
+  for(int i = 0; i < data->n_examples; i++)
+  {
+    n_selected_input_frames[i] = 0;
+    input_frames_indices[i] = NULL;
+    n_selected_target_frames[i] = 0;
+    target_frames_indices[i] = NULL;
+  }
+
+  DataSet::init(data->n_examples, data->n_inputs, data->n_targets);
+
+  data->setExample(0);
+  if(n_inputs > 0)
+    inputs_buffer = new(allocator) Sequence(0, n_inputs);
+  else
+    inputs_buffer = NULL;
+  if(n_targets > 0)
+    targets_buffer = new(allocator) Sequence(0, n_targets);
+  else
+    targets_buffer = NULL;
+}
+
+void FrameSelectorDataSet::selectInputFrames(int t_, int *frames_indices_, int n_frames_)
+{
+  int t = selected_examples[t_];
+  if(input_frames_indices[t])
+    allocator->free(input_frames_indices[t]);
+  input_frames_indices[t] = (int *)allocator->alloc(sizeof(int)*n_frames_);
+  for(int i = 0; i < n_frames_; i++)
+    input_frames_indices[t][i] = frames_indices_[i];
+  n_selected_input_frames[t] = n_frames_;
+}
+
+void FrameSelectorDataSet::selectTargetFrames(int t_, int *frames_indices_, int n_frames_)
+{
+  int t = selected_examples[t_];
+  if(target_frames_indices[t])
+    allocator->free(target_frames_indices[t]);
+  target_frames_indices[t] = (int *)allocator->alloc(sizeof(int)*n_frames_);
+  for(int i = 0; i < n_frames_; i++)
+    target_frames_indices[t][i] = frames_indices_[i];
+  n_selected_target_frames[t] = n_frames_;
+}
+
+void FrameSelectorDataSet::unselectInputFrames(int t_)
+{
+  int t = selected_examples[t_];
+  if(input_frames_indices[t])
+    allocator->free(input_frames_indices[t]);
+  input_frames_indices[t] = NULL;
+  n_selected_input_frames[t] = 0;
+}
+
+void FrameSelectorDataSet::unselectTargetFrames(int t_)
+{
+  int t = selected_examples[t_];
+  if(target_frames_indices[t])
+    allocator->free(target_frames_indices[t]);
+  target_frames_indices[t] = NULL;
+  n_selected_target_frames[t] = 0;
+}
+
+void FrameSelectorDataSet::getNumberOfFrames(int t_, int *n_input_frames_, int *n_target_frames_)
+{
+  int t = selected_examples[t_];
+  if( (n_inputs > 0) && n_input_frames_ )
+  {
+    if(input_frames_indices[t])
+      *n_input_frames_ = n_selected_input_frames[t];
+    else
+      data->getNumberOfFrames(t, n_input_frames_, NULL);
+  }
+  if( (n_targets > 0) && n_target_frames_ )
+  {
+    if(target_frames_indices[t])
+      *n_target_frames_ = n_selected_target_frames[t];
+    else
+      data->getNumberOfFrames(t, NULL, n_target_frames_);
+  }
+}
+
+void FrameSelectorDataSet::setRealExample(int t, bool set_inputs, bool set_targets)
+{
+  data->setExample(t);
+
+  if(set_inputs)
+  {
+    if(input_frames_indices[t])
+    {
+      inputs_buffer->resize(n_selected_input_frames[t], false);
+      for(int i = 0; i < n_selected_input_frames[t]; i++)
+        inputs_buffer->frames[i] = data->inputs->frames[input_frames_indices[t][i]];
+      inputs = inputs_buffer;
+    }
+    else
+      inputs = data->inputs;
+  }
+
+  if(set_targets)
+  {
+    if(target_frames_indices[t])
+    {
+      targets_buffer->resize(n_selected_target_frames[t], false);
+      for(int i = 0; i < n_selected_target_frames[t]; i++)
+        targets_buffer->frames[i] = data->targets->frames[target_frames_indices[t][i]];
+      targets = targets_buffer;
+    }
+    else
+      targets = data->targets;
+  }  
+  real_current_example_index = t;
+}
+
+void FrameSelectorDataSet::preProcess(PreProcessing *pre_processing)
+{
+  error("FrameSelectorDataSet: pre-processing not supported");
+}
+
+void FrameSelectorDataSet::pushExample()
+{
+  data->pushExample();
+  pushed_examples->push(&inputs_buffer, sizeof(Sequence *));
+  pushed_examples->push(&targets_buffer, sizeof(Sequence *));
+  pushed_examples->push(&inputs, sizeof(Sequence *));
+  pushed_examples->push(&targets, sizeof(Sequence *));
+  pushed_examples->push(&real_current_example_index, sizeof(int));
+
+  if(n_inputs > 0)
+    inputs_buffer = new(allocator) Sequence(0, n_inputs);
+  if(n_targets > 0)
+    targets_buffer = new(allocator) Sequence(0, n_targets);
+  real_current_example_index = -1;
+}
+
+void FrameSelectorDataSet::popExample()
+{
+  allocator->free(inputs_buffer);
+  allocator->free(targets_buffer);
+
+  pushed_examples->pop();
+  pushed_examples->pop();
+  pushed_examples->pop();
+  pushed_examples->pop();
+  pushed_examples->pop();
+  data->popExample();
+}
+
+FrameSelectorDataSet::~FrameSelectorDataSet()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/FrameSelectorDataSet.h work/main.d/Torch-3/core/FrameSelectorDataSet.h
--- tmp/Torch-3/core/FrameSelectorDataSet.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/FrameSelectorDataSet.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,103 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef FRAME_SELECTOR_DATA_SET_INC
+#define FRAME_SELECTOR_DATA_SET_INC
+
+#include "DataSet.h"
+
+namespace Torch {
+
+/** A dataset used to select some frames of another dataset.
+    It takes a dataset in the constructor. Then you call
+    select functions to select frames. After that, when
+    you will do a #setExample()# the example of the previous
+    dataset will be returned in #inputs# and #targets# fields,
+    with the right frames...
+
+    @author Ronan Collobert (collober@idiap.ch)
+ */
+class FrameSelectorDataSet : public DataSet
+{
+  private:
+    Sequence *inputs_buffer;
+    Sequence *targets_buffer;
+
+  public:
+    /// DataSet where we will select frames
+    DataSet *data;
+
+    /// Number of input selected frames, for each example
+    int *n_selected_input_frames;
+
+    /// Number of target selected frames, for each example
+    int *n_selected_target_frames;
+
+    /// Indices of input selected frames, for each example
+    int **input_frames_indices;
+
+    /// Indices of target selected frames, for each example
+    int **target_frames_indices;
+
+    ///
+    FrameSelectorDataSet(DataSet *data_);
+
+    /** Select input frames of the example #t#.
+        Frames indices are given by #frames_indices_#.
+        The size of #frames_indices_# is given by #n_frames_#.
+        Takes in account pushed subsets.
+    */
+    void selectInputFrames(int t_, int *frames_indices_, int n_frames_);
+
+    /// Same as #selectInputFrames()#, but for targets.
+    void selectTargetFrames(int t_, int *frames_indices_, int n_frames_);
+
+    /** Unselect inputs frames of the example #t#.
+        Takes in account pushed subsets.
+    */
+    void unselectInputFrames(int t_);
+
+    /** Unselect targets frames of the example #t#.
+        Takes in account pushed subsets.
+    */
+    void unselectTargetFrames(int t_);
+
+    virtual void preProcess(PreProcessing *pre_processing);
+    virtual void getNumberOfFrames(int t_, int *n_input_frames_, int *n_target_frames_);
+    virtual void setRealExample(int t, bool set_inputs=true, bool set_targets=true);
+    virtual void pushExample();
+    virtual void popExample();
+
+    //-----
+
+    virtual ~FrameSelectorDataSet();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/general.cc work/main.d/Torch-3/core/general.cc
--- tmp/Torch-3/core/general.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/general.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,95 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "general.h"
+
+namespace Torch {
+
+char xxpetit_message_pour_melanie[10000];
+
+void error(const char* msg, ...)
+{
+  va_list args;
+  va_start(args,msg);
+  vsprintf(xxpetit_message_pour_melanie, msg, args);
+  printf("\n$ Error: %s\n\n", xxpetit_message_pour_melanie);
+  fflush(stdout);
+  va_end(args);
+  exit(-1);
+}
+
+void warning(const char* msg, ...)
+{
+  va_list args;
+  va_start(args,msg);
+  vsprintf(xxpetit_message_pour_melanie, msg, args);
+  printf("! Warning: %s\n", xxpetit_message_pour_melanie);
+  fflush(stdout);
+  va_end(args);
+}
+
+void message(const char* msg, ...)
+{
+  va_list args;
+  va_start(args,msg);
+  vsprintf(xxpetit_message_pour_melanie, msg, args);
+  printf("# %s\n", xxpetit_message_pour_melanie);
+  fflush(stdout);
+  va_end(args);
+}
+
+void print(const char* msg, ...)
+{
+  va_list args;
+  va_start(args,msg);
+  vsprintf(xxpetit_message_pour_melanie, msg, args);
+  printf("%s", xxpetit_message_pour_melanie);
+  fflush(stdout);
+  va_end(args);
+}
+
+void controlBar(int level, int max_level)
+{
+  if(level == -1)
+    print("[");
+  else
+  {
+    if(max_level < 10)
+      print(".");
+    else
+    {
+      if( !(level % (max_level/10) ) )
+        print(".");
+    }
+  
+    if(level == max_level-1)
+      print("]\n");
+  }
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/general.h work/main.d/Torch-3/core/general.h
--- tmp/Torch-3/core/general.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/general.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,118 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef GENERAL_INC
+#define GENERAL_INC
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <string.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <time.h>
+#include <float.h>
+
+// Old systems need that to define FLT_MAX and DBL_MAX
+#ifndef DBL_MAX
+#include <values.h>
+#endif
+
+namespace Torch {
+
+#ifdef _MSC_VER
+#ifndef for
+#define for if (0) {} else for
+#endif
+#define M_PI 3.14159265358979323846
+#define popen(x,y) _popen(x,y)
+#define pclose(x) _pclose(x)
+#define isnan(x) _isnan(x)
+#define log1p(x) log(1+(x))
+#endif
+
+#ifdef USE_DOUBLE
+#define INF DBL_MAX
+#define REAL_EPSILON DBL_EPSILON
+#define real double
+#else
+#define INF FLT_MAX
+#define REAL_EPSILON FLT_EPSILON
+#define real float
+#endif
+
+//-----------------------------------
+
+/** Text outputs functions.
+
+    These functions are like #printf()#, but you should
+    use them instead. Note that you should never try to
+    print a message larger than 10000 characters.
+
+    @author Ronan Collobert (collober@idiap.ch)
+ */
+//@{
+
+/// Print an error message. The program will exit.
+void error(const char* msg, ...);
+/// Print a warning message.
+void warning(const char* msg, ...);
+/// Print a message.
+void message(const char* msg, ...);
+/// Like printf.
+void print(const char* msg, ...);
+
+/** Print a control bar [\#\#\#\#\#\#\#\#\#\#].
+    
+    First time, you can it with #level=-1#.
+    It'll print the control bar at each time
+    you will call that.
+
+    #max_level# is the value of the last #level#
+    you'll call this function.
+
+    @author Ronan Collobert (collober@idiap.ch)
+ */
+void controlBar(int level, int max_level);
+//@}
+
+//-----------------------------------
+
+#ifndef min
+/// The min function
+#define	min(a,b) ((a) > (b) ? (b) : (a))
+#endif
+
+#ifndef max
+/// The max function
+#define	max(a,b) ((a) > (b) ? (a) : (b))
+#endif
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOAscii.cc work/main.d/Torch-3/core/IOAscii.cc
--- tmp/Torch-3/core/IOAscii.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOAscii.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,145 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "IOAscii.h"
+
+namespace Torch {
+
+#ifdef USE_DOUBLE
+#define REAL_FORMAT "%lf"
+#else
+#define REAL_FORMAT "%f"
+#endif
+
+void IOAscii::saveSequence(XFile *file, Sequence *sequence)
+{
+  file->printf("%d %d\n", sequence->n_frames, sequence->frame_size);    
+  for(int i = 0; i < sequence->n_frames; i++)
+  {
+    real *z = sequence->frames[i];
+    for(int j = 0; j < sequence->frame_size; j++)
+      file->printf("%g ", z[j]);
+    file->printf("\n");
+  }
+}
+
+IOAscii::IOAscii(const char *filename_, bool one_file_is_one_sequence_, int max_load_)
+{
+  // Boaf...
+  one_file_is_one_sequence = one_file_is_one_sequence_;
+  max_load = max_load_;
+
+  filename = (char *)allocator->alloc(strlen(filename_)+1);
+  strcpy(filename, filename_);
+
+  // Read the header...
+  DiskXFile f(filename, "r");
+
+  f.scanf("%d", &n_total_frames);
+  f.scanf("%d", &frame_size);
+
+  if( (max_load > 0) && (max_load < n_total_frames) && (!one_file_is_one_sequence) )
+  {
+    n_total_frames = max_load;
+    message("IOAscii: loading only %d frames", n_total_frames);
+  }
+
+  if(one_file_is_one_sequence)
+    n_sequences = 1;
+  else
+    n_sequences = n_total_frames;
+
+  file = NULL;
+  current_frame_index = -1;
+}
+
+void IOAscii::getSequence(int t, Sequence *sequence)
+{
+  // Cas simple: on lit tout le bordel
+  if(one_file_is_one_sequence)
+  {
+    file = new(allocator) DiskXFile(filename, "r");
+    int murielle;
+    file->scanf("%d", &murielle);
+    file->scanf("%d", &murielle);
+    for(int i = 0; i < n_total_frames; i++)
+    {
+      real *dest_ = sequence->frames[i];
+      for(int j = 0; j < frame_size; j++)
+        file->scanf(REAL_FORMAT, &dest_[j]);
+    }
+    allocator->free(file);
+  }
+  else
+  {
+    // Sequentiel ?
+    if(t != current_frame_index+1)
+      error("IOAscii: sorry, data are accessible only in a sequential way");
+
+    // Doit-on ouvrir le putain de fichier ?
+    if(current_frame_index < 0)
+    {
+      file = new(allocator) DiskXFile(filename, "r");
+      int murielle;
+      file->scanf("%d", &murielle);
+      file->scanf("%d", &murielle);
+    }
+
+    // Lis la frame mec
+    real *dest_ = sequence->frames[0];
+    for(int j = 0; j < frame_size; j++)
+      file->scanf(REAL_FORMAT, &dest_[j]);
+    
+    // Si je suis a la fin du fichier, je le zigouille.
+    current_frame_index++;
+    if(current_frame_index == n_total_frames-1)
+    {
+      allocator->free(file);
+      current_frame_index = -1;
+    }
+  }
+}
+
+int IOAscii::getNumberOfFrames(int t)
+{
+  if(one_file_is_one_sequence)
+    return n_total_frames;
+  else
+    return 1;
+}
+
+int IOAscii::getTotalNumberOfFrames()
+{
+  return n_total_frames;
+}
+
+IOAscii::~IOAscii()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOAscii.h work/main.d/Torch-3/core/IOAscii.h
--- tmp/Torch-3/core/IOAscii.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOAscii.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,85 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef IO_ASCII_INC
+#define IO_ASCII_INC
+
+#include "IOSequence.h"
+#include "DiskXFile.h"
+
+namespace Torch {
+
+/** Handles the standard Ascii sequence format in Torch.
+    The format is the following:
+    \begin{itemize}
+      \item First line should contain the number of frames and the frame size (two int
+      separated by a space) of the file.
+      \item Next lines are frames of the sequence. One frame is one line. (number_of_columns real
+      at each line, separated by a space).
+    \end{itemize}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class IOAscii : public IOSequence
+{
+  private:
+    DiskXFile *file;
+    int current_frame_index;
+
+  public:
+    bool one_file_is_one_sequence;
+    int n_total_frames;
+    char *filename;
+    int max_load;
+    
+    /** Reads the sequence contained in #filename#.
+        If #one_file_is_one_sequence# is false, #getSequence()# will return one sequence
+        with one frame at each call. (If calling #getSequence(t, foo)#,
+        it will put in the sequence #foo# the frame corresponding to the line #t# of the file).
+        Note also that if #one_file_is_one_sequence# is false, the access to the IO must be
+        sequential when calling #getSequence()#.
+        If #max_load_# is positive, it loads only the first #max_load_# frames, if #one_file_is_one_sequence#
+        is false.
+        The file will be opened when reading the first sequence, and closed when reading the
+        last one.
+     */
+    IOAscii(const char *filename_, bool one_file_is_one_sequence_=false, int max_load_=-1);
+
+    /// Saves one #sequence# in #file# using the ascii format.
+    static void saveSequence(XFile *file, Sequence *sequence);
+
+    virtual void getSequence(int t, Sequence *sequence);
+    virtual int getNumberOfFrames(int t);
+    virtual int getTotalNumberOfFrames();
+
+    virtual ~IOAscii();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOBin.cc work/main.d/Torch-3/core/IOBin.cc
--- tmp/Torch-3/core/IOBin.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOBin.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,145 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "IOBin.h"
+
+namespace Torch {
+
+void IOBin::saveSequence(XFile *file, Sequence *sequence)
+{
+  file->write(&sequence->n_frames, sizeof(int), 1);
+  file->write(&sequence->frame_size, sizeof(int), 1);
+
+  for(int i = 0; i < sequence->n_frames; i++)
+    file->write(sequence->frames[i], sizeof(real), sequence->frame_size);
+}
+
+IOBin::IOBin(const char *filename_, bool one_file_is_one_sequence_, int max_load_, bool is_sequential_)
+{
+  // Boaf...
+  one_file_is_one_sequence = one_file_is_one_sequence_;
+  max_load = max_load_;
+  is_sequential = is_sequential_;
+
+  filename = (char *)allocator->alloc(strlen(filename_)+1);
+  strcpy(filename, filename_);
+
+  // Read the header...
+  DiskXFile f(filename, "r");
+
+  f.read(&n_total_frames, sizeof(int), 1);
+  f.read(&frame_size, sizeof(int), 1);
+
+  if( (max_load > 0) && (max_load < n_total_frames) && (!one_file_is_one_sequence) )
+  {
+    n_total_frames = max_load;
+    message("IOBin: loading only %d frames", n_total_frames);
+  }
+
+  if(one_file_is_one_sequence)
+    n_sequences = 1;
+  else
+    n_sequences = n_total_frames;
+  
+  file = NULL;
+  current_frame_index = -1;  
+}
+
+void IOBin::getSequence(int t, Sequence *sequence)
+{
+  // Cas simple: on lit tout le bordel
+  if(one_file_is_one_sequence)
+  {
+    file = new(allocator) DiskXFile(filename, "r");
+    int murielle;
+    file->read(&murielle, sizeof(int), 1); // fseek non car marche pas dans pipes
+    file->read(&murielle, sizeof(int), 1);
+    for(int i = 0; i < n_total_frames; i++)
+      file->read(sequence->frames[i], sizeof(real), frame_size);
+    allocator->free(file);
+  }
+  else
+  {
+    // Sequentiel ?
+    if(is_sequential)
+    {
+      if(t != current_frame_index+1)
+        error("IOBin: sorry, data are accessible only in a sequential way");
+      
+      // Doit-on ouvrir le putain de fichier ?
+      if(current_frame_index < 0)
+      {
+        file = new(allocator) DiskXFile(filename, "r");
+        int murielle;
+        file->read(&murielle, sizeof(int), 1); // fseek non car marche pas dans pipes
+        file->read(&murielle, sizeof(int), 1);
+      }
+    }
+    else
+    {
+      file = new(allocator) DiskXFile(filename, "r");
+      if(file->seek(t*frame_size*sizeof(real)+2*sizeof(int), SEEK_CUR) != 0)
+        error("IOBin: cannot seek in your file!");
+    }
+
+    // Lis la frame mec
+    file->read(sequence->frames[0], sizeof(real), frame_size);
+
+    if(is_sequential)
+    {
+      // Si je suis a la fin du fichier, je le zigouille.
+      current_frame_index++;
+      if(current_frame_index == n_total_frames-1)
+      {
+        allocator->free(file);
+        current_frame_index = -1;
+      }
+    }
+    else
+      allocator->free(file);
+  }
+}
+
+int IOBin::getNumberOfFrames(int t)
+{
+  if(one_file_is_one_sequence)
+    return n_total_frames;
+  else
+    return 1;
+}
+
+int IOBin::getTotalNumberOfFrames()
+{
+  return n_total_frames;
+}
+
+IOBin::~IOBin()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOBin.h work/main.d/Torch-3/core/IOBin.h
--- tmp/Torch-3/core/IOBin.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOBin.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,87 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef IO_BIN_INC
+#define IO_BIN_INC
+
+#include "IOSequence.h"
+#include "DiskXFile.h"
+
+namespace Torch {
+
+/** Handles the standard binary sequence format in Torch.
+    The format is the following:
+    \begin{itemize}
+      \item Two int at the beginning of the file for the number of frames and the frame size
+      of the sequence in the file.
+      \item After that, the sequence data, frame after frame. (frame_size real per row).
+    \end{itemize}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class IOBin : public IOSequence
+{
+  protected:
+    DiskXFile *file;
+    int current_frame_index;
+
+  public:
+    bool one_file_is_one_sequence;
+    int n_total_frames;
+    char *filename;
+    int max_load;
+    bool is_sequential;
+
+    /** Reads the sequence contained in #filename#.
+        If #one_file_is_one_sequence# is false, #getSequence()# will return one sequence
+        with one frame at each call. (If calling #getSequence(t, foo)#,
+        it will put in the sequence #foo# the frame corresponding to the line #t# of the file).
+        Note also that if #one_file_is_one_sequence# is false, the access to the IO must be
+        sequential when calling #getSequence()# if #is_sequential# is true. (Sequential mode
+        is faster).
+        If #max_load_# is positive, it loads only the first #max_load_# frames,
+        if #one_file_is_one_sequence# is false.
+        The file will be opened when reading the first sequence, and closed when reading the
+        last one if #is_sequential# is true. Otherwise, the file will be opened and closed
+        each time you call #getSequence()#.
+     */
+    IOBin(const char *filename_, bool one_file_is_one_sequence_=false, int max_load_=-1, bool is_sequential=true);
+
+    /// Saves #sequence# in #file# using the binary format.
+    static void saveSequence(XFile *file, Sequence *sequence);
+
+    virtual void getSequence(int t, Sequence *sequence);
+    virtual int getNumberOfFrames(int t);
+    virtual int getTotalNumberOfFrames();
+
+    virtual ~IOBin();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOBufferize.cc work/main.d/Torch-3/core/IOBufferize.cc
--- tmp/Torch-3/core/IOBufferize.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOBufferize.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,73 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "IOBufferize.h"
+
+namespace Torch {
+
+IOBufferize::IOBufferize(IOSequence *io_torch_)
+{
+  io_torch = io_torch_;
+  n_sequences = io_torch->n_sequences;
+  frame_size = io_torch->frame_size;
+  bufferized_sequence = new(allocator) Sequence(0, frame_size);
+  bufferized_sequence_index = -1;
+}
+
+void IOBufferize::getSequence(int t, Sequence *sequence)
+{
+  bufferizeSequence(t);
+  sequence->copy(bufferized_sequence);
+}
+
+void IOBufferize::bufferizeSequence(int t)
+{
+  if(t != bufferized_sequence_index)
+  {
+    int n_frames = io_torch->getNumberOfFrames(t);
+    bufferized_sequence->resize(n_frames);
+    io_torch->getSequence(t, bufferized_sequence);
+    bufferized_sequence_index = t;
+  }  
+}
+
+int IOBufferize::getNumberOfFrames(int t)
+{
+  return io_torch->getNumberOfFrames(t);
+}
+
+int IOBufferize::getTotalNumberOfFrames()
+{
+  return io_torch->getTotalNumberOfFrames();
+}
+
+IOBufferize::~IOBufferize()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOBufferize.h work/main.d/Torch-3/core/IOBufferize.h
--- tmp/Torch-3/core/IOBufferize.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOBufferize.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,69 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef IO_BUFFERIZE_INC
+#define IO_BUFFERIZE_INC
+
+#include "IOSequence.h"
+
+namespace Torch {
+
+/** This IO bufferizes the asked sequence of a given IO when calling #getSequence()#.
+    Then, if the next call of #getSequence()# ask for the same sequence, it will
+    return it without asking the given IO.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class IOBufferize : public IOSequence
+{
+  public:
+    /// IO to be bufferized.
+    IOSequence *io_torch;
+
+    /// The bufferized sequence.
+    Sequence *bufferized_sequence;
+
+    /// The bufferized sequence index.
+    int bufferized_sequence_index;
+
+    ///
+    IOBufferize(IOSequence *io_torch_);
+
+    /// Force sequence #t# to be bufferized.
+    void bufferizeSequence(int t);
+
+    virtual void getSequence(int t, Sequence *sequence);
+    virtual int getNumberOfFrames(int t);
+    virtual int getTotalNumberOfFrames();
+
+    virtual ~IOBufferize();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOMulti.cc work/main.d/Torch-3/core/IOMulti.cc
--- tmp/Torch-3/core/IOMulti.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOMulti.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,86 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "IOMulti.h"
+
+namespace Torch {
+
+IOMulti::IOMulti(IOSequence **io_files_, int n_files_)
+{
+  io_files = io_files_;
+  n_files = n_files_;
+
+  if(n_files <= 0)
+    error("IOMulti: check the number of files!");
+
+  n_sequences = 0;
+  for(int i = 0; i < n_files; i++)
+    n_sequences += io_files[i]->n_sequences;
+  frame_size = io_files[0]->frame_size;
+
+  indices = (int *)allocator->alloc(sizeof(int)*n_sequences);
+  offsets = (int *)allocator->alloc(sizeof(int)*n_sequences);
+
+  int *ptr_indices = indices;
+  int *ptr_offsets = offsets;
+  for(int i = 0; i < n_files; i++)
+  {
+    if(frame_size != io_files[i]->frame_size)
+      error("IOMulti: provided IO have incompatible frame sizes");
+
+    for(int j = 0; j < io_files[i]->n_sequences; j++)
+    {
+      *ptr_indices++ = i;
+      *ptr_offsets++ = j;
+    }
+  }
+}
+
+void IOMulti::getSequence(int t, Sequence *sequence)
+{
+  io_files[indices[t]]->getSequence(offsets[t], sequence);
+}
+
+int IOMulti::getNumberOfFrames(int t)
+{
+  return io_files[indices[t]]->getNumberOfFrames(offsets[t]);
+}
+
+int IOMulti::getTotalNumberOfFrames()
+{
+  int n_total_frames_ = 0;
+  for(int i = 0; i < n_files; i++)
+    n_total_frames_ += io_files[i]->getTotalNumberOfFrames();
+  return n_total_frames_;
+}
+
+IOMulti::~IOMulti()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOMulti.h work/main.d/Torch-3/core/IOMulti.h
--- tmp/Torch-3/core/IOMulti.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOMulti.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,62 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef IO_MULTI_INC
+#define IO_MULTI_INC
+
+#include "IOSequence.h"
+
+namespace Torch {
+
+/** This IO takes several IOSequence, and will
+    act as if you had concatened all these IOSequence when
+    calling #getMatrix()#.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class IOMulti : public IOSequence
+{
+  public:
+    IOSequence **io_files;
+    int n_files;
+    int *indices;
+    int *offsets;
+
+    /// Takes #n_files_# pointers to IOSequence, given in #io_files_#.
+    IOMulti(IOSequence **io_files_, int n_files_);
+
+    virtual void getSequence(int t, Sequence *sequence);
+    virtual int getNumberOfFrames(int t);
+    virtual int getTotalNumberOfFrames();
+
+    virtual ~IOMulti();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOSequenceArray.cc work/main.d/Torch-3/core/IOSequenceArray.cc
--- tmp/Torch-3/core/IOSequenceArray.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOSequenceArray.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,91 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "IOSequenceArray.h"
+#include "XFile.h"
+
+namespace Torch {
+
+IOSequenceArray::IOSequenceArray()
+{
+}
+
+void IOSequenceArray::write(XFile *file, Sequence **sequences_array, int n_sequences)
+{
+  if(n_sequences <= 0)
+    return;
+
+  int frame_size = sequences_array[0]->frame_size;
+  int n_total_frames = 0;
+  for(int i = 0; i < n_sequences; i++)
+  {
+    if(frame_size != sequences_array[i]->frame_size)
+      error("IOSequenceArray: sorry, sequences don't have the same frame size");
+    n_total_frames += sequences_array[i]->n_frames;
+  }
+  file->taggedWrite(&n_total_frames, sizeof(int), 1, "NTF");
+  file->taggedWrite(&frame_size, sizeof(int), 1, "FS");
+
+  for(int i = 0; i < n_sequences; i++)
+  {
+    file->taggedWrite(&sequences_array[i]->n_frames, sizeof(int), 1, "NF");
+    sequences_array[i]->saveXFile(file);
+  }
+}
+
+void IOSequenceArray::read(XFile *file, Sequence **sequences_array, int n_sequences, Allocator *allocator_)
+{
+  if(!allocator_)
+    allocator_ = allocator;
+
+  int n_total_frames, frame_size;
+  file->taggedRead(&n_total_frames, sizeof(int), 1, "NTF");
+  file->taggedRead(&frame_size, sizeof(int), 1, "FS");
+
+  Sequence *sequences_buffer = (Sequence *)allocator_->alloc(sizeof(Sequence)*n_sequences);
+  real **frames_buffer = (real **)allocator_->alloc(sizeof(real *)*n_total_frames);
+  real *buffer = (real *)allocator_->alloc(sizeof(real)*n_total_frames*frame_size);
+  for(int i = 0; i < n_total_frames; i++)
+    frames_buffer[i] = buffer+i*frame_size;
+
+  for(int i = 0; i < n_sequences; i++)
+  {
+    int n_frames_;
+    file->taggedRead(&n_frames_, sizeof(int), 1, "NF");
+    sequences_array[i] = new(allocator_, sequences_buffer) Sequence(frames_buffer, n_frames_, frame_size);
+    sequences_array[i]->loadXFile(file);
+    frames_buffer += n_frames_;
+    sequences_buffer++;
+  }
+}
+
+IOSequenceArray::~IOSequenceArray()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOSequenceArray.h work/main.d/Torch-3/core/IOSequenceArray.h
--- tmp/Torch-3/core/IOSequenceArray.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOSequenceArray.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,71 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef IO_SEQUENCE_ARRAY_INC
+#define IO_SEQUENCE_ARRAY_INC
+
+#include "Object.h"
+#include "Sequence.h"
+
+namespace Torch {
+
+/** Load and save in an efficiently manner an array of sequences.
+    (in an arbitrary binary format).
+
+    This could be useful for some (rare) classes which needs to save
+    sequences which could be in another format that the standard
+    sequence format (if you plan to use them with strange subclasses of
+    #Sequence#).
+   
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class IOSequenceArray : public Object
+{
+  public:
+
+    ///
+    IOSequenceArray(); 
+
+    /** Read an array of sequences in #file#. #n_sequences# will be read.
+        If #allocator_# is non-NULL, it will be used to allocate the memory
+        of the sequences. Else, the memory of the sequences will be destroyed
+        when destroying the class. #sequences_array# must have the size #n_sequences#.
+    */
+    virtual void read(XFile *file, Sequence **sequences_array, int n_sequences, Allocator *allocator_=NULL);
+    
+    /** Write an array of sequences in #file#. #n_sequences# will be written.
+        #sequences_array# must have the size #n_sequences#.
+    */
+    virtual void write(XFile *file, Sequence **sequences_array, int n_sequences);
+    
+    virtual ~IOSequenceArray();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOSequence.cc work/main.d/Torch-3/core/IOSequence.cc
--- tmp/Torch-3/core/IOSequence.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOSequence.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,43 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "IOSequence.h"
+
+namespace Torch {
+
+IOSequence::IOSequence()
+{
+  n_sequences = 0;
+  frame_size = 0;
+}
+
+IOSequence::~IOSequence()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOSequence.h work/main.d/Torch-3/core/IOSequence.h
--- tmp/Torch-3/core/IOSequence.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOSequence.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,69 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef IO_SEQUENCE_INC
+#define IO_SEQUENCE_INC
+
+#include "Sequence.h"
+
+namespace Torch {
+
+/** Class which provides an ensemble of sequences, which have the same
+    frame size, but could have different number of frames.
+    
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class IOSequence : public Object
+{
+  public:
+    /// Number of sequences in the interface.
+    int n_sequences;
+
+    /// Frame size of each sequence.
+    int frame_size;
+
+    ///
+    IOSequence(); 
+
+    /// Returns the number of frames of the sequence indexed by #t#.
+    virtual int getNumberOfFrames(int t) = 0;
+
+    /** Write the sequence #t# in #sequence#.
+        Sequence must have the size returned by #getNumberOfFrames()#.
+    */
+    virtual void getSequence(int t, Sequence *sequence) = 0;
+
+    /// Returns the total number of frames in the IO.
+    virtual int getTotalNumberOfFrames() = 0;
+
+    virtual ~IOSequence();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOSub.cc work/main.d/Torch-3/core/IOSub.cc
--- tmp/Torch-3/core/IOSub.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOSub.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,66 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "IOSub.h"
+
+namespace Torch {
+
+IOSub::IOSub(IOBufferize *io_torch_, int offset_, int frame_size_)
+{
+  io_torch = io_torch_;
+  offset = offset_;
+  n_sequences = io_torch->n_sequences;
+  frame_size = frame_size_;
+
+  if(frame_size > (io_torch->frame_size-offset))
+    error("IOSub: the provided frame size is too large...");
+}
+
+void IOSub::getSequence(int t, Sequence *sequence)
+{
+  io_torch->bufferizeSequence(t);
+  Sequence *src = io_torch->bufferized_sequence;
+  for(int i = 0; i < sequence->n_frames; i++)
+    memcpy(sequence->frames[i], src->frames[i]+offset, sizeof(real)*frame_size);
+}
+
+int IOSub::getNumberOfFrames(int t)
+{
+  return io_torch->getNumberOfFrames(t);
+}
+
+int IOSub::getTotalNumberOfFrames()
+{
+  return io_torch->getTotalNumberOfFrames();
+}
+
+IOSub::~IOSub()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/IOSub.h work/main.d/Torch-3/core/IOSub.h
--- tmp/Torch-3/core/IOSub.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/IOSub.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,61 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef IO_SUB_INC
+#define IO_SUB_INC
+
+#include "IOBufferize.h"
+
+namespace Torch {
+
+/** IOSequence which does a selection of adjacent columns
+    on another IOSequence, when calling #getMatrix()#.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class IOSub : public IOSequence
+{
+  public:
+    IOBufferize *io_torch;
+    int offset;
+
+    /** We will select columns indexed by #offset_#...#offset_+frame_size_-1#
+        of the frames provided by #io_torch_#, when calling #getSequence()#.
+    */
+    IOSub(IOBufferize *io_torch_, int offset_, int frame_size_);
+
+    virtual void getSequence(int t, Sequence *sequence);
+    virtual int getNumberOfFrames(int t);
+    virtual int getTotalNumberOfFrames();
+
+    virtual ~IOSub();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/KFold.cc work/main.d/Torch-3/core/KFold.cc
--- tmp/Torch-3/core/KFold.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/KFold.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,129 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "KFold.h"
+#include "Random.h"
+
+namespace Torch {
+
+KFold::KFold(Trainer* trainer_, int kfold_)
+{
+  kfold = kfold_;
+  trainer = trainer_;
+
+  train_subsets = (int**)allocator->alloc(sizeof(int*)*kfold);
+  test_subsets = (int**)allocator->alloc(sizeof(int*)*kfold);
+  n_train_subsets = (int*)allocator->alloc(sizeof(int)*kfold);
+  n_test_subsets = (int*)allocator->alloc(sizeof(int)*kfold);
+
+  for (int i=0;i<kfold;i++)
+  {
+    train_subsets[i] = NULL;
+    test_subsets[i] = NULL;
+  }
+}
+
+void KFold::sample(int n_examples)
+{
+  int *mix_subset = (int *)Allocator::sysAlloc(sizeof(int)*n_examples);
+  Random::getShuffledIndices(mix_subset, n_examples);
+  int fucking_hack_because_round_sucks = n_examples/kfold;
+  int taille_subset = ( (((real)n_examples)/((real)kfold)) - (real)fucking_hack_because_round_sucks >= 0.5 ? fucking_hack_because_round_sucks+1 : fucking_hack_because_round_sucks );
+  for(int i = 0; i < kfold; i++)
+  {
+    n_train_subsets[i] = 0;
+    n_test_subsets[i] = 0;
+
+    for(int j = 0; j < i*taille_subset; j++)
+      train_subsets[i][n_train_subsets[i]++] = mix_subset[j];
+    for(int j = i*taille_subset; j < min((i+1)*taille_subset, n_examples); j++)
+      test_subsets[i][n_test_subsets[i]++] = mix_subset[j];
+    if(i == kfold-1)
+    {
+      for(int j = min((i+1)*taille_subset, n_examples); j < n_examples; j++)
+        test_subsets[i][n_test_subsets[i]++] = mix_subset[j];
+    }
+    else
+    {
+      for(int j = (i+1)*taille_subset; j < n_examples; j++)
+        train_subsets[i][n_train_subsets[i]++] = mix_subset[j];
+    }
+  }
+  free(mix_subset);
+}
+
+void KFold::crossValidate(DataSet *data, MeasurerList *train_measurers, MeasurerList *test_measurers, MeasurerList *cross_valid_measurers)
+{
+  for (int i=0;i<kfold;i++)
+  {
+    train_subsets[i] = (int*)allocator->realloc(train_subsets[i], sizeof(int)*data->n_examples);
+    test_subsets[i] = (int*)allocator->realloc(test_subsets[i], sizeof(int)*data->n_examples);
+  }
+
+  sample(data->n_examples);
+
+  if(cross_valid_measurers)
+  {
+    for(int i = 0; i < cross_valid_measurers->n_nodes; i++)
+      cross_valid_measurers->nodes[i]->reset();
+  }
+
+  for(int i = 0; i < kfold; i++)
+  {
+    data->pushSubset(train_subsets[i], n_train_subsets[i]);
+    trainer->machine->reset();
+    trainer->train(data, train_measurers);
+    data->popSubset();
+
+    data->pushSubset(test_subsets[i], n_test_subsets[i]);
+    trainer->test(test_measurers);
+    data->popSubset();
+
+    if(cross_valid_measurers)
+    {
+      for(int j = 0; j < cross_valid_measurers->n_nodes; j++)
+        cross_valid_measurers->nodes[j]->measureExample();
+    }
+  }
+  
+  if(cross_valid_measurers)
+  {
+    for(int i = 0; i < cross_valid_measurers->n_nodes; i++)
+    {
+      cross_valid_measurers->nodes[i]->measureIteration();
+      cross_valid_measurers->nodes[i]->measureEnd();
+    }
+  }
+}
+
+KFold::~KFold()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/KFold.h work/main.d/Torch-3/core/KFold.h
--- tmp/Torch-3/core/KFold.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/KFold.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,89 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef KFOLD_INC
+#define KFOLD_INC
+
+#include "Trainer.h"
+
+namespace Torch {
+
+/** Provides an interface to sample data, for use by methods such
+    as cross-validation
+
+    @author Samy Bengio (bengio@idiap.ch)
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+
+class KFold : public Object
+{
+  public:
+    /// Training examples for each fold
+    int** train_subsets;
+
+    /// Test examples for each fold
+    int** test_subsets;
+
+    /// Number of training examples for each fold...
+    int* n_train_subsets;
+
+    /// Number of test examples for each fold...
+    int* n_test_subsets;
+
+    // Trainer used to do KFold
+    Trainer* trainer;
+
+    // Number of folds!
+    int kfold;
+
+    ///
+    KFold(Trainer* trainer_, int kfold_);
+
+    /** Do a cross-validation over #data#.
+        #train_measurers# are called in each "train pass" for each fold.
+        #test_measurers# are called in each "test pass" for each fold.
+        #cross_valid_measurers# are called during the cross-validation loop.
+    */
+    virtual void crossValidate(DataSet *data, MeasurerList *train_measurers=NULL, MeasurerList *test_measurers=NULL, MeasurerList *cross_valid_measurers=NULL);
+
+    /** Prepare the sample.
+        Given #n_examples#, puts the right examples-indices in #train_subsets#
+        and #test_subsets#, and updates #n_train_subsets# and #n_test_subsets#.
+        (You don't have to allocate these arrays).
+        The provided sample function is a standard sample for cross-validation,
+        but you could imagine what you want!
+    */
+    virtual void sample(int n_examples);
+
+    virtual ~KFold();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/List.h work/main.d/Torch-3/core/List.h
--- tmp/Torch-3/core/List.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/List.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,118 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LIST_INC
+#define LIST_INC
+
+#include "Object.h"
+
+namespace Torch {
+
+/** List Classes.
+
+A list named NAME with node pointer type TYPE has the following aspect:
+
+\begin{verbatim}
+class NAME
+{
+  /// Pointer which can be used as you want.
+  TYPE *nodes;
+  
+  /// Number of nodes.
+  int n_nodes;
+
+  /// Constructor.
+  NAME();
+
+  /// Add a list at the end of the current list.
+  void add(NAME *list);
+
+  /// Add a node at the end of the current list.
+  void addNode(TYPE *node_)
+};
+\end{verbatim}
+
+To declare a new list, just use the macro (in ".h" files):
+
+\begin{verbatim}
+#DEFINE_NEW_LIST(NAME, TYPE);
+\end{verbatim}
+
+and to implement this list, use the macro (in ".cc" files):
+\begin{verbatim}
+#define IMPLEMENT_NEW_LIST(NAME, TYPE)
+\end{verbatim}
+
+The name of a list which TYPE nodes should be something like "TYPEList".
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @type class
+    @name List
+    @args
+    @memo
+*/
+
+#define DEFINE_NEW_LIST(NAME, TYPE) \
+class NAME : public Object \
+{ \
+  public: \
+    TYPE **nodes; \
+    int n_nodes; \
+\
+    NAME(); \
+    void add(NAME *list); \
+    void addNode(TYPE *node); \
+}
+
+#define IMPLEMENT_NEW_LIST(NAME, TYPE) \
+\
+NAME::NAME() \
+{ \
+  nodes = NULL; \
+  n_nodes = 0; \
+} \
+\
+void NAME::add(NAME *list) \
+{ \
+  if(!list->n_nodes) \
+    return; \
+\
+  nodes = (TYPE **)allocator->realloc(nodes, sizeof(TYPE *)*(n_nodes+list->n_nodes)); \
+  for(int i = 0; i < list->n_nodes; i++) \
+     nodes[n_nodes++] = list->nodes[i]; \
+} \
+\
+void NAME::addNode(TYPE *node) \
+{ \
+  nodes = (TYPE **)allocator->realloc(nodes, sizeof(TYPE *)*(n_nodes+1)); \
+  nodes[n_nodes++] = node; \
+}
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/log_add.cc work/main.d/Torch-3/core/log_add.cc
--- tmp/Torch-3/core/log_add.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/log_add.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,77 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "log_add.h"
+#include "general.h"
+
+namespace Torch {
+
+#ifdef USE_DOUBLE
+#define MINUS_LOG_THRESHOLD -39.14
+#else
+#define MINUS_LOG_THRESHOLD -18.42
+#endif
+
+real logAdd(real log_a, real log_b)
+{
+  if (log_a < log_b) {
+    real tmp = log_a;
+    log_a = log_b;
+    log_b = tmp;
+  }
+
+  real minusdif = log_b - log_a;
+#ifdef DEBUG
+  if (isnan(minusdif))
+    error("LogAdd: minusdif (%f) log_b (%f) or log_a (%f) is nan",minusdif,log_b,log_a);
+#endif
+  if (minusdif < MINUS_LOG_THRESHOLD)
+    return log_a;
+  else
+    return log_a + log1p(exp(minusdif));
+}
+
+real logSub(real log_a, real log_b)
+{
+  if (log_a < log_b)
+    error("LogSub: log_a (%f) should be greater than log_b (%f)", log_a, log_b);
+
+  real minusdif = log_b - log_a;
+#ifdef DEBUG
+  if (isnan(minusdif))
+    error("LogSub: minusdif (%f) log_b (%f) or log_a (%f) is nan",minusdif,log_b,log_a);
+#endif
+  if (log_a == log_b)
+    return LOG_ZERO;
+  else if (minusdif < MINUS_LOG_THRESHOLD)
+    return log_a;
+  else
+    return log_a + log1p(-exp(minusdif));
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/log_add.h work/main.d/Torch-3/core/log_add.h
--- tmp/Torch-3/core/log_add.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/log_add.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,57 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LOG_ADD_INC
+#define LOG_ADD_INC
+
+#include "general.h"
+
+namespace Torch {
+
+/** Some simple functions for log operations.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+//@{
+#define LOG_2_PI 1.83787706640934548355
+#define LOG_ZERO -INF
+#define LOG_ONE 0
+
+/** logAdd(log_a,log_b) = log(a+b) = log(exp(log_a)+exp(log_b))
+    but done in a smart way so that if log_a or log_b are large
+    but not their difference the computation works correctly.
+*/
+real logAdd(real log_a,real log_b);
+
+/// logSub(log_a,log_b) = log(a-b)
+real logSub(real log_a,real log_b);
+//@}
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Machine.cc work/main.d/Torch-3/core/Machine.cc
--- tmp/Torch-3/core/Machine.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Machine.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,52 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Machine.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+Machine::Machine()
+{
+  outputs = NULL;
+}
+
+void Machine::setDataSet(DataSet *dataset_)
+{
+}
+
+void Machine::reset()
+{
+}
+
+Machine::~Machine()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Machine.h work/main.d/Torch-3/core/Machine.h
--- tmp/Torch-3/core/Machine.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Machine.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,69 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MACHINE_INC
+#define MACHINE_INC
+
+#include "Object.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+/** #Object# which can compute some outputs,
+    given some inputs.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Machine : public Object
+{
+  public:
+
+    /// The outputs of the machine.
+    Sequence *outputs;
+
+    ///
+    Machine();
+
+    /// Given a sequence, update #outputs#.
+    virtual void forward(Sequence *sequence) = 0;
+
+    /// Reset the machine.
+    virtual void reset();
+
+    /** Some machine depends on a dataset.
+        The trainer has to call this function when changing
+        the dataset.
+    */
+    virtual void setDataSet(DataSet *dataset_);
+
+    virtual ~Machine();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Makefile work/main.d/Torch-3/core/Makefile
--- tmp/Torch-3/core/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Makefile	2004-08-11 12:34:35.000000000 -0400
@@ -0,0 +1,42 @@
+# get user and architecture specific options
+OS := $(shell uname -s)
+TORCHDIR := $(shell cd ..; pwd)
+include ../Makefile_options_$(OS)
+
+CC_FILES := $(wildcard *.cc)
+OBJS := $(foreach f,$(CC_FILES),$(OBJS_DIR)/$(patsubst %.cc,%.o,$(f)))
+
+all:	$(LIBTORCH)
+
+$(LIBTORCH): $(OBJS)
+	@echo "Archiving..."
+	@$(AR) $(LIBTORCH) $(OBJS)
+
+$(OBJS_DIR)/%.o: %.cc
+	@echo $<
+	@$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $@ -c $<
+
+distclean:
+	@\rm -f .deps_*
+
+clean:
+	@echo "Remove objects file and dependencies..."
+	@\rm -Rf $(OBJS) $(LIBTORCH)
+	@\rm -f .deps_$(VERSION_KEY)
+
+depend:
+	@echo "Tracking dependencies..."
+	@\rm -f .deps_$(VERSION_KEY)
+	@for file in *.cc ; do printf "$(OBJS_DIR)/" >> .deps_$(VERSION_KEY); $(DEP) $(CFLAGS_$(MODE)) $(INCS) $$file >> .deps_$(VERSION_KEY); done
+
+.deps_$(VERSION_KEY):
+	@echo ">>> Please do a 'make depend' <<<"
+	exit 10
+
+ifneq ($(MAKECMDGOALS),distclean)
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),depend)
+include .deps_$(VERSION_KEY)
+endif
+endif
+endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MatDataSet.cc work/main.d/Torch-3/core/MatDataSet.cc
--- tmp/Torch-3/core/MatDataSet.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MatDataSet.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,226 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "IOBufferize.h"
+#include "MatDataSet.h"
+#include "IOAscii.h"
+#include "IOMulti.h"
+#include "IOBin.h"
+#include "IOSub.h"
+
+namespace Torch {
+
+MatDataSet::MatDataSet(const char *filename, int n_inputs_, int n_targets_,
+                       bool one_file_is_one_sequence, int max_load, bool binary_mode)
+{
+  io_allocator = new Allocator;
+  if( (n_inputs_ < 0) && (n_targets < 0) )
+    error("MatDataSet: cannot guess n_inputs <and> n_targets!");
+
+  IOSequence *io_file = NULL;
+  if(binary_mode)
+    io_file = new(io_allocator) IOBin(filename, one_file_is_one_sequence, max_load);
+  else
+    io_file = new(io_allocator) IOAscii(filename, one_file_is_one_sequence, max_load);
+
+  init_(io_file, n_inputs_, n_targets_);
+}
+
+MatDataSet::MatDataSet(char **filenames, int n_files_, int n_inputs_, int n_targets_,
+                       bool one_file_is_one_sequence, int max_load, bool binary_mode)
+{
+  io_allocator = new Allocator;
+  if(n_files_ <= 0)
+    error("MatDataSet: check the number of files!");
+
+  IOSequence **io_files = (IOSequence **)io_allocator->alloc(sizeof(IOSequence *)*n_files_);
+  if(max_load > 0)
+  {
+    int i = 0;
+    while( (max_load > 0) && (i < n_files_) )
+    {
+      if(binary_mode)
+        io_files[i] = new(io_allocator) IOBin(filenames[i], one_file_is_one_sequence, max_load);
+      else
+        io_files[i] = new(io_allocator) IOAscii(filenames[i], one_file_is_one_sequence, max_load);
+      max_load -= io_files[i]->n_sequences;
+      i++;
+    }
+    n_files_ = i;
+  }
+  else
+  {
+    if(binary_mode)
+    {
+      for(int i = 0; i < n_files_; i++)
+        io_files[i] = new(io_allocator) IOBin(filenames[i], one_file_is_one_sequence);
+    }
+    else
+    {
+      for(int i = 0; i < n_files_; i++)
+        io_files[i] = new(io_allocator) IOAscii(filenames[i], one_file_is_one_sequence);
+    }
+  }
+
+  IOMulti *io_file = new(io_allocator) IOMulti(io_files, n_files_);
+  init_(io_file, n_inputs_, n_targets_);
+}
+
+MatDataSet::MatDataSet(char **input_filenames, char **target_filenames, int n_files_,
+                       int max_load, bool binary_mode)
+{
+  IOSequence *io_inputs = NULL;
+  IOSequence *io_targets = NULL;
+  io_allocator = new Allocator;
+
+  if(n_files_ <= 0)
+    error("MatDataSet: check the number of files!");
+
+  if(input_filenames)
+  {
+    IOSequence **input_io_files = (IOSequence **)io_allocator->alloc(sizeof(IOSequence *)*n_files_);
+    int max_load_ = max_load;
+    int n_files__ = 0;
+    if(max_load_ > 0)
+    {
+      int i = 0;
+      while( (max_load_ > 0) && (i < n_files_) )
+      {
+        if(binary_mode)
+          input_io_files[i] = new(io_allocator) IOBin(input_filenames[i], true, max_load_);
+        else
+          input_io_files[i] = new(io_allocator) IOAscii(input_filenames[i], true, max_load_);
+        max_load_ -= input_io_files[i]->n_sequences;
+        i++;
+      }
+      n_files__ = i;
+    }
+    else
+    {
+      if(binary_mode)
+      {
+        for(int i = 0; i < n_files_; i++)
+          input_io_files[i] = new(io_allocator) IOBin(input_filenames[i], true);
+      }
+      else
+      {
+        for(int i = 0; i < n_files_; i++)
+          input_io_files[i] = new(io_allocator) IOAscii(input_filenames[i], true);
+      }
+      n_files__ = n_files_;
+    }
+    io_inputs = new(io_allocator) IOMulti(input_io_files, n_files__);
+  }
+
+  if(target_filenames)
+  {
+    IOSequence **target_io_files = (IOSequence **)io_allocator->alloc(sizeof(IOSequence *)*n_files_);
+    int max_load_ = max_load;
+    int n_files__ = 0;
+    if(max_load_ > 0)
+    {
+      int i = 0;
+      while( (max_load_ > 0) && (i < n_files_) )
+      {
+        if(binary_mode)
+          target_io_files[i] = new(io_allocator) IOBin(target_filenames[i], true, max_load_);
+        else
+          target_io_files[i] = new(io_allocator) IOAscii(target_filenames[i], true, max_load_);
+        max_load_ -= target_io_files[i]->n_sequences;
+        i++;
+      }
+      n_files__ = i;
+    }
+    else
+    {
+      if(binary_mode)
+      {
+        for(int i = 0; i < n_files_; i++)
+          target_io_files[i] = new(io_allocator) IOBin(target_filenames[i], true);
+      }
+      else
+      {
+        for(int i = 0; i < n_files_; i++)
+          target_io_files[i] = new(io_allocator) IOAscii(target_filenames[i], true);
+      }
+      n_files__ = n_files_;
+    }
+    io_targets = new(io_allocator) IOMulti(target_io_files, n_files__);
+  }
+
+  MemoryDataSet::init(io_inputs, io_targets);
+  message("MatDataSet: %d examples loaded [%d inputs and %d targets detected]", n_examples, n_inputs, n_targets);
+  delete io_allocator;
+}
+
+void MatDataSet::init_(IOSequence *io_file, int n_inputs_, int n_targets_)
+{
+  IOSequence *io_inputs = NULL;
+  IOSequence *io_targets = NULL;
+
+  if( (n_inputs_ > io_file->frame_size) || (n_targets_ > io_file->frame_size) )
+    error("MatDataSet: n_inputs (%d) or n_targets (%d) too large (> %d) !", n_inputs_, n_targets_, io_file->frame_size);
+
+  if(n_inputs_ < 0)
+    n_inputs_ = io_file->frame_size - n_targets_;
+
+  if(n_targets_ < 0)
+    n_targets_ = io_file->frame_size - n_inputs_;
+
+  if(io_file->frame_size != (n_inputs_ + n_targets_))
+    error("MatDataSet: %d columns in the file != %d inputs + %d targets", io_file->frame_size, n_inputs_, n_targets_);
+
+  IOBufferize *io_buffer = NULL;
+  if( (n_inputs_ > 0) && (n_targets_ > 0) )
+    io_buffer = new(io_allocator) IOBufferize(io_file);
+
+  if(n_inputs_ > 0)
+  {
+    if(n_targets_ > 0)
+      io_inputs = new(io_allocator) IOSub(io_buffer, 0, n_inputs_);
+    else
+      io_inputs = io_file;
+  }
+  if(n_targets_ > 0)
+  {
+    if(n_inputs_ > 0)
+      io_targets = new(io_allocator) IOSub(io_buffer, n_inputs_, n_targets_);
+    else
+      io_targets = io_file;
+  }
+
+  MemoryDataSet::init(io_inputs, io_targets);
+  message("MatDataSet: %d examples loaded", n_examples);
+  delete io_allocator;
+}
+
+MatDataSet::~MatDataSet()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MatDataSet.h work/main.d/Torch-3/core/MatDataSet.h
--- tmp/Torch-3/core/MatDataSet.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MatDataSet.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,80 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MAT_DATA_SET_INC
+#define MAT_DATA_SET_INC
+
+#include "MemoryDataSet.h"
+
+namespace Torch {
+
+/** Matrix DataSet...
+    The standard dataset, with data fully loaded in memory.
+    Usefull for large databases.
+
+    @see IOAscii
+    @see IOBin
+    @author Ronan Collobert (collober@idiap.ch)
+ */
+class MatDataSet : public MemoryDataSet
+{
+  private:
+    void init_(IOSequence *io_file, int n_inputs_, int n_targets_);
+    Allocator *io_allocator;
+
+  public:
+    /** Create a new dataset from the file #filename#. If the file contains only one sequence, set #one_file_is_one_sequence#
+        to true. If there is several sequences, and you want only to load the first #n# ones, set #max_load# to #n# (else #max_load#
+        should be a negative number). If #binary_mode# is true, the IOBin format will be used, else it will be the IOAscii format.
+        
+        Input and target sequence will have the same number of frames. For \emph{each} frame given by the dataset, the first #n_inputs_#
+        real are for the inputs and then the next #n_targets_# real are for the targets. (#n_inputs_# is the input frame size and
+        #n_targets_# is the target frame size).
+    */       
+    MatDataSet(const char *filename, int n_inputs_, int n_targets_,
+               bool one_file_is_one_sequence=false, int max_load=-1, bool binary_mode=false);
+
+    /** Same as the previous constructor, but for several files. If #one_file_is_one_sequence# is true, each files will be considered as they
+        had only one sequence.
+    */
+    MatDataSet(char **filenames, int n_files_, int n_inputs_, int n_targets_,
+               bool one_file_is_one_sequence=false, int max_load=-1, bool binary_mode=false);
+
+    /** Here the inputs and the targets are in separated files.
+        Input and target frame sizes are therefore auto-detected.
+        One file must correspond to one sequence.
+    */
+    MatDataSet(char **input_filenames, char **target_filenames, int n_files_,
+               int max_load=-1, bool binary_mode=false);
+
+    virtual ~MatDataSet();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MeanVarNorm.cc work/main.d/Torch-3/core/MeanVarNorm.cc
--- tmp/Torch-3/core/MeanVarNorm.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MeanVarNorm.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,197 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "MeanVarNorm.h"
+#include "XFile.h"
+
+namespace Torch {
+
+MeanVarNorm::MeanVarNorm(DataSet *data, bool norm_inputs, bool norm_targets)
+{
+  inputs_mean = NULL;
+  inputs_stdv = NULL;
+  targets_mean = NULL;
+  targets_stdv = NULL;
+  n_inputs = data->n_inputs;
+  n_targets = data->n_targets;
+
+  if(norm_inputs)
+  {
+    inputs_mean = (real *)allocator->alloc(sizeof(real)*n_inputs);
+    inputs_stdv = (real *)allocator->alloc(sizeof(real)*n_inputs);
+    for(int i = 0; i < n_inputs; i++)
+    {
+      inputs_mean[i] = 0;
+      inputs_stdv[i] = 0;
+    }
+  }
+
+  if(norm_targets)
+  {
+    targets_mean = (real *)allocator->alloc(sizeof(real)*n_targets);
+    targets_stdv = (real *)allocator->alloc(sizeof(real)*n_targets);
+    for(int i = 0; i < n_targets; i++)
+    {
+      targets_mean[i] = 0;
+      targets_stdv[i] = 0;
+    }
+  }
+
+  int n_total_input_frames = 0;
+  int n_total_target_frames = 0;
+  for(int t = 0; t < data->n_examples; t++)
+  {
+    data->setExample(t);
+
+    // Les inputs
+    if(norm_inputs)
+    {
+      for(int i = 0; i < data->inputs->n_frames; i++)
+      {
+        real *src_ = data->inputs->frames[i];
+        for(int j = 0; j < n_inputs; j++)
+        {
+          real z = src_[j];
+          inputs_mean[j] += z;
+          inputs_stdv[j] += z*z;
+        }
+      }
+      n_total_input_frames += data->inputs->n_frames;
+    }
+
+    // Les targets
+    if(norm_targets)
+    {
+      for(int i = 0; i < data->targets->n_frames; i++)
+      {
+        real *src_ = data->targets->frames[i];
+        for(int j = 0; j < n_targets; j++)
+        {
+          real z = src_[j];
+          targets_mean[j] += z;
+          targets_stdv[j] += z*z;
+        }
+      }
+      n_total_target_frames += data->targets->n_frames;
+    }
+  }
+
+  if(norm_inputs)
+  {
+    for(int i = 0; i < n_inputs; i++)
+    {
+      inputs_mean[i] /= (real)n_total_input_frames;
+      inputs_stdv[i] /= (real)n_total_input_frames;
+      inputs_stdv[i] -= inputs_mean[i]*inputs_mean[i];
+      if(inputs_stdv[i] <= 0)
+      {
+        warning("MeanVarNorm: input column %d has a null stdv. Replaced by 1.", i);
+        inputs_stdv[i] = 1.;
+      }
+      else
+        inputs_stdv[i] = sqrt(inputs_stdv[i]);
+    }
+  }
+
+  if(norm_targets)
+  {
+    for(int i = 0; i < n_targets; i++)
+    {
+      targets_mean[i] /= (real)n_total_target_frames;
+      targets_stdv[i] /= (real)n_total_target_frames;
+      targets_stdv[i] -= targets_mean[i]*targets_mean[i];
+      if(targets_stdv[i] <= 0)
+      {
+        warning("MeanVarNorm: target column %d has a null stdv. Replaced by 1.", i);
+        targets_stdv[i] = 1.;
+      }
+      else
+        targets_stdv[i] = sqrt(targets_stdv[i]);
+    }
+  }
+}
+
+void MeanVarNorm::normalizeSequence(Sequence *sequence, real *mean, real *stdv)
+{
+  for(int i = 0; i < sequence->n_frames; i++)
+  {
+    real *ptr_ = sequence->frames[i];
+    for(int k = 0; k < sequence->frame_size; k++)
+      ptr_[k] = (ptr_[k] - mean[k])/stdv[k];
+  }
+}
+
+void MeanVarNorm::preProcessInputs(Sequence *inputs)
+{
+  if(!inputs_mean)
+    return;
+
+  normalizeSequence(inputs, inputs_mean, inputs_stdv);
+}
+
+void MeanVarNorm::preProcessTargets(Sequence *targets)
+{
+  if(!targets_mean)
+    return;
+
+  normalizeSequence(targets, targets_mean, targets_stdv);
+}
+
+void MeanVarNorm::loadXFile(XFile *file)
+{
+  if(inputs_mean)
+  {
+    file->taggedRead(inputs_mean, sizeof(real), n_inputs, "IMEANS");
+    file->taggedRead(inputs_stdv, sizeof(real), n_inputs, "ISTDVS");
+  }
+  if(targets_mean)
+  {
+    file->taggedRead(targets_mean, sizeof(real), n_targets, "TMEANS");
+    file->taggedRead(targets_stdv, sizeof(real), n_targets, "TSTDVS");
+  }
+}
+
+void MeanVarNorm::saveXFile(XFile *file)
+{
+  if(inputs_mean)
+  {
+    file->taggedWrite(inputs_mean, sizeof(real), n_inputs, "IMEANS");
+    file->taggedWrite(inputs_stdv, sizeof(real), n_inputs, "ISTDVS");
+  }
+  if(targets_mean)
+  {
+    file->taggedWrite(targets_mean, sizeof(real), n_targets, "TMEANS");
+    file->taggedWrite(targets_stdv, sizeof(real), n_targets, "TSTDVS");
+  }
+}
+
+MeanVarNorm::~MeanVarNorm()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MeanVarNorm.h work/main.d/Torch-3/core/MeanVarNorm.h
--- tmp/Torch-3/core/MeanVarNorm.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MeanVarNorm.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,88 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MEAN_VAR_NORM_INC
+#define MEAN_VAR_NORM_INC
+
+#include "PreProcessing.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+/** In the constructor, it computes the mean and the standard deviation
+    over all the frames in the given DataSet (by default, only for inputs).
+    Then, when calling pre-processing methods, it normalizes each column
+    by this computed mean and stdv. (substracts the mean, then divides
+    by the standard deviation).
+
+    As a result, the mean of the full set of frames given by the concatenation
+    of all calls to #setExample()# will be 0, and the variance will be 1.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class MeanVarNorm : public PreProcessing
+{
+  private:
+    void normalizeSequence(Sequence *sequence, real *mean, real *stdv);
+
+  public:
+    /// Input frame size
+    int n_inputs;
+
+    /// Target frame size
+    int n_targets;
+
+    /// Inputs means array
+    real *inputs_mean;
+
+    /// Targets means array
+    real *targets_mean;
+
+    /// Inputs standard deviations array
+    real *inputs_stdv;
+
+    /// Targets standard deviations array
+    real *targets_stdv;
+
+    ///
+    MeanVarNorm(DataSet *data, bool norm_inputs=true, bool norm_targets=false);
+
+    virtual void preProcessInputs(Sequence *inputs);
+    virtual void preProcessTargets(Sequence *targets);
+
+    /// Load means and standard deviations
+    virtual void loadXFile(XFile *file);
+    /// Save means and standard deviations
+    virtual void saveXFile(XFile *file);
+
+    virtual ~MeanVarNorm();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Measurer.cc work/main.d/Torch-3/core/Measurer.cc
--- tmp/Torch-3/core/Measurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Measurer.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,63 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Measurer.h"
+#include "DataSet.h"
+#include "DiskXFile.h"
+
+namespace Torch {
+
+Measurer::Measurer(DataSet *data_, XFile *file_)
+{
+  file = file_;
+  data = data_;
+
+  addBOption("binary mode", &binary_mode, false, "binary mode");
+}
+
+void Measurer::reset()
+{
+}
+
+void Measurer::measureExample()
+{
+}
+
+void Measurer::measureIteration()
+{
+}
+
+void Measurer::measureEnd()
+{
+}
+
+Measurer::~Measurer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Measurer.h work/main.d/Torch-3/core/Measurer.h
--- tmp/Torch-3/core/Measurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Measurer.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,99 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MEASURER_INC
+#define MEASURER_INC
+
+#include "Object.h"
+#include "Machine.h"
+#include "DataSet.h"
+#include "XFile.h"
+
+namespace Torch {
+
+
+/** Used to measure what you want during training/testing.
+    Usually, trainers call measurers.
+    The #DataSet# associated to the measurer allow us
+    to know when the measurer should be called.
+    (if the #DataSet# is the train dataset, the
+    measurer will be called during the train phase...)
+
+    Options:
+    \begin{tabular}{lcll}
+      "binary mode"  &  bool  &  binary mode for output & [false]
+    \end{tabular}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Measurer : public Object
+{
+  public:
+    /// The measurer save measures in this file.
+    XFile *file;
+
+    /// The associated #DataSet#.
+    DataSet *data;
+
+    /// Is the measurer in binary mode ?
+    bool binary_mode;
+
+    //-----
+
+    /** Measurer with the associated #DataSet# #data_#,
+        and put results in the file #file_#.
+    */
+    Measurer(DataSet *data_, XFile *file_);
+
+    /** Measure something for the current example.
+        (This example has been selected in #data#
+         by the trainer)
+    */
+    virtual void measureExample();
+
+    /** Measure something after the current iteration.
+        (After the call of #measureExample()# for each
+        example of #data#)
+    */
+    virtual void measureIteration();
+
+    /// Measure something at the end of the training/testing phase.
+    virtual void measureEnd();
+
+    /// Reset the measurer. (By default, do nothing).
+    virtual void reset();
+
+    //-----
+
+    virtual ~Measurer();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MemoryDataSet.cc work/main.d/Torch-3/core/MemoryDataSet.cc
--- tmp/Torch-3/core/MemoryDataSet.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MemoryDataSet.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,191 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "MemoryDataSet.h"
+
+namespace Torch {
+
+MemoryDataSet::MemoryDataSet()
+{
+  inputs_array = NULL;
+  targets_array = NULL;
+}
+
+void MemoryDataSet::setRealExample(int t, bool set_inputs, bool set_targets)
+{
+  real_current_example_index = t;
+  if(inputs_array && set_inputs)
+    inputs = inputs_array[t];
+  if(targets_array && set_targets)
+    targets = targets_array[t];
+}
+
+void MemoryDataSet::pushExample()
+{
+  pushed_examples->push(&inputs, sizeof(Sequence *));
+  pushed_examples->push(&targets, sizeof(Sequence *));
+  pushed_examples->push(&real_current_example_index, sizeof(int));
+}
+
+void MemoryDataSet::popExample()
+{
+  pushed_examples->pop();
+  pushed_examples->pop();
+  pushed_examples->pop();
+}
+
+void MemoryDataSet::init(IOSequence *io_inputs, IOSequence *io_targets)
+{
+  int n_examples_ = 0;
+  if(io_inputs)
+    n_examples_ = io_inputs->n_sequences;
+  if(io_targets)
+    n_examples_ = io_targets->n_sequences;
+
+  if(io_inputs && io_targets)
+  {
+    if(io_inputs->n_sequences != io_targets->n_sequences)
+      error("MemoryDataSet: inputs IO and targets IO don't have the same number of sequences!");
+  }
+
+  // The parent
+  DataSet::init(n_examples_, (io_inputs ? io_inputs->frame_size : 0), (io_targets ? io_targets->frame_size : 0));
+  
+  // Yeah.
+  if(n_inputs > 0)
+  {
+    inputs_array = (Sequence **)allocator->alloc(sizeof(Sequence *)*n_examples);
+    allocData(io_inputs, inputs_array);
+  }
+
+  if(n_targets > 0)
+  {
+    targets_array = (Sequence **)allocator->alloc(sizeof(Sequence *)*n_examples);
+    allocData(io_targets, targets_array);
+  }
+
+  for(int t = 0; t < n_examples; t++)
+  {
+    if(n_inputs > 0)
+      io_inputs->getSequence(t, inputs_array[t]);
+    if(n_targets > 0)
+      io_targets->getSequence(t, targets_array[t]);
+  }
+}
+
+void MemoryDataSet::setInputs(Sequence **inputs_, int n_sequences_)
+{
+  if(n_sequences_ <= 0)
+    error("MemoryDataSet: invalid number of sequences in provided inputs");
+
+  // Deja alloue ?
+  if(selected_examples)
+  {
+    if(n_sequences_ != n_real_examples)
+      error("MemoryDataSet: invalid number of sequences in provided inputs");
+  }
+  else
+    DataSet::init(n_sequences_, inputs_[0]->frame_size, 0);
+
+  n_inputs = inputs_[0]->frame_size;
+  for(int t = 0; t < n_sequences_; t++)
+  {
+    if(inputs_[t]->frame_size != n_inputs)
+      error("MemoryDataSet: sorry, provided inputs sequences don't have the same frame size");
+  }
+  inputs_array = inputs_;
+}
+
+void MemoryDataSet::setTargets(Sequence **targets_, int n_sequences_)
+{
+  if(n_sequences_ <= 0)
+    error("MemoryDataSet: invalid number of sequences in provided targets");
+
+  // Deja alloue ?
+  if(selected_examples)
+  {
+    if(n_sequences_ != n_real_examples)
+      error("MemoryDataSet: invalid number of sequences in provided targets");
+  }
+  else
+    DataSet::init(n_sequences_, 0, targets_[0]->frame_size);
+
+  n_targets = targets_[0]->frame_size;
+  for(int t = 0; t < n_sequences_; t++)
+  {
+    if(targets_[t]->frame_size != n_targets)
+      error("MemoryDataSet: sorry, provided targets sequences don't have the same frame size");
+  }
+  targets_array = targets_;
+}
+
+void MemoryDataSet::getNumberOfFrames(int t, int *n_input_frames_, int *n_target_frames_)
+{
+  if( (n_inputs > 0) && n_input_frames_ )
+    *n_input_frames_ = inputs_array[selected_examples[t]]->n_frames;
+  if( (n_targets > 0) && n_target_frames_ )
+    *n_target_frames_ = targets_array[selected_examples[t]]->n_frames;
+}
+
+void MemoryDataSet::allocData(IOSequence *io_torch, Sequence **sequences_array)
+{
+  int n_total_frames = io_torch->getTotalNumberOfFrames();
+  int frame_size = io_torch->frame_size;
+
+  Sequence *sequences_buffer = (Sequence *)allocator->alloc(sizeof(Sequence)*n_examples);
+  real **frames_pointers_buffer = (real **)allocator->alloc(sizeof(real *)*n_total_frames);
+  real *frames_buffer = (real *)allocator->alloc(sizeof(real)*n_total_frames*frame_size);
+  for(int i = 0; i < n_total_frames; i++)
+    frames_pointers_buffer[i] = frames_buffer+i*frame_size;
+
+  for(int t = 0; t < io_torch->n_sequences; t++)
+  {
+    int n_frames = io_torch->getNumberOfFrames(t);
+    sequences_array[t] = new(allocator, sequences_buffer) Sequence(frames_pointers_buffer, n_frames, frame_size);
+    sequences_buffer++;
+    frames_pointers_buffer += n_frames;
+  }
+}
+
+void MemoryDataSet::preProcess(PreProcessing *pre_processing)
+{
+  for(int t = 0; t < n_examples; t++)
+  {
+    setExample(t);
+    if(n_inputs > 0)
+      pre_processing->preProcessInputs(inputs);
+    if(n_targets > 0)
+      pre_processing->preProcessTargets(targets);
+  }
+}
+
+MemoryDataSet::~MemoryDataSet()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MemoryDataSet.h work/main.d/Torch-3/core/MemoryDataSet.h
--- tmp/Torch-3/core/MemoryDataSet.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MemoryDataSet.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,90 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MEMORY_DATA_SET_INC
+#define MEMORY_DATA_SET_INC
+
+#include "DataSet.h"
+#include "IOSequence.h"
+
+namespace Torch {
+
+/** DataSet where data is fully loaded in memory.
+
+    Inputs and targets are put in two arrays: #inputs_array# and #targets_array#.
+    You can fill these fields by using the #init()# method (if you are using
+    IOSequence). But you could imagine a MemoryDataSet where you fill these fields
+    by hand (based on the #init()# method).
+    MatDataSet is a good example if you plan to do a new MemoryDataSet.
+
+    @see MatDataSet
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class MemoryDataSet : public DataSet
+{
+  private:
+    virtual void allocData(IOSequence *io_torch, Sequence **sequences_array);
+
+  public:
+
+    /// Inputs array.
+    Sequence **inputs_array;
+
+    /// Targets array.
+    Sequence **targets_array;
+
+    ///
+    MemoryDataSet();
+
+    /** May help you to initialize the DataSet if you're using IOSequence.
+        You should call this method in the constructor of your subsclasses.
+        Initialize #n_examples#, #n_real_examples#, #n_inputs# and #n_targets#.
+        #inputs_array# and #targets_array# filled with sequences given by the IOSequence classes.
+    */
+    void init(IOSequence *io_inputs, IOSequence *io_outputs);
+
+    /// Override current inputs array.
+    void setInputs(Sequence **inputs_, int n_sequences_);
+
+    /// Override current targets array.
+    void setTargets(Sequence **targets_, int n_sequences_);
+
+    virtual void getNumberOfFrames(int t, int *n_input_frames_, int *n_target_frames_);
+    virtual void preProcess(PreProcessing *pre_processing);
+    virtual void setRealExample(int t, bool set_inputs=true, bool set_targets=true);
+    virtual void pushExample();
+    virtual void popExample();
+
+    //-----
+
+    virtual ~MemoryDataSet();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MemoryXFile.cc work/main.d/Torch-3/core/MemoryXFile.cc
--- tmp/Torch-3/core/MemoryXFile.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MemoryXFile.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,442 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "MemoryXFile.h"
+
+namespace Torch {
+
+IMPLEMENT_NEW_LIST(MemoryXFileList, MemoryXFileNode);
+
+char MemoryXFile::petit_message_pour_melanie[10000];
+
+MemoryXFile::MemoryXFile(MemoryXFileList *memory_, int size_, int buffer_format_size_)
+{
+  addIOption("buffer size", &buffer_size, 65536, "buffer size for writing");
+
+  buffer_format_size = buffer_format_size_;
+  buffer_format = (char *)allocator->alloc(buffer_format_size);
+
+  // Copy the list, but not inside
+  memory = new(allocator) MemoryXFileList;
+  for(int i = 0; i < memory_->n_nodes; i++)
+  {
+    MemoryXFileNode *node_ = (MemoryXFileNode *)memory->allocator->alloc(sizeof(MemoryXFileNode));
+    node_->size = memory_->nodes[i]->size;
+    node_->mem = memory_->nodes[i]->mem;
+    memory->addNode(node_);
+  }
+
+  /*** Remarque:
+       Si je me trompe pas, size c'est ce qui est ecrit.
+       (genre si je fais des seek, je sais ce qu'il y a).
+       total_size, c'est ce qui est alloue.
+  ****/
+
+  // Check the size
+  if(size_ < 0)
+  {
+    total_size = 0;
+    for(int i = 0; i < memory->n_nodes; i++)
+      total_size += memory->nodes[i]->size;
+    size = total_size;
+  }
+  else
+  {
+    size = size_;
+    total_size = size_;
+  }
+
+  // Boxon
+  position = 0;
+  internal_memory_node_index = 0;
+  internal_position_in_the_node = 0;
+  is_eof = false;
+}
+
+MemoryXFile::MemoryXFile(void *memory_, int size_, int buffer_format_size_)
+{
+  addIOption("buffer size", &buffer_size, 65536, "buffer size for writing");
+
+  buffer_format_size = buffer_format_size_;
+  buffer_format = (char *)allocator->alloc(buffer_format_size);
+
+  // Copy the memory_, but not inside
+  memory = new(allocator) MemoryXFileList;
+  MemoryXFileNode *node_ = (MemoryXFileNode *)memory->allocator->alloc(sizeof(MemoryXFileNode));
+  node_->size = size_;
+  node_->mem = memory_;
+  memory->addNode(node_);
+
+  // Check the size
+  size = size_;
+  total_size = size_;
+
+  // Boxon
+  position = 0;
+  internal_memory_node_index = 0;
+  internal_position_in_the_node = 0;
+  is_eof = false;
+}
+
+MemoryXFile::MemoryXFile(int buffer_format_size_)
+{
+  addIOption("buffer size", &buffer_size, 65536, "buffer size for writing");
+
+  buffer_format_size = buffer_format_size_;
+  buffer_format = (char *)allocator->alloc(buffer_format_size);
+
+  // The list...
+  memory = new(allocator) MemoryXFileList;
+
+  // The size...
+  size = 0;
+  total_size = 0;
+
+  // Le boxon...
+  position = 0;
+  internal_memory_node_index = 0;
+  internal_position_in_the_node = 0;
+  is_eof = false;
+}
+
+int MemoryXFile::read(void *ptr, int block_size, int n_blocks)
+{
+  // Check eof
+  if(position == size)
+  {
+    is_eof = true;
+    return 0;
+  }
+
+  // Check what to read
+  int size_to_read = block_size*n_blocks;
+  if((size-position) < size_to_read)
+  {
+    // On va tomber sur la fin du fichier.
+    is_eof = true;
+    size_to_read = size-position;
+  }
+
+  if(!size_to_read)
+    return 0;
+
+  // Read it
+  int size_read = size_to_read;
+  char *w_ptr = (char *)ptr;
+  char *r_ptr = (char *)memory->nodes[internal_memory_node_index]->mem;
+  while(size_to_read--)
+  {
+    if(internal_position_in_the_node == memory->nodes[internal_memory_node_index]->size)
+    {
+      internal_position_in_the_node = 0;
+      r_ptr = (char *)memory->nodes[++internal_memory_node_index]->mem;
+    }
+    *w_ptr++ = r_ptr[internal_position_in_the_node++];
+  }
+
+  // Tchao boy
+  position += size_read;
+  return(size_read);
+}
+
+int MemoryXFile::write(void *ptr, int block_size, int n_blocks)
+{
+  int size_to_write = block_size*n_blocks;
+  if(!size_to_write)
+    return 0;
+
+  char *r_ptr = (char *)ptr;
+
+  // If there is still some space...
+  if((total_size-position) > 0)
+  {
+    int size_to_write_now;
+    if(size_to_write < (total_size-position))
+      size_to_write_now = size_to_write;
+    else
+      size_to_write_now = total_size-position;
+
+    size_to_write -= size_to_write_now;
+    
+    char *w_ptr = (char *)memory->nodes[internal_memory_node_index]->mem;
+    while(size_to_write_now--)
+    {
+      if(internal_position_in_the_node == memory->nodes[internal_memory_node_index]->size)
+      {
+        internal_position_in_the_node = 0;
+        w_ptr = (char *)memory->nodes[++internal_memory_node_index]->mem;
+      }
+      w_ptr[internal_position_in_the_node++] = *r_ptr++;
+    }
+  }
+
+  // Still something to write ?
+  if(size_to_write)
+  {
+    int new_block_size = (size_to_write < buffer_size ? buffer_size : size_to_write);
+    MemoryXFileNode *node_ = (MemoryXFileNode *)memory->allocator->alloc(sizeof(MemoryXFileNode));
+    node_->size = new_block_size;
+    node_->mem = memory->allocator->alloc(new_block_size);
+    memory->addNode(node_);
+    total_size += new_block_size;
+    internal_memory_node_index = memory->n_nodes-1;
+    memcpy(memory->nodes[internal_memory_node_index]->mem, r_ptr, size_to_write);
+    internal_position_in_the_node = size_to_write;
+  }
+
+  // Tchao girl
+  position += block_size*n_blocks;
+
+  // Check si on depasse...
+  if(position > size)
+    size = position;
+  return(block_size*n_blocks);
+}
+
+int MemoryXFile::eof()
+{
+  return is_eof;
+}
+
+int MemoryXFile::flush()
+{
+  return 0;
+}
+
+void MemoryXFile::rewind()
+{
+  seek(0L, SEEK_SET);
+}
+
+int MemoryXFile::printf(const char *format, ...)
+{
+  va_list args;
+  va_start(args, format);
+  int res = vsprintf(petit_message_pour_melanie, format, args);
+  va_end(args);
+
+  write(petit_message_pour_melanie, 1, strlen(petit_message_pour_melanie));  
+  return res;
+}
+
+int MemoryXFile::scanf(const char *format, void *ptr)
+{
+  // DEBUG: ne sette pas le eof si on tombe sur la fin du fichier en lisant.
+  // A CORRIGER!
+  // DEBUG: correction faite le 19/05/2004
+  // DEBUG: n_lus recupere par %n, ce qui n'est pas conseille. arg.
+
+  // Check eof
+  if(position == size)
+  {
+    is_eof = true;
+    return 0;
+  }
+
+  concat();
+
+  strcpy(buffer_format, format);
+  strcat(buffer_format, "%n");
+  int n_lus;
+  int res = sscanf(((char *)memory->nodes[0]->mem)+position, buffer_format, ptr, &n_lus);
+
+  if(res == EOF)
+  {
+    position = size;
+    internal_position_in_the_node = size;
+  }
+  else
+  {
+    position += n_lus;
+    internal_position_in_the_node += n_lus;
+  }
+
+  if(position == size)
+    is_eof = true;
+
+  if(position > size)
+    error("MemoryXFile: fatal read error, you have a bug in your code!");
+
+  return res;
+}
+
+void MemoryXFile::concat()
+{
+  int the_size = size;
+  if(!the_size)
+    return;
+
+  if(memory->n_nodes < 1)
+    return;
+
+  if(memory->n_nodes == 1)
+  {
+    if(size > 0)
+    {
+      if(((char *)memory->nodes[0]->mem)[size-1] == '\0')
+        return;
+    }
+  }
+
+  char *big_buffer = (char *)Allocator::sysAlloc(the_size+1);
+  big_buffer[the_size] = '\0';
+
+  char *dest = big_buffer;
+  for(int i = 0; i < memory->n_nodes; i++)
+  {
+    int size_ = memory->nodes[i]->size;
+    if(size_ < the_size)
+    {
+      memcpy(dest, memory->nodes[i]->mem, size_);
+      the_size -= size_;
+      dest += size_;      
+    }
+    else
+    {
+      memcpy(dest, memory->nodes[i]->mem, the_size);
+      break;
+    }
+  }
+
+  // Scrappe the list
+  allocator->free(memory);
+
+  // Copy the list, but not inside
+  memory = new(allocator) MemoryXFileList;
+
+  MemoryXFileNode *node_ = (MemoryXFileNode *)memory->allocator->alloc(sizeof(MemoryXFileNode));
+  node_->size = size+1;
+  node_->mem = big_buffer;
+  memory->addNode(node_);
+  memory->allocator->retain(big_buffer);
+
+  // Check the size
+  total_size = size+1;
+
+  // Boxon
+  internal_memory_node_index = 0;
+  internal_position_in_the_node = position;
+}
+
+long MemoryXFile::tell()
+{
+  return((long)position);
+}
+
+int MemoryXFile::seek(long offset, int whence)
+{
+  int new_pos = 0;
+  switch(whence)
+  {
+    case SEEK_SET:
+      new_pos = (int)offset;
+      break;
+    case SEEK_CUR:
+      new_pos = position + (int)offset;
+      break;
+    case SEEK_END:
+      new_pos = size - (int)offset;
+      break;
+  }
+
+  if( (new_pos > size) || (new_pos < 0) )
+    return -1;
+
+  int new_pos_ = new_pos;
+  int internal_memory_node_index_ = 0;
+  while(new_pos_ >= memory->nodes[internal_memory_node_index_]->size)
+    new_pos_ -= memory->nodes[internal_memory_node_index_]->size;
+
+  // Boxon
+  position = new_pos;
+  internal_memory_node_index = internal_memory_node_index_;
+  internal_position_in_the_node = new_pos_;
+  is_eof = false; // Efface le flag de fin.
+
+  return 0;
+}
+
+char *MemoryXFile::gets(char *dest, int size_)
+{
+  // Check eof
+  if(position == size)
+  {    
+    is_eof = true;
+    return NULL;
+  }
+
+  // Check what to read
+  // Faire gaffe au '\0' en plus a mettre a la fin...
+  int size_to_read = size_-1;
+  if((size-position) < size_to_read)
+  {
+    size_to_read = size-position;
+    // On *risque* de tomber sur la fin du fichier.
+    is_eof = true;
+  }
+
+  if(!size_to_read)
+    return NULL;
+
+  // Read it
+  int size_read = 0;
+  char *w_ptr = dest;
+  char *r_ptr = (char *)memory->nodes[internal_memory_node_index]->mem;
+  while(size_to_read--)
+  {
+    if(internal_position_in_the_node == memory->nodes[internal_memory_node_index]->size)
+    {
+      internal_position_in_the_node = 0;
+      r_ptr = (char *)memory->nodes[++internal_memory_node_index]->mem;
+    }
+
+    char z = r_ptr[internal_position_in_the_node++];
+    size_read++;
+    *w_ptr++ = z;
+
+    if(z == '\n')
+    {
+      // On n'est pas tombe sur la fin du fichier.
+      is_eof = false;
+      break;
+    }
+  }
+
+  *w_ptr++ = '\0';
+
+  // Ye Ye Ye
+  position += size_read;
+
+  return dest;
+}
+
+MemoryXFile::~MemoryXFile()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MemoryXFile.h work/main.d/Torch-3/core/MemoryXFile.h
--- tmp/Torch-3/core/MemoryXFile.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MemoryXFile.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,123 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MEMORY_X_FILE_INC
+#define MEMORY_X_FILE_INC
+
+#include "XFile.h"
+#include "List.h"
+
+namespace Torch {
+
+struct MemoryXFileNode
+{
+    void *mem;
+    int size;
+};
+
+DEFINE_NEW_LIST(MemoryXFileList, MemoryXFileNode);
+
+/** A file in the memory.
+    Note that the MemoryXFile is a read-write file!
+    When writing, data is buffered (to avoid reallocating blocks of small sizes!).
+
+    Options:
+    \begin{tabular}{lcll}
+      "buffer size"  &  int  &  buffer size for writing & [65536]
+    \end{tabular}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class MemoryXFile : public XFile
+{
+  private:
+    static char petit_message_pour_melanie[10000];
+    bool is_eof;
+
+  public:
+
+    /// The memory
+    MemoryXFileList *memory;
+
+    /// The position in the memory
+    int position;
+
+    /// The size of the memory
+    int size;
+
+    /// The total size of the memory, including allocated buffer.
+    int total_size;
+
+    /// Minimal number of bytes that will be allocated when writing...
+    int buffer_size;
+
+    // Internal
+    int internal_memory_node_index;
+    int internal_position_in_the_node;
+    char *buffer_format;
+    int buffer_format_size;
+
+    /// Create a read-write file from nothing.
+    MemoryXFile(int buffer_format_size_=256);
+
+    /** Give a MemoryXFileList for the memory. A new list is created, but the memory
+        in the nodes are not copied.
+        If the #size# that you want to be readable is \emph{less} than the
+        sum of the #n# in the field of the #MemoryXFileList#, you can provide it in #size_# */
+    MemoryXFile(MemoryXFileList *memory_, int size_=-1, int buffer_format_size_=256);
+
+    /// Give a pointer for the memory. (No copy is done!)
+    MemoryXFile(void *memory_, int size_, int buffer_format_size_=256);
+
+    /** Concat all the memory in one node. Add a null character at the end.
+        This null character is useful for #sscanf# in the #scanf# method. */
+    void concat();
+
+    virtual int read(void *ptr, int block_size, int n_blocks);
+    virtual int write(void *ptr, int block_size, int n_blocks);
+    virtual int eof();
+    virtual int flush();
+    virtual int seek(long offset, int whence);
+    virtual long tell();
+    virtual void rewind();
+    virtual int printf(const char *format, ...);
+
+    /** Warning: this method call the concat function,
+        and therefore could take time if you do intensive read/write. */
+    virtual int scanf(const char *format, void *ptr);
+    virtual char *gets(char *dest, int size_);
+
+    //-----
+
+    virtual ~MemoryXFile();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MSEMeasurer.cc work/main.d/Torch-3/core/MSEMeasurer.cc
--- tmp/Torch-3/core/MSEMeasurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MSEMeasurer.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,86 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "MSEMeasurer.h"
+
+namespace Torch {
+
+MSEMeasurer::MSEMeasurer(Sequence *inputs_, DataSet *data_, XFile *file_) : Measurer(data_, file_)
+{
+  inputs = inputs_;
+  internal_error = 0;
+  addBOption("average examples", &average_examples, true, "divided by the number of examples");
+  addBOption("average frame size", &average_frame_size, true, "divided by the frame size");
+  addBOption("average frames", &average_frames, true, "divided by the number of frames");
+}
+
+void MSEMeasurer::measureExample()
+{
+  Sequence *desired = data->targets;
+
+  real sum = 0;
+  for(int i = 0; i < inputs->n_frames; i++)
+  {
+    real *src_1 = desired->frames[i];
+    real *src_2 = inputs->frames[i];
+    for(int j = 0; j < inputs->frame_size; j++)
+    {
+      real z = src_2[j] - src_1[j];
+      sum += z*z;
+    }
+  }
+  if(average_frames)
+    sum /= inputs->n_frames;
+  if(average_frame_size)
+    sum /= inputs->frame_size;
+  internal_error += sum;
+}
+
+void MSEMeasurer::measureIteration()
+{
+  if(average_examples)
+    internal_error /= data->n_examples;
+
+  if(binary_mode)
+    file->write(&internal_error, sizeof(real), 1);
+  else
+    file->printf("%g\n", internal_error);
+  file->flush();
+  reset();
+}
+
+void MSEMeasurer::reset()
+{
+  internal_error = 0;
+}
+
+MSEMeasurer::~MSEMeasurer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MSEMeasurer.h work/main.d/Torch-3/core/MSEMeasurer.h
--- tmp/Torch-3/core/MSEMeasurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MSEMeasurer.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,78 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MSE_MEASURER_INC
+#define MSE_MEASURER_INC
+
+#include "Measurer.h"
+
+namespace Torch {
+
+/** Mean Squared Error measurer.
+    Compute the MSE between its inputs,
+    and the targets of its associated #DataSet#.
+
+  addBOption("average examples", &average_examples, true, "divided by the number of examples");
+  addBOption("average frame size", &average_frame_size, true, "divided by the frame size");
+  addBOption("average frames", &average_frames, true, "divided by the number of frames");
+
+    Options:
+    \begin{tabular}{lcll}
+      "average examples"    &  bool  &  divided by the number of examples  &  [true]\\
+      "average frame size"  &  bool  &  divided by the frame size          &  [true]\\
+      "average frames"      &  bool  &  divided by the number of frames    &  [true]
+    \end{tabular}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class MSEMeasurer : public Measurer
+{
+  public:
+    bool average_examples;
+    bool average_frame_size;
+    bool average_frames;
+    real internal_error;
+    Sequence *inputs;
+
+    //-----
+
+    ///
+    MSEMeasurer(Sequence *inputs_, DataSet *data_, XFile *file_);
+
+    //-----
+
+    virtual void reset();
+    virtual void measureExample();
+    virtual void measureIteration();
+
+    virtual ~MSEMeasurer();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MultiClassFormat.cc work/main.d/Torch-3/core/MultiClassFormat.cc
--- tmp/Torch-3/core/MultiClassFormat.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MultiClassFormat.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,190 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "MultiClassFormat.h"
+
+namespace Torch {
+
+extern "C" int multiClassTriMelanie(const void *a, const void *b)
+{
+  real *ar = (real *)a;
+  real *br = (real *)b;
+
+  if(*ar < *br)
+    return -1;
+  else
+    return  1;
+}
+
+MultiClassFormat::MultiClassFormat(DataSet *data)
+{
+  tabclasses = NULL;
+
+  if(data->n_targets != 1)
+    warning("MultiClassFormat: the data has %d ouputs", data->n_targets);
+  
+  int n_set = 0;
+  for(int i = 0; i < data->n_examples; i++)
+  {
+    data->setExample(i);
+    
+    bool flag = false;
+    for(int k = 0; k < n_set; k++)
+    {
+      if(data->targets->frames[0][0] == tabclasses[k])
+        flag = true;
+    }
+
+    if(!flag)
+    {
+      tabclasses = (real *)allocator->realloc(tabclasses, sizeof(real)*(n_set+1));
+      tabclasses[n_set++] = data->targets->frames[0][0];
+    }
+  }
+
+  switch(n_set)
+  {
+    case 0:
+      error("MultiClassFormat: you have no examples");
+      break;
+    case 1:
+      warning("MultiClassFormat: you have only one class [%g]", tabclasses[0]);
+      break;
+    default:
+      message("MultiClassFormat: %d classes detected", n_set);
+      break;
+  }
+
+  // He He He...
+  n_classes = n_set;
+  qsort(tabclasses, n_classes, sizeof(real), multiClassTriMelanie);
+  class_labels = (real **)allocator->alloc(sizeof(real *)*n_classes);
+  for(int i = 0; i < n_classes; i++)
+    class_labels[i] = tabclasses+i;
+}
+
+MultiClassFormat::MultiClassFormat(int n_classes_, real *class_labels_)
+{
+  n_classes = n_classes_;
+  tabclasses = (real *)allocator->alloc(sizeof(real)*n_classes);
+
+  if(class_labels_)
+  {
+    for(int i = 0; i < n_classes; i++)
+      tabclasses[i] = class_labels_[i];
+  }
+  else
+  {
+    for(int i = 0; i < n_classes; i++)
+      tabclasses[i] = (real)i;
+  }
+
+  class_labels = (real **)allocator->alloc(sizeof(real *)*n_classes);
+  for(int i = 0; i < n_classes; i++)
+    class_labels[i] = tabclasses+i;
+}
+
+int MultiClassFormat::getOutputSize()
+{
+  return 1;
+}
+
+void MultiClassFormat::fromOneHot(real *outputs, real *one_hot_outputs)
+{
+  real max = -INF;
+  int index = -1;
+  for(int i = 0; i < n_classes; i++)
+  {
+    if(one_hot_outputs[i] > max)
+    {
+      max = one_hot_outputs[i];
+      index = i;
+    }
+  }
+  outputs[0] = (real)index;
+}
+
+void MultiClassFormat::toOneHot(real *outputs, real *one_hot_outputs)
+{
+  real out = outputs[0];
+  // heuristic: find the one or two labels that are closer to "out" and
+  // attribute them the difference between out and their label. put 0 for
+  // all the other values
+
+  // first initialize one_hot_outputs with all zeros
+  for(int i = 0; i < n_classes; i++)
+    one_hot_outputs[i] = 0.;
+
+  // then there are 3 different cases
+  if(out > n_classes-1)
+  {
+    one_hot_outputs[n_classes-1] = fabs(out - tabclasses[n_classes-1]);
+  }
+  else if(out < 0)
+  {
+    one_hot_outputs[0] = fabs(out - tabclasses[0]);
+  }
+  else
+  {
+    int before = (int)floor(out);
+    int after = (int)ceil(out);
+    // the scores are reversed so the max score is given to the neirest
+    real diff_before = after - out;
+    real diff_after = out - before;
+    if (before == after)
+      diff_before = diff_after = 1.;
+    
+    one_hot_outputs[before] = diff_before;
+    one_hot_outputs[after] = diff_after;
+  }
+}
+
+int MultiClassFormat::getClass(real *vector)
+{
+  real out = vector[0];
+  real dist = fabs(out - tabclasses[0]);
+  int index = 0;
+
+  for(int i = 1; i < n_classes; i++)
+  {
+    real z = fabs(out - tabclasses[i]);
+    if(z < dist)
+    {
+      index = i;
+      dist = z;
+    }
+  }
+  
+  return(index);
+}
+
+MultiClassFormat::~MultiClassFormat()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/MultiClassFormat.h work/main.d/Torch-3/core/MultiClassFormat.h
--- tmp/Torch-3/core/MultiClassFormat.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/MultiClassFormat.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,66 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MULTI_CLASS_FORMAT_INC
+#define MULTI_CLASS_FORMAT_INC
+
+#include "ClassFormat.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+/** Define the multi class encoding format.
+    Each class is coded by a single number.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class MultiClassFormat : public ClassFormat
+{
+  public:
+
+    /// Array of class labels.
+    real *tabclasses;
+
+    /// Autodetect classes.
+    MultiClassFormat(DataSet *data);
+
+    /// By default (if #class_labels_# is not specified), class labels are 0, 1, ...
+    MultiClassFormat(int n_classes_, real *class_labels_=NULL);
+
+    virtual int getClass(real *vector);
+    virtual int getOutputSize();
+    virtual void fromOneHot(real *outputs, real *one_hot_outputs);
+    virtual void toOneHot(real *outputs, real *one_hot_outputs);
+
+    virtual ~MultiClassFormat();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/NullXFile.cc work/main.d/Torch-3/core/NullXFile.cc
--- tmp/Torch-3/core/NullXFile.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/NullXFile.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,90 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "NullXFile.h"
+
+namespace Torch {
+
+NullXFile::NullXFile()
+{
+}
+
+int NullXFile::read(void *ptr, int block_size, int n_blocks)
+{
+  return 0;
+}
+
+int NullXFile::write(void *ptr, int block_size, int n_blocks)
+{
+  return n_blocks;
+}
+
+int NullXFile::eof()
+{
+  return 0;
+}
+
+int NullXFile::flush()
+{
+  return 0;
+}
+
+int NullXFile::seek(long offset, int whence)
+{
+  return 0;
+}
+
+long NullXFile::tell()
+{
+  return 0L;
+}
+
+void NullXFile::rewind()
+{
+}
+
+int NullXFile::printf(const char *format, ...)
+{
+  return 0;
+}
+
+int NullXFile::scanf(const char *format, void *ptr)
+{
+  return 0;
+}
+
+char *NullXFile::gets(char *dest, int size_)
+{
+  return NULL;
+}
+
+NullXFile::~NullXFile()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/NullXFile.h work/main.d/Torch-3/core/NullXFile.h
--- tmp/Torch-3/core/NullXFile.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/NullXFile.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,66 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef NULL_X_FILE_INC
+#define NULL_X_FILE_INC
+
+#include "XFile.h"
+
+namespace Torch {
+
+/** NullXFile. A XFile which do nothing!
+    Equivalent to the "/dev/null" file on UNIX systems.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class NullXFile : public XFile
+{
+  public:
+
+    ///
+    NullXFile();
+    virtual int read(void *ptr, int block_size, int n_blocks);
+    virtual int write(void *ptr, int block_size, int n_blocks);
+    virtual int eof();
+    virtual int flush();
+    virtual int seek(long offset, int whence);
+    virtual long tell();
+    virtual void rewind();
+    virtual int printf(const char *format, ...);
+    virtual int scanf(const char *format, void *ptr);
+    virtual char *gets(char *dest, int size_);
+
+    //-----
+
+    virtual ~NullXFile();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Object.cc work/main.d/Torch-3/core/Object.cc
--- tmp/Torch-3/core/Object.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Object.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,173 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Object.h"
+#include "DiskXFile.h"
+#include "XFile.h"
+
+namespace Torch {
+
+Object::Object()
+{
+  n_options = 0;
+  options = NULL;
+  allocator = new Allocator;
+}
+
+void Object::addOption(const char *name, int size, void *ptr, const char *help)
+{
+  options = (Option *)allocator->realloc((void *)options, (n_options+1)*sizeof(Option));
+
+  Option *optr = options+n_options;
+
+  optr->name = (char *)allocator->alloc(strlen(name)+1);
+  optr->help = (char *)allocator->alloc(strlen(help)+1);
+  strcpy(optr->name, name);
+  strcpy(optr->help, help);
+  optr->size = size;
+  optr->ptr = ptr;
+  n_options++;
+}
+
+void Object::addIOption(const char *name, int *ptr,  int init_value,  const char *help)
+{
+  *ptr = init_value;
+  addOption(name, sizeof(int), ptr, help);
+}
+
+void Object::addROption(const char *name, real *ptr, real init_value, const char *help)
+{
+  *ptr = init_value;
+  addOption(name, sizeof(real), ptr, help);
+}
+
+void Object::addBOption(const char *name, bool *ptr, bool init_value, const char *help)
+{
+  *ptr = init_value;
+  addOption(name, sizeof(bool), ptr, help);
+}
+
+void Object::addOOption(const char *name, Object **ptr, Object *init_value, const char *help)
+{
+  *ptr = init_value;
+  addOption(name, sizeof(Object *), ptr, help);  
+}
+
+void Object::setOption(const char *name, void *ptr)
+{
+  Option *optr = options;
+
+  bool flag = false;
+  for(int i = 0; i < n_options; i++, optr++)
+  {
+    if( !strcmp(optr->name, name) )
+    {
+      flag = true;
+      break;
+    }
+  }
+
+  if(!flag)
+    error("Object: option doesn't exist: %s", name);
+
+  char *odata = (char *)optr->ptr;
+  char *odatao = (char *)ptr;
+
+  for(int i = 0; i < optr->size; i++)
+  {
+    *odata = *odatao;
+    odata++;
+    odatao++;
+  }
+}
+
+void Object::setIOption(const char *name, int option)
+{
+  setOption(name, (void *)&option);
+}
+
+void Object::setROption(const char *name, real option)
+{
+  setOption(name, (void *)&option);
+}
+
+void Object::setBOption(const char *name, bool option)
+{
+  setOption(name, (void *)&option);
+}
+
+void Object::setOOption(const char *name, Object *option)
+{
+  setOption(name, (void *)&option);
+}
+
+void Object::load(const char *filename)
+{
+  DiskXFile file(filename, "r");
+  loadXFile(&file);
+}
+
+void Object::save(const char *filename)
+{
+  DiskXFile file(filename, "w");
+  saveXFile(&file);
+}
+
+void Object::loadXFile(XFile *file)
+{
+}
+
+void Object::saveXFile(XFile *file)
+{
+}
+
+void* Object::operator new(size_t size, Allocator *allocator_)
+{
+  if(allocator_)
+    return(allocator_->alloc(size, 1));
+  else
+    return(Allocator::sysAlloc(size));
+}
+
+void* Object::operator new(size_t size, Allocator *allocator_, void *ptr_)
+{
+  allocator_->retain(ptr_, 2);
+  return ptr_;
+}
+
+void Object::operator delete(void *ptr)
+{
+  free(ptr);
+}
+
+Object::~Object()
+{
+  delete allocator;
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Object.h work/main.d/Torch-3/core/Object.h
--- tmp/Torch-3/core/Object.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Object.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,157 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef OBJECT_INC
+#define OBJECT_INC
+
+#include "general.h"
+#include "Allocator.h"
+
+namespace Torch {
+
+//-----
+
+class XFile;
+
+typedef struct Option_
+{
+    char *name;
+    char *help;
+    int size;
+    void *ptr;
+} Option;
+
+//-----
+
+/** Almost all classes in Torch should be a sub-class of this class.
+    It provides two interesting things: first a useful interface to
+    manage option, and second the "allocator trick".
+    
+    Indeed, in Torch, a class which allocate memory should desallocate
+    this memory when it's destroyed. The idea is the following: in the
+    constructor of Object, an Allocator object is created. You can use
+    it in your subclasses to allocate memory. This memory will be destroyed
+    when the Object is destroyed.
+
+    "new" operator have been defined to be used with Allocator.
+
+    @see Allocator
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Object
+{
+  public:
+    int n_options;
+    Option *options;
+
+    /// Allocator associated to the Object.
+    Allocator *allocator;
+
+    ///
+    Object();
+    
+    //-----
+
+    /** Add the option #name#.
+        This one has a pointer on #ptr# and has the size #size#.
+        You can provide an help in #help#.
+        (Note that if #help# is empty, its an empty string and not NULL).
+        If the option can be changed at any time, you can set
+        #is_allowed_after_init# to #true#.
+    */
+    void addOption(const char *name, int size, void *ptr, const char *help="");
+
+    /** Several wrappers of #addOption()# for
+        Int, Real and Bool options.
+        Be carefull: there is no type checking.
+    */
+    void addIOption(const char *name, int *ptr,  int init_value,  const char *help="");
+
+    ///
+    void addROption(const char *name, real *ptr, real init_value, const char *help="");
+
+    ///
+    void addBOption(const char *name, bool *ptr, bool init_value, const char *help="");
+
+    ///
+    void addOOption(const char *name, Object **ptr, Object *init_value, const char *help="");
+
+    /// Set the option #name# to the value contained at #ptr#.
+    void setOption(const char *name, void *ptr);
+
+    /** Several wrappers of #setOption()# for
+        Int, Real and Bool options.
+        Be carefull: there is no type checking.
+    */
+    void setIOption(const char *name, int option);
+
+    ///
+    void setROption(const char *name, real option);
+
+    ///
+    void setBOption(const char *name, bool option);
+
+    ///
+    void setOOption(const char *name, Object *option);
+
+    /// Load the object from a file pointer (\emph{not the options})
+    virtual void loadXFile(XFile *file);
+
+    /// Save the object to a file pointer (\emph{not the options})
+    virtual void saveXFile(XFile *file);
+
+    /// Load the machine from a file name (\emph{not the options})
+    void load(const char *filename);
+
+    /// Save the machine to a file name (\emph{not the options})
+    void save(const char *filename);
+
+    /** Allocate the object using #allocator_#. The object will be
+        destroyed and freed when the allocator will be destroyed.
+        If no allocator is provided, the new will be similar than
+        the standard new.
+    */
+    void* operator new(size_t size, Allocator *allocator_=NULL);
+
+    /** Allocate the object using the memory given by #ptr_#.
+        The object will be destroyed (but not freed!) when the
+        allocator will be destroyed.
+    */
+    void* operator new(size_t size, Allocator *allocator_, void *ptr_);
+
+    /// Delete an object.
+    void  operator delete(void *ptr);
+
+    //-----
+
+    virtual ~Object();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/OneHotClassFormat.cc work/main.d/Torch-3/core/OneHotClassFormat.cc
--- tmp/Torch-3/core/OneHotClassFormat.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/OneHotClassFormat.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,100 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "OneHotClassFormat.h"
+
+namespace Torch {
+
+OneHotClassFormat::OneHotClassFormat(DataSet *data)
+{
+  n_classes = data->n_targets;
+  class_labels_buffer = (real *)allocator->alloc(sizeof(real)*n_classes*n_classes);
+  class_labels = (real **)allocator->alloc(sizeof(real *)*n_classes);
+  for(int i = 0; i < n_classes; i++)
+  {
+    class_labels[i] = class_labels_buffer+i*n_classes;
+    for(int j = 0; j < n_classes; j++)
+      class_labels[i][j] = 0.;
+    class_labels[i][i] = 1.;
+  }
+  message("OneHotClassFormat: %d classes detected", n_classes);
+}
+
+OneHotClassFormat::OneHotClassFormat(int n_targets)
+{
+  n_classes = n_targets;
+  class_labels_buffer = (real *)allocator->alloc(sizeof(real)*n_classes*n_classes);
+  class_labels = (real **)allocator->alloc(sizeof(real *)*n_classes);
+  for(int i = 0; i < n_classes; i++)
+  {
+    class_labels[i] = class_labels_buffer+i*n_classes;
+    for(int j = 0; j < n_classes; j++)
+      class_labels[i][j] = 0.;
+    class_labels[i][i] = 1.;
+  }
+  message("OneHotClassFormat: %d classes detected", n_classes);
+}
+
+int OneHotClassFormat::getOutputSize()
+{
+  return n_classes;
+}
+
+void OneHotClassFormat::fromOneHot(real *outputs, real *one_hot_outputs)
+{
+  for(int i = 0; i < n_classes; i++)
+    outputs[i] = one_hot_outputs[i];
+}
+
+void OneHotClassFormat::toOneHot(real *outputs, real *one_hot_outputs)
+{
+  for(int i = 0; i < n_classes; i++)
+    one_hot_outputs[i] = outputs[i];
+}
+
+int OneHotClassFormat::getClass(real *vector)
+{
+  real z = vector[0];
+  int index = 0;
+  for(int i = 1; i < n_classes; i++)
+  {
+    if(vector[i] > z)
+    {
+      index = i;
+      z  = vector[i];
+    }
+  }
+  return(index);
+}
+
+OneHotClassFormat::~OneHotClassFormat()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/OneHotClassFormat.h work/main.d/Torch-3/core/OneHotClassFormat.h
--- tmp/Torch-3/core/OneHotClassFormat.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/OneHotClassFormat.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,64 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef ONE_HOT_CLASS_FORMAT_INC
+#define ONE_HOT_CLASS_FORMAT_INC
+
+#include "ClassFormat.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+/** Define the one hot class encoding format.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class OneHotClassFormat : public ClassFormat
+{
+  public:
+    real *class_labels_buffer;
+
+    /** Autodetect number of classes.
+        (Equal to the frame size of the targets).
+    */
+    OneHotClassFormat(DataSet *data);
+
+    /// Specify the number of targets.
+    OneHotClassFormat(int n_targets);
+
+    virtual int getClass(real *target);
+    virtual int getOutputSize();
+    virtual void fromOneHot(real *outputs, real *one_hot_outputs);
+    virtual void toOneHot(real *outputs, real *one_hot_outputs);
+
+    virtual ~OneHotClassFormat();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/OutputMeasurer.cc work/main.d/Torch-3/core/OutputMeasurer.cc
--- tmp/Torch-3/core/OutputMeasurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/OutputMeasurer.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,87 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "OutputMeasurer.h"
+
+namespace Torch {
+
+OutputMeasurer::OutputMeasurer(DataSet *data_, XFile *file_) : Measurer(data_, file_)
+{
+  sequences = new(allocator) SequenceList;
+  total_frame_size = 0;
+}
+
+void OutputMeasurer::addSequence(Sequence *sequence)
+{
+  sequences->addNode(sequence);
+  total_frame_size += sequence->frame_size;
+}
+
+void OutputMeasurer::measureExample()
+{
+  if(sequences->n_nodes == 0)
+    return;
+  
+  int n_frames = sequences->nodes[0]->n_frames;
+  for(int i = 0; i < sequences->n_nodes; i++)
+  {
+    if(sequences->nodes[i]->n_frames != n_frames)
+      error("OutputMeasurer: sorry, sequences don't have the same number of frames");
+  }
+
+  if(binary_mode)
+  {
+    file->write(&n_frames, sizeof(int), 1);
+    file->write(&total_frame_size, sizeof(int), 1);
+    for(int i = 0; i < n_frames; i++)
+    {
+      for(int j = 0; j < sequences->n_nodes; j++)
+        file->write(sequences->nodes[j]->frames[i], sizeof(real), sequences->nodes[j]->frame_size);
+    }
+  }
+  else
+  {
+    file->printf("%d %d\n", n_frames, total_frame_size);
+    for(int i = 0; i < n_frames; i++)
+    {
+      for(int j = 0; j < sequences->n_nodes; j++)
+      {
+        real *src = sequences->nodes[j]->frames[i];
+        for(int k = 0; k < sequences->nodes[j]->frame_size; k++)
+          file->printf("%g ", src[k]);
+      }
+      file->printf("\n");
+    }
+  }
+}
+
+OutputMeasurer::~OutputMeasurer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/OutputMeasurer.h work/main.d/Torch-3/core/OutputMeasurer.h
--- tmp/Torch-3/core/OutputMeasurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/OutputMeasurer.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,69 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef OUTPUT_MEASURER_INC
+#define OUTPUT_MEASURER_INC
+
+#include "Measurer.h"
+
+namespace Torch {
+
+/** Compute the outputification error (in %)
+    of the #inputs# with respect to the #targets# of #data#.
+
+    The format of the output is given with a #OutputFormat#.
+    It can print the confusion matrix if specified.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class OutputMeasurer : public Measurer
+{
+  public:
+    /// Sequences to output.
+    SequenceList *sequences;
+    
+    /// Sum of frame size of all sequences
+    int total_frame_size;
+
+    //-----
+
+    ///
+    OutputMeasurer(DataSet *data_, XFile *file_);
+
+    /// Adds a sequence which will be outputed.
+    void addSequence(Sequence *sequence);
+
+    //-----
+
+    virtual void measureExample();
+    virtual ~OutputMeasurer();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Parameters.cc work/main.d/Torch-3/core/Parameters.cc
--- tmp/Torch-3/core/Parameters.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Parameters.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,158 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Parameters.h"
+#include "XFile.h"
+
+namespace Torch {
+
+Parameters::Parameters()
+{
+  // General
+  data = NULL;
+  n_data = 0;
+  size = NULL;
+  n_params = 0;
+}
+
+Parameters::Parameters(int n_params_)
+{
+  if(n_params_ <= 0)
+  {
+    data = NULL;
+    n_data = 0;
+    size = NULL;
+    n_params = 0;
+    return;
+  }
+
+  // General
+  data = (real **)allocator->alloc(sizeof(real *));
+  data[0] = (real *)allocator->alloc(sizeof(real)*n_params_);
+  n_data = 1;
+  size = (int *)allocator->alloc(sizeof(int));
+  size[0] = n_params_;
+  n_params = n_params_;
+}
+
+void Parameters::addParameters(real *params_, int n_params_, bool do_copy)
+{
+  if(!params_)
+    return;
+
+  data = (real **)allocator->realloc(data, sizeof(real *)*(n_data+1));
+  size = (int *)allocator->realloc(size, sizeof(int)*(n_data+1));
+  size[n_data] = n_params_;
+  if(do_copy)
+  {
+    data[n_data] = (real *)allocator->alloc(sizeof(real)*n_params_);
+    real *dest_ = data[n_data];
+    for(int i = 0; i < n_params_; i++)
+      dest_[i] = params_[i];
+  }
+  else
+    data[n_data] = params_;
+
+  n_data++;
+  n_params += n_params_;
+}
+
+void Parameters::add(Parameters *params_, bool do_copy)
+{
+  if(!params_)
+    return;
+
+  for(int i = 0; i < params_->n_data; i++)
+    this->addParameters(params_->data[i], params_->size[i], do_copy);
+}
+
+void Parameters::copy(Parameters *from)
+{
+  if(n_params == 0)
+    return;
+
+  int src_number = 0;
+  int src_index = 0;
+
+  int src_size = from->size[0];
+  real *src_ = from->data[0];
+  for(int i = 0; i < n_data; i++)
+  {
+    real *dest_ = data[i];
+    for(int j = 0; j < size[i]; j++)
+    {
+      if(src_index == src_size)
+      {
+        src_index = 0;
+        src_size = from->size[++src_number];
+        src_ = from->data[src_number];
+      }
+      dest_[j] = src_[src_index++];
+    }
+  }
+}
+
+void Parameters::copyFrom(real *vec)
+{
+  for(int i = 0; i < n_data; i++)
+  {
+    real *dest_ = data[i];
+    for(int j = 0; j < size[i]; j++)
+      dest_[j] = vec[j];
+    vec += size[i];
+  }
+}
+
+void Parameters::copyTo(real *vec)
+{
+  for(int i = 0; i < n_data; i++)
+  {
+    real *src_ = data[i];
+    for(int j = 0; j < size[i]; j++)
+      vec[j] = src_[j];
+    vec += size[i];
+  }
+}
+
+void Parameters::loadXFile(XFile *file)
+{
+  for(int i = 0; i < n_data; i++)
+    file->taggedRead(data[i], sizeof(real), size[i], "PARAMS");
+}
+
+void Parameters::saveXFile(XFile *file)
+{
+  for(int i = 0; i < n_data; i++)
+    file->taggedWrite(data[i], sizeof(real), size[i], "PARAMS");
+}
+
+Parameters::~Parameters()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Parameters.h work/main.d/Torch-3/core/Parameters.h
--- tmp/Torch-3/core/Parameters.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Parameters.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,103 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef PARAMETERS_INC
+#define PARAMETERS_INC
+
+#include "Object.h"
+
+namespace Torch {
+
+/** Parameters definition.
+    Parameters are a bench of real arrays.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Parameters : public Object
+{
+  public:
+    /** Array of pointers to array of parameters.
+        The size of this array is given by #n_data#.
+        The size of #data[i]# is given by #size[i]#
+    */
+    real **data;
+
+    /// Size of #data#
+    int n_data;
+
+    /// #size[i]# is the size of #data[i]#
+    int *size;
+
+    /// Total number of parameters
+    int n_params;
+    
+    /// No parameters ?
+    Parameters();
+
+    /// Create one entry in #data# with the given size.
+    Parameters(int n_params_);
+
+    /** Add an entry in #data#.
+        If #do_copy# is true, copy the parameters.
+        Else, just copy the pointer.
+    */
+    void addParameters(real *params, int n_params_, bool do_copy=false);
+    
+    /** Add all entries given by #params# in #data#.
+        If #do_copy# is true, copy the parameters, else just copy the pointers.
+     */
+    void add(Parameters *params, bool do_copy=false);
+
+    /** Copy the given parameters.
+        The given parameters don't need to have the same structure.
+        But it must have the same total length.
+    */
+    void copy(Parameters *from);
+
+    /** Copy a real vector in the parameters.
+        The parameters \emph{must} have the good size!
+    */
+    void copyFrom(real *vec);
+
+    /** Copy the full parameters in a real vector.
+        The parameters \emph{must} have the good size!
+    */
+    void copyTo(real *vec);
+
+    /// Save all the parameters.
+    virtual void saveXFile(XFile *file);
+
+    /// Load all the parameters.
+    virtual void loadXFile(XFile *file);
+
+    virtual ~Parameters();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/PipeXFile.cc work/main.d/Torch-3/core/PipeXFile.cc
--- tmp/Torch-3/core/PipeXFile.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/PipeXFile.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,44 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "PipeXFile.h"
+
+namespace Torch {
+
+PipeXFile::PipeXFile(const char *command, const char *open_flags)
+  : DiskXFile(popen(command, open_flags))
+{
+  is_opened = true;
+  its_a_pipe = true;
+}
+
+PipeXFile::~PipeXFile()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/PipeXFile.h work/main.d/Torch-3/core/PipeXFile.h
--- tmp/Torch-3/core/PipeXFile.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/PipeXFile.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,54 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef PIPE_X_FILE_INC
+#define PIPE_X_FILE_INC
+
+#include "DiskXFile.h"
+
+namespace Torch {
+
+/** A file in a pipe.
+    
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class PipeXFile : public DiskXFile
+{
+  public:
+
+    /// Execute command with the flags #open_flags#
+    PipeXFile(const char *command, const char *open_flags);
+
+    //-----
+
+    virtual ~PipeXFile();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/PreProcessing.cc work/main.d/Torch-3/core/PreProcessing.cc
--- tmp/Torch-3/core/PreProcessing.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/PreProcessing.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,46 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "PreProcessing.h"
+
+namespace Torch {
+
+// Que d'al ici.
+PreProcessing::PreProcessing()
+{
+}
+
+// Que d'al la.
+PreProcessing::~PreProcessing()
+{
+}
+
+// Oh yeah.
+IMPLEMENT_NEW_LIST(PreProcessingList, PreProcessing)
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/PreProcessing.h work/main.d/Torch-3/core/PreProcessing.h
--- tmp/Torch-3/core/PreProcessing.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/PreProcessing.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,62 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef PRE_PROCESSING_INC
+#define PRE_PROCESSING_INC
+
+#include "Sequence.h"
+
+namespace Torch {
+
+/** This class is able to do pre-processing on examples
+    in a #DataSet#. Pre-processing doesn't modify the
+    \emph{structure} of sequences, but only the \emph{contents}.
+
+    @see DataSet
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class PreProcessing : public Object
+{
+  public:
+    ///
+    PreProcessing(); 
+
+    /// Given an input sequence, do the pre-processing.
+    virtual void preProcessInputs(Sequence *inputs) = 0;
+
+    /// Given an target sequence, do the pre-processing.
+    virtual void preProcessTargets(Sequence *targets) = 0;
+
+    virtual ~PreProcessing();
+};
+
+DEFINE_NEW_LIST(PreProcessingList, PreProcessing);
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Random.cc work/main.d/Torch-3/core/Random.cc
--- tmp/Torch-3/core/Random.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Random.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,289 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Random.h"
+#include "Allocator.h"
+
+namespace Torch {
+
+// The initial seed.
+unsigned long Random::the_initial_seed;
+
+///// Code for the Mersenne Twister random generator....
+const int Random::n = 624;
+const int Random::m = 397;
+int Random::left = 1;
+int Random::initf = 0;
+unsigned long *Random::next;
+unsigned long Random::state[Random::n]; /* the array for the state vector  */
+////////////////////////////////////////////////////////
+
+
+/// For normal distribution
+real Random::normal_x;
+real Random::normal_y;
+real Random::normal_rho;
+bool Random::normal_is_valid = false;
+
+void Random::seed()
+{
+  time_t ltime;
+  struct tm *today;
+  time(&ltime);
+  today = localtime(&ltime);
+  manualSeed((unsigned long)today->tm_sec);
+}
+
+///////////// The next 4 methods are taken from http://www.math.keio.ac.jp/matumoto/emt.html
+///////////// Here is the copyright:
+///////////// Some minor modifications have been made to adapt to "my" C++...
+
+/*
+   A C-program for MT19937, with initialization improved 2002/2/10.
+   Coded by Takuji Nishimura and Makoto Matsumoto.
+   This is a faster version by taking Shawn Cokus's optimization,
+   Matthe Bellew's simplification, Isaku Wada's real version.
+
+   Before using, initialize the state by using init_genrand(seed)
+   or init_by_array(init_key, key_length).
+
+   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+     1. Redistributions of source code must retain the above copyright
+        notice, this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+     3. The names of its contributors may not be used to endorse or promote
+        products derived from this software without specific prior written
+        permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+   Any feedback is very welcome.
+   http://www.math.keio.ac.jp/matumoto/emt.html
+   email: matumoto@math.keio.ac.jp
+*/
+
+////////////////// Macros for the Mersenne Twister random generator...
+/* Period parameters */  
+//#define n 624
+//#define m 397
+#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
+#define UMASK 0x80000000UL /* most significant w-r bits */
+#define LMASK 0x7fffffffUL /* least significant r bits */
+#define MIXBITS(u,v) ( ((u) & UMASK) | ((v) & LMASK) )
+#define TWIST(u,v) ((MIXBITS(u,v) >> 1) ^ ((v)&1UL ? MATRIX_A : 0UL))
+/////////////////////////////////////////////////////////// That's it.
+
+void Random::manualSeed(unsigned long the_seed_)
+{
+  the_initial_seed = the_seed_;
+  state[0]= the_initial_seed & 0xffffffffUL;
+  for(int j = 1; j < n; j++)
+  {
+    state[j] = (1812433253UL * (state[j-1] ^ (state[j-1] >> 30)) + j); 
+    /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
+    /* In the previous versions, mSBs of the seed affect   */
+    /* only mSBs of the array state[].                        */
+    /* 2002/01/09 modified by makoto matsumoto             */
+    state[j] &= 0xffffffffUL;  /* for >32 bit machines */
+  }
+  left = 1;
+  initf = 1;
+}
+
+unsigned long Random::getInitialSeed()
+{
+  if(initf == 0)
+  {
+    warning("Random: initializing the random generator");
+    seed();
+  }
+
+  return the_initial_seed;
+}
+
+void Random::nextState()
+{
+  unsigned long *p=state;
+  
+  /* if init_genrand() has not been called, */
+  /* a default initial seed is used         */
+  if(initf == 0)
+    seed();
+//    manualSeed(5489UL);
+
+  left = n;
+  next = state;
+    
+  for(int j = n-m+1; --j; p++) 
+    *p = p[m] ^ TWIST(p[0], p[1]);
+
+  for(int j = m; --j; p++) 
+    *p = p[m-n] ^ TWIST(p[0], p[1]);
+
+  *p = p[m-n] ^ TWIST(p[0], state[0]);
+}
+
+unsigned long Random::random()
+{
+  unsigned long y;
+
+  if (--left == 0)
+    nextState();
+  y = *next++;
+  
+  /* Tempering */
+  y ^= (y >> 11);
+  y ^= (y << 7) & 0x9d2c5680UL;
+  y ^= (y << 15) & 0xefc60000UL;
+  y ^= (y >> 18);
+
+  return y;
+}
+
+/* generates a random number on [0,1)-real-interval */
+real Random::uniform()
+{
+  unsigned long y;
+
+  if(--left == 0)
+    nextState();
+  y = *next++;
+
+  /* Tempering */
+  y ^= (y >> 11);
+  y ^= (y << 7) & 0x9d2c5680UL;
+  y ^= (y << 15) & 0xefc60000UL;
+  y ^= (y >> 18);
+  
+  return (real)y * (1.0/4294967296.0); 
+  /* divided by 2^32 */
+}
+
+///
+/// Thanks *a lot* Takuji Nishimura and Makoto Matsumoto!
+///
+/////////////////////////////////////////////////////////////////////
+//// Now my own code...
+
+void Random::getShuffledIndices(int *indices, int n_indices)
+{
+  for(int i = 0; i < n_indices; i++)
+    indices[i] = i;
+  
+  Random::shuffle(indices, sizeof(int), n_indices);
+}
+
+void Random::shuffle(void *tabular, int size_elem, int n_elems)
+{
+  void *save = Allocator::sysAlloc(size_elem);
+  char *tab = (char *)tabular;
+
+  for(int i = 0; i < n_elems-1; i++)
+  {
+    int z = Random::random() % (n_elems-i);
+    memcpy(save, tab+i*size_elem, size_elem);
+    memmove(tab+i*size_elem, tab+(z+i)*size_elem, size_elem);
+    memcpy(tab+(z+i)*size_elem, save, size_elem);
+  }
+  free(save);
+}
+
+real Random::boundedUniform(real a, real b)
+{
+  return(Random::uniform() * (b - a) + a);
+}
+
+real Random::normal(real mean, real stdv)
+{
+  if(!normal_is_valid)
+  {
+    normal_x = Random::uniform();
+    normal_y = Random::uniform();
+    normal_rho = sqrt(-2. * log(1.0-normal_y));
+    normal_is_valid = true;
+  }
+  else
+    normal_is_valid = false;
+  
+  if(normal_is_valid)
+    return normal_rho*cos(2.*M_PI*normal_x)*stdv+mean;
+  else
+    return normal_rho*sin(2.*M_PI*normal_x)*stdv+mean;
+}
+
+real Random::exponential(real lambda)
+{
+  return(-1. / lambda * log(1-Random::uniform()));
+}
+
+real Random::cauchy(real median, real sigma)
+{
+  return(median + sigma * tan(M_PI*(Random::uniform()-0.5)));
+}
+
+// Faut etre malade pour utiliser ca.
+// M'enfin.
+real Random::logNormal(real mean, real stdv)
+{
+  real zm = mean*mean;
+  real zs = stdv*stdv;
+  return(exp(Random::normal(log(zm/sqrt(zs + zm)), sqrt(log(zs/zm+1)) )));
+}
+
+int Random::geometric(real p)
+{
+  return((int)(log(1-Random::uniform()) / log(p)) + 1);
+}
+
+bool Random::bernouilli(real p)
+{
+  return(Random::uniform() <= p);
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Random.h work/main.d/Torch-3/core/Random.h
--- tmp/Torch-3/core/Random.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Random.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,131 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef RANDOM_INC
+#define RANDOM_INC
+
+#include "general.h"
+
+namespace Torch {
+
+/** Random class which contains several static random methods.
+    
+    These methods are based on a uniform random generator,
+    named "Mersenne Twister", available at:
+    http://www.math.keio.ac.jp/matumoto/emt.html.
+    Copyright Makoto Matsumoto and Takuji Nishimura.
+    (Have a look inside the implementation file for details).
+
+    The random generator can be initialized with the manualSeed() method.
+    Otherwise, it will be automatically initialized with a seed based
+    on the current computer clock.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Random
+{
+  public:
+    // The seed used to initialize the random generator.
+    static unsigned long the_initial_seed;
+
+    // Internal variables for the Mersenne Twister generator
+    static const int n;
+    static const int m;
+    static unsigned long state[]; /* the array for the state vector  */
+    static int left;
+    static int initf;
+    static unsigned long *next;
+
+    // Internal variables for the normal distribution generator
+    static real normal_x;
+    static real normal_y;
+    static real normal_rho;
+    static bool normal_is_valid;
+
+    // Internal method for the Mersenne Twister generator
+    static void nextState();
+
+    /// Initializes the random number generator with the computer clock.
+    static void seed();
+
+    /// Initializes the random number generator with the given long "the_seed_".
+    static void manualSeed(unsigned long the_seed_);
+
+    /// Returns the starting seed used.
+    static unsigned long getInitialSeed();
+
+    /// Generates a uniform 32 bits integer.
+    static unsigned long random();
+
+    /// Generates a uniform random number on [0,1[.
+    static real uniform();
+
+    /// Returns in #indices# #n_indices# shuffled. (between 0 and #n_indices-1#).
+    static void getShuffledIndices(int *indices, int n_indices);
+
+    /// Shuffles tabular, which contains #n_elems# of size #size_elem#.
+    static void shuffle(void *tabular, int size_elem, int n_elems);
+
+    /// Generates a uniform random number on [a,b[ (b>a).
+    static real boundedUniform(real a, real b);
+
+    /** Generates a random number from a normal distribution.
+        (With mean #mean# and standard deviation #stdv >= 0#).
+    */
+    static real normal(real mean=0, real stdv=1);
+
+    /** Generates a random number from an exponential distribution.
+        The density is $p(x) = lambda * exp(-lambda * x)$, where
+        lambda is a positive number.
+    */
+    static real exponential(real lambda);
+
+    /** Returns a random number from a Cauchy distribution.
+        The Cauchy density is $p(x) = sigma/(pi*(sigma^2 + (x-median)^2))$
+    */
+    static real cauchy(real median=0, real sigma=1);
+
+    /** Generates a random number from a log-normal distribution.
+        (#mean > 0# is the mean of the log-normal distribution
+        and #stdv# is its standard deviation).
+    */
+    static real logNormal(real mean, real stdv);
+
+    /** Generates a random number from a geometric distribution.
+        It returns an integer #i#, where $p(i) = (1-p) * p^(i-1)$.
+        p must satisfy $0 < p < 1$.
+    */
+    static int geometric(real p);
+
+    /// Returns true with probability $p$ and false with probability $1-p$ (p > 0).
+    static bool bernouilli(real p=0.5);
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Sequence.cc work/main.d/Torch-3/core/Sequence.cc
--- tmp/Torch-3/core/Sequence.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Sequence.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,277 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Sequence.h"
+#include "XFile.h"
+
+namespace Torch {
+
+Sequence::Sequence()
+{
+  // General
+  frames = NULL;
+  n_real_frames = 0;
+  n_frames = 0;
+  frame_size = 0;
+}
+
+Sequence::Sequence(real **frames_, int n_frames_, int frame_size_)
+{
+  frames = frames_;
+  n_real_frames = n_frames_;
+  n_frames = n_frames_;
+  frame_size = frame_size_;
+}
+
+Sequence::Sequence(int n_frames_, int frame_size_)
+{
+  // General
+  n_real_frames = n_frames_;
+  n_frames = n_frames_;
+  frame_size = frame_size_;
+  if(n_frames > 0)    
+    frames = (real **)allocator->alloc(sizeof(real *)*n_frames);
+  else
+  {
+    frames = NULL;
+    n_frames = 0;
+  }
+
+  if(frame_size <= 0)
+    error("Sequence: try to create a sequence with a negative size");
+
+  if(n_frames > 0)
+  {
+    real *data_buffer = NULL;
+    data_buffer = (real *)allocator->alloc(sizeof(real)*n_frames*frame_size);
+    for(int i = 0; i < n_frames; i++)
+      frames[i] = data_buffer+i*frame_size;
+  }
+}
+
+void Sequence::resize(int n_frames_, bool allocate_new_frames)
+{
+  // Do we have already this frames in memory ? OOooOOh cooOOool...
+  if(n_real_frames >= n_frames_)
+  {
+    n_frames = n_frames_;
+    return;
+  }
+
+  // Allocate array of frames and possibly the frames...
+  // If frame_size is 0 (or user explicit specification), frames won't be allocated  
+  reallocFramesArray(n_frames_);
+  if( (frame_size == 0) || (!allocate_new_frames) )
+  {
+    for(int i = n_real_frames; i < n_frames_; i++)
+      frames[i] = NULL;
+  }
+  else
+  {
+    real *data_buffer = (real *)allocator->alloc(sizeof(real)*(n_frames_-n_real_frames)*frame_size);
+    for(int i = n_real_frames; i < n_frames_; i++)
+      frames[i] = data_buffer+(i-n_real_frames)*frame_size;
+  }
+
+  n_frames = n_frames_;
+  n_real_frames = n_frames_;
+}
+
+void Sequence::addFrame(real *frame, bool do_copy)
+{
+  if(!frame)
+    return;
+
+  reallocFramesArray(n_real_frames+1);
+  if(do_copy)
+  {
+    frames[n_real_frames] = (real *)allocator->alloc(sizeof(real)*frame_size);
+    real *frame_dest = frames[n_real_frames];
+    for(int i = 0; i < frame_size; i++)
+      frame_dest[i] = frame[i];
+  }
+  else
+    frames[n_real_frames] = frame;
+
+  if(n_real_frames == n_frames)
+    n_frames++;
+  n_real_frames++;
+}
+
+void Sequence::add(Sequence *sequence, bool do_copy)
+{
+  if(!sequence)
+    return;
+
+  if(frame_size != sequence->frame_size)
+    error("Sequence: try to add a sequence with a wrong frame size");
+
+  reallocFramesArray(n_real_frames+sequence->n_frames);
+  if(do_copy)
+  {
+    for(int i = 0; i < sequence->n_frames; i++)
+    {
+      frames[n_real_frames+i] = (real *)allocator->alloc(sizeof(real)*frame_size);
+      real *frame_dest = frames[n_real_frames+i];
+      real *frame_src = sequence->frames[i];
+      for(int i = 0; i < frame_size; i++)
+        frame_dest[i] = frame_src[i];
+    }
+  }
+  else
+  {
+    for(int i = 0; i < sequence->n_frames; i++)
+      frames[n_real_frames+i] = sequence->frames[i];
+  }
+
+  if(n_real_frames == n_frames)
+    n_frames += sequence->n_frames;
+
+  n_real_frames += sequence->n_frames;
+}
+
+void Sequence::copy(Sequence *from)
+{
+  int src_frame_size = from->frame_size;
+  int src_frame_number = 0;
+  int src_index_in_frame = 0;
+
+  real *src_frame = from->frames[0];
+  for(int i = 0; i < n_frames; i++)
+  {
+    real *dest_frame = frames[i];
+    for(int j = 0; j < frame_size; j++)
+    {
+      if(src_index_in_frame == src_frame_size)
+      {
+        src_index_in_frame = 0;
+        src_frame = from->frames[++src_frame_number];
+      }
+      dest_frame[j] = src_frame[src_index_in_frame++];
+    }
+  }
+}
+
+void Sequence::reallocFramesArray(int n_frames_)
+{
+  if(allocator->isMine(frames))
+    frames = (real **)allocator->realloc(frames, sizeof(real *)*(n_frames_));
+  else
+  {
+    real **frames_ = (real **)allocator->alloc(sizeof(real *)*(n_frames_));
+    for(int i = 0; i < n_real_frames; i++)
+      frames_[i] = frames[i];
+    frames = frames_;
+  }
+}
+
+void Sequence::copyFrom(real *vec)
+{
+  for(int i = 0; i < n_frames; i++)
+  {
+    real *frame_ = frames[i];
+    for(int j = 0; j < frame_size; j++)
+      frame_[j] = vec[j];
+    vec += frame_size;
+  }
+}
+
+void Sequence::copyTo(real *vec)
+{
+  for(int i = 0; i < n_frames; i++)
+  {
+    real *frame_ = frames[i];
+    for(int j = 0; j < frame_size; j++)
+      vec[j] = frame_[j];
+    vec += frame_size;
+  }
+}
+
+int Sequence::getSequenceSpace()
+{
+  return(sizeof(Sequence));
+}
+
+int Sequence::getFramesSpace()
+{
+  return(frame_size*n_frames*sizeof(real)+n_frames*sizeof(real *));
+}
+
+Sequence *Sequence::clone(Allocator *allocator_, void *sequence_memory, void *frames_memory)
+{
+  if(!allocator_)
+    allocator_ = allocator;
+
+  real **frames_ = (real **)frames_memory;
+  if(frames_memory)
+  {
+    real *buffer = (real *)(frames_ + n_frames);
+    for(int i = 0; i < n_frames; i++)
+      frames_[i] = buffer+i*frame_size;
+  }
+
+  Sequence *the_clone = NULL;
+  if(sequence_memory)
+  {
+    if(frames_memory)
+      the_clone = new(allocator_, sequence_memory) Sequence(frames_, n_frames, frame_size);
+    else
+      the_clone = new(allocator_, sequence_memory) Sequence(n_frames, frame_size);
+  }
+  else
+  {
+    if(frames_memory)
+      the_clone = new(allocator_) Sequence(frames_, n_frames, frame_size);
+    else
+      the_clone = new(allocator_) Sequence(n_frames, frame_size);
+  }
+
+  the_clone->copy(this);
+
+  return the_clone;
+}
+
+void Sequence::loadXFile(XFile *file)
+{
+  for(int i = 0; i < n_frames; i++)
+    file->taggedRead(frames[i], sizeof(real), frame_size, "FRAME");
+}
+
+void Sequence::saveXFile(XFile *file)
+{
+  for(int i = 0; i < n_frames; i++)
+    file->taggedWrite(frames[i], sizeof(real), frame_size, "FRAME");
+}
+
+Sequence::~Sequence()
+{
+}
+
+IMPLEMENT_NEW_LIST(SequenceList, Sequence)
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Sequence.h work/main.d/Torch-3/core/Sequence.h
--- tmp/Torch-3/core/Sequence.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Sequence.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,144 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SEQUENCE_INC
+#define SEQUENCE_INC
+
+#include "Object.h"
+#include "List.h"
+
+namespace Torch {
+
+/** Sequence definition.
+    A sequence is a set of frames (that is, a vector) which have the same size.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Sequence : public Object
+{
+  private:
+    /* Resize the array of frames to #n_frames_#.
+       If the array hasn't be allocated by the class, allocate a new one
+       and copy previous frame pointers. Else, just do a realloc.
+       Note that #n_frames_# must be the new #n_real_frames#...
+    */
+    void reallocFramesArray(int n_frames_);
+
+  public:
+    /// Real number of frames
+    int n_real_frames;
+
+    /** Array of usable frame pointers.
+        The actual size of this array is given by #n_real_frames#.
+        And the usable size is given by #n_frames#. */
+    real **frames;
+
+    /// Number of visible frames
+    int n_frames;
+
+    /// Frame size
+    int frame_size;
+
+    /// Create an empty sequence
+    Sequence();
+
+    /** Create a sequences of #n_frames_# frames with size #frame_size_#.
+        The frames are given by the #frames_# array.
+        Nothing (except pointers!) will be copied.
+    */
+    Sequence(real **frames_, int n_frames_, int frame_size_);
+
+    /** Create a sequence with #n_frames_# \emph{standard} frames
+        of size #frame_size#.
+    */
+    Sequence(int n_frames_, int frame_size_);
+
+    /** Resize the sequence to #n_frames_#. Note that if #n_frames_# is lower
+        than the previous one, the frames won't be deallocated, and can be retrieved
+        by another resize...
+    */
+    void resize(int n_frames_, bool allocate_new_frames=true);
+
+    /** Add a frame at the end of the Sequence.
+        If #do_copy# is true, copy the sequence.
+        Else, just copy the pointer.
+    */
+    void addFrame(real *frame, bool do_copy=false);
+    
+    /** Add a sequence at the end of the Sequence.
+        If #do_copy# is true, copy the frame contents.
+        Else, just copy the frame pointers.
+     */
+    void add(Sequence *sequence, bool do_copy=false);
+
+    /** Copy the given sequence.
+        The given sequence don't need to have the same structure.
+        But it must have the same total length.
+    */
+    void copy(Sequence *from);
+
+    /** Copy a real vector in the full sequence.
+        The sequence \emph{must} have the good size!
+    */
+    void copyFrom(real *vec);
+
+    /** Copy the full sequence in a real vector.
+        The sequence \emph{must} have the good size!
+    */
+    void copyTo(real *vec);
+
+    /// Get the space needed to allocate one Sequence
+    virtual int getSequenceSpace();
+
+    /// Get the space needed to allocate frames contained in the sequence.
+    virtual int getFramesSpace();
+
+    /** Clone the sequence.
+        If #allocator_# is non-null, call it for all memory allocation and object initialization.
+        Else, the returned sequence will be destroyed when the original sequence will be destroyed.
+        If #sequence_memory# is non-null, puts the class memory-space in it; it must contain
+        the space given by #getSequenceSpace()#.
+        If #frames_memory# is non-null, use the given memory for frames allocation; it must contain
+        the space given by #getFramesSpace()#.
+    */
+    virtual Sequence *clone(Allocator *allocator_=NULL, void *sequence_memory=NULL, void *frames_memory=NULL);
+
+    /// Save the \emph{usable} frames. (#n_frames# available in #frames#).
+    virtual void saveXFile(XFile *file);
+
+    /// Load the \emph{usable} frames. (#n_frames# available in #frames#).
+    virtual void loadXFile(XFile *file);
+
+    virtual ~Sequence();
+};
+
+DEFINE_NEW_LIST(SequenceList, Sequence);
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Stack.cc work/main.d/Torch-3/core/Stack.cc
--- tmp/Torch-3/core/Stack.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Stack.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,73 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Stack.h"
+
+namespace Torch {
+
+Stack::Stack()
+{
+  stack_size = 0;
+  stack = NULL;
+  n_stacked_objects = 0;
+}
+
+void Stack::push(void *ptr, int size)
+{
+  if(n_stacked_objects >= stack_size)
+  {
+    stack_size++;
+    stack = (StackNode *)allocator->realloc(stack, sizeof(StackNode)*stack_size);
+  }
+
+  stack[n_stacked_objects].address = ptr;
+  stack[n_stacked_objects].size = size;
+  if(ptr)
+  {
+    stack[n_stacked_objects].ptr = allocator->alloc(size);
+    memcpy(stack[n_stacked_objects].ptr, ptr, size);
+  }
+  else
+    stack[n_stacked_objects].ptr = NULL;
+
+  n_stacked_objects++;
+}
+
+void Stack::pop()
+{
+  n_stacked_objects--;
+  if(stack[n_stacked_objects].ptr)
+    memcpy(stack[n_stacked_objects].address, stack[n_stacked_objects].ptr, stack[n_stacked_objects].size);
+  allocator->free(stack[n_stacked_objects].ptr);
+}
+
+Stack::~Stack()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Stack.h work/main.d/Torch-3/core/Stack.h
--- tmp/Torch-3/core/Stack.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Stack.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,72 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef STACK_INC
+#define STACK_INC
+
+#include "Object.h"
+
+namespace Torch {
+
+struct StackNode
+{
+    void *address;
+    void *ptr;
+    int size;
+};
+
+/** This is an implementation of a "stack".
+    You can "push" an array in memory, which will
+    be restored when calling "pop", in a stack manner.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Stack : public Object
+{
+  private:
+    int stack_size;
+
+  public:
+    StackNode *stack;
+    int n_stacked_objects;
+
+    /// Create a stack.
+    Stack();
+
+    /// Save #size# bytes of memory given by #ptr#.
+    void push(void *ptr, int size);
+
+    /// Restore the last pushed memory.
+    void pop();
+
+    virtual ~Stack();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/string_utils.cc work/main.d/Torch-3/core/string_utils.cc
--- tmp/Torch-3/core/string_utils.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/string_utils.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,89 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                and Ronan Collobert (collober@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "general.h"
+#include "string_utils.h"
+#include "Allocator.h"
+#include <stdarg.h>
+
+namespace Torch {
+
+char *strBaseName(char *filename) {
+   char *p = strrchr(filename, '/');
+   return p ? (p+1) : filename;
+}
+
+char *strRemoveSuffix(char *filename, char c)
+{
+  char *copy = NULL;
+  int len = strlen(filename);
+  char *p = filename + len - 1;
+  int i=len-1;
+  while (*p != c && i-- >0) p--;
+  if (i>0) {
+    //*p = '\0';
+    copy = (char*)Allocator::sysAlloc(sizeof(char)*(i+1));
+    strncpy(copy,filename,i);
+    copy[i] = '\0';
+  } else {
+    copy = (char*)Allocator::sysAlloc(sizeof(char)*(len+1));
+    strcpy(copy,filename);
+  }
+  return copy;
+}
+
+char *strConcat(int n, ...)
+{
+  char **strs = (char **)Allocator::sysAlloc(sizeof(char *)*n);
+
+  int taille = 0;
+  va_list args;
+  va_start(args, n);
+  for(int i = 0; i < n; i++)
+  {
+    strs[i] = va_arg(args, char *);
+    taille += strlen(strs[i]);
+  }
+  va_end(args);
+  taille++; // Pour le truc de fin
+
+  char *the_concat = (char *)Allocator::sysAlloc(sizeof(char)*taille);
+  the_concat[0] = '\0';
+
+  for(int i = 0; i < n; i++)
+    strcat(the_concat, strs[i]);
+
+  free(strs);
+
+  return(the_concat);
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/string_utils.h work/main.d/Torch-3/core/string_utils.h
--- tmp/Torch-3/core/string_utils.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/string_utils.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,65 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                and Ronan Collobert (collober@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef STRING_UTILS_INC
+#define STRING_UTILS_INC
+
+#include <string.h>
+
+namespace Torch {
+
+/** Some simple functions for string operations.
+
+    @author Samy Bengio (bengio@idiap.ch)
+    @author Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+//@{
+/** Returns the name of a file without leading pathname.
+    (It's not a new string, but a pointer in the given string)
+ */
+char *strBaseName(char *filename);
+
+/** Returns a fresh copy of the name of a file without suffix.
+    (Trailing chars after c) You have to free the memory!
+*/
+char *strRemoveSuffix(char *filename, char c='.');
+
+/** Returns the concatenation #n# strings.
+    The strings are the parameters given after #n#;
+    You have to free the memory!
+*/
+char *strConcat(int n, ...);
+
+//@}
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/TimeMeasurer.cc work/main.d/Torch-3/core/TimeMeasurer.cc
--- tmp/Torch-3/core/TimeMeasurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/TimeMeasurer.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,69 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "TimeMeasurer.h"
+
+namespace Torch {
+
+TimeMeasurer::TimeMeasurer(DataSet *data_, XFile *file_) : Measurer(data_, file_)
+{
+  timer = new(allocator) Timer;
+}
+
+void TimeMeasurer::reset()
+{
+  timer->reset();
+}
+
+void TimeMeasurer::measureIteration()
+{
+  real the_time_ = timer->getTime();
+
+  if(binary_mode)
+    file->write(&the_time_, sizeof(real), 1);
+  else
+    file->printf("%g\n", the_time_);
+  file->flush();
+}
+
+void TimeMeasurer::measureEnd()
+{
+  real the_time_ = timer->getTime();
+
+  if(binary_mode)
+    file->write(&the_time_, sizeof(real), 1);
+  else
+    file->printf("%g\n", the_time_);
+  file->flush();
+}
+
+TimeMeasurer::~TimeMeasurer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/TimeMeasurer.h work/main.d/Torch-3/core/TimeMeasurer.h
--- tmp/Torch-3/core/TimeMeasurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/TimeMeasurer.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,66 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef TIME_MEASURER_INC
+#define TIME_MEASURER_INC
+
+#include "Measurer.h"
+#include "Timer.h"
+
+namespace Torch {
+
+/** Measure the time (in seconds) between
+    two  #measureIteration()# calls.
+
+    Save in #file# the sum of these time,
+    at each iteration.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class TimeMeasurer : public Measurer
+{
+  public:
+    Timer *timer;
+
+    //-----
+
+    ///
+    TimeMeasurer(DataSet *data_, XFile *file_);
+
+    //-----
+
+    virtual void reset();
+    virtual void measureIteration();
+    virtual void measureEnd();
+
+    virtual ~TimeMeasurer();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Timer.cc work/main.d/Torch-3/core/Timer.cc
--- tmp/Torch-3/core/Timer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Timer.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,107 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Timer.h"
+#ifndef _MSC_VER
+#include <sys/times.h>
+#include <unistd.h>
+#endif
+
+namespace Torch {
+
+#ifdef _MSC_VER
+time_t Timer::base_time = 0;
+#endif
+
+real Timer::getRunTime()
+{
+#ifdef _MSC_VER
+  time_t truc_foireux;
+  time(&truc_foireux);
+  return(difftime(truc_foireux, base_time));
+#else
+  struct tms current;
+  times(&current);
+  
+  real norm = (real)sysconf(_SC_CLK_TCK);
+  return(((real)current.tms_utime)/norm);
+#endif
+}
+
+Timer::Timer()
+{
+#ifdef _MSC_VER
+	while(!base_time)
+		time(&base_time);
+#endif
+  total_time = 0;
+  is_running = true;
+  start_time = getRunTime();
+}
+
+void Timer::reset()
+{
+  total_time = 0;
+  start_time = getRunTime();
+}
+
+void Timer::stop()
+{
+  if(!is_running)
+    return;
+  
+  real current_time = getRunTime() - start_time;
+  total_time += current_time;
+  is_running = false;
+}
+
+void Timer::resume()
+{
+  if(is_running)
+    return;
+
+  start_time = getRunTime();
+  is_running = true;
+}
+
+real Timer::getTime()
+{
+  if(is_running)
+  {
+    real current_time = getRunTime() - start_time;
+    return(total_time+current_time);
+  }
+  else
+    return total_time;
+}
+
+Timer::~Timer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Timer.h work/main.d/Torch-3/core/Timer.h
--- tmp/Torch-3/core/Timer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Timer.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,84 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef TIMER_INC
+#define TIMER_INC
+
+#include "Object.h"
+
+namespace Torch {
+
+/** Timer... to measure time.
+    It accumulates the time measured in several #resume()# (or
+    constructor definition) and #stop()# calls.
+
+    Use #getTime()# to know this accumulated time.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Timer : public Object
+{
+#ifdef _MSC_VER
+  private:
+    static time_t base_time;
+#endif
+  public:
+    bool is_running;
+    real total_time;
+    real start_time;
+
+    /// Create the timer and start it now!
+    Timer();
+
+    /** Reset the timer. The timer will count time starting
+        from now, and the accumulated time is erased.
+    */
+    void reset();
+
+    /// Stop the timer. Updates accumulated time.
+    void stop();
+
+    /// Resume the timer. It will count time starting from now.
+    void resume();
+
+    /** Get the total accumulated time. (Until now, if the
+        timer is still running.
+    */
+    real getTime();
+
+    /** System dependent function which returns time elapsed
+        since an arbitrary point reference in the past.
+    */
+    static real getRunTime();
+
+    ~Timer();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Trainer.cc work/main.d/Torch-3/core/Trainer.cc
--- tmp/Torch-3/core/Trainer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Trainer.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,209 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Trainer.h"
+#include "Random.h"
+
+namespace Torch {
+
+IMPLEMENT_NEW_LIST(MeasurerList, Measurer)
+
+Trainer::Trainer(Machine *machine_)
+{
+  machine = machine_;
+}
+
+void Trainer::test(MeasurerList *measurers)
+{
+  DataSet **datas;
+  Measurer ***mes;
+  int *n_mes;
+  int n_datas;
+
+  print("# Trainer: testing [");
+
+  Allocator *allocator_ = extractMeasurers(measurers, NULL, &datas, &mes, &n_mes, &n_datas);
+
+  ////
+  int n_ex = 0;
+  for(int andrea = 0; andrea < n_datas; andrea++)
+    n_ex += datas[andrea]->n_examples;
+  real n_ex_mod = ( (n_ex == 0) ? 0. : 10.1/((real)n_ex));
+  real ex_curr = 0;
+  real n_dots = 0;
+  ////
+
+  for(int andrea = 0; andrea < n_datas; andrea++)
+  {
+    DataSet *dataset = datas[andrea];
+
+    for(int i = 0; i < n_mes[andrea]; i++)
+      mes[andrea][i]->reset();
+
+    for(int t = 0; t < dataset->n_examples; t++)
+    {
+      dataset->setExample(t);
+      machine->forward(dataset->inputs);
+    
+      for(int i = 0; i < n_mes[andrea]; i++)
+        mes[andrea][i]->measureExample();
+
+      if(++ex_curr * n_ex_mod >= (n_dots+1))
+      {
+        if(n_ex < 10)
+          print("_");
+        else
+          print(".");
+        n_dots++;
+      }
+    }
+  
+    for(int i = 0; i < n_mes[andrea]; i++)
+      mes[andrea][i]->measureIteration();
+
+    for(int i = 0; i < n_mes[andrea]; i++)
+      mes[andrea][i]->measureEnd();
+
+  }
+  
+  print("]\n");
+  delete allocator_;      
+}
+
+// ExtractMeasurers, ou la magie du quatre etoiles...
+Allocator *Trainer::extractMeasurers(MeasurerList *measurers, DataSet *train, DataSet ***datas, Measurer ****meas, int **n_meas, int *n_datas)
+{
+  DataSet **datas_ = NULL;
+  Measurer ***meas_ = NULL;
+  int *n_meas_ = NULL;
+  int n_datas_ = 0;
+
+  Allocator *allocator_ = new Allocator;
+
+  // 0) Coup bas ? Eh... l'aut...
+  if(!measurers)
+  {
+    if(train)
+    {
+      datas_ = (DataSet **)allocator_->alloc(sizeof(DataSet *));
+      datas_[n_datas_++] = train;
+      n_meas_ = (int *)allocator_->alloc(sizeof(int));
+      n_meas_[0] = 0;
+    }
+
+    *datas = datas_;
+    *meas = meas_;
+    *n_meas = n_meas_;
+    *n_datas = n_datas_;
+
+    return allocator_;
+  }
+
+  // 1) Find all differents datas [-- bourrin -- et en + : +1 au cas ou tous != et tous != de train...]...
+  datas_ = (DataSet **)allocator_->alloc(sizeof(DataSet *)*(measurers->n_nodes+1));
+  n_datas_ = 0;
+  if(train)
+    datas_[n_datas_++] = train;
+
+  for(int i = 0; i < measurers->n_nodes; i++)
+  {
+    DataSet *potential_new_dataset = measurers->nodes[i]->data;
+    bool already_registered = false;
+    for(int j = 0; j < n_datas_; j++)
+    {
+      if(potential_new_dataset == datas_[j])
+      {
+        already_registered = true;
+        break;
+      }
+    }
+
+    if(!already_registered)
+      datas_[n_datas_++] = potential_new_dataset;
+  }
+
+  // 2) Allocations a la con avec l'allocator qu'on va refiler a l'aut'naze
+  if(n_datas_ > 0)
+  {
+    n_meas_ = (int *)allocator_->alloc(sizeof(int)*n_datas_);
+    meas_ = (Measurer ***)allocator_->alloc(sizeof(Measurer **)*n_datas_);
+  }
+
+  // 3) For each dataset...
+  for(int i = 0; i < n_datas_; i++)
+  {
+    DataSet *counted_data = datas_[i];
+
+    // 2a) Count associated measurers...
+    n_meas_[i] = 0;
+    for(int j = 0; j < measurers->n_nodes; j++)
+    {
+      if(measurers->nodes[j]->data == counted_data)
+        n_meas_[i]++;
+    }
+
+    // 2b) Y'a qqch ??? [pour le train...]
+    if(!n_meas_[i])
+      continue;
+
+    // 2c) Allocate memory
+    meas_[i] = (Measurer **)allocator_->alloc(sizeof(Measurer *)*n_meas_[i]);
+    
+    // 2d) Rempli le bordel a donf [processeurs deterministes seulement]
+    int index = 0;
+    for(int j = 0; j < measurers->n_nodes; j++)
+    {
+      if(measurers->nodes[j]->data == counted_data)
+        meas_[i][index++] = measurers->nodes[j];
+    }    
+  }
+
+  // 4) Envoie la sauce. Restez pas plante la, y'a plus rien a voir, bordel.
+  *datas = datas_;
+  *meas = meas_;
+  *n_meas = n_meas_;
+  *n_datas = n_datas_;
+
+  return allocator_;
+}
+
+void Trainer::loadXFile(XFile *file)
+{
+  machine->loadXFile(file);
+}
+
+void Trainer::saveXFile(XFile *file)
+{
+  machine->saveXFile(file);
+}
+
+Trainer::~Trainer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/Trainer.h work/main.d/Torch-3/core/Trainer.h
--- tmp/Torch-3/core/Trainer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/Trainer.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,108 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef TRAINER_INC
+#define TRAINER_INC
+
+#include "Object.h"
+#include "Machine.h"
+#include "DataSet.h"
+#include "List.h"
+#include "Measurer.h"
+
+namespace Torch {
+
+DEFINE_NEW_LIST(MeasurerList, Measurer);
+
+/** Trainer.
+  
+    A trainer takes a #Machine# and is able to train this machine on a given dataset
+    with the #train()# method.
+    For each machine, it should exist a trainer which knows how to train this machine.
+    Testing the machine is possible with the #test()# method.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Trainer : public Object
+{
+  public:
+    Machine *machine;
+
+    //-----
+
+    ///
+    Trainer(Machine *machine_);
+
+    //-----
+
+    /** Train the machine.
+        The Trainer has to call the measurers
+        when it want.
+    */
+    virtual void train(DataSet *data_, MeasurerList *measurers) = 0;
+
+    /** Test the machine.
+        This method call all the measurers,
+        for all the examples of their associated
+        dataset.
+        It's already written...
+    */
+    virtual void test(MeasurerList *measurers);
+
+    /** Make a table of measurers from a #List#.
+    
+        Given a #List# of #measurers#,
+        and, if you want, a #train# #DataSet# (else NULL)
+        \begin{itemize}
+          \item Returns all datasets associated to the measurers in #datas#.
+                For i != j, (*datas)[i] != (*datas)[j].
+                Moreover, if #train# != NULL, (*datas)[0] = #train#.
+          \item Returns the list of measurers associated to (*datas)[i] in (*meas)[i].
+          \item Returns the number of measureurs associated to (*datas)[i] in (*n_meas)[i].
+          \item Returns in *n_datas the number of datasets in *datas.
+        \end{itemize}
+    
+    Returns an allocator to all the memory allocated by the function.
+    You have to delete this allocator by yourself.
+    */
+    static Allocator *extractMeasurers(MeasurerList *measurers, DataSet *train, DataSet ***datas, Measurer ****meas, int **n_meas, int *n_datas);
+
+    /// By default, just load the machine
+    virtual void loadXFile(XFile *file);
+
+    /// By default, just save the machine
+    virtual void saveXFile(XFile *file);
+
+    //-----
+
+    virtual ~Trainer();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/TwoClassFormat.cc work/main.d/Torch-3/core/TwoClassFormat.cc
--- tmp/Torch-3/core/TwoClassFormat.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/TwoClassFormat.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,131 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "TwoClassFormat.h"
+
+namespace Torch {
+
+TwoClassFormat::TwoClassFormat(DataSet *data)
+{
+  if(data->n_targets != 1)
+    warning("TwoClassFormat: the data has %d ouputs", data->n_targets);
+  
+  int n_set = 0;
+  for(int i = 0; i < data->n_examples; i++)
+  {
+    data->setExample(i);
+    
+    bool flag = false;
+    for(int k = 0; k < n_set; k++)
+    {
+      if(data->targets->frames[0][0] == tabclasses[k])
+        flag = true;
+    }
+
+    if(!flag)
+    {
+      if(n_set == 2)
+        error("TwoClassFormat: you have more than two classes");
+
+      tabclasses[n_set++] = data->targets->frames[0][0];
+    }
+  }
+
+  switch(n_set)
+  {
+    case 0:
+      warning("TwoClassFormat: you have no examples");
+      tabclasses[0] = 0;
+      tabclasses[1] = 0;
+      break;
+    case 1:
+      warning("TwoClassFormat: you have only one class [%g]", tabclasses[0]);
+      tabclasses[1] = tabclasses[0];
+      break;
+    case 2:
+      if(tabclasses[0] > tabclasses[1])
+      {
+        real z = tabclasses[1];
+        tabclasses[1] = tabclasses[0];
+        tabclasses[0] = z;
+      }
+      message("TwoClassFormat: two classes detected [%g and %g]", tabclasses[0], tabclasses[1]);
+      break;
+  }
+
+  // He He He...
+  n_classes = 2;
+  class_labels = (real **)allocator->alloc(sizeof(real *)*n_classes);
+  for(int i = 0; i < n_classes; i++)
+    class_labels[i] = tabclasses+i;
+}
+
+TwoClassFormat::TwoClassFormat(real class_1, real class_2)
+{
+  tabclasses[0] = class_1;
+  tabclasses[1] = class_2;
+  n_classes = 2;
+  class_labels = (real **)allocator->alloc(sizeof(real *)*n_classes);
+  for(int i = 0; i < n_classes; i++)
+    class_labels[i] = tabclasses+i;
+}
+
+int TwoClassFormat::getOutputSize()
+{
+  return 1;
+}
+
+void TwoClassFormat::fromOneHot(real *outputs, real *one_hot_outputs)
+{
+  outputs[0] = one_hot_outputs[0] - one_hot_outputs[1];
+  if(tabclasses[1] > tabclasses[0]) 
+    outputs[0] = one_hot_outputs[1] - one_hot_outputs[0];
+  else
+    outputs[0] = one_hot_outputs[0] - one_hot_outputs[1];
+}
+
+void TwoClassFormat::toOneHot(real *outputs, real *one_hot_outputs)
+{
+  int maxclass = (tabclasses[1]>tabclasses[0]);
+  int minclass = (tabclasses[0]>tabclasses[1]);
+  one_hot_outputs[0] = fabs(outputs[0] - tabclasses[maxclass]);
+  one_hot_outputs[1] = fabs(outputs[0] - tabclasses[minclass]);
+}
+
+int TwoClassFormat::getClass(real *vector)
+{
+  real out = vector[0];
+  
+  return(fabs(out - tabclasses[0]) > fabs(out - tabclasses[1]) ? 1 : 0);
+}
+
+TwoClassFormat::~TwoClassFormat()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/TwoClassFormat.h work/main.d/Torch-3/core/TwoClassFormat.h
--- tmp/Torch-3/core/TwoClassFormat.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/TwoClassFormat.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,62 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef TWO_CLASS_FORMAT_INC
+#define TWO_CLASS_FORMAT_INC
+
+#include "ClassFormat.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+/** Define the two class encoding format.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class TwoClassFormat : public ClassFormat
+{
+  public:
+    real tabclasses[2];
+
+    /// Autodetect classes.
+    TwoClassFormat(DataSet *data);
+
+    /// Specify the label of the classes.
+    TwoClassFormat(real class_1, real class_2);
+
+    virtual int getClass(real *vector);
+    virtual int getOutputSize();
+    virtual void fromOneHot(real *outputs, real *one_hot_outputs);
+    virtual void toOneHot(real *outputs, real *one_hot_outputs);
+
+    virtual ~TwoClassFormat();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/WeightedSumMachine.cc work/main.d/Torch-3/core/WeightedSumMachine.cc
--- tmp/Torch-3/core/WeightedSumMachine.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/WeightedSumMachine.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,110 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "WeightedSumMachine.h"
+
+namespace Torch {
+
+WeightedSumMachine::WeightedSumMachine(Trainer **trainers_, int n_trainers_, MeasurerList** trainers_measurers_, real *weights_)
+{
+  // Boaf
+  trainers = trainers_;
+  trainers_measurers = trainers_measurers_;
+  n_trainers = n_trainers_;
+
+  n_outputs = trainers[0]->machine->outputs->frame_size;
+  for(int i = 0; i < n_trainers; i++)
+  {
+    if(n_outputs != trainers[i]->machine->outputs->frame_size)
+      error("WeightedSumMachine: provided machines don't have the same output size!");
+  }
+  outputs = new(allocator) Sequence(0, n_outputs);
+
+  if(weights_)
+    weights = weights_;
+  else
+  {
+    weights = (real *)allocator->alloc(n_trainers*sizeof(real));
+    for(int i = 0; i < n_trainers; i++)
+      weights[i] = 0;
+  }
+
+  n_trainers_trained = 0;
+}
+
+void WeightedSumMachine::reset()
+{
+  for (int i=0;i<n_trainers;i++)
+    trainers[i]->machine->reset();
+  n_trainers_trained = 0;
+}
+
+void WeightedSumMachine::forward(Sequence *inputs)
+{
+  for(int i = 0; i < n_trainers_trained; i++)
+    trainers[i]->machine->forward(inputs);
+
+  int n_frames = trainers[0]->machine->outputs->n_frames;
+  outputs->resize(n_frames);  
+  for(int i = 0; i < n_frames; i++)
+  {
+    real *dest_ = outputs->frames[i];
+    for(int j = 0; j < n_outputs; j++)
+      dest_[j] = 0;
+    
+    for(int j = 0; j < n_trainers_trained; j++)
+    {
+      real z = weights[j];
+      real *src_ = trainers[j]->machine->outputs->frames[i];
+      for(int k = 0; k < n_outputs; k++)
+        dest_[k] += z * src_[k];
+    }
+  }
+}
+
+void WeightedSumMachine::loadXFile(XFile *file)
+{
+  file->taggedRead(&n_trainers_trained, sizeof(int), 1, "NTRAINERS");
+  file->taggedRead(weights, sizeof(real), n_trainers, "WEIGHTS");  
+  for (int i = 0; i < n_trainers; i++)
+    trainers[i]->loadXFile(file);
+}
+
+void WeightedSumMachine::saveXFile(XFile *file)
+{
+  file->taggedWrite(&n_trainers_trained, sizeof(int), 1, "NTRAINERS");
+  file->taggedWrite(weights, sizeof(real), n_trainers, "WEIGHTS");
+  for (int i = 0; i < n_trainers; i++)
+    trainers[i]->saveXFile(file);
+}
+
+WeightedSumMachine::~WeightedSumMachine()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/WeightedSumMachine.h work/main.d/Torch-3/core/WeightedSumMachine.h
--- tmp/Torch-3/core/WeightedSumMachine.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/WeightedSumMachine.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,91 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef WEIGHTED_SUM_MACHINE_INC
+#define WEIGHTED_SUM_MACHINE_INC
+
+#include "Trainer.h"
+
+namespace Torch {
+
+/** Weighted-sum machine.
+    This class contains a series of #Trainers#, and its forward method
+    simply performs the average of the output of each machine associated to
+    the trainer on the same input.
+
+    @see Bagging
+    @see Boosting
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class WeightedSumMachine : public Machine
+{
+  public:
+    /// Output frame size
+    int n_outputs;
+
+    /// The trainers used in the combination.
+    Trainer **trainers;
+
+    /// The corresponding measurers.
+    MeasurerList **trainers_measurers;
+
+    /// The number of trainers in the combination.
+    int n_trainers;
+
+    /** The number of trainers that have been already trained.
+        After the initialization, it's zero.
+        Note that the forward method depends on this value.
+        (only the first #n_trainers_trained# trainers are used)
+    */
+    int n_trainers_trained;
+
+    /// The weights of the combination.
+    real *weights;
+
+    /// True if the weights aren't given by the user, false otherwise.
+    bool weights_is_allocated;
+
+    /** #trainers_measurers# is an array which possibly specify the measurers which
+        should be given to the corresponding trainer when training.
+        If #weights_# isn't specified, weights are setted to zero.
+    */
+    WeightedSumMachine(Trainer **trainer_, int n_trainers_, MeasurerList **trainers_measurers, real *weights_=NULL);
+
+    //-----
+
+    virtual void forward(Sequence *inputs);
+    virtual void reset();
+    virtual void loadXFile(XFile *file);
+    virtual void saveXFile(XFile *file);
+
+    virtual ~WeightedSumMachine();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/XFile.cc work/main.d/Torch-3/core/XFile.cc
--- tmp/Torch-3/core/XFile.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/XFile.cc	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,76 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "XFile.h"
+
+namespace Torch {
+
+XFile::XFile()
+{
+}
+
+int XFile::taggedRead(void *ptr, int block_size, int n_blocks, const char *tag)
+{
+  int tag_size;
+  this->read(&tag_size, sizeof(int), 1);
+  if(tag_size != (int)strlen(tag))
+    error("XFile: sorry, the tag <%s> cannot be read!", tag);
+
+  char *tag_ = (char *)Allocator::sysAlloc(tag_size+1);
+  tag_[tag_size] = '\0';
+  this->read(tag_, 1, tag_size);
+
+  if(strcmp(tag, tag_))
+    error("XFile: tag <%s> not found!", tag);
+  free(tag_);
+
+  int block_size_;
+  int n_blocks_;
+  this->read(&block_size_, sizeof(int), 1);
+  this->read(&n_blocks_, sizeof(int), 1);
+
+  if( (block_size_ != block_size) || (n_blocks_ != n_blocks) )
+    error("XFile: tag <%s> has a corrupted size!", tag);
+
+  return this->read(ptr, block_size, n_blocks);
+}
+
+int XFile::taggedWrite(void *ptr, int block_size, int n_blocks, const char *tag){
+  int tag_size = strlen(tag);
+  this->write(&tag_size, sizeof(int), 1);
+  this->write((char *)tag, 1, tag_size);
+  this->write(&block_size, sizeof(int), 1);
+  this->write(&n_blocks, sizeof(int), 1);
+  return this->write(ptr, block_size, n_blocks);
+}
+
+XFile::~XFile()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/core/XFile.h work/main.d/Torch-3/core/XFile.h
--- tmp/Torch-3/core/XFile.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/core/XFile.h	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,96 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef X_FILE_INC
+#define X_FILE_INC
+
+#include "Object.h"
+
+namespace Torch {
+
+/** XFile. A File which could be anything.
+    The syntax (and results) for method is very similar
+    to C FILE. (Except for the FILE pointer which is not
+    given in the parameters!).
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class XFile : public Object
+{
+  public:
+
+    ///
+    XFile();
+
+    /// Read something.
+    virtual int read(void *ptr, int block_size, int n_blocks) = 0;
+
+    /// Write.
+    virtual int write(void *ptr, int block_size, int n_blocks) = 0;
+
+    /** Read and check the tag/the size. To be used with #taggedWrite()#.
+        If the tag and the size readed doesn't correspond to the given
+        tag and size, an error will occur.
+    */
+    int taggedRead(void *ptr, int block_size, int n_blocks, const char *tag);
+
+    /// Write and write the tag/the size.
+    int taggedWrite(void *ptr, int block_size, int n_blocks, const char *tag);
+
+    /// Are we at the end ?
+    virtual int eof() = 0;
+
+    /// Flush the file.
+    virtual int flush() = 0;
+
+    /// Seek.
+    virtual int seek(long offset, int whence) = 0;
+
+    /// Tell me where am I...
+    virtual long tell() = 0;
+    
+    /// Rewind.
+    virtual void rewind() = 0;
+
+    /// Print some text.
+    virtual int printf(const char *format, ...) = 0;
+
+    /// Scan some text.
+    virtual int scanf(const char *format, void *ptr) = 0;
+
+    /// Get one line (read at most #size_# characters).
+    virtual char *gets(char *dest, int size_) = 0;
+
+    //-----
+
+    virtual ~XFile();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/DiskHTKDataSet.cc work/main.d/Torch-3/datasets/DiskHTKDataSet.cc
--- tmp/Torch-3/datasets/DiskHTKDataSet.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/DiskHTKDataSet.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,103 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "DiskHTKDataSet.h"
+#include "IOHTK.h"
+#include "IOHTKTarget.h"
+#include "IOSub.h"
+#include "IOMulti.h"
+
+namespace Torch {
+
+DiskHTKDataSet::DiskHTKDataSet(const char *inputs_filename, bool one_file_is_one_sequence, int max_load, const char *targets_filename, LexiconInfo* lex_, bool words)
+{
+	IOHTK* io_inputs_ptr = new(allocator) IOHTK(inputs_filename, one_file_is_one_sequence, max_load,true);
+	io_inputs = io_inputs_ptr;
+	
+  io_targets = NULL;
+	if(targets_filename) {
+    n_per_frame = (int)(io_inputs_ptr->header->sample_period);
+		io_targets = new(allocator) IOHTKTarget(targets_filename, lex_, n_per_frame, words);
+  }
+
+  DiskDataSet::init(io_inputs, io_targets);
+  message("DiskHTKDataSet: %d examples loaded", n_examples);
+
+}
+
+DiskHTKDataSet::DiskHTKDataSet(char **inputs_filenames, char ** targets_filename, int n_files_, bool one_file_is_one_sequence, int max_load, LexiconInfo* lex_, bool words)
+{
+  
+	if(n_files_ <= 0)
+    error("DiskHTKDataSet: check the number of files!");
+
+	//inputs
+	int n_files = n_files_;
+
+  IOHTK **io_files = (IOHTK **)allocator->alloc(sizeof(IOHTK *)*n_files_);
+  if(max_load > 0)
+  {
+    int i = 0;
+    while( (max_load > 0) && (i < n_files_) )
+    {
+        io_files[i] = new(allocator) IOHTK(inputs_filenames[i], one_file_is_one_sequence, max_load, true);
+				max_load -= io_files[i]->n_sequences;
+				i++;
+    }
+    n_files = i;
+  }
+  else
+  {
+      for(int i = 0; i < n_files_; i++)
+        io_files[i] = new(allocator) IOHTK(inputs_filenames[i], one_file_is_one_sequence, -1, true);
+  }
+  
+	io_inputs = new(allocator) IOMulti((IOSequence**)io_files, n_files);
+	
+	//targets 
+	io_targets = NULL;
+	if(targets_filename){
+    n_per_frame = (int)(io_files[0]->header->sample_period);
+		IOHTKTarget **io_files_targets = (IOHTKTarget **)allocator->alloc(sizeof(IOHTKTarget *)*n_files_);
+		for ( int i=0; i < n_files_;i++)
+			io_files_targets[i] = new(allocator) IOHTKTarget(inputs_filenames[i], lex_, n_per_frame, words);
+		io_targets = new(allocator) IOMulti((IOSequence**)io_files_targets, n_files_);
+	}
+
+  
+	DiskDataSet::init(io_inputs, io_targets);
+  message("DiskHTKDataSet: %d examples loaded", n_examples);
+}
+
+
+
+DiskHTKDataSet::~DiskHTKDataSet()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/DiskHTKDataSet.h work/main.d/Torch-3/datasets/DiskHTKDataSet.h
--- tmp/Torch-3/datasets/DiskHTKDataSet.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/DiskHTKDataSet.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,66 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DISK_HTK_DATA_SET_INC
+#define DISK_HTK_DATA_SET_INC
+
+#include "DiskDataSet.h"
+#include "MeanVarNorm.h"
+#include "IOHTK.h"
+#include "LexiconInfo.h"
+
+namespace Torch {
+
+/** Provides an interface to manipulate HTK data which are
+    kept on disk, and not fully loaded in memory.
+    It uses #IOSequence#.
+    Usefull for large databases.
+
+    @see DiskMatDataSet
+    @see IOSequence
+		@see IOHTK
+		@see IOHTKTarget
+		@author Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+ */
+class DiskHTKDataSet : public DiskDataSet
+{
+  private:
+    void init_(IOSequence *io_file, int n_inputs_, int n_targets_);
+
+  public:
+    int n_per_frame;
+
+    DiskHTKDataSet(const char *inputs_filenames, bool one_file_is_one_sequence, int max_load, const char * targets_filename = NULL, LexiconInfo* lex_=NULL, bool words=true);
+    DiskHTKDataSet(char **inputs_filenames, char ** targets_filename, int n_files_, bool one_file_is_one_sequence, int max_load, LexiconInfo* lex_=NULL, bool words=true);
+
+    virtual ~DiskHTKDataSet();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/ExampleFrameSelectorDataSet.cc work/main.d/Torch-3/datasets/ExampleFrameSelectorDataSet.cc
--- tmp/Torch-3/datasets/ExampleFrameSelectorDataSet.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/ExampleFrameSelectorDataSet.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,163 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "ExampleFrameSelectorDataSet.h"
+
+namespace Torch {
+
+ExampleFrameSelectorDataSet::ExampleFrameSelectorDataSet(DataSet *data_)
+{
+  data = data_;
+  if(data->n_examples == 0)
+    error("ExampleFrameSelectorDataSet: cannot handle DataSet with no examples");
+
+	internal = NULL;
+	
+	DataSet::init(data->n_examples, data->n_inputs, data->n_targets);
+	n_max_internal = n_examples;
+	selected_example_size = n_examples;
+
+  data->setExample(0);
+  if(n_inputs > 0)
+    inputs = new(allocator) Sequence(0, n_inputs);
+  else
+    inputs = NULL;
+
+  if(n_targets > 0)
+    targets = new(allocator) Sequence(0, n_targets);
+	else
+		targets = NULL;
+  
+  n_pushed_examples = 0;
+  n_max_pushed_examples = 0;
+  pushed_examples = NULL;
+	n_max_internal = 0;
+	n_examples = 0;
+	n_real_examples = n_examples;
+}
+
+void ExampleFrameSelectorDataSet::addExample(int t, int inputs_start_indices_, int n_inputs_frames_, int targets_start_indices_, int n_targets_frames_)
+{
+	int index = n_examples++;
+	n_real_examples = n_examples;
+	if(n_examples > n_max_internal){
+		n_max_internal++;
+		internal = (InternalAMoi *)allocator->realloc(internal, sizeof(InternalAMoi)*(n_max_internal));
+	}
+	internal[index].data_index = t;
+	internal[index].start_inputs_frame = inputs_start_indices_;
+	internal[index].start_targets_frame = targets_start_indices_;
+	internal[index].n_selected_inputs_frames = n_inputs_frames_;
+	internal[index].n_selected_targets_frames = n_targets_frames_;
+  
+	if(n_examples >= selected_example_size){
+		selected_example_size *= 2;
+		allocator->free(selected_examples);
+		selected_examples = (int *)allocator->alloc(sizeof(int)*selected_example_size);
+		for(int i = 0; i < selected_example_size; i++)
+			selected_examples[i] = i;
+	}
+}
+
+void ExampleFrameSelectorDataSet::preProcess(PreProcessing *pre_processing)
+{
+	error("ExampleFrameSelectorDataSet: preProcess() not supported !!");
+}
+
+void ExampleFrameSelectorDataSet::removeExample(int t){
+
+	InternalAMoi* ptr = internal+t;
+	InternalAMoi* to_copy_ptr = internal+t+1;
+	for(int i=t;i<n_examples;i++){
+		*ptr++ = *to_copy_ptr++;
+	}
+	n_examples--;
+	n_real_examples = n_examples;
+}
+
+void ExampleFrameSelectorDataSet::getNumberOfFrames(int t_, int *n_input_frames_, int *n_target_frames_)
+{
+  if (n_input_frames_)
+	  *n_input_frames_ = internal[t_].n_selected_inputs_frames;
+  if (n_target_frames_)
+	  *n_target_frames_ = internal[t_].n_selected_targets_frames;
+}
+
+void ExampleFrameSelectorDataSet::setRealExample(int t, bool set_inputs, bool set_targets)
+{
+	InternalAMoi* ptr = internal + t;
+  data->setExample(ptr->data_index, set_inputs, set_targets);
+
+  if(set_inputs){
+		inputs->resize(ptr->n_selected_inputs_frames, false);
+		for(int i = 0; i < ptr->n_selected_inputs_frames; i++)
+			inputs->frames[i] = data->inputs->frames[ptr->start_inputs_frame+i];
+	}
+	
+  if(set_targets)
+  {
+		targets->resize(ptr->n_selected_targets_frames, false);
+		for(int i = 0; i < ptr->n_selected_targets_frames; i++)
+			targets->frames[i] = data->targets->frames[ptr->start_targets_frame+i];
+	}
+
+  real_current_example_index = t;
+}
+
+void ExampleFrameSelectorDataSet::pushExample()
+{
+  data->pushExample();
+ 
+  pushed_examples->push(&inputs, sizeof(Sequence *));
+  pushed_examples->push(&targets, sizeof(Sequence *));
+  pushed_examples->push(&real_current_example_index, sizeof(int));
+
+  if(n_inputs > 0)
+    inputs = new(allocator) Sequence(0, n_inputs);
+  if(n_targets > 0)
+    targets = new(allocator) Sequence(0, n_targets);
+  real_current_example_index = -1;
+}
+
+void ExampleFrameSelectorDataSet::popExample()
+{
+  allocator->free(inputs);
+  allocator->free(targets);
+
+  pushed_examples->pop();
+  pushed_examples->pop();
+  pushed_examples->pop();
+  data->popExample();
+}
+
+
+ExampleFrameSelectorDataSet::~ExampleFrameSelectorDataSet()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/ExampleFrameSelectorDataSet.h work/main.d/Torch-3/datasets/ExampleFrameSelectorDataSet.h
--- tmp/Torch-3/datasets/ExampleFrameSelectorDataSet.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/ExampleFrameSelectorDataSet.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,92 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef EXAMPLE_FRAME_SELECTOR_DATA_SET_INC
+#define EXAMPLE_FRAME_SELECTOR_DATA_SET_INC
+
+#include "DataSet.h"
+
+namespace Torch {
+
+struct InternalAMoi{
+	int data_index;
+	int start_inputs_frame;
+	int start_targets_frame;
+	int n_selected_inputs_frames;
+	int n_selected_targets_frames;
+};
+
+
+/**
+	This dataset is empty at the begining. Each subsequence of the original dataset
+	can be added/remove by the methods:
+	\begin{itemize}
+	\item addExample
+	\item removeExample
+	\end{itemize}
+	@see FrameSelectorDataSet
+	@author Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+	*/
+
+class ExampleFrameSelectorDataSet : public DataSet
+{
+  private:
+    int n_pushed_examples;
+    int n_max_pushed_examples;
+		InternalAMoi* internal;
+		int n_max_internal;
+		int selected_example_size;
+
+  public:
+    DataSet *data;
+    int *n_selected_input_frames;
+    int *n_selected_target_frames;
+    int **input_frames_indices;
+    int **target_frames_indices;
+
+    ///
+    ExampleFrameSelectorDataSet(DataSet *data_);
+
+		void addExample(int t, int inputs_start_indices_, int n_inputs_frames_, 
+		 												int targets_start_indices_, int n_targets_frames_);
+
+		void removeExample(int t);
+		virtual void getNumberOfFrames(int t_, int *n_input_frames_, int *n_target_frames_);
+    virtual void setRealExample(int t, bool set_inputs, bool set_targets);
+    virtual void pushExample();
+    virtual void popExample();
+
+virtual void preProcess(PreProcessing *pre_processing);
+    //-----
+
+    virtual ~ExampleFrameSelectorDataSet();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/HTKDataSet.cc work/main.d/Torch-3/datasets/HTKDataSet.cc
--- tmp/Torch-3/datasets/HTKDataSet.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/HTKDataSet.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,109 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "HTKDataSet.h"
+#include "IOHTK.h"
+#include "IOHTKTarget.h"
+#include "IOSub.h"
+#include "IOMulti.h"
+
+namespace Torch {
+
+HTKDataSet::HTKDataSet(const char *inputs_filename, bool one_file_is_one_sequence, int max_load, const char *targets_filename, LexiconInfo* lex_, bool words)
+{
+  io_allocator = new Allocator;
+
+	IOHTK* io_inputs = new(io_allocator) IOHTK(inputs_filename, one_file_is_one_sequence, max_load,true);
+	
+  IOHTKTarget* io_targets = NULL;
+	if(targets_filename) {
+    n_per_frame = (int)(io_inputs->header->sample_period);
+		io_targets = new(io_allocator) IOHTKTarget(targets_filename, lex_, n_per_frame, words);
+  }
+
+  MemoryDataSet::init(io_inputs, io_targets);
+  message("HTKDataSet: %d examples loaded", n_examples);
+	
+	delete io_allocator;
+}
+
+HTKDataSet::HTKDataSet(char **inputs_filenames, char ** targets_filenames, int n_files_, bool one_file_is_one_sequence, int max_load, LexiconInfo* lex_, bool words)
+{
+
+  io_allocator = new Allocator;
+	
+	if(n_files_ <= 0)
+    error("HTKDataSet: check the number of files!");
+
+	//inputs
+	int n_files = n_files_;
+
+  IOHTK **io_files = (IOHTK **)io_allocator->alloc(sizeof(IOHTK *)*n_files_);
+  if(max_load > 0)
+  {
+    int i = 0;
+    while( (max_load > 0) && (i < n_files_) )
+    {
+        io_files[i] = new(io_allocator) IOHTK(inputs_filenames[i], one_file_is_one_sequence, max_load, true);
+				max_load -= io_files[i]->n_sequences;
+				i++;
+    }
+    n_files = i;
+  }
+  else
+  {
+      for(int i = 0; i < n_files_; i++) 
+        io_files[i] = new(io_allocator) IOHTK(inputs_filenames[i], one_file_is_one_sequence, -1, true);
+  }
+  
+	IOMulti* io_inputs = new(io_allocator) IOMulti((IOSequence**)io_files, n_files);
+	
+	//targets 
+	IOMulti* io_targets = NULL;
+	if(targets_filenames){
+    n_per_frame = (int)(io_files[0]->header->sample_period);
+		IOHTKTarget **io_files_targets = (IOHTKTarget **)io_allocator->alloc(sizeof(IOHTKTarget *)*n_files);
+		for ( int i=0; i < n_files;i++)
+			io_files_targets[i] = new(io_allocator) IOHTKTarget(targets_filenames[i], lex_, n_per_frame, words);
+		io_targets = new(io_allocator) IOMulti((IOSequence**)io_files_targets, n_files);
+	}
+
+  
+	MemoryDataSet::init(io_inputs, io_targets);
+  message("HTKDataSet: %d examples loaded", n_examples);
+
+	delete io_allocator;
+}
+
+
+
+HTKDataSet::~HTKDataSet()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/HTKDataSet.h work/main.d/Torch-3/datasets/HTKDataSet.h
--- tmp/Torch-3/datasets/HTKDataSet.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/HTKDataSet.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,66 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef HTK_DATA_SET_INC
+#define HTK_DATA_SET_INC
+
+#include "MemoryDataSet.h"
+#include "MeanVarNorm.h"
+#include "IOHTK.h"
+#include "LexiconInfo.h"
+
+namespace Torch {
+
+/** This dataset can deal with the HTK format for features and targets.
+
+	@see MatDataSet
+	@see IOHTK
+	@see IOHTKTarget
+	@author Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+*/
+class HTKDataSet : public MemoryDataSet
+{
+  private:
+    void init_(IOSequence *io_file, int n_inputs_, int n_targets_);
+    Allocator *io_allocator;
+
+  public:
+    int n_per_frame;
+
+    ///
+    HTKDataSet(const char *inputs_filenames, bool one_file_is_one_sequence, int max_load, const char * targets_filename = NULL, LexiconInfo* lex_=NULL, bool words=true);
+
+    ///
+    HTKDataSet(char **inputs_filenames, char ** targets_filename, int n_files_, bool one_file_is_one_sequence, int max_load, LexiconInfo* lex_=NULL, bool words=true);
+
+    virtual ~HTKDataSet();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/IOHTK.cc work/main.d/Torch-3/datasets/IOHTK.cc
--- tmp/Torch-3/datasets/IOHTK.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/IOHTK.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,283 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "IOHTK.h"
+#include "DiskXFile.h"
+
+namespace Torch {
+
+//several kind of features
+static const char *pmkmap[] = {"WAVEFORM", "LPC", "LPREFC", "LPCEPSTRA", 
+  "LPDELCEP", "IREFC", 
+  "MFCC", "FBANK", "MELSPEC",
+  "USER", "DISCRETE", 
+  "ANON"};
+
+
+IOHTK::IOHTK(const char *filename_, bool one_file_is_one_sequence_, int max_load_, bool is_sequential_)
+{
+  // Boaf...
+  one_file_is_one_sequence = one_file_is_one_sequence_;
+  max_load = max_load_;
+  is_sequential = is_sequential_;
+
+  filename = (char *)allocator->alloc(strlen(filename_)+1);
+  header = (HTKHeader *)allocator->alloc(sizeof(HTKHeader));
+  strcpy(filename, filename_);
+
+  // Read the file...
+  file = new(allocator) DiskXFile(filename, "r");
+
+	// Read the header
+  readHeader(file);
+
+	//vector size and number of frames
+  n_total_frames = header->n_samples;
+  frame_size =  header->sample_size/4;
+	
+	//some error check
+  if(!(n_total_frames >= 0)||!(frame_size>0))
+    error("IOHTK: file %s is probably not an HTK file format\n",filename);
+
+  if( (max_load > 0) && (max_load < n_total_frames) && (!one_file_is_one_sequence) )
+  {
+    n_total_frames = max_load;
+    message("IOHTK: loading only %d rows", n_total_frames);
+  }
+
+  // Prepare the sequence buffer...
+  if(one_file_is_one_sequence)
+    n_sequences = 1;
+  else
+    n_sequences = n_total_frames;
+  
+  current_frame_index = -1;  
+	allocator->free(file);
+}
+
+void IOHTK::readHeader(XFile* file_){
+
+  file_->read(&header->n_samples,sizeof(long),1);
+  file_->read(&header->sample_period,sizeof(long),1);
+  file_->read(&header->sample_size,sizeof(short),1);
+  file_->read(&header->sample_kind,sizeof(short),1);
+
+}
+
+
+void IOHTK::getSequence(int t, Sequence* sequence)
+{
+  // Cas simple: on lit tout le bordel
+  if(one_file_is_one_sequence)
+  {
+    file = new(allocator) DiskXFile(filename, "r");
+		readHeader(file);
+
+#ifdef USE_DOUBLE
+		float* temp = (float*)allocator->alloc(sizeof(float)*frame_size);
+    for(int i = 0; i < n_total_frames; i++){
+			file->read(temp, sizeof(float),frame_size);
+			for(int j = 0; j < frame_size; j++)
+				sequence->frames[i][j] = temp[j];
+		}
+		allocator->free(temp);
+#else
+    for(int i = 0; i < n_total_frames; i++)
+      file->read(sequence->frames[i], sizeof(real), frame_size);
+#endif
+    allocator->free(file);
+  }
+  else
+  {
+    // Sequentiel ?
+    if(is_sequential)
+    {
+      if(t != current_frame_index+1)
+        error("IOBin: sorry, data are accessible only in a sequential way");
+      
+      // Doit-on ouvrir le putain de fichier ?
+      if(current_frame_index < 0)
+      {
+        file = new(allocator) DiskXFile(filename, "r");
+				readHeader(file);
+      }
+    }
+    else
+    {
+      file = new(allocator) DiskXFile(filename, "r");
+      if(file->seek(t*frame_size*sizeof(real)+2*sizeof(long)+2*sizeof(short), SEEK_CUR) != 0)
+        error("IOBin: cannot seek in your file!");
+    }
+
+    // Lis la frame mec
+#ifdef USE_DOUBLE
+		float* temp = (float*)allocator->alloc(sizeof(float)*frame_size);
+			file->read(temp, sizeof(float),frame_size);
+			for(int j = 0; j < frame_size; j++)
+				sequence->frames[0][j] = temp[j];
+		allocator->free(temp);
+#else
+    file->read(sequence->frames[0], sizeof(real), frame_size);
+#endif
+
+    if(is_sequential)
+    {
+      // Si je suis a la fin du fichier, je le zigouille.
+      current_frame_index++;
+      if(current_frame_index == n_total_frames-1)
+      {
+        allocator->free(file);
+        current_frame_index = -1;
+      }
+    }
+    else
+      allocator->free(file);
+  }
+
+}
+
+int IOHTK::getNumberOfFrames(int t)
+{
+  if(one_file_is_one_sequence)
+    return n_total_frames;
+  else
+    return 1;
+}
+
+int IOHTK::getTotalNumberOfFrames()
+{
+  return n_total_frames;
+}
+
+
+void IOHTK::saveSequence(XFile *file, Sequence* sequence, HTKHeader* header_)
+{
+		file->write(&header_->n_samples,sizeof(long),1);
+		file->write(&header_->sample_period,sizeof(long),1);
+		file->write(&header_->sample_size,sizeof(short),1);
+		file->write(&header_->sample_kind,sizeof(short),1);
+#ifdef USE_DOUBLE
+		float* temp = (float*)Allocator::sysAlloc(sizeof(float)*sequence->frame_size);
+			for(int i = 0; i < sequence->n_frames; i++){
+				for(int j = 0; j < sequence->frame_size; j++)
+					temp[j] = (float)sequence->frames[i][j];
+				file->write(temp, sizeof(float), sequence->frame_size);
+			}
+		free(temp);
+#else
+  for(int i = 0; i < sequence->n_frames; i++)
+    file->write(sequence->frames[i], sizeof(real), sequence->frame_size);
+#endif
+}
+
+
+IOHTK::~IOHTK()
+{
+}
+
+/******************* HTK source code **********************/
+
+char* IOHTK::parmKind2Str(ParmKind the_kind, char* buf)
+{
+  strcpy(buf,pmkmap[baseParmKind(the_kind)]);
+  if (hasEnergy(the_kind))    strcat(buf,"_E");
+  if (hasDelta(the_kind))     strcat(buf,"_D");
+  if (hasNulle(the_kind))     strcat(buf,"_N");
+  if (hasAccs(the_kind))      strcat(buf,"_A");
+  if (hasCompx(the_kind))     strcat(buf,"_C");
+  if (hasCrcc(the_kind))      strcat(buf,"_K");
+  if (hasZerom(the_kind))     strcat(buf,"_Z");
+  if (hasZeroc(the_kind))     strcat(buf,"_0");
+  if (hasVQ(the_kind))        strcat(buf,"_V");
+  return buf;
+}
+
+ParmKind IOHTK::str2ParmKind(char *str)
+{
+  ParmKind i = -1;
+  char *s,buf[255];
+  bool hasE,hasD,hasN,hasA,hasC,hasK,hasZ,has0,hasV,found;
+  int len;
+
+  hasV=hasE=hasD=hasN=hasA=hasC=hasK=hasZ=has0=false;
+  strcpy(buf,str);len=strlen(buf);
+  s=buf+len-2;
+  while (len>2 && *s=='_') {
+    switch(*(s+1)){
+      case 'E': hasE = true;break;
+      case 'D': hasD = true;break;
+      case 'N': hasN = true;break;
+      case 'A': hasA = true;break;
+      case 'C': hasC = true;break;
+      case 'K': hasK = true;break;
+      case 'Z': hasZ = true;break;
+      case '0': has0 = true;break;
+      case 'V': hasV = true;break;
+      default: error("str2ParmKind: unknown ParmKind qualifier %s",str);
+               exit (-1);
+    }
+    *s = '\0';len -= 2;s -= 2;
+  }
+  found = false;
+  do {
+    s=(char*)pmkmap[++i];
+    if (strcmp(buf,s) == 0) {
+      found = true;
+      break;
+    }
+  } while (strcmp("ANON",s)!=0);
+  if (!found)
+    return ANON;
+  if (i == LPDELCEP)         /* for backward compatibility with V1.2 */
+    i = LPCEPSTRA | HASDELTA;
+  if (hasE) i |= HASENERGY;
+  if (hasD) i |= HASDELTA;
+  if (hasN) i |= HASNULLE;
+  if (hasA) i |= HASACCS;
+  if (hasK) i |= HASCRCC;
+  if (hasC) i |= HASCOMPX;
+  if (hasZ) i |= HASZEROM;
+  if (has0) i |= HASZEROC;
+  if (hasV) i |= HASVQ;
+  return i;
+}
+
+ParmKind IOHTK::baseParmKind(ParmKind k) { return k & BASEMASK;}
+
+/* EXPORT->HasXXXX: returns true if XXXX included in ParmKind */
+bool IOHTK::hasEnergy(ParmKind k){return (k & HASENERGY) != 0;}
+bool IOHTK::hasDelta(ParmKind k) {return (k & HASDELTA) != 0;}
+bool IOHTK::hasAccs(ParmKind k)  {return (k & HASACCS) != 0;}
+bool IOHTK::hasNulle(ParmKind k) {return (k & HASNULLE) != 0;}
+bool IOHTK::hasCompx(ParmKind k) {return (k & HASCOMPX) != 0;}
+bool IOHTK::hasCrcc(ParmKind k)  {return (k & HASCRCC) != 0;}
+bool IOHTK::hasZerom(ParmKind k) {return (k & HASZEROM) != 0;}
+bool IOHTK::hasZeroc(ParmKind k) {return (k & HASZEROC) != 0;}
+bool IOHTK::hasVQ(ParmKind k)    {return (k & HASVQ) != 0;}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/IOHTK.h work/main.d/Torch-3/datasets/IOHTK.h
--- tmp/Torch-3/datasets/IOHTK.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/IOHTK.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,133 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef IO_HTK_INC
+#define IO_HTK_INC
+
+#include "IOSequence.h"
+#include "DiskXFile.h"
+
+namespace Torch {
+
+// HTK File Header 
+struct HTKHeader {              
+    long  n_samples;
+    long  sample_period;
+    short sample_size;
+    short sample_kind;
+};
+
+#define BASEMASK  077         /* Mask to remove qualifiers */
+#define HASENERGY  0100       /* _E log energy included */
+#define HASNULLE   0200       /* _N absolute energy suppressed */
+#define HASDELTA   0400       /* _D delta coef appended */
+#define HASACCS   01000       /* _A acceleration coefs appended */
+#define HASCOMPX  02000       /* _C is compressed */
+#define HASZEROM  04000       /* _Z zero meaned */
+#define HASCRCC  010000       /* _K has CRC check */
+#define HASZEROC 020000       /* _0 0'th Cepstra included */
+#define HASVQ    040000       /* _V has VQ index attached */
+
+enum _BaseParmKind{
+  WAVEFORM,            /* Raw speech waveform (handled by HWave) */
+  LPC,LPREFC,LPCEPSTRA,LPDELCEP,   /* LP-based Coefficients */
+  IREFC,                           /* Ref Coef in 16 bit form */
+  MFCC,                            /* Mel-Freq Cepstra */
+  FBANK,                           /* Log Filter Bank */
+  MELSPEC,                         /* Mel-Freq Spectrum (Linear) */
+  USER,                            /* Arbitrary user specified data */
+  DISCRETE,                        /* Discrete VQ symbols (shorts) */
+  ANON
+};
+
+typedef short ParmKind;          /* BaseParmKind + Qualifiers */
+
+/** Handles the standard binary sequence format in HTK.
+
+   @see IOBin
+   @author Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+*/
+class IOHTK : public IOSequence
+{
+  private:
+    DiskXFile *file;
+    int current_frame_index;
+		void readHeader(XFile* file);
+
+  public:
+    bool one_file_is_one_sequence;
+    int n_total_frames;
+    char *filename;
+    int max_load;
+    bool is_sequential;
+
+		/// Contain the htk header informations
+		HTKHeader* header;
+
+    /** Reads the sequence contained in #filename#.
+        If #one_file_is_one_sequence# is false, #getSequence()# will return one sequence
+        with one frame at each call. (If calling #getSequence(t, foo)#,
+        it will put in the sequence #foo# the frame corresponding to the line #t# of the file).
+        Note also that if #one_file_is_one_sequence# is false, the access to the IO must be
+        sequential when calling #getSequence()# if #is_sequential# is true. (Sequential mode
+        is faster).
+        If #max_load_# is positive, it loads only the first #max_load_# frames,
+        if #one_file_is_one_sequence# is false.
+        The file will be opened when reading the first sequence, and closed when reading the
+        last one if #is_sequential# is true. Otherwise, the file will be opened and closed
+        each time you call #getSequence()#.
+     */
+    IOHTK(const char *filename_, bool one_file_is_one_sequence_=false, int max_load_=-1, bool is_sequential_=false);
+
+    /// Saves #sequence# in #file# using the HTK format.
+    static void saveSequence(XFile *file, Sequence *sequence, HTKHeader* header_);
+
+    virtual void getSequence(int t, Sequence *sequence);
+    virtual int getNumberOfFrames(int t);
+    virtual int getTotalNumberOfFrames();
+
+    virtual ~IOHTK();
+		
+		/// HTK source code 
+    char* parmKind2Str(ParmKind kind, char *buf);
+    ParmKind str2ParmKind(char *str);
+    ParmKind baseParmKind(ParmKind kind);
+    bool hasEnergy(ParmKind kind);
+    bool hasDelta(ParmKind kind) ;
+    bool hasAccs(ParmKind kind)  ;
+    bool hasNulle(ParmKind kind) ;
+    bool hasCompx(ParmKind kind) ;
+    bool hasCrcc(ParmKind kind)  ;
+    bool hasZerom(ParmKind kind) ;
+    bool hasZeroc(ParmKind kind) ;
+    bool hasVQ(ParmKind kind)    ;      
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/IOHTKTarget.cc work/main.d/Torch-3/datasets/IOHTKTarget.cc
--- tmp/Torch-3/datasets/IOHTKTarget.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/IOHTKTarget.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,135 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "IOHTKTarget.h"
+#include "DiskXFile.h"
+
+namespace Torch {
+
+#ifdef USE_DOUBLE
+#define REAL_FORMAT "%lf"
+#else
+#define REAL_FORMAT "%f"
+#endif
+
+
+IOHTKTarget::IOHTKTarget(const char *filename_, LexiconInfo* lex_, int n_per_frame_, bool words_)
+{
+  // Boaf...
+  lexicon = lex_;
+  n_per_frame = n_per_frame_;
+  words = words_;
+
+  one_file_is_one_sequence = true;
+  
+  filename = (char *)allocator->alloc(strlen(filename_)+1);
+  strcpy(filename, filename_);
+
+  // Read the file...
+  file = new(allocator) DiskXFile(filename, "r");
+
+    
+  char buffer[80];
+  file->gets(buffer,80);
+  char* elements[10];
+  elements[0] = strtok(buffer," \t");
+  int n_element;
+  for (n_element=1;(elements[n_element]=strtok(NULL," \t"));n_element++);
+  if(n_element == 1){
+    frame_size = 1;
+  }else if (n_element == 3){
+    frame_size = 2;
+  }else 
+    error("IOHTKTarget: this target file contains more nor 1 or 3 columns (%d)...",n_element);
+  n_total_frames = 1;
+  while(file->gets(buffer,80)){
+    n_total_frames++;
+  }
+  n_sequences = 1;
+  allocator->free(file);
+}
+
+int IOHTKTarget::getNumberOfFrames(int t)
+{
+    return n_total_frames;
+}
+
+int IOHTKTarget::getTotalNumberOfFrames()
+{
+  return n_total_frames;
+}
+
+void IOHTKTarget::saveSequence(XFile *file_, Sequence* sequence, LexiconInfo* lex_, int n_per_frame_, bool words_)
+{
+  for(int i = 0; i < sequence->n_frames; i++) {
+    if (sequence->frame_size == 2) {
+      int begin = i == 0 ? 0 : (int)(sequence->frames[i-1][1] * n_per_frame_);
+      int end = (int)(sequence->frames[i][1] *n_per_frame_);
+
+      file_->printf("%d",begin);
+      file_->printf("%d",end);
+    }
+    if(words_)
+      file_->printf("%s\n",lex_->vocabulary->words[(int)sequence->frames[i][0]]);
+    else
+      file_->printf("%s\n",lex_->phone_info->phone_names[(int)sequence->frames[i][0]]);
+  } 
+}
+
+void IOHTKTarget::getSequence(int t, Sequence* sequence)
+{
+  // Read the file...
+  char buffer[80];
+  int begin;
+  int end;
+  file = new(allocator) DiskXFile(filename, "r");
+
+  for(int i = 0; i < n_total_frames; i++) {
+    real *dest_ = sequence->frames[i];
+    if(frame_size == 2){
+      file->scanf("%d",&begin);
+      file->scanf("%d",&end);
+      dest_[1] = (real)(end/n_per_frame); 
+    }
+    file->scanf("%s",&buffer);
+    if(words)
+      dest_[0] = lexicon->vocabulary->getIndex(buffer);
+    else
+      dest_[0] = lexicon->phone_info->getIndex(buffer);
+		if (dest_[0] < 0)
+			error("IOHTKTarget::getSequence: \"%s\" not found in %s", buffer, words? "vocabulary" : "phone set");
+  }
+
+  allocator->free(file);
+}
+
+IOHTKTarget::~IOHTKTarget()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/IOHTKTarget.h work/main.d/Torch-3/datasets/IOHTKTarget.h
--- tmp/Torch-3/datasets/IOHTKTarget.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/IOHTKTarget.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,79 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef IO_HTK_TARGET_INC
+#define IO_HTK_TARGET_INC
+
+#include "IOSequence.h"
+#include "LexiconInfo.h"
+#include "DiskXFile.h"
+
+namespace Torch {
+
+/** Handles the standard Ascii HTK targets/labels format in Torch.
+    There are two format:
+    \begin{itemize}
+      \item each line is a word/phoneme
+      separated by a space).
+      \item each line consiste in two integer (begin and end of the sequence) and a string containing the label (word/phoneme)
+    \end{itemize}
+		@see IOAscii
+    @author Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+*/
+class IOHTKTarget : public IOSequence
+{
+  private:
+    DiskXFile *file;
+    int current_frame_index;
+
+  public:
+    bool one_file_is_one_sequence;
+    int n_total_frames;
+    char *filename;
+    int max_load;
+		int n_per_frame;
+		LexiconInfo* lexicon;
+		bool words;
+
+
+    IOHTKTarget(const char *filename_, LexiconInfo* lex_, int n_per_frame_, bool words=true);
+
+    /// Saves one #sequence# in #file# using the ascii format.
+    /// static added by John Dines
+		static void saveSequence(XFile *file, Sequence* sequence, LexiconInfo* lex_, int n_per_frame_, bool words_=true);
+
+    virtual void getSequence(int t, Sequence *sequence);
+    virtual int getNumberOfFrames(int t);
+    virtual int getTotalNumberOfFrames();
+
+    virtual ~IOHTKTarget();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/LexiconInfo.cc work/main.d/Torch-3/datasets/LexiconInfo.cc
--- tmp/Torch-3/datasets/LexiconInfo.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/LexiconInfo.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,253 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "LexiconInfo.h"
+#include "Allocator.h"
+
+namespace Torch {
+
+
+LexiconInfo::LexiconInfo( const char *phones_fname , const char *sil_phone , const char *pause_phone ,
+                          const char *lex_fname , const char *sent_start_word , const char *sent_end_word ,
+                          const char *sil_word )
+{
+    char line[1000] , ch , curr_word[1000] , *curr_phone ;
+    DiskXFile lex_fd( lex_fname , "r" ) ;
+    real prior=1.0 ;
+    int n_flds , index , vocab_index=0 , temp_phones[100] , temp , ind , total_n_entries ;
+    LexiconInfoEntry *curr_entry ;
+
+    n_entries = 0 ;
+    entries = NULL ;
+    sent_start_index = -1 ;
+    sent_end_index = -1 ;
+    sil_index = -1 ;
+    phone_info = NULL ;
+    vocabulary = NULL ;
+    vocab_to_lex_map = NULL ;
+
+    // Create the PhoneInfo and Vocabulary objects
+    phone_info = new(allocator) PhoneInfo( phones_fname , sil_phone , pause_phone ) ; 
+    vocabulary = new(allocator) Vocabulary( lex_fname , sent_start_word , 
+                                            sent_end_word , sil_word ) ;
+
+    // Allocate memory for mappings between vocab entries and dictionary entries.
+    vocab_to_lex_map = (VocabToLexMapEntry *)allocator->alloc( vocabulary->n_words *
+                                                               sizeof(VocabToLexMapEntry) ) ;
+    for ( int i=0 ; i<vocabulary->n_words ; i++ )
+    {
+        vocab_to_lex_map[i].n_pronuns = 0 ;
+        vocab_to_lex_map[i].pronuns = NULL ;
+    }
+
+    // Do a first pass off the file to determine the total number of pronuns.
+    total_n_entries = 0 ;
+    while ( lex_fd.gets( line , 1000 ) != NULL )
+    {
+        if ( (line[0] == '#') || (strtok( line , "(\r\n\t " ) == NULL) )
+            continue ;
+
+        total_n_entries++ ;
+    }
+    
+    // Allocate some memory
+    entries = (LexiconInfoEntry *)allocator->alloc( total_n_entries * sizeof(LexiconInfoEntry) ) ;
+    lex_fd.seek( 0 , SEEK_SET ) ;
+   
+    // Now re-read the file and fill in the entries.
+    n_entries = 0 ;
+    while ( lex_fd.gets( line , 1000 ) != NULL )
+    {
+#ifdef USE_DOUBLE
+        if ( (line[0] == '#') || ((n_flds = sscanf( line , "%[^( \t]%c%lf" , 
+                                                    curr_word , &ch , &prior)) == 0) )
+#else
+        if ( (line[0] == '#') || ((n_flds = sscanf( line , "%[^( \t]%c%f" , 
+                                                    curr_word , &ch , &prior)) == 0) )
+#endif
+        {
+            continue ;
+        }
+
+        if ( n_flds < 3 )
+            prior = 1.0 ;
+            
+        if ( n_entries >= total_n_entries )
+            error("LexiconInfo::LexiconInfo - n_entries exceeded expected\n") ;
+
+        // Find the vocab index of the new word
+        vocab_index = vocabulary->getIndex( curr_word , vocab_index ) ;
+        if ( vocab_index < 0 )
+            error("LexiconInfo::LexiconInfo - word %s not found in vocabulary\n",curr_word) ;
+        
+        // Allocate memory for the new lexicon entry.
+        curr_entry = entries + n_entries ;
+        initLexInfoEntry( curr_entry ) ;
+        
+        curr_entry->vocab_index = vocab_index ;
+        curr_entry->log_prior = log( prior ) ;
+        
+        // read in the phones for the new pronunciation
+        strtok( line , " \r\n\t" ) ;    // get past the word
+        while ( (curr_phone=strtok(NULL," \r\n\t")) != NULL )
+        {
+            // find the index of the phone's model
+            index = phone_info->getIndex( curr_phone ) ;
+
+            // Add it to the list of models we are compiling or report error
+            //   if the phone name was not found.
+            if ( (index < 0) || (index >= phone_info->n_phones) )
+                error("LexiconInfo::LexiconInfo - %s not found in phone list\n" , curr_phone) ;
+            else
+                temp_phones[(curr_entry->n_phones)++] = index ;
+        }
+
+        curr_entry->phones = (int *)allocator->alloc( curr_entry->n_phones*sizeof(int) ) ;
+        memcpy( curr_entry->phones , temp_phones , curr_entry->n_phones*sizeof(int) ) ;
+        
+        if ( curr_entry->n_phones == 0 )
+            error("LexiconInfo::LexiconInfo - %s had no phones\n",curr_word) ;
+        
+        // Update the appropriate vocab_to_lex_map entry
+        temp = ++(vocab_to_lex_map[vocab_index].n_pronuns) ;
+        vocab_to_lex_map[vocab_index].pronuns = (int *)allocator->realloc( 
+                                 vocab_to_lex_map[vocab_index].pronuns , temp * sizeof(int) ) ;
+        vocab_to_lex_map[vocab_index].pronuns[temp-1] = n_entries ;
+        
+        // Check if these are 'special' words
+        if ( vocab_index == vocabulary->sent_start_index )
+        {
+            if ( sent_start_index >= 0 )
+                error("LexiconInfo::LexiconInfo - cannot have >1 pronuns of the start word\n") ;
+            sent_start_index = n_entries ;
+        }
+        if ( vocab_index == vocabulary->sent_end_index )
+        {
+            if ( sent_end_index >= 0 )
+                error("LexiconInfo::LexiconInfo - cannot have >1 pronuns of the end word\n") ;
+            sent_end_index = n_entries ;
+        }
+        if ( vocab_index == vocabulary->sil_index )
+        {
+            if ( sil_index >= 0 )
+                error("LexiconInfo::LexiconInfo - cannot have >1 pronuns of the sil word\n") ;
+            sil_index = n_entries ;
+        }
+        
+        n_entries++ ;
+    }
+
+    if ( n_entries != total_n_entries )
+        error("LexiconInfo::LexiconInfo - unexpected n_entries\n") ;
+        
+    if ( (sent_end_index >= 0) && (sent_start_index == sent_end_index) )
+    {
+        // Create a separate, identical entry for the sent_end_index
+        //   so that there will be a separate model for the sentence end word.
+        entries = (LexiconInfoEntry *)allocator->realloc( entries , 
+                                          (n_entries+1)*sizeof(LexiconInfoEntry) ) ;
+        curr_entry = entries + n_entries ;
+        initLexInfoEntry( curr_entry ) ;
+        curr_entry->vocab_index = entries[sent_start_index].vocab_index ;
+        curr_entry->log_prior = entries[sent_start_index].log_prior ;
+        curr_entry->n_phones = entries[sent_start_index].n_phones ;
+        curr_entry->phones = (int *)allocator->alloc( curr_entry->n_phones*sizeof(int) ) ;
+        memcpy( curr_entry->phones , entries[sent_start_index].phones ,
+                curr_entry->n_phones*sizeof(int) ) ;
+
+        // Update the appropriate vocab_to_lex_map entry
+        temp = ++(vocab_to_lex_map[curr_entry->vocab_index].n_pronuns) ;
+        vocab_to_lex_map[curr_entry->vocab_index].pronuns = (int *)allocator->realloc( 
+                  vocab_to_lex_map[curr_entry->vocab_index].pronuns , temp*sizeof(int) ) ;
+        vocab_to_lex_map[curr_entry->vocab_index].pronuns[temp-1] = n_entries ;
+        
+        sent_end_index = n_entries++ ;
+    }
+    
+    if ( (sil_index >= 0) && ((sil_index==sent_start_index) || (sil_index==sent_end_index)) )
+    {
+        if ( sil_index == sent_end_index )
+            ind = sent_end_index ;
+        else
+            ind = sent_start_index ;
+            
+        // Create a separate, identical entry for the sil_index
+        //   so that there will be a separate model for the silence word.
+        entries = (LexiconInfoEntry *)allocator->realloc( entries , 
+                                          (n_entries+1)*sizeof(LexiconInfoEntry) ) ;
+        curr_entry = entries + n_entries ;
+        initLexInfoEntry( curr_entry ) ;
+        curr_entry->vocab_index = entries[ind].vocab_index ;
+        curr_entry->log_prior = entries[ind].log_prior ;
+        curr_entry->n_phones = entries[ind].n_phones ;
+        curr_entry->phones = (int *)allocator->alloc( curr_entry->n_phones*sizeof(int) ) ;
+        memcpy( curr_entry->phones , entries[ind].phones ,
+                curr_entry->n_phones*sizeof(int) ) ;
+
+        // Update the appropriate vocab_to_lex_map entry
+        temp = ++(vocab_to_lex_map[curr_entry->vocab_index].n_pronuns) ;
+        vocab_to_lex_map[curr_entry->vocab_index].pronuns = (int *)allocator->realloc( 
+                  vocab_to_lex_map[curr_entry->vocab_index].pronuns , temp*sizeof(int) ) ;
+        vocab_to_lex_map[curr_entry->vocab_index].pronuns[temp-1] = n_entries ;
+        
+        sil_index = n_entries++ ;
+    }
+}
+   
+
+LexiconInfo::~LexiconInfo()
+{
+}
+
+
+void LexiconInfo::initLexInfoEntry( LexiconInfoEntry *entry )
+{
+    entry->n_phones = 0 ;
+    entry->phones = NULL ;
+    entry->log_prior = 0.0 ;
+    entry->vocab_index = -1 ;
+}
+
+
+#ifdef DEBUG
+void LexiconInfo::outputText()
+{
+    printf("n_entries=%d  start_ind=%d  end_ind=%d  sil_ind=%d\n",n_entries,sent_start_index,
+           sent_end_index,sil_index) ;
+    for ( int i=0 ; i<n_entries ; i++ )
+    {
+        printf("%-16s(%.3f)",vocabulary->getWord( entries[i].vocab_index ),entries[i].log_prior) ;
+        for ( int j=0 ; j<entries[i].n_phones ; j++ )
+            printf(" %s" , phone_info->getPhone( entries[i].phones[j] )) ;
+        printf("\n") ;
+    }
+}
+#endif
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/LexiconInfo.h work/main.d/Torch-3/datasets/LexiconInfo.h
--- tmp/Torch-3/datasets/LexiconInfo.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/LexiconInfo.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,99 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LEXICONINFO_INC
+#define LEXICONINFO_INC
+
+#include "general.h"
+#include "Object.h"
+#include "Vocabulary.h"
+#include "PhoneInfo.h"
+
+
+namespace Torch {
+
+
+typedef struct
+{
+    int n_phones ;
+    int *phones ;
+    real log_prior ;
+    int vocab_index ;
+} LexiconInfoEntry ;
+
+
+typedef struct
+{
+    int n_pronuns ;
+    int *pronuns ;
+} VocabToLexMapEntry ;
+
+
+/** 
+    This class stores information about how phonemes are assembled
+    into pronunciations. For each pronunciation, a list of indices
+    into a PhoneInfo instance is stored, along with a prior and a 
+    index into a Vocabulary instance. Information is also stored to
+    map Vocabulary entries to one or more pronunciations.
+    
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class LexiconInfo : public Object
+{
+public:
+    int n_entries ;
+    LexiconInfoEntry *entries ;
+    int sent_start_index ;
+    int sent_end_index ;
+    int sil_index ;
+    PhoneInfo *phone_info ;
+    Vocabulary *vocabulary ;
+    VocabToLexMapEntry *vocab_to_lex_map ;
+
+    /// Creates a LexiconInfo instance. 'phones_fname' is used to create a
+    ///   PhoneInfo instance (see PhoneInfo header). 'lex_fname' is used to
+    ///   create a Vocabulary instance and then to create pronunciation
+    ///   entries and the mapping between Vocabulary entries and pronunciation
+    ///   entries.
+    LexiconInfo( const char *phones_fname , const char *sil_phone , const char *pause_phone ,
+                 const char *lex_fname , const char *sent_start_word=NULL , const char *sent_end_word=NULL ,
+                 const char *sil_word=NULL ) ;
+    virtual ~LexiconInfo() ;
+
+    void initLexInfoEntry( LexiconInfoEntry *entry ) ;
+
+#ifdef DEBUG
+    void outputText() ;
+#endif
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/LICENSE work/main.d/Torch-3/datasets/LICENSE
--- tmp/Torch-3/datasets/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/LICENSE	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,28 @@
+
+Copyright (c) 2003--2004 Ronan Collobert
+Copyright (c) 2003--2004 Samy Bengio
+Copyright (c) 2003--2004 Johnny Mariéthoz
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/Makefile work/main.d/Torch-3/datasets/Makefile
--- tmp/Torch-3/datasets/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/Makefile	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,42 @@
+# get user and architecture specific options
+OS := $(shell uname -s)
+TORCHDIR := $(shell cd ..; pwd)
+include ../Makefile_options_$(OS)
+
+CC_FILES := $(wildcard *.cc)
+OBJS := $(foreach f,$(CC_FILES),$(OBJS_DIR)/$(patsubst %.cc,%.o,$(f)))
+
+all:	$(LIBTORCH)
+
+$(LIBTORCH): $(OBJS)
+	@echo "Archiving..."
+	@$(AR) $(LIBTORCH) $(OBJS)
+
+$(OBJS_DIR)/%.o: %.cc
+	@echo $<
+	@$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $@ -c $<
+
+distclean:
+	@\rm -f .deps_*
+
+clean:
+	@echo "Remove objects file and dependencies..."
+	@\rm -Rf $(OBJS) $(LIBTORCH)
+	@\rm -f .deps_$(VERSION_KEY)
+
+depend:
+	@echo "Tracking dependencies..."
+	@\rm -f .deps_$(VERSION_KEY)
+	@for file in *.cc ; do printf "$(OBJS_DIR)/" >> .deps_$(VERSION_KEY); $(DEP) $(CFLAGS_$(MODE)) $(INCS) $$file >> .deps_$(VERSION_KEY); done
+
+.deps_$(VERSION_KEY):
+	@echo ">>> Please do a 'make depend' <<<"
+	exit 10
+
+ifneq ($(MAKECMDGOALS),distclean)
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),depend)
+include .deps_$(VERSION_KEY)
+endif
+endif
+endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/PhoneInfo.cc work/main.d/Torch-3/datasets/PhoneInfo.cc
--- tmp/Torch-3/datasets/PhoneInfo.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/PhoneInfo.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,297 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "PhoneInfo.h"
+
+namespace Torch {
+
+
+PhoneInfo::PhoneInfo()
+{
+    n_phones = 0 ;
+    phone_names = NULL ;
+    sil_index = -1 ;
+    pause_index = -1 ;
+}
+
+
+PhoneInfo::PhoneInfo( const char *phones_fname , const char *sil_name , const char *pause_name )
+{
+    DiskXFile phones_fd( phones_fname , "r" ) ;
+    char *str , line[1000] ;
+    int total_n_phones ;
+    
+    if ( (phones_fname == NULL) || (strcmp(phones_fname,"")==0) )
+        error("PhoneInfo::PhoneInfo(2) - phones_fname undefined\n") ;
+        
+    n_phones = 0 ;
+    phone_names = NULL ;
+    sil_index = -1 ;
+    pause_index = -1 ;
+
+    // read the first line of the file and use it to determine the file type
+    phones_fd.gets( line , 1000 ) ;
+    if ( strstr( line , "PHONE" ) ) 
+    {
+        // This is a NOWAY format phone models file
+        readPhonesFromNoway( &phones_fd , sil_name , pause_name ) ;
+    }
+    else if ( strstr( line , "~o" ) )
+    {
+        // This is a HTK model definition file
+        readPhonesFromHTK( &phones_fd , sil_name , pause_name ) ;
+    }
+    else
+    {
+        // Assume that the file contains just a list of phone names
+        //   with 1 phone name per line.
+        // Do a first pass to determine the number of phones
+        total_n_phones = 0 ;
+        do
+        {
+            if ( (line[0] == '#') || ((str = strtok( line , " \r\n\t" )) == NULL) ) 
+                continue ;
+            total_n_phones++ ;
+        }
+        while ( phones_fd.gets( line , 1000 ) != NULL ) ;
+
+        // Allocate some memory for the list of phone names.
+        phone_names = (char **)allocator->alloc( total_n_phones * sizeof(char *) ) ;
+        phones_fd.seek( 0 , SEEK_SET ) ;
+        
+        while ( phones_fd.gets( line , 1000 ) != NULL )
+        {
+            if ( (line[0] == '#') || ((str = strtok( line , " \r\n\t" )) == NULL) ) 
+                continue ;
+
+            if ( n_phones >= total_n_phones )
+                error("PhoneInfo::PhoneInfo - n_phones exceeds expected\n") ;
+                
+            phone_names[n_phones] = (char *)allocator->alloc( (strlen(str)+1) * sizeof(char) ) ;
+            strcpy( phone_names[n_phones] , str ) ;
+
+            if ( (sil_name != NULL) && (strcmp(sil_name,str)==0) )
+            {
+                if ( sil_index >= 0 )
+                    error("PhoneInfo::PhoneInfo(2) - sil_index already defined\n") ;
+                sil_index = n_phones ;
+            }
+            if ( (pause_name != NULL) && (strcmp(pause_name,str)==0) )
+            {
+                if ( pause_index >= 0 )
+                    error("PhoneInfo::PhoneInfo(2) - pause_index already defined\n") ;
+                pause_index = n_phones ;
+            }
+
+            n_phones++ ;
+        }
+
+        if ( n_phones != total_n_phones )
+            error("PhoneInfo::PhoneInfo(2) - unexpected n_phones\n") ;
+    }
+
+    if ( (sil_name != NULL) && (strcmp(sil_name,"")!=0) && (sil_index<0) )
+        error("PhoneInfo::PhoneInfo(2) - silence phone not found\n") ;
+    if ( (pause_name != NULL) && (strcmp(pause_name,"")!=0) && (pause_index<0) ) 
+        error("PhoneInfo::PhoneInfo(2) - pause phone not found\n") ;
+}
+            
+
+PhoneInfo::~PhoneInfo()
+{
+}
+
+
+void PhoneInfo::addPhone( char *phone_name , bool is_sil , bool is_pause )
+{
+    if ( phone_name == NULL )
+        return ;
+
+    phone_names = (char **)allocator->realloc( phone_names , (n_phones+1)*sizeof(char *) ) ;
+    phone_names[n_phones] = (char *)allocator->alloc( (strlen(phone_name)+1)*sizeof(char) ) ;
+    strcpy( phone_names[n_phones] , phone_name ) ;
+
+    if ( is_sil == true )
+    {
+        if ( sil_index >= 0 )
+            error("PhoneInfo::addPhone - silence phone already defined\n") ;
+        sil_index = n_phones ;
+    }
+    if ( is_pause == true )
+    {
+        if ( pause_index >= 0 )
+            error("PhoneInfo::addPhone - pause phone already defined\n") ;
+        pause_index = n_phones ;
+    }
+    
+    n_phones++ ;
+}
+
+
+char *PhoneInfo::getPhone( int index )
+{
+    if ( (index < 0) || (index >= n_phones) )
+        error("PhoneInfo::getPhone - index out of range\n") ;
+
+    return phone_names[index] ;
+}
+
+
+int PhoneInfo::getIndex( char *phone_name )
+{
+    if ( phone_name == NULL )
+        error("PhoneInfo::getIndex - phone_name is NULL\n") ;
+
+    // Just do a linear search.
+    for ( int i=0 ; i<n_phones ; i++ )
+    {
+        if ( strcmp( phone_name , phone_names[i] ) == 0 )
+            return i ;
+    }
+
+    return -1 ;
+}
+
+
+void PhoneInfo::readPhonesFromNoway( DiskXFile *phones_fd , const char *sil_name , const char *pause_name )
+{
+    char line[1000] , str[1000] ;
+    int cnt=0 , n_states , index ;
+    
+    // Assume the first line of the file has already been read.
+    // The second line contains the number of phones in the file.
+    phones_fd->gets( line , 1000 ) ;
+    if ( sscanf( line , "%d" , &n_phones ) != 1 )
+        error("PhoneInfo::readPhonesFromNoway - error reading n_phones\n") ;
+
+    phone_names = (char **)allocator->alloc( n_phones * sizeof(char *) ) ;
+    
+    while ( phones_fd->gets( line , 1000 ) != NULL )
+    {
+        // interpret the line containing the index, n_states, name fields
+        if ( sscanf( line , "%d %d %s" , &index , &n_states , str ) != 3 )
+            error("PhoneInfo::readPhonesFromNoway - error reading index,n_st,name line\n") ;
+        if ( index != (cnt+1) )
+            error("PhoneInfo::readPhonesFromNoway - phone index mismatch\n") ;
+        
+        // add the phone to our list
+        phone_names[cnt] = (char *)allocator->alloc( (strlen(str)+1)*sizeof(char) ) ;
+        strcpy( phone_names[cnt] , str ) ;
+
+        if ( (sil_name != NULL) && (strcmp(sil_name,str)==0) )
+        {
+            if ( sil_index >= 0 )
+                error("PhoneInfo::readPhonesFromNoway - sil_index already defined\n") ;
+            sil_index = cnt ;
+        }
+        if ( (pause_name != NULL) && (strcmp(pause_name,str)==0) )
+        {
+            if ( pause_index >= 0 )
+                error("PhoneInfo::readPhonesFromNoway - pause_index already defined\n") ;
+            pause_index = cnt ;
+        }
+
+        // There are (n_states+1) lines before the next line containing a phone name.
+        // Read and discard.
+        for ( int i=0 ; i<(n_states+1) ; i++ )
+            phones_fd->gets( line , 1000 ) ;
+
+        cnt++ ;
+    }
+
+    if ( cnt != n_phones )
+        error("PhoneInfo::readPhonesFromNoway - n_phones mismatch\n") ;
+}
+        
+        
+void PhoneInfo::readPhonesFromHTK( DiskXFile *phones_fd , const char *sil_name , const char *pause_name )
+{
+    char line[1000] , *str ;
+    int total_n_phones=0 ;
+    
+    // Assume the first line of the file has already been read.
+    // Do a first pass of the file to determine the number of phones.
+    while ( phones_fd->gets( line , 1000 ) != NULL )
+    {
+        if ( strstr( line , "~h" ) != NULL )
+            total_n_phones++ ;
+    }
+
+    // Allocate memory
+    phone_names = (char **)allocator->alloc( total_n_phones * sizeof(char *) ) ;
+    phones_fd->seek( 0 , SEEK_SET ) ;
+    
+    n_phones = 0 ;
+    while ( phones_fd->gets( line , 1000 ) != NULL )
+    {
+        if ( strstr( line , "~h" ) != NULL )
+        {
+            strtok( line , "\"" ) ; // get past the ~h
+            if ( (str = strtok( NULL , "\"" )) == NULL )
+                error("PhoneInfo::readPhonesFromHTK - could not locate phone name\n") ;
+           
+            if ( n_phones >= total_n_phones )
+                error("PhoneInfo::readPhonesFromHTK - n_phones exceeds expected\n") ;
+            
+            phone_names[n_phones] = (char *)allocator->alloc( (strlen(str)+1)*sizeof(char) ) ;
+            strcpy( phone_names[n_phones] , str ) ;
+
+            if ( (sil_name != NULL) && (strcmp(sil_name,str)==0) )
+            {
+                if ( sil_index >= 0 )
+                    error("PhoneInfo::readPhonesFromHTK - sil_index already defined\n") ;
+                sil_index = n_phones ;
+            }
+            if ( (pause_name != NULL) && (strcmp(pause_name,str)==0) )
+            {
+                if ( pause_index >= 0 )
+                    error("PhoneInfo::readPhonesFromHTK - pause_index already defined\n") ;
+                pause_index = n_phones ;
+            }
+
+            n_phones++ ;
+        }
+    }
+
+    if ( total_n_phones != n_phones )
+        error("PhoneInfo::readPhonesFromHTK - unexpected n_phones\n") ;
+}
+    
+
+#ifdef DEBUG
+void PhoneInfo::outputText()
+{
+    printf("PhoneInfo: n_phones=%d sil_index=%d pause_index=%d\n",n_phones,sil_index,pause_index) ;
+    for ( int i=0 ; i<n_phones ; i++ )
+        printf("%s\n",phone_names[i]) ;
+    printf("\n") ;
+}
+#endif
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/PhoneInfo.h work/main.d/Torch-3/datasets/PhoneInfo.h
--- tmp/Torch-3/datasets/PhoneInfo.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/PhoneInfo.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,97 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef PHONEINFO_INC
+#define PHONEINFO_INC
+
+#include "general.h"
+#include "Object.h"
+#include "DiskXFile.h"
+
+namespace Torch {
+
+
+/** 
+    This class contains the names of the phonemes that make up
+    the words in the lexicon. An empty instance can be created,
+    and then phones added manually using the addPhone method,
+    or a filename can be specified containing phone information.
+    The list of phone names is then extracted automatically
+    from the file. 
+    
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class PhoneInfo : public Object
+{
+public:
+    int n_phones ;
+    char **phone_names ;
+    int sil_index ;
+    int pause_index ;
+
+    /// Creates an empty PhoneInfo instance
+    PhoneInfo() ;
+
+    /// Reads the phone information from 'phones_fname' file. 
+    /// Looks at the first line of the file. 
+    /// If it is "PHONE" then the file is assumed to be in Noway phone models format. 
+    /// If it is "~o" then the file is assumed to be in HTK model definition format.
+    /// Otherwise the file is assumed to contain just a straight list of phone names.
+    /// If the sil_name and pause_name params are set, then the indices of the
+    ///   silence and pause phonemes in the list are set.
+    PhoneInfo( const char *phones_fname , const char *sil_name=NULL , const char *pause_name=NULL ) ;
+    
+    virtual ~PhoneInfo() ;
+    
+    /// Adds a phoneme to the end of the list of phonemes.
+    /// is_sil and is_pause indicate if the phoneme is one of the special phonemes.
+    /// A phoneme can be both the silence phoneme and the pause phoneme.
+    void addPhone( char *phone_name , bool is_sil=false , bool is_pause=false ) ;
+
+    /// Returns a pointer to the phoneme name at position "index" in the list.
+    char *getPhone( int index ) ;
+
+    /// Does a linear search through the list and returns the index of the
+    ///   phoneme name supplied as a parameter.
+    /// If the phoneme was not in the list returns -1.
+    int getIndex( char *phone_name ) ;
+
+    // Internal functions.
+    void readPhonesFromNoway( DiskXFile *phones_fd , const char *sil_name=NULL , const char *pause_name=NULL ) ;
+    void readPhonesFromHTK( DiskXFile *phones_fd , const char *sil_name=NULL , const char *pause_name=NULL ) ;
+
+#ifdef DEBUG
+    void outputText() ;
+#endif
+} ;
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/Vocabulary.cc work/main.d/Torch-3/datasets/Vocabulary.cc
--- tmp/Torch-3/datasets/Vocabulary.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/Vocabulary.cc	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,269 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Vocabulary.h"
+#include "ctype.h"
+#include "log_add.h"
+#include "DiskXFile.h"
+
+
+namespace Torch {
+
+
+Vocabulary::Vocabulary( const char *lex_fname , const char *sent_start_word , const char *sent_end_word , 
+                        const char *sil_word )
+{
+    DiskXFile lex_fd( lex_fname , "r" ) ;
+    char line1[1000] , line2[1000] , *line , *prev_line ;
+    int total_n_words ;
+    
+    if ( (lex_fname == NULL) || (strcmp(lex_fname,"")==0) )
+        error("Vocabulary::Vocabulary - lexicon filename undefined\n") ;
+
+    n_words = 0 ;
+    words = NULL ;
+    sent_start_index = -1 ;
+    sent_end_index = -1 ;
+    sil_index = -1 ;
+    
+    // Do a first-pass of the file to determine memory requirements.
+    // We assume that multiple pronunciations will be grouped together.
+    line = line1 ;
+    prev_line = line2 ;
+    prev_line[0] = '\0' ;
+    total_n_words = 0 ;
+    while ( lex_fd.gets( line , 1000 ) != NULL )
+    {
+        if ( (line[0] == '#') || (strtok( line , "(\r\n\t " ) == NULL) )
+            continue ;
+
+        // Is this a new word ?
+        if ( strcmp( line , prev_line ) != 0 )
+            total_n_words++ ;
+        
+        if ( line == line1 )
+        {
+            line = line2 ; 
+            prev_line = line1 ;
+        }
+        else
+        {
+            line = line1 ;
+            prev_line = line2 ;
+        }
+    }
+
+    // Allocate the 'words' array
+    words = (char **)allocator->alloc( total_n_words * sizeof(char *) ) ;
+
+    // Return to the start of the file.
+    lex_fd.seek( 0 , SEEK_SET ) ;
+    
+    // Add words to the vocabulary.
+    // Do not add duplicates.
+    // Maintain alphabetical order.
+    while ( lex_fd.gets( line , 1000 ) != NULL )
+    {
+        if ( (line[0] == '#') || (strtok( line , "(\r\n\t " ) == NULL) )
+            continue ;
+
+        // add it to the vocabulary
+        addWord( line ) ;
+    }
+    
+    if ( n_words > total_n_words )
+        error("Vocabulary::Vocabulary - n_words exceeds expected.\n") ;
+
+    sent_start_index = -1 ;
+    if ( (sent_start_word != NULL) && (strcmp(sent_start_word,"") != 0) )
+    {
+        for ( int i=0 ; i<n_words ; i++ )
+        {
+            if ( strcmp( words[i] , sent_start_word ) == 0 )
+            {
+                if ( sent_start_index >= 0 )
+                    error("Vocabulary::Vocabulary - duplicate start words\n") ;
+                sent_start_index = i ;
+            }
+        }
+    }
+    sent_end_index = -1 ;
+    if ( (sent_end_word != NULL) && (strcmp(sent_end_word,"") != 0) )
+    {
+        for ( int i=0 ; i<n_words ; i++ )
+        {
+            if ( strcmp( words[i] , sent_end_word ) == 0 )
+            {
+                if ( sent_end_index >= 0 )
+                    error("Vocabulary::Vocabulary - duplicate end words\n") ;
+                sent_end_index = i ;
+            }
+        }
+    }
+    sil_index = -1 ;
+    if ( (sil_word != NULL) && (strcmp(sil_word,"") != 0) )
+    {
+        for ( int i=0 ; i<n_words ; i++ )
+        {
+            if ( strcmp( words[i] , sil_word ) == 0 )
+            {
+                if ( sil_index >= 0 )
+                    error("Vocabulary::Vocabulary - duplicate end words\n") ;
+                sil_index = i ;
+            }
+        }
+    }
+
+    if ( n_words != total_n_words )
+        error("Vocabulary::Vocabulary - did not get expected n_words\n") ;
+}
+
+
+Vocabulary::~Vocabulary()
+{
+}
+
+
+void Vocabulary::addWord( char *word )
+{
+    int cmp_result=0 ;
+
+	if ( word[0] == '#' )
+	{
+		// The string is a comment so don't add to vocabulary
+		return ;
+	}
+   
+    if ( n_words > 0 )
+        cmp_result = strcmp( words[n_words-1] , word ) ;
+        
+    if ( (cmp_result < 0) || (n_words == 0) )
+    {
+        // The new word belongs at the end of the list
+        // Allocate memory in the list of words for the new word   
+        words[n_words] = (char *)allocator->alloc( (strlen(word)+1) * sizeof(char) ) ;
+        strcpy( words[n_words] , word ) ;
+        n_words++ ;
+        return ;
+    }
+    else if ( cmp_result > 0 )
+    {
+        // Find the place in the list of words where we want to insert the new word
+        for ( int i=0 ; i<n_words ; i++ )
+        {
+            cmp_result = strcmp( words[i] , word ) ;
+            if ( cmp_result > 0 )
+            {
+                // Shuffle down all words from i onwards and place the
+                //   new word in position i.
+
+                // Allocate memory in the list of words for the new word   
+                for ( int j=n_words ; j>i ; j-- )
+                    words[j] = words[j-1] ;
+                words[i] = (char *)allocator->alloc( (strlen(word)+1) * sizeof(char) ) ;
+                strcpy( words[i] , word ) ;
+                n_words++ ;
+                return ;
+            }
+            else if ( cmp_result == 0 )
+            {
+                // the word is already in our vocab - don't duplicate
+                return ;
+            }
+        }
+    }
+    else
+    {
+        // The word is already at the end of the list - don't duplicate
+        return ;
+    }
+
+    // If we make it here there is a problem
+    return ;
+}
+
+
+char *Vocabulary::getWord( int index )
+{
+    if ( (index<0) || (index>=n_words) )
+        error("Vocabulary::getWord - index out of range\n") ;
+	else
+		return words[index] ;
+    return NULL ;
+}
+
+
+int Vocabulary::getIndex( char *word , int guess )
+{
+    // We assume that the list of words is in ascending order so 
+    //   that we can do a binary search.
+    int min=0 , max=(n_words-1) , curr_pos=0 ;
+    int cmp_result=0 ;
+   
+    // If guess is valid, do a quick check to see if the word is where
+    //   the caller expects it to be - either at guess or at guess+1
+    if ( (guess >= 0) && (guess<n_words) )
+    {
+        if ( strcmp(word,words[guess]) == 0 ) 
+            return guess ;
+        else if ( ((guess+1)<n_words) && (strcmp(word,words[guess+1])==0) )
+            return guess+1 ;
+    }
+        
+    while (1)
+    {
+        curr_pos = min+(max-min)/2 ;
+        cmp_result = strcmp( word , words[curr_pos] ) ;
+        if ( cmp_result < 0 )
+            max = curr_pos-1 ;
+        else if ( cmp_result > 0 )
+            min = curr_pos+1 ;
+        else
+            return curr_pos ;
+            
+        if ( min > max )
+            return -1 ;
+    }
+
+    return -1 ;
+}
+
+
+#ifdef DEBUG
+void Vocabulary::outputText()
+{
+    printf("** START VOCABULARY - n_words=%d start_index=%d end_index=%d sil_index=%d**\n" , 
+                                     n_words , sent_start_index , sent_end_index , sil_index ) ;
+    for ( int i=0 ; i<n_words ; i++ )
+        printf("%s\n",words[i]) ;
+    printf("** END VOCABULARY **\n") ;
+}
+#endif
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/datasets/Vocabulary.h work/main.d/Torch-3/datasets/Vocabulary.h
--- tmp/Torch-3/datasets/Vocabulary.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/datasets/Vocabulary.h	2004-08-11 12:34:37.000000000 -0400
@@ -0,0 +1,88 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef VOCABULARY_INC
+#define VOCABULARY_INC
+
+#include "general.h"
+#include "Object.h"
+
+namespace Torch {
+
+
+/** 
+	This object contains the list of words we want our recogniser to recognise
+    plus a few "special" words (eg. sentence markers, silence word). There are
+    no duplicates in the list, and the list is sorted alphabetically.
+      
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class Vocabulary : public Object
+{
+public:
+	int n_words ;
+    char **words ;
+    int sent_start_index ;
+    int sent_end_index ;
+    int sil_index ;
+	
+	/* Constructors / Destructor */
+
+    /// Creates the vocabulary.
+    /// 'lex_fname' is the name of the lexicon file containing the pronunciations to be
+    ///   recognised.  The format is the standard "word(prior) ph ph ph" format
+    ///   where the (prior) is optional.
+    /// 'sent_start_word' and 'sent_end_word' are the words that will start and
+    ///   end every recognised utterance. 
+	Vocabulary( const char *lex_fname , const char *sent_start_word , const char *sent_end_word , 
+                const char *sil_word=NULL ) ;
+	virtual ~Vocabulary() ;
+
+	/* Methods */
+    
+    /// Adds a word to the vocabulary. Maintains alphabetic order. Does not add
+    ///   duplicate entries.
+	void addWord( char *word ) ;
+
+    /// Returns the word given the index into the vocabulary
+	char *getWord( int index ) ;
+    
+    /// Returns the index of a given word.  If 'guess' is defined, then the
+    ///   words at indices of 'guess' and 'guess+1' are checked for a match
+    ///   before the rest of the vocab is searched.
+    int getIndex( char *word , int guess=-1 ) ;
+
+#ifdef DEBUG
+	void outputText() ;
+#endif
+};
+
+
+}
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/BeamSearchDecoder.cc work/main.d/Torch-3/decoder/BeamSearchDecoder.cc
--- tmp/Torch-3/decoder/BeamSearchDecoder.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/BeamSearchDecoder.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,733 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "BeamSearchDecoder.h"
+
+
+namespace Torch {
+
+
+BeamSearchDecoder::BeamSearchDecoder( LinearLexicon *lexicon_ , LanguageModel *lang_model_ ,
+                                      real log_word_entrance_penalty_ , real word_int_beam_ ,
+                                      real word_end_beam_ , bool delayed_lm_ , bool verbose_mode_ )
+{
+    if ( lexicon_ == NULL )
+        error("BeamSearchDecoder::BeamSearchDecoder - no lexicon defined\n") ;
+    
+    lexicon = lexicon_ ;
+    vocabulary = lexicon->lex_info->vocabulary ;
+    lang_model = lang_model_ ;
+    phone_models = lexicon->phone_models ;
+    
+    n_frames = 0 ;
+    log_word_entrance_penalty = log_word_entrance_penalty_ ;
+    verbose_mode = verbose_mode_ ;
+    delayed_lm = delayed_lm_ ;
+
+    word_state_hyps_1 = (DecodingHypothesis ***)Allocator::sysAlloc( lexicon->n_models * 
+                                                   sizeof(DecodingHypothesis **) ) ;
+    word_state_hyps_2 = (DecodingHypothesis ***)Allocator::sysAlloc( lexicon->n_models * 
+                                                   sizeof(DecodingHypothesis **) ) ;
+    word_end_hyps_1 = (DecodingHypothesis **)Allocator::sysAlloc( lexicon->n_models * 
+                                                   sizeof(DecodingHypothesis *) ) ;
+    word_end_hyps_2 = (DecodingHypothesis **)Allocator::sysAlloc( lexicon->n_models * 
+                                                   sizeof(DecodingHypothesis *) ) ;
+    word_entry_hyps_1 = (DecodingHypothesis **)Allocator::sysAlloc( lexicon->n_models * 
+                                                   sizeof(DecodingHypothesis *) ) ;
+    word_entry_hyps_2 = (DecodingHypothesis **)Allocator::sysAlloc( lexicon->n_models * 
+                                                   sizeof(DecodingHypothesis *) ) ;
+    curr_word_hyps = word_state_hyps_1 ;
+    prev_word_hyps = word_state_hyps_2 ;
+    curr_word_end_hyps = word_end_hyps_1 ;
+    prev_word_end_hyps = word_end_hyps_2 ;
+    curr_word_entry_hyps = word_entry_hyps_1 ;
+    prev_word_entry_hyps = word_entry_hyps_2 ;
+    
+    for ( int w=0 ; w<lexicon->n_models ; w++ )
+    {
+        word_state_hyps_1[w] = (DecodingHypothesis **)Allocator::sysAlloc( 
+                                    lexicon->nStatesInModel(w) * sizeof(DecodingHypothesis *) ) ;
+        word_state_hyps_2[w] = (DecodingHypothesis **)Allocator::sysAlloc( 
+                                    lexicon->nStatesInModel(w) * sizeof(DecodingHypothesis *) ) ;
+        for ( int s=0 ; s<lexicon->nStatesInModel(w) ; s++ )
+        {
+            word_state_hyps_1[w][s] = new DecodingHypothesis() ;
+            word_state_hyps_1[w][s]->initHyp( w , s ) ;
+            word_state_hyps_2[w][s] = new DecodingHypothesis() ;
+            word_state_hyps_2[w][s]->initHyp( w , s ) ;
+        }
+        
+        word_end_hyps_1[w] = word_state_hyps_1[w][lexicon->nStatesInModel(w)-1] ;
+        word_end_hyps_2[w] = word_state_hyps_2[w][lexicon->nStatesInModel(w)-1] ;
+        word_entry_hyps_1[w] = word_state_hyps_1[w][0] ; 
+        word_entry_hyps_2[w] = word_state_hyps_2[w][0] ; 
+    }
+
+    sent_start_index = lexicon->lex_info->sent_start_index ;
+    sent_end_index = lexicon->lex_info->sent_end_index ;
+    
+    max_interior_score = LOG_ZERO ;
+    best_word_end_hyp = NULL ;
+    
+    if ( word_int_beam_ > 0.0 )
+        word_int_beam = word_int_beam_ ;
+    else
+        word_int_beam = -LOG_ZERO ;
+    
+    if ( word_end_beam_ > 0.0 )
+        word_end_beam = word_end_beam_ ;
+    else
+        word_end_beam = -LOG_ZERO ;
+}
+
+
+BeamSearchDecoder::~BeamSearchDecoder()
+{
+    resetHypotheses() ;
+
+    if ( word_state_hyps_1 != NULL )
+    {
+        for ( int w=0 ; w<lexicon->n_models ; w++ )
+        {
+            for ( int s=0 ; s<lexicon->nStatesInModel(w) ; s++ )
+                delete word_state_hyps_1[w][s] ;
+            free( word_state_hyps_1[w] ) ;
+        }
+        free( word_state_hyps_1 ) ;
+    }
+    if ( word_state_hyps_2 != NULL )
+    {
+        for ( int w=0 ; w<lexicon->n_models ; w++ )
+        {
+            for ( int s=0 ; s<lexicon->nStatesInModel(w) ; s++ )
+                delete word_state_hyps_2[w][s] ;
+            free( word_state_hyps_2[w] ) ;
+        }
+        free( word_state_hyps_2 ) ;
+    }
+
+    if ( word_end_hyps_1 != NULL )
+        free( word_end_hyps_1 ) ;
+    if ( word_end_hyps_2 != NULL )
+        free( word_end_hyps_2 ) ;
+    if ( word_entry_hyps_1 != NULL )
+        free( word_entry_hyps_1 ) ;
+    if ( word_entry_hyps_2 != NULL )
+        free( word_entry_hyps_2 ) ;
+}      
+
+
+void BeamSearchDecoder::decode( real **input_data , int n_frames_ , int *num_result_words , 
+                                int **result_words , int **result_words_times )
+{
+    int temp_words[5000] , temp_times[5000] ;
+    DecodingHypothesis *curr_hyp ;
+    real score ;
+
+#ifdef DEBUG
+    if ( (num_result_words==NULL) || (result_words==NULL) || (result_words_times==NULL) )
+        error("BeamSearchDecoder::decode - Result variables are NULL\n") ;
+#endif
+
+    n_frames = n_frames_ ;
+
+    // Initialise the hypothesis buffers and queues.
+    init() ;
+    
+    // process the inputs
+    for ( int t=0 ; t<n_frames ; t++ )
+    {
+        if ( verbose_mode == true )
+        {
+            fprintf( stderr , "\r                                                                        \r") ;
+            fprintf( stderr , "Frame %d of %d",t+1,n_frames) ; fflush(stderr) ;
+        }
+
+        // Swap hypothesis buffers
+        swapHypBuffers() ;
+        
+        // Pass the new input vector to the phone set - it knows whether the inputs
+        //   are emission probabilities or features and how to handle each.
+        phone_models->setInputVector( input_data[t] ) ;
+
+        // Process the transitions between states inside words.
+        processWordInteriorStates() ;
+
+        if ( t == (n_frames-1) )
+        {
+            // We've reached the end of the input data - no need to evaluate word transitions.
+            if ( verbose_mode == true )
+                fprintf( stderr , "\r                                                                    \r") ;
+            break ;
+        }
+
+        // If there is a language model, then tune the word-end hypotheses (that remain
+        //   after pruning) using the language model.
+        // After that, evaluate word transitions.
+        if ( lang_model != NULL )
+        {
+            if ( delayed_lm == false )
+                processWordTransitionsLM( t ) ;
+            else
+            {
+                applyLMProbs() ;
+                processWordTransitionsNoLM( t ) ;
+            }
+        }
+        else
+            processWordTransitionsNoLM( t ) ;
+        
+        // We now have hypotheses for the initial states of all possible next words.
+        // These hypotheses cannot remain in the (non-emitting) initial states.
+        // We have to consider transitions from each initial state to all possible
+        //   (emitting) successor states and see if the word entry hypothesis score is better
+        //   than the current hypothesis in the successor state.
+        // If so, we update the hypothesis in the successor state using the word entry
+        //   hypothesis.
+        processWordEntryHypotheses() ;
+    }
+   
+    if ( sent_end_index >= 0 )
+    {
+        // We look at the hypothesis that is in the final state of the sentence end pronunciation.
+        curr_hyp = curr_word_end_hyps[sent_end_index] ;
+    }
+    else
+    {
+        if ( (sent_start_index >= 0) && (best_word_end_hyp==curr_word_end_hyps[sent_start_index]) )
+        {
+            // Cannot have start word as end of sentence word.
+            // Find the next best.
+            score = LOG_ZERO ;
+            curr_hyp = NULL ;
+            for ( int i=0 ; i<lexicon->n_models ; i++ )
+            {
+                if ( i == sent_start_index )
+                    continue ;
+
+                if ( curr_word_end_hyps[i]->score > score )
+                {
+                    score = curr_word_end_hyps[i]->score ;
+                    curr_hyp = curr_word_end_hyps[i] ;
+                }
+            }
+        }
+        else
+            curr_hyp = best_word_end_hyp ;
+    }
+            
+    if ( (curr_hyp == NULL) || (curr_hyp->score <= LOG_ZERO) )
+    {
+        // There is no hypothesis that is in the final state of the sentence end model.
+        *num_result_words = 0 ;
+        *result_words = NULL ;
+        *result_words_times = NULL ;
+        return ;
+    }
+    
+    // Allocate memory for the result array (ie. array of indices corresponding to words
+    //   in the lexicon).
+    WordChainElem *temp_elem = curr_hyp->word_level_info ;
+    *num_result_words = 0 ;
+    while ( temp_elem != NULL )
+    {
+        temp_words[*num_result_words] = temp_elem->word ;
+        temp_times[*num_result_words] = temp_elem->word_start_frame ;
+        temp_elem = temp_elem->prev_elem ;
+        (*num_result_words)++ ;
+    }
+    *result_words = (int *)Allocator::sysAlloc( (*num_result_words) * sizeof(int) ) ;
+    *result_words_times = (int *)Allocator::sysAlloc( (*num_result_words) * sizeof(int) ) ;
+    for ( int w=0 ; w<(*num_result_words) ; w++ )
+    {
+        (*result_words)[w] = temp_words[(*num_result_words)-w-1] ;
+        (*result_words_times)[w] = temp_times[(*num_result_words)-w-1] ;
+    }
+}
+
+
+void BeamSearchDecoder::resetHypotheses()
+{
+    // Reset the scores of the new state hypotheses buffers
+    // If the decoder has already been used, only the curr_word_hyps will
+    //   contain active hypotheses that need to be deactivated.
+    for ( int w=0 ; w<lexicon->n_models ; w++ )
+    {
+        for ( int s=0 ; s<(lexicon->nStatesInModel(w)) ; s++ )
+        {
+            curr_word_hyps[w][s]->deactivate() ;
+            // word_state_hyps_1[w][s]->deactivate() ;
+            // word_state_hyps_2[w][s]->deactivate() ;
+        }
+    }
+}
+
+
+void BeamSearchDecoder::swapHypBuffers()
+{
+    // Swap buffers
+    if ( curr_word_hyps == word_state_hyps_1 )
+    {
+        curr_word_hyps = word_state_hyps_2 ;
+        prev_word_hyps = word_state_hyps_1 ;
+        curr_word_end_hyps = word_end_hyps_2 ;
+        prev_word_end_hyps = word_end_hyps_1 ;
+        curr_word_entry_hyps = word_entry_hyps_2 ;
+        prev_word_entry_hyps = word_entry_hyps_1 ;
+    }    
+    else
+    {
+        curr_word_hyps = word_state_hyps_1 ;
+        prev_word_hyps = word_state_hyps_2 ;
+        curr_word_end_hyps = word_end_hyps_1 ;
+        prev_word_end_hyps = word_end_hyps_2 ;
+        curr_word_entry_hyps = word_entry_hyps_1 ;
+        prev_word_entry_hyps = word_entry_hyps_2 ;
+    }
+    
+    if ( verbose_mode == true )
+    {
+        fprintf( stderr , ": " ) ; fflush(stderr) ;
+    }
+}
+
+void BeamSearchDecoder::processWordInteriorStates()
+{
+    DecodingHypothesis *prev_hyp ;
+    real emission_prob , new_score , *suc_log_trans_probs , int_prune_thresh ;
+    real temp_int_prune_thresh , temp_end_prune_thresh , max_end_score ;
+    int n_processed=0 , n_states_minus_one ;
+    short n_sucs , *sucs ; 
+
+    // Process the interior state hypotheses for the "normal" lexicon words.
+    int_prune_thresh = max_interior_score - word_int_beam ;
+
+    max_interior_score = LOG_ZERO ;
+    max_end_score = LOG_ZERO ;
+    temp_int_prune_thresh = LOG_ZERO ;
+    temp_end_prune_thresh = LOG_ZERO ;
+    best_word_end_hyp = NULL ;
+    
+    for ( int w=0 ; w<lexicon->n_models ; w++ )
+    {
+        n_states_minus_one = lexicon->nStatesInModel(w) - 1 ;
+        for ( int s=1 ; s<n_states_minus_one ; s++ )      // for all emitting states
+        {
+            prev_hyp = prev_word_hyps[w][s] ;
+            if ( prev_hyp->score <= LOG_ZERO )
+                continue ;
+
+#ifdef DEBUG
+            // We assume from this point on that the word/state field in the hypothesis
+            //   correspond to the indices in the nested loops (s & w). Check that this is so.
+            if ( (prev_hyp->word != w) || (prev_hyp->state != s) )
+                error("BeamSearchDecoder::processWordIntStates - word-state index mismatch\n") ;
+#endif
+            if ( w == sent_end_index )
+            {
+                // We don't want to prune any of the sentence end hypotheses.
+                emission_prob = lexicon->calcEmissionProb( w , s ) ;
+                lexicon->getSuccessorInfo( w , s , &n_sucs , &sucs , &suc_log_trans_probs ) ;
+                for ( int suc=0 ; suc<n_sucs ; suc++ )
+                {
+                    new_score = prev_hyp->score + emission_prob + suc_log_trans_probs[suc] ;
+                    if ( new_score > curr_word_hyps[w][sucs[suc]]->score )
+                        curr_word_hyps[w][sucs[suc]]->extendState( prev_hyp , new_score ) ;
+                }
+            }
+            else if ( prev_hyp->score >= int_prune_thresh )
+            {
+                n_processed++ ;
+                
+                // Retrieve/calculate the emission probability for the current state.
+                emission_prob = lexicon->calcEmissionProb( w , s ) ;
+                
+                // The hypothesis we've just retrieved is for a particular word, w,
+                //   and state, sprev.
+                // See if a path through (w,sprev) improves the current hypothesis for
+                //   every (next) state, s, of word w.
+                lexicon->getSuccessorInfo( w , s , &n_sucs , &sucs , &suc_log_trans_probs ) ;
+                for ( int suc=0 ; suc<n_sucs ; suc++ )
+                {
+                    new_score = prev_hyp->score + emission_prob + suc_log_trans_probs[suc] ;
+
+                    if ( sucs[suc] == n_states_minus_one )
+                    {
+                        // The final state is a special case. If we have a language model,
+                        //   then we want to prune word end hyps before we apply LM probs.
+                        // If we don't have a language model, then we only need to keep 
+                        //   track of the most likely word end.
+                        if ( lang_model != NULL )
+                        {
+                            if ( (new_score >= temp_end_prune_thresh) &&
+                                 (new_score > curr_word_hyps[w][n_states_minus_one]->score ) )
+                            { 
+                                if ( new_score > max_end_score )
+                                {
+                                    best_word_end_hyp = curr_word_hyps[w][n_states_minus_one] ;
+                                    max_end_score = new_score ;
+                                    temp_end_prune_thresh = new_score - word_end_beam ;
+                                }
+                                curr_word_hyps[w][n_states_minus_one]->extendState( prev_hyp , 
+                                                                                    new_score ) ;
+                            }
+                        }
+                        else
+                        {
+                            if ( new_score > max_end_score )
+                            {
+                                if ( best_word_end_hyp != NULL )
+                                    best_word_end_hyp->deactivate() ;
+                                best_word_end_hyp = curr_word_hyps[w][n_states_minus_one] ;
+                                max_end_score = new_score ;
+                                curr_word_hyps[w][n_states_minus_one]->extendState( prev_hyp , 
+                                                                                    new_score ) ;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if ( new_score > curr_word_hyps[w][sucs[suc]]->score )
+                        {
+                            if ( new_score >= temp_int_prune_thresh )
+                            {
+                                if ( new_score > max_interior_score )
+                                {
+                                    max_interior_score = new_score ;
+                                    temp_int_prune_thresh = new_score - word_int_beam ;
+                                }
+                                curr_word_hyps[w][sucs[suc]]->extendState( prev_hyp , new_score );
+                            }
+                        }
+                    }                    
+                }
+            }
+            
+            // We've finished with this hypothesis, so deactivate it.
+            prev_hyp->deactivate() ;
+        }
+    }
+
+    if ( verbose_mode == true )
+    {
+        fprintf( stderr , "%d," , n_processed ) ; fflush(stderr) ;
+    }
+}
+
+
+void BeamSearchDecoder::applyLMProbs()
+{
+    real temp_end_prune_thresh , best_score , score ;
+   
+    if ( best_word_end_hyp != NULL )
+        temp_end_prune_thresh = best_word_end_hyp->score - word_end_beam ;
+    else
+        temp_end_prune_thresh = LOG_ZERO ;
+        
+    best_word_end_hyp = NULL ;
+    best_score = LOG_ZERO ;
+    for ( int i=0 ; i<lexicon->n_models ; i++ )
+    { 
+        if ( i == sent_end_index )
+        {
+            curr_word_end_hyps[i]->deactivate() ;
+            continue ;
+        }
+            
+        score = curr_word_end_hyps[i]->score ;
+        if ( score > LOG_ZERO )
+        {
+            if ( score < temp_end_prune_thresh )
+                curr_word_end_hyps[i]->deactivate() ;
+            else
+            {
+                score += lang_model->calcLMProb( curr_word_end_hyps[i] ) ;
+                if ( score > best_score )
+                {
+                    curr_word_end_hyps[i]->score = score ;
+                    best_score = score ;
+                    if ( best_word_end_hyp != NULL )
+                        best_word_end_hyp->deactivate() ;
+                    best_word_end_hyp = curr_word_end_hyps[i] ;
+                }
+                else
+                    curr_word_end_hyps[i]->deactivate() ;
+            }
+        }
+    }
+}
+
+
+void BeamSearchDecoder::processWordTransitionsLM( int curr_frame )
+{   
+    real prob ;
+    int *pronuns , n_pronuns , n_processed ;
+    WordChainElem *next_word_chain_elem ;
+    real temp_end_prune_thresh ;
+    
+    if ( best_word_end_hyp != NULL )
+        temp_end_prune_thresh = best_word_end_hyp->score - word_end_beam ;
+    else
+        temp_end_prune_thresh = LOG_ZERO ;
+        
+    n_processed=0 ;
+    for ( int i=0 ; i<lexicon->n_models ; i++ )
+    {
+        if ( i == sent_end_index )
+        {
+            curr_word_end_hyps[i]->deactivate() ;
+            continue ;
+        }
+        if ( curr_word_end_hyps[i]->score <= LOG_ZERO )
+            continue ;
+        if ( curr_word_end_hyps[i]->score < temp_end_prune_thresh )
+        {
+            curr_word_end_hyps[i]->deactivate() ;
+            continue ;
+        }
+
+        n_processed++ ;
+
+        for ( int w=0 ; w<vocabulary->n_words ; w++ )
+        {
+            if ( (w == vocabulary->sent_end_index) && (i == sent_start_index) )
+                continue ;
+
+            prob = log_word_entrance_penalty + curr_word_end_hyps[i]->score +
+                   lang_model->calcLMProb( curr_word_end_hyps[i] , w ) ;
+            
+            pronuns = lexicon->lex_info->vocab_to_lex_map[w].pronuns ;
+            n_pronuns = lexicon->lex_info->vocab_to_lex_map[w].n_pronuns ;
+        
+            next_word_chain_elem = DecodingHypothesis::word_chain_elem_pool.getElem( w , 
+                                        curr_word_end_hyps[i]->word_level_info , curr_frame ) ;
+            for ( int p=0 ; p<n_pronuns ; p++ )
+            {
+                if ( pronuns[p] == sent_start_index )
+                    continue ;
+                    
+                if ( prob > curr_word_entry_hyps[pronuns[p]]->score )
+                    curr_word_entry_hyps[pronuns[p]]->extendWord( prob , next_word_chain_elem ) ;
+            }
+            if ( next_word_chain_elem->n_connected <= 0 )
+                DecodingHypothesis::word_chain_elem_pool.returnElem( next_word_chain_elem ) ;
+        }
+        curr_word_end_hyps[i]->deactivate() ;
+    }
+
+    if ( verbose_mode == true )
+    {
+        fprintf( stderr , "%d " , n_processed ) ; fflush(stderr) ;
+    }
+}
+
+
+void BeamSearchDecoder::processWordTransitionsNoLM( int curr_frame )
+{
+    // The best_word_end_hyp member points to the best word end hypothesis.
+    int *pronuns , n_pronuns ;
+    WordChainElem *next_word_chain_elem ;
+    real score ;
+
+    if ( verbose_mode == true )
+    {
+        fprintf( stderr , ":" ) ; fflush(stderr) ;
+    }
+
+    // Now extend the best word end hypothesis to the initial states of all
+    //   words and the initial state of the sentence end word.
+    // If the best word end hyp was the final state of the sentence end hypothesis
+    //   then we don't extend it to any other words.
+    if ( best_word_end_hyp != NULL )
+    {
+        score = best_word_end_hyp->score + log_word_entrance_penalty ;
+        for ( int w=0 ; w<vocabulary->n_words ; w++ )
+        {
+            if ( (w == vocabulary->sent_end_index) && (sent_start_index >= 0) &&
+                 (best_word_end_hyp == curr_word_end_hyps[sent_start_index]) )
+                continue ; // A start-to-end transition is invalid
+            pronuns = lexicon->lex_info->vocab_to_lex_map[w].pronuns ;
+            n_pronuns = lexicon->lex_info->vocab_to_lex_map[w].n_pronuns ;
+            
+#ifdef DEBUG
+            if ( n_pronuns == 0 )
+                error("BeamSearchDecoder::processWordTransNoLM - voc word %d has no pronuns\n",w);
+#endif
+            next_word_chain_elem = DecodingHypothesis::word_chain_elem_pool.getElem( w , 
+                                            best_word_end_hyp->word_level_info , curr_frame) ;
+            for ( int p=0 ; p<n_pronuns ; p++ )
+            {
+                if ( pronuns[p] == sent_start_index )
+                    continue ; // Cannot make a transition to the sentence start word.
+                
+#ifdef DEBUG
+                // If the score of each word entry hyp at this point is not LOG_ZERO then we
+                //   have a problem.
+                if ( curr_word_entry_hyps[pronuns[p]]->score > LOG_ZERO )
+                    error("BeamSearchDecoder::processWordTransNoLM - word entry hyp not reset\n") ;
+#endif
+                curr_word_entry_hyps[pronuns[p]]->extendWord( score , next_word_chain_elem ) ;
+            }
+            if ( next_word_chain_elem->n_connected <= 0 )
+                DecodingHypothesis::word_chain_elem_pool.returnElem( next_word_chain_elem ) ;
+        }
+    }
+    
+    // Deactivate the best word-end hypotheses and the sentence end word-end hypothesis.
+    if ( best_word_end_hyp != NULL )
+        best_word_end_hyp->deactivate() ;
+    best_word_end_hyp = NULL ;
+    if ( sent_end_index >= 0 )
+        curr_word_end_hyps[sent_end_index]->deactivate() ;
+}
+    
+
+void BeamSearchDecoder::processWordEntryHypotheses()
+{
+    DecodingHypothesis *curr_hyp ;
+    short n_sucs , *sucs ;
+    real *suc_log_trans_probs , new_score , temp_prune_thresh ;
+
+    temp_prune_thresh = max_interior_score - word_int_beam ;
+    for ( int w=0 ; w<lexicon->n_models ; w++ )
+    {
+        curr_hyp = curr_word_entry_hyps[w] ;
+        if ( curr_hyp->score <= LOG_ZERO )
+        {
+            curr_hyp->deactivate() ;
+            continue ;
+        }
+        
+        // For each successor state, s, for the initial state of word, w, is our hyposthesis 
+        //   improved if we consider the best word boundary hypothesis ? 
+        //   (ie. Is there a better path ending in state s that comes in through a word boundary?)
+        lexicon->getSuccessorInfo( w , 0 , &n_sucs , &sucs , &suc_log_trans_probs ) ;
+        for ( int s=0 ; s<n_sucs ; s++ )
+        {
+            new_score = curr_hyp->score + suc_log_trans_probs[s] ;
+            if ( new_score > curr_word_hyps[w][sucs[s]]->score )
+            {
+                if ( w == sent_end_index )
+                {
+                    // We don't want to prune sentence end hypotheses.
+                    curr_word_hyps[w][sucs[s]]->extendState( curr_hyp , new_score ) ;
+                }
+                else if ( new_score >= temp_prune_thresh )
+                {
+                    if ( new_score > max_interior_score )
+                    {
+                        max_interior_score = new_score ;
+                        temp_prune_thresh = max_interior_score - word_int_beam ;
+                    }
+                    curr_word_hyps[w][sucs[s]]->extendState( curr_hyp , new_score ) ;
+                }
+            }
+        }
+
+        curr_hyp->deactivate() ;
+    }
+}
+
+
+void BeamSearchDecoder::init()
+{
+    short n_sucs , *sucs ;
+    int n_pronuns , *pronuns ;
+    real *suc_log_trans_probs ;
+    real new_score ;
+    WordChainElem *next_word_chain_elem ;
+
+    // Reset all hypotheses.
+    resetHypotheses() ;
+
+    max_interior_score = LOG_ZERO ;
+    best_word_end_hyp = NULL ;
+   
+    // If there is a sentence start word defined, initialise just the initial state 
+    //   of the sentence start pronun.
+    if ( sent_start_index >= 0 )
+    {
+        next_word_chain_elem = DecodingHypothesis::word_chain_elem_pool.getElem( 
+                                                    vocabulary->sent_start_index , NULL , 0) ;
+        curr_word_hyps[sent_start_index][0]->extendWord( 0.0 , next_word_chain_elem ) ;
+    
+        // Extend to the successor states of the initial state of the sentence start pronun.
+        lexicon->getSuccessorInfo( sent_start_index , 0 , &n_sucs , &sucs , &suc_log_trans_probs ) ;
+        for ( int s=0 ; s<n_sucs ; s++ )
+        {
+            new_score = curr_word_hyps[sent_start_index][0]->score + suc_log_trans_probs[s] ;
+            curr_word_hyps[sent_start_index][sucs[s]]->extendState( 
+                                        curr_word_hyps[sent_start_index][0] , new_score ) ;
+        }
+
+        curr_word_hyps[sent_start_index][0]->deactivate() ;
+    }
+    else
+    {
+        // There is no sentence start pronunciation defined.
+        // Initialise hypotheses for the initial states of all models 
+        //   in the lexicon (except the sent end word if defined).
+        for ( int w=0 ; w<vocabulary->n_words ; w++ )
+        {
+            next_word_chain_elem = DecodingHypothesis::word_chain_elem_pool.getElem( w, NULL, 0 ) ;
+            
+            n_pronuns = lexicon->lex_info->vocab_to_lex_map[w].n_pronuns ;
+            pronuns = lexicon->lex_info->vocab_to_lex_map[w].pronuns ;
+            for ( int p=0 ; p<n_pronuns ; p++ )
+            {
+                if ( pronuns[p] == sent_end_index )
+                    continue ;
+                    
+                curr_word_hyps[pronuns[p]][0]->extendWord( 0.0 , next_word_chain_elem ) ;
+            }
+            
+            if ( next_word_chain_elem->n_connected <= 0 )
+                DecodingHypothesis::word_chain_elem_pool.returnElem( next_word_chain_elem ) ;
+        }
+
+        // Now go through all models and extend the intial state hypotheses.
+        for ( int m=0 ; m<lexicon->n_models ; m++ )
+        {
+            if ( m == sent_end_index )
+                continue ;
+
+            lexicon->getSuccessorInfo( m , 0 , &n_sucs , &sucs , &suc_log_trans_probs ) ;
+            for ( int s=0 ; s<n_sucs ; s++ )
+            {
+                new_score = curr_word_hyps[m][0]->score + suc_log_trans_probs[s] ;
+                curr_word_hyps[m][sucs[s]]->extendState( curr_word_hyps[m][0] , new_score ) ;
+            }
+
+            curr_word_hyps[m][0]->deactivate() ;
+        }
+    }
+}
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/BeamSearchDecoder.h work/main.d/Torch-3/decoder/BeamSearchDecoder.h
--- tmp/Torch-3/decoder/BeamSearchDecoder.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/BeamSearchDecoder.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,121 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef BEAMSEARCHDECODER_INC
+#define BEAMSEARCHDECODER_INC
+
+#include "general.h"
+#include "DecodingHypothesis.h"
+#include "PhoneModels.h"
+#include "LinearLexicon.h"
+#include "LanguageModel.h"
+#include "Vocabulary.h"
+#include "log_add.h"
+
+
+namespace Torch {
+
+
+/** This class implements a Viterbi decoder with beam search
+    capabilities.  A Lexicon and LanguageModel are required at
+    creation time (the LanguageModel is optional).  By default, 
+    no pruning occurs.  Two levels of pruning can be configured - 
+    word interior hypothesis pruning and word end hypothesis pruning.
+    The application of language model probabilities can be
+    delayed or performed normally.
+
+    @author Darren Moore (moore@idiap.ch)
+*/
+class BeamSearchDecoder
+{
+public:
+    PhoneModels *phone_models ;
+    LinearLexicon *lexicon ;
+    LanguageModel *lang_model ;
+    Vocabulary *vocabulary ;
+    int n_frames ;
+    real log_word_entrance_penalty ;
+    real word_int_beam ;
+    real word_end_beam ;
+
+    DecodingHypothesis ***word_state_hyps_1 ;
+    DecodingHypothesis ***word_state_hyps_2 ;
+    DecodingHypothesis **word_end_hyps_1 ;   
+    DecodingHypothesis **word_end_hyps_2 ;
+    DecodingHypothesis **word_entry_hyps_1 ;
+    DecodingHypothesis **word_entry_hyps_2 ;
+    DecodingHypothesis ***curr_word_hyps ;
+    DecodingHypothesis ***prev_word_hyps ;
+    DecodingHypothesis **curr_word_entry_hyps ;
+    DecodingHypothesis **prev_word_entry_hyps ;
+    DecodingHypothesis **curr_word_end_hyps ;
+    DecodingHypothesis **prev_word_end_hyps ;
+
+    int sent_start_index ;
+    int sent_end_index ;
+
+    bool verbose_mode ;
+    real max_interior_score ;
+    DecodingHypothesis *best_word_end_hyp ;
+    bool delayed_lm ;
+    
+    /* Constructors/destructor */
+    BeamSearchDecoder( LinearLexicon *lexicon_ , LanguageModel *lang_model_ ,
+                       real log_word_entrance_penalty_=0.0 , real word_int_beam_=LOG_ZERO ,
+                       real word_end_beam_=LOG_ZERO , bool delayed_lm_=true , 
+                       bool verbose_mode_=false ) ;
+    virtual ~BeamSearchDecoder() ;
+
+    /* Methods */
+
+    /// Decodes using the input data vectors in 'input_data'.
+    /// 'n_frames_' is the number of vectors of input data.
+    /// 'vec_size' is the number of elements in each vector.  The input data can be either
+    ///   features or emission probabilities and 'vec_size' must reflect this.
+    /// After this function returns, 'num_result_words' contains the number of words 
+    ///   recognised and 'result_words' contains the vocabulary indices of the recognised
+    ///   words.  The 'result_words' array is allocated inside this function.
+    void decode( real **input_data , int n_frames_ , int *num_result_words , int **result_words ,
+                 int **result_words_times ) ;
+
+    void resetHypotheses() ;
+    void swapHypBuffers() ;
+    void processWordInteriorStates() ;
+    void applyLMProbs() ;
+    void processWordTransitionsLM( int curr_frame ) ;
+    void processWordTransitionsNoLM( int curr_frame ) ;
+    void processWordEntryHypotheses() ;
+    void init() ;
+} ;
+
+
+}
+
+
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/DecoderBatchTest.cc work/main.d/Torch-3/decoder/DecoderBatchTest.cc
--- tmp/Torch-3/decoder/DecoderBatchTest.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/DecoderBatchTest.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,520 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "DecoderBatchTest.h"
+#include "EditDistance.h"
+#include "time.h"
+#include "string_stuff.h"
+#include "DiskXFile.h"
+
+
+namespace Torch {
+
+
+DecoderBatchTest::DecoderBatchTest( char *datafiles_filename , DSTDataFileFormat datafiles_format ,
+                                    char *expected_results_file , BeamSearchDecoder *decoder_ , 
+                                    bool remove_sil , bool output_res , char *out_fname ,
+                                    bool output_ctm , real frame_msec_step_size )
+{
+    clock_t start_time , end_time ;
+
+    if ( decoder_ == NULL )
+        error("DBT::DBT - decoder_ is NULL\n") ;
+    if ( (datafiles_filename == NULL) || (strcmp(datafiles_filename,"")==0) )
+        error("DBT::DBT - datafiles_filename is undefined\n") ;
+        
+    total_time = 0.0 ;
+    start_time = clock() ;
+    decoder = decoder_ ;
+    vocabulary = decoder->vocabulary ;
+    n_tests = 0 ;
+    tests = NULL ;
+    archive_fd = NULL ;
+
+    if ( (expected_results_file == NULL) || (strcmp(expected_results_file,"")==0) )
+        have_expected_results = false ;
+    else
+        have_expected_results = true ;
+
+    // Open the results file
+    if ( (out_fname != NULL) && (strcmp(out_fname,"")!=0) )
+    {
+        if ( (output_fd=fopen( out_fname , "w" )) == NULL )
+            error("DBT::DBT - error opening output file\n") ;
+    }
+    else
+        output_fd = NULL ;
+
+    if ( (datafiles_format == DST_FEATS_PFILE_ARCHIVE) ||
+         (datafiles_format == DST_PROBS_LNA8BIT_ARCHIVE) ||
+         (datafiles_format == DST_FEATS_ONLINE_FTRS_ARCHIVE) )
+    {
+        // 'datafiles_filename' is the actual feature or prob archive file for all test
+        //   sentences.  'expected_results_file' (if specified) contains the ground truth 
+        //   transcriptions in "raw" format - 1 sentence per line with the order of 
+        //   sentences matching the order in the archive file.
+        configureWithArchiveInput( datafiles_filename , datafiles_format ,
+                                   expected_results_file , remove_sil , output_res , output_ctm ,
+                                   frame_msec_step_size ) ;
+    }
+    else
+    {
+        // We have a separate input file for each test (eg. separate lna file for 
+        //   each sentence).  'datafiles_filename' should contain a list of absolute 
+        //   pathnames of the input files for all tests (1 abs filename per line). 
+        // 'expected_results_file' is the ground truth transcriptions for each test
+        //   in HTK MLF format (see below) (filenames must be absolute and must have
+        //   a 3 letter extension (the extension gets ignored)).
+        configureWithIndividualInputs( datafiles_filename , datafiles_format ,
+                                       expected_results_file , remove_sil , output_res ,
+                                       output_ctm , frame_msec_step_size ) ;
+    }
+    end_time = clock() ;
+    total_time = (real)(end_time-start_time) / CLOCKS_PER_SEC ;
+}
+
+
+DecoderBatchTest::~DecoderBatchTest()
+{
+    if ( archive_fd != NULL )
+        fclose( archive_fd ) ;
+
+    if ( output_fd != NULL )
+        fclose( output_fd ) ;
+
+    if ( tests != NULL )
+    {
+        for ( int i=0 ; i<n_tests ; i++ )
+            delete tests[i] ;
+        free( tests ) ;
+    }
+}
+
+
+void DecoderBatchTest::printStatistics( int i_cost , int d_cost , int s_cost )
+{
+    // Calculates the insertions, deletions, substitutions, accuracy
+    //   and outputs. Also calculates the total time taken to decode (not including
+    //   loading of datafiles).
+    real decode_time=0.0 ;
+    
+    EditDistance totalRes , singleRes ;
+    totalRes.setCosts( i_cost , d_cost , s_cost ) ;
+    singleRes.setCosts( i_cost , d_cost , s_cost ) ;
+
+    for (int i=0 ; i<n_tests ; i++ )
+    {
+        decode_time += tests[i]->decode_time ;
+        if ( tests[i]->actual_words != NULL )
+        {
+            singleRes.distance( tests[i]->actual_words , tests[i]->n_actual_words ,
+                                tests[i]->expected_words , tests[i]->n_expected_words ) ;
+            totalRes.add( &singleRes ) ;
+        }
+    }
+
+    printf("\nTotal time spent actually decoding = %.2f secs\n",decode_time) ;
+    printf("Total time spent configuring and running batch test = %.2f secs\n\n",total_time) ;
+    DiskXFile xf(stdout);
+    totalRes.print( &xf ) ;
+    totalRes.printRatio( &xf ) ;
+    printf("\n") ;
+}
+
+
+void DecoderBatchTest::run()
+{
+    clock_t start_time , end_time ;
+
+    start_time = clock() ;
+    for ( int i=0 ; i<n_tests ; i++ )
+    {
+        tests[i]->run( decoder , archive_fd ) ;
+    }
+    end_time = clock() ;
+    total_time += (real)(end_time-start_time) / CLOCKS_PER_SEC ;
+
+    if ( have_expected_results == true )
+        printStatistics(7,7,10) ;   // HTK settings for Ins, Sub, Del calculations
+}
+
+
+void DecoderBatchTest::configureWithIndividualInputs( 
+                               char *datafiles_filename , DSTDataFileFormat datafiles_format ,
+                               char *expected_results_file , bool remove_sil , bool output_res ,
+                               bool output_ctm , real frame_msec_step_size )
+{    
+    FILE *datafiles_fd=NULL , *results_fd=NULL ;
+    char line[1000] , fname[1000] , result_fname[1000] , res_word[1000] , *ptr ;
+    int temp_result_list[1000] , n_sentence_words=0 , i=0 , test_index , word_cnt ;
+    char **filenames=NULL ;
+    bool have_mlf=false ;
+
+    // Open the file containing the names of the data files we want to run tests for.
+    datafiles_fd = fopen( datafiles_filename , "r" ) ;
+    if ( datafiles_fd == NULL )
+        error("DecoderBatchTest::configure - error opening datafiles file") ;
+
+    // Open the file containing the expected results for each test.
+    // We assume that the format is as per HTK MLF format.
+    // Note that the filename line must be enclosed in "". 
+    if ( have_expected_results == true )
+    {
+        if ( (results_fd = fopen( expected_results_file , "r" )) == NULL )
+            error("DecoderBatchTest::configureWII - error opening results file") ;
+
+        // Read the first line of the results file to determine its type
+        fgets( line , 1000 , results_fd ) ;
+        if ( strstr( line , "MLF" ) )
+            have_mlf = true ;
+        else
+        {
+            have_mlf = false ;
+            fseek( results_fd , 0 , SEEK_SET ) ;
+        }
+    }
+    
+    // Determine the number of filenames present in the datafiles file
+    n_tests=0 ;
+    while ( fgets( line , 1000 , datafiles_fd ) != NULL )
+    {
+        if ( (sscanf(line,"%s",fname)==0) || (line[0] == '#') || (line[0] == '\n') ||
+             (line[0] == '\r') || (line[0] == ' ') || (line[0] == '\t') )
+            continue ;
+        n_tests++ ;
+        tests = (DecoderSingleTest **)Allocator::sysRealloc( tests ,
+                                                   n_tests * sizeof(DecoderSingleTest *) ) ;
+        tests[n_tests-1] = NULL ;
+        filenames = (char **)Allocator::sysRealloc( filenames , n_tests * sizeof(char *) ) ;
+        filenames[n_tests-1] = (char *)Allocator::sysAlloc( (strlen(fname)+1)*sizeof(char) ) ;
+        strcpy( filenames[n_tests-1] , fname ) ;
+    }
+
+    if ( have_expected_results == true )
+    {
+        // Read each entry in the expected results file, find its corresponding
+        //   filename in the temporary list of filename, create a DecoderSingleTest
+        //   instance and add it to the list of tests.
+        test_index = 0 ;
+        while ( fgets( line , 1000 , results_fd ) != NULL )
+        {
+            if ( have_mlf == true )
+            {
+                if ( sscanf(line,"\"%[^\"]",result_fname) != 0 )
+                {
+                    // remove the extension and path from the filename
+                    if ( (ptr=strrchr( result_fname , '/' )) != NULL )
+                        memmove( result_fname , ptr+1 , strlen(ptr)+1 ) ;
+                    if ( (ptr=strrchr( result_fname , '.' )) != NULL )
+                        *ptr = '\0' ;
+
+                    // find the filename in the temporary list of filenames
+                    for ( i=0 ; i<n_tests ; i++ )
+                    {
+                        if ( strstr( filenames[i] , result_fname ) )
+                        {
+                            // We found the filename in the temporary list of filenames.
+                            // Read the expected words.
+                            n_sentence_words = 0 ;
+                            fgets( line , 1000 , results_fd ) ;
+                            while ( line[0] != '.' )
+                            {
+                                sscanf( line , "%s" , res_word ) ;
+                                temp_result_list[n_sentence_words]=vocabulary->getIndex(res_word) ;
+                                if ( temp_result_list[n_sentence_words] >= 0 )
+                                    n_sentence_words++ ;
+                                fgets( line , 1000 , results_fd ) ;
+                            }
+
+                            // Now configure the next DecoderSingleTest instance 
+                            //   with the details of the test.
+                            if ( tests[i] != NULL )
+                                error("DecoderSingleTest::configureWII - duplicate exp results\n");
+                            tests[i] = new DecoderSingleTest() ;
+                            tests[i]->configure( i , filenames[i] , n_sentence_words , 
+                                    temp_result_list , datafiles_format , decoder->phone_models , 
+                                    remove_sil , output_res , output_fd , output_ctm ,
+                                    frame_msec_step_size ) ;
+                            break ;
+                        }
+                    }
+                }
+            }
+            else
+            {
+                // We have expected results in reference format
+                // Extract the words in the sentence
+                ptr = strtok( line , " \r\n\t" ) ;
+                word_cnt = 0 ;
+                while ( ptr != NULL )
+                {
+                    if ( (temp_result_list[word_cnt] = vocabulary->getIndex( ptr )) < 0 )
+                        printf("DBT::cWAI - result word %s not in vocab for test %d\n",ptr,i+1) ;
+                    word_cnt++ ;
+                    ptr = strtok( NULL , " \r\n\t" ) ;
+                }
+
+                // Configure the DecoderSingleTest instance
+                if ( test_index >= n_tests )
+                    error("DecoderSingleTest::configureWII - test_index out of range\n");
+                if ( tests[test_index] != NULL )
+                    error("DecoderSingleTest::configureWII - duplicate exp results\n");
+                tests[test_index] = new DecoderSingleTest() ;
+                tests[test_index]->configure( test_index , filenames[test_index] , word_cnt , 
+                                              temp_result_list , datafiles_format , 
+                                              decoder->phone_models , remove_sil , output_res , 
+                                              output_fd , output_ctm , frame_msec_step_size ) ;
+                test_index++ ;
+            }
+        }
+        
+        // Check that each element of 'tests' has been configured
+        for ( i=0 ; i<n_tests ; i++ )
+        {
+            if ( tests[i] == NULL )
+            {
+                error( "DecoderSingleTest::configureWII - exp res not found for file %s\n" ,
+                       filenames[i] ) ;
+            }
+
+            // this is useful to generate an in-order ref transcription file from an MLF file.
+            //for ( int j=0 ; j<tests[i]->n_expected_words ; j++ )
+            //    printf("%s ",vocabulary->getWord( tests[i]->expected_words[j] ) ) ;
+            //printf("\n");
+        }
+    }
+    else
+    {
+        for ( i=0 ; i<n_tests ; i++ )
+        {
+            tests[i] = new DecoderSingleTest() ;
+            tests[i]->configure( i , filenames[i] , 0 , NULL , datafiles_format , 
+                                 decoder->phone_models , remove_sil , 
+                                 output_res , output_fd , output_ctm , frame_msec_step_size ) ;
+        }
+    }
+
+    // Free the temporary list of filenames
+    for ( i=0 ; i<n_tests ; i++ )
+        free( filenames[i] ) ;
+    free( filenames ) ; 
+                    
+    if ( have_expected_results == true )
+        fclose( results_fd ) ;
+    fclose( datafiles_fd ) ;
+}
+
+
+void DecoderBatchTest::configureWithArchiveInput( 
+                               char *archive_filename , DSTDataFileFormat archive_format ,
+                               char *expected_results_file , bool remove_sil , bool output_res ,
+                               bool output_ctm , real frame_msec_step_size )
+{
+    FILE *results_fd=NULL ;
+    long *offsets=NULL ;
+    char line[1000] , *ptr ;
+    int temp_result_list[1000] , word_cnt ;
+    
+    if ( (archive_fd = fopen( archive_filename , "r" )) == NULL )
+        error("DecoderBatchTest::configureWithArchiveInput - error opening archive file\n") ;
+
+    if ( have_expected_results == true )
+    {
+        if ( (results_fd = fopen( expected_results_file , "r" )) == NULL )
+            error("DecoderBatchTest::configureWithArchiveInput - error opening exp res file\n") ;
+    }
+        
+    if ( archive_format == DST_PROBS_LNA8BIT_ARCHIVE )
+    {
+        // We need to find out the offset in the file where each new utterance begins
+        //   and create a new test for each.
+        findLNA8ArchiveUtteranceOffsets( archive_fd , decoder->phone_models->n_emission_probs , 
+                                         &offsets , &n_tests ) ;
+    }
+    else if ( archive_format == DST_FEATS_ONLINE_FTRS_ARCHIVE )
+    {
+        findOnlineFtrsArchiveUtteranceOffsets( archive_fd , decoder->phone_models->n_features , 
+                                               &offsets , &n_tests ) ;
+    }
+    
+    fseek( archive_fd , 0 , SEEK_SET ) ;
+
+    // We now know how many tests (utterances) are in the archive, and the
+    //   offset into the archive where the utterance data resides.  We can now
+    //   configure each test.
+    tests = (DecoderSingleTest **)Allocator::sysAlloc( n_tests*sizeof(DecoderSingleTest *) ) ;
+    for ( int i=0 ; i<n_tests ; i++ )
+    {
+        tests[i] = new DecoderSingleTest() ;
+
+        if ( have_expected_results == true )
+        {
+            // Read the next line from the expected results file
+            if ( fgets( line , 1000 , results_fd ) == NULL )
+                error("DBT::configureWithArchiveInput - error reading from results file\n") ;
+            //strtoupper( line ) ;
+
+            // Extract the words in the sentence
+            ptr = strtok( line , " \r\n\t" ) ;
+            word_cnt = 0 ;
+            while ( ptr != NULL )
+            {
+                if ( (temp_result_list[word_cnt] = vocabulary->getIndex( ptr )) < 0 )
+                    printf("DBT::cWAI - result word %s not in vocab for test %d\n",ptr,i+1) ;
+                word_cnt++ ;
+                ptr = strtok( NULL , " \r\n\t" ) ;
+            }
+
+            // Configure the DecoderSingleTest instance
+            tests[i]->configure( i , offsets[i] , word_cnt , temp_result_list , 
+                    archive_format , decoder->phone_models , 
+                    remove_sil , output_res , output_fd , output_ctm ,
+                    frame_msec_step_size ) ;
+        }
+        else
+        {
+            tests[i]->configure( i , offsets[i] , 0 , NULL , archive_format , 
+                    decoder->phone_models , remove_sil , output_res , 
+                    output_fd , output_ctm , frame_msec_step_size ) ;
+        }
+    }
+
+    if ( offsets != NULL )
+        free( offsets ) ;
+
+    if ( have_expected_results == true )
+        fclose(results_fd) ;
+}
+
+
+void DecoderBatchTest::findLNA8ArchiveUtteranceOffsets( FILE *arch_fd , int n_probs , 
+                                                        long **offsets , int *n_utts )
+{
+    int count ;
+    long pos=0 ;
+    unsigned char buf[1000] ;
+    bool got_end_word ;
+    
+    *n_utts = 0 ;
+    *offsets = NULL ;
+    got_end_word = true ;
+
+    if ( n_probs <= 0 )
+        error("DBT::findLNA8ArchiveUtteranceOffsets - lna vector size unspecified\n") ;
+
+    while ( (count=fread( buf , sizeof(unsigned char) , n_probs+1 , arch_fd )) == (n_probs+1) )
+    {
+        if ( (got_end_word == true) && (buf[0] == 0x00) )
+        {
+            (*n_utts)++ ;
+            *offsets = (long *)Allocator::sysRealloc( (*offsets) , (*n_utts)*sizeof(long) ) ;
+            (*offsets)[(*n_utts)-1] = pos ;
+            got_end_word = false ;
+        }
+        else if ( buf[0] == 0x80 )
+        {
+            if ( got_end_word == true )
+                error("DBT::findLNA8ArchiveUtteranceOffsets - double 0x80\n") ;
+            got_end_word = true ;
+        }
+        else
+        {
+            if ( buf[0] != 0x00 )
+                error("DBT::findLNA8ArchiveUtteranceOffsets - first byte of line was not 0x00\n") ;
+        }
+
+        pos += (n_probs+1) ;
+#ifdef DEBUG
+        if ( pos != ftell( arch_fd ) )
+            error("DBT::findLNA8ArchiveUtteranceOffsets - pos does not match ftell\n") ;
+#endif
+    }
+}
+
+
+void DecoderBatchTest::findOnlineFtrsArchiveUtteranceOffsets( FILE *arch_fd , int n_feats , 
+                                                              long **offsets , int *n_utts )
+{
+    int count , step_size ;
+    long pos=0 ;
+    unsigned char buf[1000] ;
+    bool got_end_word ;
+    
+    *n_utts = 0 ;
+    *offsets = NULL ;
+    got_end_word = true ;
+
+    if ( n_feats <= 0 )
+        error("DBT::findOnlineFtrsArchiveUtteranceOffsets - n_features unspecified\n") ;
+
+    step_size = 1 + (n_feats * sizeof(float)) ;
+    while ( (count=fread( buf , sizeof(unsigned char) , step_size , arch_fd )) == step_size )
+    {
+        if ( (got_end_word == true) && (buf[0] == 0x00) )
+        {
+            (*n_utts)++ ;
+            *offsets = (long *)Allocator::sysRealloc( (*offsets) , (*n_utts)*sizeof(long) ) ;
+            (*offsets)[(*n_utts)-1] = pos ;
+            got_end_word = false ;
+        }
+        else if ( buf[0] == 0x80 )
+        {
+            if ( got_end_word == true )
+                error("DBT::findOnlineFtrsArchiveUtteranceOffsets - double 0x80\n") ;
+            got_end_word = true ;
+        }
+        else
+        {
+            if ( buf[0] != 0x00 )
+                error("DBT::findOnlineFtrsArchiveUtteranceOffsets - first byte was not 0x00\n") ;
+        }
+
+        pos += step_size ;
+#ifdef DEBUG
+        if ( pos != ftell( arch_fd ) )
+            error("DBT::findLNA8ArchiveUtteranceOffsets - pos does not match ftell\n") ;
+#endif
+    }
+}
+
+#ifdef DEBUG
+void DecoderBatchTest::outputText()
+{
+    printf("Number of tests = %d\n",n_tests) ;
+    for ( int i=0 ; i<n_tests ; i++ )
+    {
+        printf("\nTest %d\n********\n",i) ;
+        tests[i]->outputText() ;
+        printf("\n") ;
+    }
+}
+#endif
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/DecoderBatchTest.h work/main.d/Torch-3/decoder/DecoderBatchTest.h
--- tmp/Torch-3/decoder/DecoderBatchTest.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/DecoderBatchTest.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,118 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DECODERBATCHTEST_INC
+#define DECODERBATCHTEST_INC
+
+#include "general.h"
+#include "BeamSearchDecoder.h"
+#include "Vocabulary.h"
+#include "DecoderSingleTest.h"
+
+namespace Torch {
+
+
+/** This class is used to decode a set of test files and display statistics and results
+    for each file (ie. expected and actual words recognised) and also for the entire 
+    test set (ie. insertions, deletions, substitutions, accuracy, total time).
+
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+
+
+class DecoderBatchTest
+{
+public:
+    BeamSearchDecoder *decoder ;
+    Vocabulary *vocabulary ;
+    int n_tests ;
+    DecoderSingleTest **tests ;
+    real total_time ;
+    FILE *archive_fd ;
+    FILE *output_fd ;
+    bool have_expected_results ;
+    
+    /* Constructors / destructor */
+    
+    /// Configures the batch test.
+    /// 'datafiles_filename' is the file containing a list of the input data files
+    ///   that need to be decoded.  Absolute pathnames are required.  The decoding 
+    ///   will occur in the order the files are listed in this file.
+    /// 'expected_results_file' is the file containing the correct transcriptions
+    ///   for all input data files.  The ordering of the files does not have to be
+    ///   the same as the order in 'datafiles_filename'.
+    /// 'decoder_' is a pointer to the decoder to be used to perform the recognition.
+    /// 'remove_sil' indicates whether the silence word is to be removed from the
+    ///   recognition results before statistics are calculated.
+    /// 'output_res' indicates whether the result of each recognition is to be output
+    ///   immediately after it is obtained.
+    /// 'preload_data' indicates whether all of the input data in all files is to be
+    ///   preloaded into memory before any decoding occurs (takes lots of memory and lots
+    ///   of time before any results are obtained if the number of input data files
+    ///   is large.
+    /// 'pre_calc_emission_probs' indicates whether emission probabilities for
+    ///   all input files are to be calculated before the decoder is invoked.  This
+    ///   only applies if 'preload_data' is true.
+    DecoderBatchTest( char *datafiles_filename , DSTDataFileFormat datafiles_format , 
+                      char *expected_results_file , BeamSearchDecoder *decoder_ , 
+                      bool remove_sil=false , bool output_res=false , char *out_fname=NULL , 
+                      bool output_ctm=false , real frame_msec_step_size=10.0 ) ; 
+    ~DecoderBatchTest() ;
+
+    /* Methods */
+    void configureWithArchiveInput( char *archive_filename , DSTDataFileFormat archive_format ,
+                                    char *expected_results_file , bool remove_sil , 
+                                    bool output_res , bool output_ctm , real frame_msec_step_size );
+    void configureWithIndividualInputs( char *datafiles_filename , 
+                                        DSTDataFileFormat datafiles_format ,
+                                        char *expected_results_file , bool remove_sil , 
+                                        bool output_res , bool output_ctm ,
+                                        real frame_msec_step_size ) ;
+    void findLNA8ArchiveUtteranceOffsets( FILE *arch_fd , int n_probs , long int **offsets , 
+                                          int *n_utts ) ;
+    void findOnlineFtrsArchiveUtteranceOffsets( FILE *arch_fd , int n_feats , long int **offsets , 
+                                                int *n_utts ) ;
+
+    /// Intended to be called after the 'run' method has returned.  Processes the
+    ///   recognition results for all input data files and compiles insertions, 
+    ///   deletions, substitions, accuracy and time statisitcs for the entire batch run.
+    void printStatistics( int i_cost , int d_cost , int s_cost ) ;
+
+    /// Runs the batch test according to the options set by the call to 'configure'.
+    void run() ;
+
+#ifdef DEBUG
+    void outputText() ;
+#endif
+} ;
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/DecoderSingleTest.cc work/main.d/Torch-3/decoder/DecoderSingleTest.cc
--- tmp/Torch-3/decoder/DecoderSingleTest.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/DecoderSingleTest.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,647 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "DecoderSingleTest.h"
+#include "IOHTK.h"
+#include "Sequence.h"
+#include "DiskXFile.h"
+#include "time.h"
+#include "sys/types.h"
+#include "sys/stat.h"
+
+
+namespace Torch {
+
+
+DecoderSingleTest::DecoderSingleTest()
+{
+    test_filename = NULL ;
+    test_id = -1 ;
+    expected_words = NULL ;
+    n_expected_words = 0 ;
+    actual_words = NULL ;
+    actual_words_times = NULL ;
+    n_actual_words = 0 ;
+    data_format = DST_NOFORMAT ;
+    decode_time = 0.0 ;
+    output_result = false ;
+    remove_sent_marks = false ;
+    output_ctm = false ;
+    frames_per_msec = 0.0 ;
+    archive_offset = -1 ;
+    output_fd=NULL ;
+
+    n_frames=0 ;
+    n_features=0 ;
+    n_emission_probs=0 ;
+    decoder_input = NULL ;
+    phone_models = NULL ;
+}
+
+
+DecoderSingleTest::~DecoderSingleTest()
+{
+    if ( test_filename != NULL )
+        free( test_filename ) ;
+    if ( expected_words != NULL )
+        free( expected_words ) ;
+    if ( actual_words != NULL )
+        free( actual_words ) ;
+    if ( actual_words_times != NULL )
+        free( actual_words_times ) ;
+    if ( decoder_input != NULL )
+    {
+        for ( int i=0 ; i<n_frames ; i++ )
+            free( decoder_input[i] ) ;
+        free( decoder_input ) ;
+    }
+}
+
+
+void DecoderSingleTest::configure( int test_id_ , char *test_filename_ , int n_expected_words_ ,
+                             int *expected_words_ , DSTDataFileFormat data_format_ ,
+                             PhoneModels *phone_models_ , bool remove_sent_marks_ , 
+                             bool output_result_ , FILE *out_fd , bool output_ctm_ ,
+                             real frame_ms_step_size )
+{
+    test_id = test_id_ ;
+    archive_offset = -1 ;
+    if ( (phone_models = phone_models_) == NULL )
+        error("DST::configure - phone_models is NULL\n") ;
+    
+    // Allocate memory to hold the filename of the test data and copy the string.
+    test_filename = (char *)Allocator::sysAlloc( (strlen(test_filename_)+1) * sizeof(char) ) ;
+    strcpy( test_filename , test_filename_ ) ;
+    
+    // Allocate memory to hold the array of word indices that constitute the
+    //   expected result of the test and copy the results.
+    if ( (n_expected_words_>0) && (expected_words_!=NULL) )
+    {
+        n_expected_words = n_expected_words_ ;
+        expected_words = (int *)Allocator::sysAlloc( n_expected_words * sizeof(int) ) ;
+        memcpy( expected_words , expected_words_ , n_expected_words*sizeof(int) ) ;
+    }
+    else
+    {
+        n_expected_words = 0 ;
+        expected_words = NULL ;
+    }
+
+    // If there are existing actual results - delete them
+    if ( actual_words != NULL )
+    {
+        free( actual_words ) ;
+        actual_words = NULL ;
+    }
+    if ( actual_words_times != NULL )
+    {
+        free( actual_words_times ) ;
+        actual_words_times = NULL ;
+    }
+    n_actual_words = 0 ;
+
+    data_format = data_format_ ;
+    frames_per_msec = 1.0 / frame_ms_step_size ;
+    output_ctm = output_ctm_ ;
+    if ( output_ctm == true )
+        remove_sent_marks = false ;
+    else
+        remove_sent_marks = remove_sent_marks_ ;
+    output_result = output_result_ ;
+    if ( (output_fd = out_fd) == NULL )
+        output_fd = stdout ;
+}
+
+
+void DecoderSingleTest::configure( int test_id_ , long archive_offset_ , int n_expected_words_ ,
+                              int *expected_words_ , DSTDataFileFormat data_format_ ,
+                              PhoneModels *phone_models_ , bool remove_sent_marks_ , 
+                              bool output_result_ , FILE *out_fd , bool output_ctm_ ,
+                              real frame_ms_step_size )
+{
+    test_id = test_id_ ;
+    test_filename = NULL ;
+    if ( (phone_models = phone_models_) == NULL )
+        error("DST::configure(2) - phone_models is NULL\n") ;
+    archive_offset = archive_offset_ ;
+    
+    // Allocate memory to hold the array of word indices that constitute the
+    //   expected result of the test and copy the results.
+    if ( (n_expected_words_>0) && (expected_words_!=NULL) )
+    {
+        n_expected_words = n_expected_words_ ;
+        expected_words = (int *)Allocator::sysAlloc( n_expected_words * sizeof(int) ) ;
+        memcpy( expected_words , expected_words_ , n_expected_words*sizeof(int) ) ;
+    }
+    else
+    {
+        n_expected_words = 0 ;
+        expected_words = NULL ;
+    }
+
+    // If there are existing actual results - delete them
+    if ( actual_words != NULL )
+    {
+        free( actual_words ) ;
+        actual_words = NULL ;
+    }
+    if ( actual_words_times != NULL )
+    {
+        free( actual_words_times ) ;
+        actual_words_times = NULL ;
+    }
+    n_actual_words = 0 ;
+
+    data_format = data_format_ ;
+    frames_per_msec = 1.0 / frame_ms_step_size ;
+    output_ctm = output_ctm_ ;
+    if ( output_ctm == true )
+        remove_sent_marks = false ;
+    else
+        remove_sent_marks = remove_sent_marks_ ;
+    output_result = output_result_ ;
+    if ( (output_fd = out_fd) == NULL )
+        output_fd = stdout ;
+}
+
+
+void DecoderSingleTest::run( BeamSearchDecoder *decoder , FILE *archive_fd )
+{
+    clock_t start_time , end_time ;
+    int start_index = 0 ;
+
+    // The data file hasn't been loaded yet - load it
+    loadDataFile( archive_fd ) ;
+
+    // Now look at the type of data that was in the file and compare it with the
+    //   type expected by the phone set.
+    if ( ((n_emission_probs == 0) && (phone_models->input_vecs_are_features == false)) ||
+         ((n_features == 0) && (phone_models->input_vecs_are_features == true)) )
+    {
+        // We've got feature vectors (or nothing), but the phone_models is expecting
+        //   vectors of emission probabilities (or vice versa).
+        error("DecoderSingleTest::run - datafile format does not agree with phone_models\n") ;
+    }
+
+    if ( (n_features != phone_models->n_features) && 
+         (n_emission_probs != phone_models->n_emission_probs) )
+    {
+        error("DecoderSingleTest::run - input vector size does not agree with phone_models\n") ;
+    }
+   
+    // If the input vectors are features and we are calculating emission probs
+    //   using an MLP, we need to initialise the context window of the MLP.
+    if ( (phone_models->input_vecs_are_features == true) && (phone_models->mlp != NULL) )
+        start_index = phone_models->mlp->initContextWindow( decoder_input ) ;
+    n_frames -= start_index ;
+    
+    // invoke the decoder
+    start_time = clock() ;
+    decoder->decode( decoder_input+start_index , n_frames , &n_actual_words , 
+                     &actual_words , &actual_words_times ) ;
+    end_time = clock() ;
+    decode_time = (real)(end_time-start_time) / CLOCKS_PER_SEC ;
+    
+    // process the decoding result
+    if ( remove_sent_marks == true )
+        removeSentMarksFromActual( decoder->vocabulary ) ;
+    if ( output_result == true )
+        outputText( decoder->vocabulary ) ;
+
+    // Free up some memory
+    for( int i=0 ; i<(n_frames+start_index) ; i++ )
+        free( decoder_input[i] ) ;
+    free( decoder_input ) ;
+    decoder_input = NULL ;
+    n_emission_probs = 0 ;
+    n_features = 0 ;
+}
+
+
+void DecoderSingleTest::removeSentMarksFromActual( Vocabulary *vocabulary )
+{
+    if ( (n_actual_words == 0) || (vocabulary == NULL) )
+        return ;
+  
+    // remove the sentence start word
+    if ( actual_words[0] == vocabulary->sent_start_index )
+    {
+        for ( int j=1 ; j<n_actual_words ; j++ )
+        {
+            actual_words[j-1] = actual_words[j] ;
+            actual_words_times[j-1] = actual_words_times[j] ;
+        }
+        n_actual_words-- ;
+    }
+    
+    // remove the sentence end word
+    if ( actual_words[n_actual_words-1] == vocabulary->sent_end_index )
+        n_actual_words-- ;
+
+    // remove any instances of silence
+    if ( vocabulary->sil_index >= 0 )
+    {
+        for ( int j=0 ; j<n_actual_words ; j++ )
+        {
+            while ( (j<n_actual_words) && (actual_words[j] == vocabulary->sil_index) )
+            {
+                for ( int k=(j+1) ; k<n_actual_words ; k++ )
+                {
+                    actual_words[k-1] = actual_words[k] ;
+                    actual_words_times[k-1] = actual_words_times[k] ;
+                }
+                n_actual_words-- ;
+            }
+        }
+    }
+}
+
+
+void DecoderSingleTest::loadDataFile( FILE *archive_fd )
+{
+    // Make sure that the test_filename and data_format member variables
+    //   have been configured.
+    if ( (test_filename == NULL) && (archive_fd == NULL) )
+        error("DecoderSingleTest::loadDataFile - test_filename/archive_fd not configured\n") ;
+    if ( data_format == DST_NOFORMAT )
+        error("DecoderSingleTest::loadDataFile - data_format not configured\n") ;
+
+    // Free any existing data and reset the size-related member variables
+    if ( decoder_input != NULL )
+    {
+        for( int i=0 ; i<n_frames ; i++ )
+            free( decoder_input[i] ) ;
+        free( decoder_input ) ;
+        decoder_input = NULL ;
+    }
+    n_frames=0 ;
+    n_features=0 ;
+    n_emission_probs=0 ;
+    
+    switch ( data_format )
+    {
+    case DST_FEATS_HTK:
+    {
+        // load the input htk data (ie. feature vectors) into a new IOHtk instance
+        IOHTK *htk_data = new IOHTK( test_filename , true ) ;
+
+        // reorganise the IOHtk 1-dimesional data into a 2D array
+        n_frames = htk_data->n_total_frames ;
+        n_features = htk_data->frame_size ;
+        decoder_input = (real **)Allocator::sysAlloc( n_frames * sizeof(real *) ) ;
+
+        // read the HTK data into a sequence
+        Sequence *temp_seq = new Sequence( n_frames , n_features ) ;
+        htk_data->getSequence( 0 , temp_seq ) ;
+        
+        // copy the sequence data into the decoder_input array
+        for ( int i=0 ; i<n_frames ; i++ )
+        {
+            decoder_input[i] = (real *)Allocator::sysAlloc( n_features * sizeof(real) ) ;
+            memcpy( decoder_input[i] , temp_seq->frames[i] , n_features * sizeof(real) ) ;
+        }    
+
+        delete htk_data ;
+        delete temp_seq ;
+        break ;
+    }
+    case DST_FEATS_ONLINE_FTRS:
+    {
+        loadOnlineFtrs( test_filename ) ;
+        break ;
+    }
+    case DST_FEATS_ONLINE_FTRS_ARCHIVE:
+    {
+        loadOnlineFtrsFromArchive( archive_fd ) ;
+        break ;
+    }
+    case DST_PROBS_LNA8BIT:
+    {
+        loadLNA8bit( test_filename ) ;
+        break ;
+    }
+    case DST_PROBS_LNA8BIT_ARCHIVE:
+    {
+        loadLNA8bitFromArchive( archive_fd ) ; 
+        break ;
+    }
+    default:
+        error("DecoderSingleTest::loadDataFile - data_format not recognised\n") ;
+    }
+
+#ifdef DEBUG
+    if ( (n_features==0) && (n_emission_probs==0) )
+        error("DecoderSingleTest::loadDataFile - no data loaded\n") ;
+#endif
+}
+
+
+void DecoderSingleTest::outputText( Vocabulary *vocab )
+{
+    real sec_duration , sec_start_time ;
+    
+    if ( (test_filename == NULL) && (archive_offset<0) )
+        return ;
+    
+    if ( (n_expected_words > 0) && (output_ctm == false) )
+    {
+        // We have expected words, so output a verbose results containing
+        //   the filename, expected result, actual result, segmentation.
+        if ( test_filename != NULL )
+            fprintf( output_fd , "%s\n" , test_filename ) ;
+        else
+            fprintf( output_fd , "\n") ;
+
+        fprintf( output_fd , "\tExpected :  ") ;
+        for ( int i=0 ; i<n_expected_words ; i++ )
+        {
+            if ( vocab == NULL )
+                fprintf( output_fd , "%d " , expected_words[i] ) ;
+            else if ( expected_words[i] < 0 )
+                fprintf( output_fd , "<OOV> ") ;
+            else
+                fprintf( output_fd , "%s " , vocab->getWord(expected_words[i]) ) ;
+        }
+
+        fprintf( output_fd , "\n\tActual :    ") ;
+        for ( int i=0 ; i<n_actual_words ; i++ )
+        {
+            if ( vocab == NULL )
+                fprintf( output_fd , "%d " , actual_words[i] ) ;
+            else
+                fprintf( output_fd , "%s " , vocab->getWord(actual_words[i]) ) ;
+        }
+        fprintf( output_fd , "  [ ") ;
+        for ( int i=0 ; i<n_actual_words ; i++ )
+            fprintf( output_fd , "%d " , actual_words_times[i]+1 ) ;
+        fprintf( output_fd , "(%d) ]\n",n_frames) ;
+    }
+    else if ( (output_ctm == true) && (n_actual_words>0) )
+    {
+        if ( actual_words[0] != vocab->sent_start_index )
+            error("DST::outputText - did not see sent start symbol in output\n") ;
+        if ( actual_words[n_actual_words-1] != vocab->sent_end_index )
+            error("DST::outputText - did not see sent end symbol in output\n") ;
+            
+        for ( int i=1 ; i<(n_actual_words-1) ; i++ )
+        {
+            sec_duration = ( actual_words_times[i+1] - actual_words_times[i] ) / 
+                           frames_per_msec / 1000.0 ;
+            sec_start_time = actual_words_times[i] / frames_per_msec / 1000.0 ;
+            fprintf( output_fd , "%d A %.3f %.3f %s\n" , test_id , sec_start_time , sec_duration , 
+                                                         vocab->getWord(actual_words[i]) ) ;
+        }
+    }
+    else
+    {
+        // We just want to output the actual result words - nothing more or less
+        for ( int i=0 ; i<n_actual_words ; i++ )
+            fprintf( output_fd , "%s " , vocab->getWord(actual_words[i]) ) ;
+        fprintf( output_fd , "\n") ;
+    }
+    fflush( output_fd ) ;
+}
+
+
+void DecoderSingleTest::loadLNA8bit( char *lna_filename )
+{
+    FILE *lna_fd ;
+    int buf_size , step_size , i ;
+    unsigned char buf[2000] ;
+    real sum=0.0 ;
+
+#ifdef DEBUG
+    if ( sizeof(unsigned char) != 1 )
+        error("DecoderSingleTest::loadLNA8bit - unsigned char not 1 byte\n") ;
+    if ( (lna_filename == NULL) || (strcmp(lna_filename,"")==0) )
+        error("DecoderSingleTest::loadLNA8bit - lna_filename undefined\n") ;
+    if ( phone_models->n_emission_probs <= 0 )
+        error("DecoderSingleTest::loadLNA8bit - ph_models->n_emission_probs not set\n") ;
+#endif
+
+    n_frames = 0 ;
+    decoder_input = NULL ;
+    n_emission_probs = phone_models->n_emission_probs ;
+    step_size = 1 + (n_emission_probs * sizeof(unsigned char)) ;
+
+    if ( (lna_fd = fopen( lna_filename , "r" )) == NULL )
+        error("DecoderSingleTest::loadLNA8bit - error opening LNA file\n") ;
+        
+    do
+    {
+        if ( (buf_size=(int)fread( buf , 1 , step_size , lna_fd )) != step_size )
+            error("DecoderSingleTest::loadLNA8bit - error reading prob vector\n") ;
+
+        if ( (buf[0] != 0x00) && (buf[0] != 0x80) )
+            error("DecoderSingleTest::loadLNA8bit - flag byte error\n") ;
+            
+        n_frames++ ;
+        decoder_input = (real **)Allocator::sysRealloc( decoder_input , n_frames*sizeof(real *) ) ;
+        decoder_input[n_frames-1] = (real *)Allocator::sysAlloc( n_emission_probs * sizeof(real) ) ;
+        
+        // Convert from the 8-bit integer in the file to the equivalent floating point
+        //   log probability.
+        sum = 0.0 ;
+        for ( i=0 ; i<n_emission_probs ; i++ )
+        {
+            decoder_input[n_frames-1][i] = -((real)buf[i+1] + 0.5) / 24.0 ;
+            sum += (real)exp( decoder_input[n_frames-1][i] ) ;
+        }
+
+        if ( (sum < 0.97) || (sum > 1.03) )
+            error("DecoderSingleTest::loadLNA8bit - sum of probs = %.4f not in [0.97,1.03]\n",sum) ;
+    }
+    while ( buf[0] != 0x80 ) ;
+           
+    // We're done.
+    n_features = 0 ;
+    fclose( lna_fd ) ;
+}
+
+
+void DecoderSingleTest::loadLNA8bitFromArchive( FILE *archive_fd )
+{
+    int buf_size , step_size , i ;
+    unsigned char buf[2000] ;
+    real sum=0.0 ;
+
+#ifdef DEBUG
+    if ( sizeof(unsigned char) != 1 )
+        error("DecoderSingleTest::loadLNA8bitFromArchive - unsigned char not 1 byte\n") ;
+    if ( archive_fd == NULL )
+        error("DecoderSingleTest::loadLNA8bitFromArchive - archive_fd NULL\n") ;
+    if ( phone_models->n_emission_probs <= 0 )
+        error("DecoderSingleTest::loadLNA8bitFromArchive - ph_models->n_emission_probs not set\n") ;
+    if ( archive_offset < 0 )
+        error("DecoderSingleTest::loadLNA8bitFromArchive - archive_offset not setup\n") ;
+#endif
+        
+    n_frames = 0 ;
+    decoder_input = NULL ;
+    n_emission_probs = phone_models->n_emission_probs ;
+    step_size = 1 + (n_emission_probs * sizeof(unsigned char)) ;
+
+    // Go to the correct place in the archive file
+    fseek( archive_fd , archive_offset , SEEK_SET ) ;
+    
+    do
+    {
+        if ( (buf_size=(int)fread( buf , 1 , step_size , archive_fd )) != step_size )
+            error("DecoderSingleTest::loadLNA8bitFromArchive - error reading prob vector\n") ;
+
+        if ( (buf[0] != 0x00) && (buf[0] != 0x80) )
+            error("DecoderSingleTest::loadLNA8bitFromArchive - flag byte error\n") ;
+            
+        n_frames++ ;
+        decoder_input = (real **)Allocator::sysRealloc( decoder_input , n_frames*sizeof(real *) ) ;
+        decoder_input[n_frames-1] = (real *)Allocator::sysAlloc( n_emission_probs * sizeof(real) ) ;
+        
+        // Convert from the 8-bit integer in the file to the equivalent floating point
+        //   log probability.
+        sum = 0.0 ;
+        for ( i=0 ; i<n_emission_probs ; i++ )
+        {
+            decoder_input[n_frames-1][i] = -((real)buf[i+1] + 0.5) / 24.0 ;
+            sum += (real)exp( decoder_input[n_frames-1][i] ) ;
+        }
+
+        if ( (sum < 0.97) || (sum > 1.03) )
+            error("DST::loadLNA8bitFromArchive - sum_probs=%.4f not in [0.97,1.03]\n",sum) ;
+    }
+    while ( buf[0] != 0x80 ) ;
+           
+    // We're done.
+    n_features = 0 ;
+}
+
+
+void DecoderSingleTest::loadOnlineFtrs( char *online_ftrs_filename )
+{
+    // Only read the first sentence in the file.
+    DiskXFile *online_ftrs_fd ;
+    unsigned char buf[2000] , flag ;
+    
+#ifdef DEBUG
+    if ( decoder_input != NULL )
+        error("DecoderSingleTest::loadOnlineFtrs - already have decoder input data\n") ;
+    if ( (sizeof(unsigned char) != 1) || (sizeof(float) != 4) )
+        error("DecoderSingleTest::loadOnlineFtrs - types have unexpected sizes\n") ;
+#endif
+
+    n_frames = 0 ;
+    decoder_input = NULL ;
+    n_features = phone_models->n_features ;
+
+    // Open the file
+    online_ftrs_fd = new DiskXFile( online_ftrs_filename , "r" ) ;
+
+    do
+    {
+        // manually read the flag byte (so that DiskXFile does not reverse).
+        online_ftrs_fd->read( &flag , sizeof(unsigned char) , 1 ) ;
+
+        // read the features
+        if ( online_ftrs_fd->read( buf , sizeof(float) , n_features ) != n_features )
+            error("DecoderSingleTest::loadOnlineFtrs - error reading feature vector\n") ;
+
+        if ( (flag != 0x00) && (flag != 0x80) )
+            error("DecoderSingleTest::loadOnlineFtrs - flag byte error\n") ;
+            
+        n_frames++ ;
+        decoder_input = (real **)Allocator::sysRealloc( decoder_input, n_frames*sizeof(real *) ) ;
+        decoder_input[n_frames-1] = (real *)Allocator::sysAlloc( n_features * sizeof(real) ) ;
+#ifdef USE_DOUBLE
+        for ( int i=0 ; i<n_features ; i++ )
+            decoder_input[n_frames-1][i] = (real)((float *)buf)[i] ;
+#else
+        memcpy( decoder_input[n_frames-1] , buf , n_features*sizeof(real) ) ;
+#endif
+    }
+    while ( flag != 0x80 ) ;
+           
+    // We're done.
+    n_emission_probs = 0 ;
+    delete online_ftrs_fd ;
+}
+
+
+void DecoderSingleTest::loadOnlineFtrsFromArchive( FILE *archive_fd )
+{
+    unsigned char buf[2000] , flag ;
+    DiskXFile *arch_file ;
+
+#ifdef DEBUG
+    if ( (sizeof(unsigned char) != 1) || (sizeof(float) != 4) )
+        error("DecoderSingleTest::loadOnlineFtrsFromArchive - types have unexpected sizes\n") ;
+    if ( archive_fd == NULL )
+        error("DecoderSingleTest::loadOnlineFtrsFromArchive - archive_fd NULL\n") ;
+    if ( phone_models->n_features <= 0 )
+        error("DecoderSingleTest::loadOnlineFtrsFromArchive - ph_models->n_features not set\n") ;
+    if ( archive_offset < 0 )
+        error("DecoderSingleTest::loadOnlineFtrsFromArchive - archive_offset not setup\n") ;
+#endif
+        
+    n_frames = 0 ;
+    decoder_input = NULL ;
+    n_features = phone_models->n_features ;
+
+    // Go to the correct place in the archive file
+    arch_file = new DiskXFile( archive_fd ) ;
+    arch_file->seek( archive_offset , SEEK_SET ) ;
+
+    // Read until the end of the the sentence.
+    do
+    {
+        // manually read the flag byte (so that DiskXFile does not reverse).
+        arch_file->read( &flag , sizeof(unsigned char) , 1 ) ;
+        
+        if ( arch_file->read( buf , sizeof(float) , n_features ) != n_features )
+            error("DecoderSingleTest::loadOnlineFtrsFromArchive - error reading feature vector\n") ;
+
+        if ( (flag != 0x00) && (flag != 0x80) )
+            error("DecoderSingleTest::loadOnlineFtrsFromArchive - flag byte error\n") ;
+            
+        n_frames++ ;
+        decoder_input = (real **)Allocator::sysRealloc( decoder_input, n_frames*sizeof(real *) ) ;
+        decoder_input[n_frames-1] = (real *)Allocator::sysAlloc( n_features * sizeof(real) ) ;
+#ifdef USE_DOUBLE
+        for ( int i=0 ; i<n_features ; i++ )
+            decoder_input[n_frames-1][i] = (real)((float *)buf)[i] ;
+#else
+        memcpy( decoder_input[n_frames-1] , buf , n_features*sizeof(real) ) ;
+#endif
+    }
+    while ( flag != 0x80 ) ;
+
+    n_emission_probs = 0 ;
+    delete arch_file ;
+}
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/DecoderSingleTest.h work/main.d/Torch-3/decoder/DecoderSingleTest.h
--- tmp/Torch-3/decoder/DecoderSingleTest.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/DecoderSingleTest.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,153 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DECODERSINGLETEST_INC
+#define DECODERSINGLETEST_INC
+
+#include "general.h"
+#include "BeamSearchDecoder.h"
+#include "PhoneModels.h"
+#include "Vocabulary.h"
+
+
+namespace Torch {
+
+
+typedef enum 
+{
+    DST_FEATS_HTK=0 ,
+    DST_FEATS_ONLINE_FTRS ,
+    DST_FEATS_ONLINE_FTRS_ARCHIVE ,
+    DST_FEATS_PFILE_ARCHIVE ,  // unimplemented
+    DST_PROBS_LNA8BIT ,
+    DST_PROBS_LNA8BIT_ARCHIVE ,
+    DST_NOFORMAT
+} DSTDataFileFormat ;
+
+
+/** This class is used to recognise a single input data file, post-process the
+    recognition result and output the result.  The DecoderBatchTest class
+    contains of an array of these objects.
+
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class DecoderSingleTest
+{
+public:
+    char *test_filename ;
+    int test_id ;
+    int *expected_words ;
+    int n_expected_words ;
+    int *actual_words ;
+    int *actual_words_times ;
+    int n_actual_words ;
+    DSTDataFileFormat data_format ;
+    real decode_time ;
+    bool output_result ;
+    bool remove_sent_marks ;
+    bool output_ctm ;
+    real frames_per_msec ;
+    long archive_offset ;
+    FILE *output_fd ;
+
+    int n_frames ;
+    int n_features ;
+    int n_emission_probs ;
+    real **decoder_input ;
+    PhoneModels *phone_models ;
+
+    /* Constructors/destructor */
+    DecoderSingleTest() ;
+    ~DecoderSingleTest() ;
+
+    /* Methods */
+
+    /// Configures the test.
+    /// 'test_id_' is an ID assigned to this particular test.
+    /// 'test_filename_' is the absolute pathname of the input data file.
+    /// 'n_expected_words_' and 'expected_words_' contain information about 
+    ///   the expected result of the test (ie. the correct transcription).
+    /// 'data_format_' indicates the type of data contained in the input
+    ///   data file.  Only 1 input data format has been implemented so far.
+    /// 'phone_models_' is a pointer to the PhoneModels instance that contains
+    ///   the phone HMM's. This used to verify that datafiles contain expected
+    ///   data (eg. emission probs or features, correct vector sizes)
+    /// 'remove_sent_marks_' indicates whether the sentence start and end
+    ///   words in the recognition result are to be removed.
+    /// 'output_result_' indicates whether the recognition result is to be
+    ///   output after the decoding has occurred.
+    /// 'out_fd' is the file where output will be written (if NULL then
+    ///   stdout assumed).
+    /// 'output_ctm_' indicates if the output is to be in CTM format.
+    /// 'frame_msec_step_size' is the frame step size in milliseconds and is
+    ///   only used for CTM output.
+    void configure( int test_id_ , char *test_filename_ , int n_expected_words_ , 
+                    int *expected_words_ , DSTDataFileFormat data_format_ , 
+                    PhoneModels *phone_models_=NULL , bool remove_sent_marks_=false , 
+                    bool output_result_=false , FILE *out_fd=NULL , bool output_ctm_=false , 
+                    real frame_msec_step_size=10.0 ) ;
+
+    /// Configures the test. This version is used when we have input data
+    ///   in a big archive file.
+    /// Parameters are same as other 'configure' method except 'test_filename_'
+    ///   has been replaced by 'archive_offset_'
+    /// 'archive_offset' is the offset into an archive input file where the
+    ///   input data for this test resides. 
+    void configure( int test_id_ , long archive_offset_ , int n_expected_words_ , 
+                    int *expected_words_ , DSTDataFileFormat data_format_ , 
+                    PhoneModels *phone_models_=NULL , bool remove_sent_marks_=false , 
+                    bool output_result_=false , FILE *out_fd=NULL , bool output_ctm_=false , 
+                    real frame_msec_step_size=10.0 ) ;
+                    
+    /// Runs the tests using the recogniser pointed to by 'decoder'.
+    /// 'archive_fd' is the big file containing the input data. When
+    ///   this is not NULL, the archive_offset member variable is used
+    ///   to fseek to the correct point in the archive file.
+    void run( BeamSearchDecoder *decoder , FILE *archive_fd=NULL ) ;
+
+    /// Outputs the recognition result. If 'vocab' is defined, then the
+    ///   recognition result (ie. vocab entry indices) are converted to
+    ///   strings and displayed.  If 'vocab' is NULL then the indices are
+    ///   output directly.
+    void outputText( Vocabulary *vocab=NULL ) ;
+    
+    /// Internal functions.
+    void removeSentMarksFromActual( Vocabulary *vocabulary ) ;
+    void loadDataFile( FILE *archive_fd=NULL ) ;
+    void loadLNA8bit( char *lna_filename ) ;
+    void loadLNA8bitFromArchive( FILE *archive_fd ) ;
+    void loadOnlineFtrs( char *online_ftrs_filename ) ;
+    void loadOnlineFtrsFromArchive( FILE *archive_fd ) ;
+} ;
+
+
+}
+
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/DecodingHMM.cc work/main.d/Torch-3/decoder/DecodingHMM.cc
--- tmp/Torch-3/decoder/DecodingHMM.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/DecodingHMM.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,326 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "DecodingHMM.h"
+#include "log_add.h"
+
+
+namespace Torch {
+
+
+DecodingHMM::DecodingHMM()
+{
+    n_states = 0 ;
+    states = NULL ;
+}
+
+
+DecodingHMM::DecodingHMM( HMM *orig_model , short *emis_prob_vec_indices )
+{
+    // We just want to extract only the bits of the 'HMM' instance
+    //   that are required for decoding.
+    // We also want to associate a list of possible predecessor states
+    //   with each state, as well as transition probabilities for each
+    //   predecessor.
+    // This will replace the transition 2D-array used in HMM, which is
+    //   general but not optimal for the varieties of HMM's used for speech
+    //   recognition.
+    
+    real *log_trans ;
+    short *neighbour_states ;
+    short n_neighbours=0 ;
+    
+    if ( orig_model == NULL )
+        error("DecodingHMM::DecodingHMM - original HMM NULL\n") ;
+
+    log_trans = (real *)Allocator::sysAlloc( 1000 * sizeof(real) ) ;
+    neighbour_states = (short *)Allocator::sysAlloc( 1000 * sizeof(short) ) ;
+    n_states = (short)orig_model->n_states ;
+    
+    // Allocate memory to hold the states
+    states = (DecodingHMMState **)Allocator::sysAlloc( n_states * sizeof(DecodingHMMState *) ) ;
+
+    // Create each state in turn.
+    for ( short i=0 ; i<n_states ; i++ )
+    {
+        states[i] = (DecodingHMMState *)Allocator::sysAlloc( sizeof(DecodingHMMState) ) ;
+        initState( states[i] , orig_model->states[i] , emis_prob_vec_indices[i] ) ;
+    }
+
+    // Now go through the log_transitions array in the HMM instance
+    //   and extract only the non-zero transitions FROM this state.
+    for ( short from=0 ; from<n_states ; from++ )
+    {
+        n_neighbours = 0 ;
+        for ( short to=0 ; to<n_states ; to++ )
+        {
+            if ( orig_model->log_transitions[to][from] > LOG_ZERO )
+            {
+                log_trans[n_neighbours] = orig_model->log_transitions[to][from] ;
+                neighbour_states[n_neighbours++] = to ;
+            }
+
+        }
+        setupSuccessorStates( states[from] , n_neighbours , neighbour_states , log_trans ) ;
+    }
+
+    free( log_trans ) ;
+    free( neighbour_states ) ;
+}
+
+
+DecodingHMM::DecodingHMM( int n_models , DecodingHMM **models )
+{
+    // This will take a list of smaller models and concatenate them
+    //   into a single model.
+    // Typically used to form a word-level model from a collection
+    //   of phoneme models.
+    mergeModels( n_models , models ) ;
+}
+
+
+DecodingHMM::DecodingHMM( short n_states_ , Distribution **states_ , real **log_trans_probs_ ,
+                          short *emis_prob_vec_indices )
+{
+    real *log_trans ;
+    short *neighbour_states , n_neighbours=0 ;
+    
+    n_states = n_states_ ;
+    
+    log_trans = (real *)Allocator::sysAlloc( 1000 * sizeof(real) ) ;
+    neighbour_states = (short *)Allocator::sysAlloc( 1000 * sizeof(short) ) ;
+    
+    // Allocate memory to hold the states
+    states = (DecodingHMMState **)Allocator::sysAlloc( n_states * sizeof(DecodingHMMState *) ) ;
+
+    // Create each state in turn
+    for ( short i=0 ; i<n_states ; i++ )
+    {
+        states[i] = (DecodingHMMState *)Allocator::sysAlloc( sizeof(DecodingHMMState) ) ;
+        initState( states[i] , states_[i] , emis_prob_vec_indices[i] ) ;
+    }
+
+    // Now go through the log_transitions array in the HMM instance
+    //   and extract only the non-zero transitions FROM this state.
+    for ( short from=0 ; from<n_states ; from++ )
+    {
+        n_neighbours = 0 ;
+        for ( short to=0 ; to<n_states ; to++ )
+        {
+            if ( log_trans_probs_[from][to] > LOG_ZERO )
+            {
+                log_trans[n_neighbours] = log_trans_probs_[from][to] ;
+                neighbour_states[n_neighbours++] = to ;
+            }
+        }
+        setupSuccessorStates( states[from] , n_neighbours , neighbour_states , log_trans ) ;
+    }
+
+    free( log_trans ) ;
+    free( neighbour_states ) ;
+}
+
+
+DecodingHMM::~DecodingHMM()
+{
+    if ( states != NULL )
+    {
+        for ( short i=0 ; i<n_states ; i++ )
+        {
+            free( states[i]->successor_states ) ;
+            free( states[i]->suc_log_trans_probs ) ;
+            free( states[i] ) ;
+        }
+        free( states ) ;
+    }
+}
+
+
+void DecodingHMM::mergeModels( int n_models , DecodingHMM **models )
+{
+    short index , prev_n_states , old_n_sucs ;
+    real old_prob ;
+    DecodingHMMState **new_states=NULL ;
+    
+    if ( n_models > 1 )
+    {
+        mergeModels( n_models-1 , models+1 ) ;
+
+        // We now need to merge models[0] with the current contents of this instance
+        //   into a model that has the initial state of model[0], emitting states of
+        //   model[0], emitting states of this instance, final state of this instance.
+        prev_n_states = n_states ;
+        n_states += (models[0]->n_states - 2) ;
+        new_states = (DecodingHMMState **)Allocator::sysAlloc( n_states * 
+                                                               sizeof(DecodingHMMState *) ) ;
+
+        // Create new state instances corresponding to each state in the model we have
+        //   to merge with  (except the final state) and insert these at the start
+        //   of the new array of states.
+        index = 0 ;
+        for ( short i=0 ; i<(models[0]->n_states-1) ; i++ )
+        {
+            new_states[index] = 
+                        (DecodingHMMState *)Allocator::sysAlloc( sizeof(DecodingHMMState) ) ;
+            initState( new_states[index] , models[0]->states[i]->distribution ,
+                       models[0]->states[i]->emission_prob_vec_index ) ;
+            index++ ;
+        }
+
+        // Copy all existing states except the initial state into the correct positions
+        //   at the end of the array of states and update their successor indices to
+        //   reflect the new positions.
+        for ( short i=1 ; i<prev_n_states ; i++ )
+        {
+            new_states[index] = states[i] ;
+            
+            // Update the state indices to match the combined model
+            for ( short j=0 ; j<new_states[index]->n_successors ; j++ )
+                new_states[index]->successor_states[j] += (models[0]->n_states - 2) ;
+
+            index++ ;
+        }
+
+        // Update the successor indices of the existing initial state of this instance
+        //   to reflect the new state positions.
+        for ( short j=0 ; j<states[0]->n_successors ; j++ )
+            states[0]->successor_states[j] += (models[0]->n_states - 2) ;
+
+        // Now update the successor information for the states from the first model.
+        for ( short i=0 ; i<(models[0]->n_states-1) ; i++ )
+        {
+            // Copy the successor information
+            setupSuccessorStates( new_states[i] , models[0]->states[i]->n_successors ,
+                                  models[0]->states[i]->successor_states ,
+                                  models[0]->states[i]->suc_log_trans_probs ) ;
+            
+            // Look at the last successor entry for each state.  If it is the final
+            //   state of the first model, remove the entry and replace it with the successors
+            //   of the initial state of the second model.
+            old_prob = new_states[i]->suc_log_trans_probs[new_states[i]->n_successors-1] ;
+            old_n_sucs = new_states[i]->n_successors ;
+            if ( new_states[i]->successor_states[new_states[i]->n_successors-1] == 
+                                                                    (models[0]->n_states-1) )
+            {
+                new_states[i]->n_successors += (states[0]->n_successors - 1) ;
+                new_states[i]->successor_states = (short *)Allocator::sysRealloc( 
+                                                new_states[i]->successor_states ,
+                                                new_states[i]->n_successors * sizeof(short) ) ;
+                                                     
+                new_states[i]->suc_log_trans_probs = (real *)Allocator::sysRealloc( 
+                                                     new_states[i]->suc_log_trans_probs ,
+                                                     new_states[i]->n_successors * sizeof(real) ) ;
+
+                for ( short j=0 ; j<(states[0]->n_successors) ; j++ )
+                {
+                    new_states[i]->successor_states[old_n_sucs+j-1] = 
+                                                                states[0]->successor_states[j] ;
+                    new_states[i]->suc_log_trans_probs[old_n_sucs+j-1] = old_prob + 
+                                                                states[0]->suc_log_trans_probs[j] ;
+                }
+            }
+        }
+        
+        if ( states[0]->successor_states != NULL )
+            free( states[0]->successor_states ) ;
+        if ( states[0]->suc_log_trans_probs != NULL )
+            free( states[0]->suc_log_trans_probs ) ;
+        free( states[0] ) ;
+        free( states ) ;
+        states = new_states ;
+    }
+    else if ( n_models == 1 )
+    {
+        // If we only have 1 model in the input array, just copy its contents
+        n_states = models[0]->n_states ;
+        states = (DecodingHMMState **)Allocator::sysAlloc( n_states * sizeof(DecodingHMMState *) ) ;
+        
+        for ( short i=0 ; i<n_states ; i++ )
+        {
+            states[i] = (DecodingHMMState *)Allocator::sysAlloc( sizeof(DecodingHMMState) ) ;
+            initState( states[i] , models[0]->states[i]->distribution ,
+                       models[0]->states[i]->emission_prob_vec_index ) ;
+            setupSuccessorStates( states[i] , models[0]->states[i]->n_successors ,
+                                  models[0]->states[i]->successor_states ,
+                                  models[0]->states[i]->suc_log_trans_probs ) ;
+        }
+    }
+}
+
+
+void DecodingHMM::initState( DecodingHMMState *state , Distribution *distribution_ ,
+                             short emission_prob_vec_index_ )
+{
+    state->distribution = distribution_ ;
+    state->emission_prob_vec_index = emission_prob_vec_index_ ;
+    state->n_successors = 0 ;
+    state->successor_states = NULL ;
+    state->suc_log_trans_probs = NULL ;
+}
+
+
+void DecodingHMM::setupSuccessorStates( DecodingHMMState *state , short n_successors_ , 
+                                        short *successor_states_ , real *log_trans_probs_ )
+{
+    state->n_successors = n_successors_ ;
+
+    if ( n_successors_ > 0 )
+    {
+        state->successor_states = (short *)Allocator::sysAlloc( n_successors_ * sizeof(short) ) ;
+        state->suc_log_trans_probs = (real *)Allocator::sysAlloc( n_successors_ * sizeof(real) ) ;
+        for ( int i=0 ; i<n_successors_ ; i++ )
+        {
+            state->successor_states[i] = successor_states_[i] ;
+            state->suc_log_trans_probs[i] = log_trans_probs_[i] ;
+        }
+    }
+}
+
+
+#ifdef DEBUG
+void DecodingHMM::outputText()
+{
+    printf("DecodingHMM with %d states\n*************************\n" , n_states) ;
+    for ( int i=0 ; i<n_states ; i++ )
+    {
+        printf("State %d :\n" , i ) ;
+        printf("DecodingHMMState: n_sucs=%d    ",states[i]->n_successors) ;
+        for ( int j=0 ; j<states[i]->n_successors ; j++ )
+            printf("%d ",states[i]->successor_states[j]) ;
+        printf("   ") ;
+        for ( int j=0 ; j<states[i]->n_successors ; j++ )
+            printf("%.20f ",states[i]->suc_log_trans_probs[j]) ;
+        printf("\n") ;
+    }
+    printf("\n") ;
+}
+#endif
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/DecodingHMM.h work/main.d/Torch-3/decoder/DecodingHMM.h
--- tmp/Torch-3/decoder/DecodingHMM.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/DecodingHMM.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,110 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DECODINGHMM_INC
+#define DECODINGHMM_INC
+
+#include "general.h"
+#include "Distribution.h"
+#include "HMM.h"
+
+namespace Torch {
+
+
+/* This structure is used to store all HMM state information 
+    required for decoding. Each state contains a list of successor 
+    states and associated transition probabilities.
+
+    @author Darren Moore (moore@idiap.ch)
+*/
+typedef struct
+{
+    Distribution *distribution ;
+    short emission_prob_vec_index ;
+    short n_successors ;
+    short *successor_states ;
+    real *suc_log_trans_probs ;
+} DecodingHMMState ;
+
+
+/** This class contains all HMM information required for decoding.  Most information
+    is embedded in the states themselves (DecodingHMMState structures).  The DecodingHMM
+    can be created a number of ways to facilitate compatibility with the Torch HMM class
+    and to allow easy concatenation of models (eg. when constructing word models from
+    phoneme models).
+    
+    @author Darren Moore (moore@idiap.ch)
+*/
+class DecodingHMM
+{
+public:
+    short n_states ;
+    DecodingHMMState **states ;
+
+    /* Constructors / destructor */
+    DecodingHMM() ;
+
+    /// Converts a Torch HMM instance to a DecodingHMM representation.  The Torch HMM
+    ///   class contains a lot of member variables used in training that are not
+    ///   required when decoding, as well as a full transition matrix.
+    DecodingHMM( HMM *orig_model , short *emis_prob_vec_indices ) ;
+
+    /// Concatenates all elements in the array of DecodingHMM instances into a single
+    ///   DecodingHMM.  Component models that have initial-final state transitions are ok.
+    DecodingHMM( int n_models , DecodingHMM **models ) ;
+
+    /// Creates a DecodingHMM using the distributions in 'states_' and the log
+    ///   transition probabilties in 'log_trans_probs_'.
+    DecodingHMM( short n_states_ , Distribution **states_ , real **log_trans_probs_ ,
+                 short *emis_prob_vec_indices ) ; 
+    virtual ~DecodingHMM() ;
+
+    /* Methods */
+
+    /// Internal function to merge component models into a big HMM
+    void mergeModels( int n_models , DecodingHMM **models ) ;
+
+    /// Configures successor state information for the state denoted by 'state'.
+    void setupSuccessorStates( DecodingHMMState *state , short n_successors_ , 
+                               short *sucessor_states_ , real *log_trans_probs_ ) ;
+
+    /// Initialises the state denoted by 'state' with a Distribution and
+    ///   optionally an index into the vector of emission probabilities.
+    void initState( DecodingHMMState *state , Distribution *distribution_ , 
+                    short emission_prob_vec_index_=-1 ) ;
+                               
+#ifdef DEBUG
+    void outputText() ;
+#endif
+} ;
+    
+
+}
+
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/DecodingHypothesis.cc work/main.d/Torch-3/decoder/DecodingHypothesis.cc
--- tmp/Torch-3/decoder/DecodingHypothesis.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/DecodingHypothesis.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,133 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "DecodingHypothesis.h"
+#include "WordChainElemPool.h"
+#include "log_add.h"
+
+
+namespace Torch {
+
+
+WordChainElemPool DecodingHypothesis::word_chain_elem_pool(1000) ;
+
+
+DecodingHypothesis::DecodingHypothesis()
+{
+    word = -1 ;
+    state = -1 ;
+    score = LOG_ZERO ;
+    word_level_info = NULL ;
+}
+
+
+DecodingHypothesis::DecodingHypothesis( int word_ , int state_ )
+{
+    word = word_ ;
+    state = state_ ;
+    score = LOG_ZERO ;
+    word_level_info = NULL ;
+}
+
+
+DecodingHypothesis::~DecodingHypothesis()
+{
+    if ( word_level_info != NULL )
+    {
+        if ( --(word_level_info->n_connected) <= 0 )
+            DecodingHypothesis::word_chain_elem_pool.returnElem( word_level_info ) ;
+    }
+}
+
+
+void DecodingHypothesis::initHyp( int word_ , int state_ )
+{
+    word = word_ ;
+    state = state_ ;
+    score = LOG_ZERO ;
+    word_level_info = NULL ;
+}
+
+
+void DecodingHypothesis::deactivate()
+{
+    score = LOG_ZERO ;
+    if ( word_level_info != NULL )
+    {
+        if ( --(word_level_info->n_connected) <= 0 )
+        {
+            // Only this hypothesis is accessing this word-level information.
+            // Return the word_level_info instance to the word_chain_elem_pool.
+#ifdef DEBUG
+            if ( word_level_info->n_connected < 0 )
+                error("DecodingHypothesis::deactivate - n_connected < 0\n") ;
+#endif
+            DecodingHypothesis::word_chain_elem_pool.returnElem( word_level_info ) ;
+        }
+        word_level_info = NULL ;
+    }
+}
+
+
+void DecodingHypothesis::extendWord( real new_score , WordChainElem *new_word_chain_elem )
+{
+#ifdef DEBUG
+    if ( new_word_chain_elem == NULL )
+        error("DecodingHypothesis:extendWord - new_word_chain_elem is NULL\n");
+#endif
+    deactivate() ;
+    score = new_score ;
+    word_level_info = new_word_chain_elem ;
+    new_word_chain_elem->n_connected++ ;
+}
+            
+
+void DecodingHypothesis::extendState( DecodingHypothesis *prev_hyp , real new_score )
+{
+#ifdef DEBUG
+    if ( prev_hyp->word_level_info == NULL )
+        error("DecodingHypothesis:extendState - prev_hyp->word_level_info is NULL\n") ;
+#endif
+    deactivate() ;
+    score = new_score ;
+    word_level_info = prev_hyp->word_level_info ;
+    if ( word_level_info != NULL )
+        word_level_info->n_connected++ ;
+}
+
+
+#ifdef DEBUG
+void DecodingHypothesis::outputText()
+{
+    printf("word=%d, state=%d, score=%.3f\n",word,state,score);
+}
+#endif
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/DecodingHypothesis.h work/main.d/Torch-3/decoder/DecodingHypothesis.h
--- tmp/Torch-3/decoder/DecodingHypothesis.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/DecodingHypothesis.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,88 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DECODINGHYPOTHESIS_INC
+#define DECODINGHYPOTHESIS_INC
+
+#include "general.h"
+#include "WordChainElemPool.h"
+
+namespace Torch {
+
+
+/** This class contains all hypothesis data that needs to be updated
+    and propagated as hypotheses are extended through word models and 
+    across word boundaries.  Methods are provided to transfer data
+    between DecodingHypothesis objects in varying ways.
+
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class DecodingHypothesis
+{
+public:
+    int word ;      // the index of the pronunciation in the lexicon
+    int state ;
+    real score ;
+    WordChainElem *word_level_info ;
+    static WordChainElemPool word_chain_elem_pool ;
+
+    /* Constructors / destructor */
+    
+    DecodingHypothesis() ;
+    DecodingHypothesis( int word_ , int state_ ) ;
+    virtual ~DecodingHypothesis() ;
+
+    /* Methods */
+
+    void initHyp( int word_ , int state_ ) ;
+
+    /// Unlinks this instance from its word_level_info member variable.
+    /// If this instance was the only entity connected to the
+    ///   word_level_info object, then the word_level_info object is
+    ///   returned to the global word_chain_elem_pool.
+    void deactivate() ;
+
+    /// Updates the hypothesis information when a word boundary
+    ///   has been crossed.
+    void extendWord( real new_score , WordChainElem *new_word_chain_elem ) ;
+
+    /// Updates the hypothesis information when a word-interior state
+    ///   transition has been made.
+    void extendState( DecodingHypothesis *prev_hyp , real new_score ) ;
+
+#ifdef DEBUG
+    void outputText() ;
+#endif
+} ;
+
+
+}
+
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LanguageModel.cc work/main.d/Torch-3/decoder/LanguageModel.cc
--- tmp/Torch-3/decoder/LanguageModel.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LanguageModel.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,665 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "LanguageModel.h"
+#include "string_stuff.h"
+#include "DiskXFile.h"
+
+
+namespace Torch {
+
+
+LanguageModel::LanguageModel( int order_ , Vocabulary *vocabulary_ , 
+                              char *lm_fname , real lm_scaling_factor_ )
+{
+    FILE *lm_fd ;
+    char buf[4] ;
+    
+    if ( vocabulary_ == NULL )
+        error("LanguageModel::LanguageModel - no vocabulary defined\n") ;
+    if ( order_ <= 0 )
+        error("LanguageModel::LanguageModel - LM order must be > 0\n") ;
+    if ( (lm_fname == NULL) || (strcmp(lm_fname,"")==0) )
+        error("LanguageModel::LanguageModel - no LM filename specified\n") ;
+        
+    order = order_ ;
+    vocabulary = vocabulary_ ;
+    n_words = vocabulary->n_words ;
+    lm_scaling_factor = lm_scaling_factor_ ;
+    ngram = new LMNGram( order , vocabulary ) ;
+
+    lm_has_start_word = false ;
+    lm_has_end_word = false ;
+
+    // Open the LM file
+    if ( (lm_fd = fopen( lm_fname , "r" )) == NULL )
+        error("LanguageModel::LanguageModel - error opening LM file\n") ;
+
+    // Read the first 4 bytes to see if the file is a Noway binary file
+    if ( (int)fread( buf , sizeof(char) , 4 , lm_fd ) != 4 )
+        error("LanguageModel::LanguageModel - error reading first 4 bytes\n") ;
+    
+    if ( (strcmp( buf , "NG3" ) == 0) || (strcmp( buf , "TR2" ) == 0) )
+    {
+        // The file is in Noway binary format.
+        readNowayBin( lm_fd ) ;
+    }
+    else
+    {
+        // Assume that the file is in ARPA format.
+        fseek( lm_fd , 0 , SEEK_SET ) ;
+        readARPA( lm_fd ) ;
+    }
+
+    fclose( lm_fd ) ;
+ 
+#ifdef DEBUG
+    //outputText() ;
+#endif
+}
+
+
+LanguageModel::~LanguageModel()
+{
+    if ( ngram != NULL )
+        delete ngram ;
+}
+
+
+real LanguageModel::calcLMProb( DecodingHypothesis *prev_word_end_hyp , int next_word )
+{
+    int words[30] , n_wrds ;
+    WordChainElem *temp_elem ;
+    real prob ;
+
+#ifdef DEBUG
+    if ( next_word < 0 )
+        error("LanguageModel::calcLMProb(2) - next_word < 0\n") ;
+#endif
+
+    // We have a word end hypothesis and a next word.
+    // We want to calculate the LM probability for this next word.
+    // eg. We have a word end for some w2 and a next word w3.
+    //     We want to calculate P(w3|w1,w2)
+    
+    // If the next word is silence or a sentence marker, don't do a LM lookup.
+    if ( (next_word == vocabulary->sent_start_index) && (lm_has_start_word == false) )
+        return 0.0 ;
+    if ( (next_word == vocabulary->sent_end_index) && (lm_has_end_word == false) )
+        return 0.0 ;
+    if ( next_word == vocabulary->sil_index )
+        return 0.0 ;
+    
+    // Construct a list of the previous words.
+    n_wrds = 0 ;
+    if ( prev_word_end_hyp != NULL )
+    {    
+        temp_elem = prev_word_end_hyp->word_level_info ;
+#ifdef DEBUG
+        if ( prev_word_end_hyp->word_level_info == NULL )
+            error("LanguageModel::calcLMProb(2) - word_level_info is NULL\n") ;
+#endif
+
+        while ( temp_elem != NULL )
+        {
+            if ( (temp_elem->word == vocabulary->sil_index) ||
+                 ((lm_has_start_word==false) && (temp_elem->word==vocabulary->sent_start_index)) )
+            {
+                // skip these words for the purpose of LM lookups
+                temp_elem = temp_elem->prev_elem ;
+                continue ;
+            }
+
+            words[n_wrds++] = temp_elem->word ;
+            temp_elem = temp_elem->prev_elem ;
+            if ( n_wrds >= (order-1) )
+                break ;
+        }
+    }
+    
+    words[n_wrds++] = next_word ;
+    
+    // Find the n-gram probability
+    prob = ngram->getLogProbBackoff( n_wrds , words ) ;
+
+    // Scale the n-gram probability using the LM scaling factor.
+    // Note that we are multiplying the log LM prob by the scaling factor
+    prob *= lm_scaling_factor ;
+
+    return ( prob ) ;
+}
+
+
+real LanguageModel::calcLMProb( DecodingHypothesis *word_end_hyp )
+{
+    int words[30] , n_wrds , temp , j ;
+    WordChainElem *temp_elem ;
+    real prob ;
+    
+    if ( word_end_hyp == NULL )
+        return LOG_ZERO ;
+        
+    // We have a word end hypothesis.  We want to tune this using our language model.
+    // eg. we have a word end for some w3 and we want to tune this using P(w3|w1,w2)
+        
+    // Construct a list of the current word and previous words.
+    n_wrds = 0 ;
+    temp_elem = word_end_hyp->word_level_info ;
+#ifdef DEBUG
+    if ( word_end_hyp->word_level_info == NULL )
+        error("LanguageModel::calcLMProb - word_level_info is NULL\n") ;
+#endif
+    // If the most recent word is a sentence marker and the LM does not
+    //   have entries for the sentence markers, don't do a LM lookup.
+    if ( (temp_elem->word == vocabulary->sent_start_index) && (lm_has_start_word == false) )
+        return 0.0 ;
+    if ( (temp_elem->word == vocabulary->sent_end_index) && (lm_has_end_word == false) )
+        return 0.0 ;
+    if ( temp_elem->word == vocabulary->sil_index )
+        return 0.0 ;
+
+    while ( temp_elem != NULL )
+    {
+        if ( (temp_elem->word == vocabulary->sil_index) ||
+            ((lm_has_start_word==false) && (temp_elem->word==vocabulary->sent_start_index)) )
+        {
+            // skip these words for the purpose of LM lookups
+            temp_elem = temp_elem->prev_elem ;
+            continue ;
+        }
+        words[n_wrds++] = temp_elem->word ;
+        temp_elem = temp_elem->prev_elem ;
+        if ( n_wrds >= order )
+            break ;
+    }
+
+    // The method in LMNGram requires a different ordering of words
+    temp = words[0] ;
+    for ( j=1 ; j<n_wrds ; j++ )
+        words[j-1] = words[j] ;
+    words[n_wrds-1] = temp ;
+        
+    // Find the n-gram probability
+    prob = ngram->getLogProbBackoff( n_wrds , words ) ;
+
+    // Scale the n-gram probability using the LM scaling factor.
+    // Note that we are multiplying the log LM prob by the scaling factor
+    //   IS THIS OK ?
+    prob *= lm_scaling_factor ;
+
+    // Tune the word end hypothesis score using the n-gram probability and return
+    return ( prob ) ;
+}
+
+
+void LanguageModel::readARPA( FILE *arpa_fd )
+{
+    int n_exp_entries[30] ; // n_exp_entries[0] is the expected number of unigram entries
+                            // n_exp_entries[0] is the expected number of bigram entries
+    int n_act_entries[30] ; // the actual number of entries read from the file.
+    int words[30] ;    // holds the predecessor words for a given word.
+    real curr_prob=0.0 , curr_bow=0.0 ;
+    char *curr_word=NULL ;
+    int curr_index ;
+    real ln_10 = (real)log(10.0) ;
+    int tempn=0 , tempn_entries=0 , max_n_in_file=0 ;
+    char line[1000] ;
+    bool got_begin_data_mark=false , expecting_end=false , got_end=false , error_flag ;
+    int curr_gram_data=0 ;
+    
+    if ( arpa_fd == NULL )
+        error("LanguageModel::readARPA - arpa_fd is NULL\n") ;
+        
+    // discard lines until we get the "beginning of data mark".
+    while ( fgets( line , 1000 , arpa_fd ) != NULL )
+    {
+        // if the new line is empty, get the next line
+        if ( (line[0]==' ') || (line[0]=='\r') || (line[0]=='\n') || (line[0]=='\t') ||
+             (line[0]=='#') )
+            continue ;
+            
+        if ( line[0] == '\\' )
+        {
+            strtoupper( line ) ;
+            if ( strstr( line , "\\END\\" ) != NULL )
+            {
+                if ( curr_gram_data < order )
+                {
+                    // we haven't encountered the n-grams we expected
+                    error("LanguageModel::readARPA - not enough data in file\n") ;
+                }
+            
+                // we've reached the end of the ARPA file - we're done
+                got_end = true ;
+                break ;
+            }
+            else if ( expecting_end == true )
+            {
+                // we're expecting the end marker and didn't get it - get the next line
+                continue ;
+            }
+            else if ( strstr( line , "\\DATA\\" ) != NULL )
+            {
+                if ( got_begin_data_mark == true )
+                {
+                    // we have already seen the beginning of data marker - error !
+                    error("LanguageModel::readARPA - duplicate beginning of data marker\n") ;
+                }
+                got_begin_data_mark = true ;
+            }
+            else if ( strstr( line , "-GRAMS:" ) != NULL )
+            {
+                if ( got_begin_data_mark == true )
+                {
+                    // find out whether we are at the start of the 1-gram, 
+                    //   2-gram, 3-gram, etc data.
+                    if ( (curr_gram_data+1) != ( line[1]-0x30 ) )
+                        error("LanguageModel::readARPA - N-Gram N out of order\n") ;
+
+                    curr_gram_data = line[1]-0x30 ;
+                    n_act_entries[curr_gram_data-1] = 0 ;
+                    if ( curr_gram_data > order )
+                    {
+                        // the order has exceeded the order of our LM - we're done 
+                        //   reading probabilties.
+                        expecting_end = true ;
+                    }
+                }
+            }
+            else
+            {
+                // we got something else that started with a '\' - error !!
+                error("LanguageModel::readARPA - unrecognised marker\n%s\n",line) ;
+            }
+        }
+        else
+        {
+            if ( (got_begin_data_mark == false) || (expecting_end == true) )
+                continue ;
+
+            if ( strstr( line , "<UNK>") != NULL )
+            {
+                n_exp_entries[curr_gram_data-1]-- ;
+                continue ;
+            }
+
+            if ( curr_gram_data == 0 )
+            {
+                // we are just below the \data\ - therefore expecting ngram x=y lines
+                sscanf( line , "%*s %d=%d" , &tempn , &tempn_entries ) ;
+                if ( tempn != (max_n_in_file+1) )
+                    error("LanguageModel::readARPA - ngram n=y -> unexpected n\n") ;
+                max_n_in_file = tempn ;
+                if ( tempn <= order )
+                    n_exp_entries[tempn-1] = tempn_entries ;
+            }    
+            else if ( (curr_gram_data > 0) && (curr_gram_data < max_n_in_file) )
+            {
+                // The line should contain (curr_gram_data+2) fields.
+                // eg. for 2-gram entry -> p wd_1 wd_2 bo_wt_2
+            
+                // Read the probability from the first field (in log10 format) and convert
+                //   to ln format.
+#ifdef USE_DOUBLE
+                if ( sscanf( line , "%lf" , &curr_prob ) != 1 )
+#else
+                if ( sscanf( line , "%f" , &curr_prob ) != 1 )
+#endif
+                    error("LanguageModel::readARPA - error reading prob\n") ;
+                if ( curr_prob < -90.0 )
+                    curr_prob = LOG_ZERO/2 ;
+                else
+                    curr_prob *= ln_10 ;
+                
+                // get past the prob field so we can read the words
+                strtok( line , " \n\r\t" ) ;
+                                
+                // read wd_1 , ... , wd_n (ie. all predecessor words of wd_n)
+                error_flag = false ;
+                for ( int i=0 ; i<curr_gram_data ; i++ )
+                {
+                    // Extract the next word from the line
+                    curr_word = strtok( NULL , " \n\r\t" ) ;
+
+                    // determine the index of the word in the vocabulary
+                    curr_index = vocabulary->getIndex( curr_word ) ;
+                    if ( curr_index < 0 ) 
+                    {
+                        // The word is not in our vocab - don't add the entry to our LM
+                        error_flag = true ;
+                        n_exp_entries[curr_gram_data-1]-- ;
+                        break ;
+                        //error("LanguageModel::readARPA - %s in ARPA file not in vocab\n" ,
+                        //                           curr_word ) ;
+                    }
+                    else
+                    {
+                        if ( curr_index == vocabulary->sent_start_index )
+                            lm_has_start_word = true ;
+                        if ( curr_index == vocabulary->sent_end_index )
+                            lm_has_end_word = true ;
+                    }
+                    
+                    // Place the word index into the array of predecessor words in
+                    //   oldest-word-first order.
+                    words[i] = curr_index ;
+                }
+
+                if ( error_flag == true )
+                    continue ;
+
+                // Extract the back off weight from the last field in the line and
+                //   convert from log10 to ln.
+#ifdef USE_DOUBLE
+                if ( sscanf( strtok( NULL , " \n\r\t" ) , "%lf" , &curr_bow ) != 1 )
+#else
+                if ( sscanf( strtok( NULL , " \n\r\t" ) , "%f" , &curr_bow ) != 1 )
+#endif
+                    error("LanguageModel::readARPA - back off weight not found\n") ;
+                if ( curr_bow < -90.0 )
+                    curr_bow = 0.0 ;
+                else
+                    curr_bow *= ln_10 ;
+                
+                // add the entry to the curr_gram_data-gram for the new word
+                ngram->addEntry( curr_gram_data, words, curr_prob, curr_bow ) ;
+                n_act_entries[curr_gram_data-1]++ ;
+            }
+            else if ( curr_gram_data == max_n_in_file )
+            {
+                // The line should contain (curr_gram_data+1) fields because
+                //   backoff weights are only required for N-grams that form a prefix of
+                //   longer N-grams in the model file (ie. not this one - the longest).
+                // eg. for 4-gram entry -> p wd_1 wd_2 wd_3 wd_4
+                //    (where 4-gram probabilities are the maximum in the file.
+            
+                // read the probability from the first field
+#ifdef USE_DOUBLE
+                sscanf( line , "%lf" , &curr_prob ) ;
+#else
+                sscanf( line , "%f" , &curr_prob ) ;
+#endif
+                if ( curr_prob < -90.0 )
+                    curr_prob = LOG_ZERO/2 ;
+                else
+                    curr_prob *= ln_10 ;
+                
+                // get past the prob field so we can read the words
+                strtok( line , " \n\r\t" ) ;
+                                
+                // read wd_1 , ... , wd_n and insert indices in 'words' array.
+                error_flag = false ;
+                for ( int i=0 ; i<curr_gram_data ; i++ )
+                {
+                    // Extract the next word from the line
+                    curr_word = strtok( NULL , " \n\r\t" ) ;
+
+                    // determine the index of the word in the vocabulary
+                    curr_index = vocabulary->getIndex( curr_word ) ;
+                    if ( curr_index < 0 ) 
+                    {
+                        // The word is not in our vocab - don't add the entry to our LM
+                        error_flag = true ;
+                        n_exp_entries[curr_gram_data-1]-- ;
+                        break ;
+                        //error("LanguageModel::readARPA - %s in ARPA file not in vocab\n" ,
+                        //                           curr_word ) ;
+                    }
+                    else
+                    {
+                        if ( curr_index == vocabulary->sent_start_index )
+                            lm_has_start_word = true ;
+                        if ( curr_index == vocabulary->sent_end_index )
+                            lm_has_end_word = true ;
+                    }
+                    
+                    // Place the word index into the array of predecessor words in
+                    //   oldest-word-first order.
+                    words[i] = curr_index ;
+                }
+                    
+                if ( error_flag == true )
+                    continue ;
+
+                // add the entry to the curr_gram_data-gram for the new word
+                n_act_entries[curr_gram_data-1]++ ;
+                ngram->addEntry( curr_gram_data , words , curr_prob ) ;
+            }
+        }
+    }   
+    
+    // make sure that we got the /end/ marker
+    if ( got_end == false )
+        error("LanguageModel::readARPA - EOF but no end marker\n") ;
+        
+    // Issue warnings if the number of expected entries for each n-gram did
+    //   not match the actual number read from the file
+    for ( int i=0 ; i<order ; i++ )
+    {
+        if ( n_exp_entries[i] != n_act_entries[i] )
+        {
+            warning("LanguageModel::readARPA - warning - %d-gram entry count mismatch\n" , i+1 ) ;
+            warning("\t%d expected != %d actual\n",n_exp_entries[i],n_act_entries[i]) ;
+        }
+    }
+}
+
+
+void LanguageModel::readNowayBin( FILE *nw_fd )
+{
+    // This reads a Noway Binary format language model file.
+    // Only the TR2 and NG3 types are supported (ie. trigrams).
+    char buf[1000] , *bptr , c ;
+    int n_xgrams[3] ;
+    unsigned short wd_index , log10_prob , n_bigrams , n_trigrams ;
+    short log10_backoff ;
+    int *vocab_index_map ;
+    int total_bigrams=0 , total_trigrams=0 , words[3] ;
+    real prob , backoff ;
+    real neg_ln_10 = -log(10.0) , ln_10 = log(10.0) ;
+    bool uni_invocab=true , bi_invocab=true , tri_invocab=true ;
+    DiskXFile *lm_file ;
+    
+#ifdef DEBUG
+    if ( (sizeof(unsigned short) != 2) || (sizeof(int) != 4) )
+        error("LanguageModel::readNowayBin - unexpected type sizes\n") ;
+#endif
+
+    if ( nw_fd == NULL )
+        error("LanguageModel::readNowayBin - nw_fd is NULL\n") ;
+    if ( order > 3 )
+        error("LanguageModel::readNowayBin - order is greater than 3\n") ;
+
+    lm_file = new DiskXFile( nw_fd ) ;
+    
+    // Assume that the first 4-bytes have already been read, 
+    //   and have been verified to contain TR2 or NG3.
+    // Read the number of unigrams, bigrams and trigrams.
+    if ( lm_file->read( n_xgrams , sizeof(int) , 3 ) != 3 )
+        error("LanguageModel::readNowayBin - error reading number of ngrams\n") ;
+
+    // Allocate memory to hold the mapping between our vocab indices and
+    //   the indices in the file.
+    vocab_index_map = (int *)Allocator::sysAlloc( n_xgrams[0] * sizeof(int) ) ;
+
+    // Now read in the "vocabulary"
+    for ( int i=0 ; i<n_xgrams[0] ; i++ )
+    {
+        // Read the word string and make sure it is uppercase
+        bptr = buf ;
+        lm_file->read( &c , 1 , 1 ) ;
+        while ( c > 0 )
+        {
+            *bptr = (unsigned char)c ;
+            bptr++ ;
+            lm_file->read( &c , 1 , 1 ) ;
+        }
+        *bptr = '\0' ;
+        //strtoupper( buf ) ;
+        
+        // Read the word index from the file
+        if ( lm_file->read( &wd_index , sizeof(unsigned short) , 1 ) != 1 )
+            error("LanguageModel::readNowayBin - error reading word index\n") ;
+
+        if ( wd_index >= n_xgrams[0] )
+            error("LanguageModel::readNowayBin - word index exceeds num unigrams\n") ;
+            
+        // Find the index of the word in our vocabulary and store the mapping.
+        vocab_index_map[wd_index] = vocabulary->getIndex( buf ) ;
+
+        if ( (vocab_index_map[wd_index] >= 0) && 
+             (vocab_index_map[wd_index] == vocabulary->sent_start_index) )
+             lm_has_start_word = true ;
+        if ( (vocab_index_map[wd_index] >= 0) && 
+             (vocab_index_map[wd_index] == vocabulary->sent_end_index) )
+             lm_has_end_word = true ;
+    }
+    
+    // Now we read the unigram, bigram and trigram entries.
+    for ( int i=0 ; i<n_xgrams[0] ; i++ )
+    {
+        // Read the word index from file
+        if ( lm_file->read( &wd_index , sizeof(unsigned short) , 1 ) != 1 )
+            error("LanguageModel::readNowayBin - error reading unigram word index\n") ;
+        if ( vocab_index_map[wd_index] < 0 )
+            uni_invocab = false ;
+        
+        // Read the probability ( -(log10(prob)*8192) format ) and convert to ln(prob).
+        if ( lm_file->read( &log10_prob , sizeof(unsigned short) , 1 ) != 1 )
+            error("LanguageModel::readNowayBin - error reading unigram prob\n") ;
+        prob = ((real)log10_prob / 8192.0) * neg_ln_10 ;
+        
+        // Read the backoff weight
+        if ( lm_file->read( &log10_backoff , sizeof(short) , 1 ) != 1 )
+            error("LanguageModel::readNowayBin - error reading unigram backoff\n") ;
+        backoff = ((real)log10_backoff / 8192.0) * ln_10 ;
+
+#ifdef DEBUG
+        if ( prob > 0.0 )
+            error("LanguageModel::readNowayBin - prob > 0.0\n") ;
+#endif
+
+        // Read the number of bigrams associated with this word
+        if ( lm_file->read( &n_bigrams , sizeof(unsigned short) , 1 ) != 1 )
+            error("LanguageModel::readNowayBin - error reading number of bigrams\n") ;
+        total_bigrams += n_bigrams ;
+
+        if ( uni_invocab == true )
+        {
+            // Add the new entry to the 1-gram
+            words[0] = vocab_index_map[wd_index] ;
+            ngram->addEntry( 1 , words , prob , backoff ) ;
+        }
+        
+        // Now read all the bigrams that have the current word as the predecessor
+        for ( int j=0 ; j<n_bigrams ; j++ )
+        {
+            // Read the word index from file
+            if ( lm_file->read( &wd_index , sizeof(unsigned short) , 1 ) != 1 )
+                error("LanguageModel::readNowayBin - error reading bigram word index\n") ;
+            if ( vocab_index_map[wd_index] < 0 )
+                bi_invocab = false ;
+            
+            // Read the probability ( -(log10(prob)*8192) format ) and convert to ln(prob).
+            if ( lm_file->read( &log10_prob , sizeof(unsigned short) , 1 ) != 1 )
+                error("LanguageModel::readNowayBin - error reading bigram prob\n") ;
+            prob = ((real)log10_prob / 8192.0) * neg_ln_10 ;
+
+            // Read the backoff weight
+            if ( lm_file->read( &log10_backoff , sizeof(short) , 1 ) != 1 )
+                error("LanguageModel::readNowayBin - error reading bigram backoff\n") ;
+            backoff = ((real)log10_backoff / 8192.0) * ln_10 ;
+#ifdef DEBUG
+            if ( prob>0.0 )
+                error("LanguageModel::readNowayBin - bigram prob > 0.0\n") ;
+#endif
+
+            // Read the number of trigrams associated with this word
+            if ( lm_file->read( &n_trigrams , sizeof(unsigned short) , 1 ) != 1 )
+                error("LanguageModel::readNowayBin - error reading number of trigrams\n") ;
+            total_trigrams += n_trigrams ;
+
+            // Add the new entry to the 2-gram
+            if ( (uni_invocab == true) && (bi_invocab == true) )
+            {
+                words[1] = vocab_index_map[wd_index] ;
+                if ( order >= 2 )
+                    ngram->addEntry( 2 , words , prob , backoff ) ;
+            }
+        
+            // Now read all the trigrams that have the current bigram as the predecessor
+            for ( int k=0 ; k<n_trigrams ; k++ )
+            {
+                // Read the word index from file
+                if ( lm_file->read( &wd_index , sizeof(unsigned short) , 1 ) != 1 )
+                    error("LanguageModel::readNowayBin - error reading trigram word index\n") ;
+                if ( vocab_index_map[wd_index] < 0 )
+                    tri_invocab = false ;
+                    
+                // Read the probability ( -(log10(prob)*8192) format ) and convert to ln(prob).
+                if ( lm_file->read( &log10_prob , sizeof(unsigned short) , 1 ) != 1 )
+                    error("LanguageModel::readNowayBin - error reading trigram prob\n") ;
+                prob = ((real)log10_prob / 8192.0) * neg_ln_10 ;
+
+#ifdef DEBUG
+                if ( prob > 0.0 )
+                    error("LanguageModel::readNowayBin - bigram prob or backoff > 0.0\n") ;
+#endif
+
+                // Add the new entry to the 3-gram
+                if ( (uni_invocab == true) && (bi_invocab == true) && (tri_invocab == true) )
+                {
+                    words[2] = vocab_index_map[wd_index] ;
+                    if ( order >= 3 )
+                        ngram->addEntry( 3 , words , prob ) ;
+                }
+                tri_invocab = true ;
+            }
+            bi_invocab = true ;
+        }
+        uni_invocab = true ;
+    }
+
+    if ( (total_bigrams != n_xgrams[1]) || (total_trigrams != n_xgrams[2]) )
+        error("LanguageModel::readNowayBin - did not read expected number of bi & trigrams\n") ;
+
+    free( vocab_index_map ) ;
+    delete lm_file ;
+}
+
+
+#ifdef DEBUG
+void LanguageModel::outputText()
+{
+    ngram->outputText() ;
+}
+#endif
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LanguageModel.h work/main.d/Torch-3/decoder/LanguageModel.h
--- tmp/Torch-3/decoder/LanguageModel.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LanguageModel.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,97 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LANGUAGEMODEL_INC
+#define LANGUAGEMODEL_INC
+
+#include "general.h"
+#include "DecodingHypothesis.h"
+#include "Vocabulary.h"
+#include "LMNGram.h"
+
+namespace Torch {
+
+
+/** 
+    This object implements an n-gram language model. The n-gram data structures
+    are encapsulated in the ngram member variable (see LMNGram class). Methods
+    are provided to read a LM file in ARPA format or in Noway binary format.
+    A method is provided to calculate a LM prob (with backoff) for a given 
+    sequence of words.
+      
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class LanguageModel
+{
+public:
+    int order ;
+    int n_words ;
+    Vocabulary *vocabulary ;
+    LMNGram *ngram ;
+    real lm_scaling_factor ;
+
+    bool lm_has_start_word ;
+    bool lm_has_end_word ;
+
+    /* constructors / destructor */
+
+    /// Creates the language model. 
+    /// 'order_' is the order of the LM (eg. 3 for trigram).
+    LanguageModel( int order_ , Vocabulary *vocabulary_ , char *lm_fname , 
+                   real lm_scaling_factor_=1.0 ) ; 
+    virtual ~LanguageModel() ;
+
+    /* methods */
+    /// Calculates the language model probability (with backoff) of the word
+    ///   sequence stored in the hypothesis pointed to by 'word_end_hyp'.
+    real calcLMProb( DecodingHypothesis *word_end_hyp ) ;
+    
+    /// Calculates the language model probability (with backoff) of 'next_word'
+    ///   given the previous word sequence stored in the hypothesis pointed to 
+    ///   by 'prev_word_end_hyp'.
+    real calcLMProb( DecodingHypothesis *prev_word_end_hyp , int next_word ) ;
+
+    /// Creates a language model from an ARPA format file. Internal function.
+    void readARPA( FILE *arpa_fd ) ;
+    
+    /// Creates a language model from an Noway binary LM format file. Internal function.
+    /// nb. Only the TR2 and NG3 types are supported (ie. trigrams). 
+    void readNowayBin( FILE *nw_fd ) ;
+
+#ifdef DEBUG
+    void outputText() ;
+#endif
+};
+
+
+
+}
+
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LICENSE work/main.d/Torch-3/decoder/LICENSE
--- tmp/Torch-3/decoder/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LICENSE	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,28 @@
+
+Copyright (c) 2003--2004 Ronan Collobert
+Copyright (c) 2003--2004 Samy Bengio
+Copyright (c) 2003--2004 Johnny Mariéthoz
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LinearLexicon.cc work/main.d/Torch-3/decoder/LinearLexicon.cc
--- tmp/Torch-3/decoder/LinearLexicon.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LinearLexicon.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,194 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "LinearLexicon.h"
+#include "log_add.h"
+#include "string_stuff.h"
+
+
+namespace Torch {
+
+
+LinearLexicon::LinearLexicon( SpeechHMM *speech_hmm , PhoneModels *phone_models_ )
+{
+    if ( speech_hmm == NULL )
+        error("LinearLexicon::LinearLexicon(2) - speech_hmm is NULL\n") ;
+   
+    createLinearLexicon( speech_hmm->lexicon , phone_models_ ) ;
+}
+
+
+LinearLexicon::LinearLexicon( LexiconInfo *lex_info_ , PhoneModels *phone_models_ )
+{
+    createLinearLexicon( lex_info_ , phone_models_ ) ;
+}
+
+
+void LinearLexicon::createLinearLexicon( LexiconInfo *lex_info_ , PhoneModels *phone_models_ )
+{
+    DecodingHMM **temp_models=NULL ;
+    int max_n_phones=100 , n_phones ;
+    short n_sucs , *sucs ;
+    real *sucs_log_trans_probs ;
+	
+    if ( lex_info_ == NULL )
+        error("LinearLexicon::createLinearLexicon - lex_info_ is NULL\n") ;
+    if ( phone_models_ == NULL )
+        error("LinearLexicon::createLinearLexicon - phone_models_ is NULL\n") ;
+
+    lex_info = lex_info_ ;
+    phone_models = phone_models_ ;
+    
+    if ( (lex_info->sent_start_index >=0) && 
+         (lex_info->sent_start_index == lex_info->sent_end_index) )
+        error("LinearLexicon::createLinearLexicon - sent start & end cannot be the same word\n") ;
+        
+    n_models = lex_info->n_entries ;
+    models = (DecodingHMM **)Allocator::sysAlloc( n_models * sizeof(DecodingHMM *) ) ; 
+    total_states = 0 ;
+
+    // Allocate memory to hold the temporary list of models that gets assembled for each word
+    temp_models = (DecodingHMM **)Allocator::sysAlloc( max_n_phones * sizeof(DecodingHMM *) ) ;
+    for ( int i=0 ; i<n_models ; i++ )
+    {
+        n_phones = lex_info->entries[i].n_phones ;
+        
+        // Check that the temp array that is used to assemble the list of phone models is
+        //   big enough.
+        if ( n_phones > max_n_phones )
+        {
+            // Realloc some more memory for our temp array
+            max_n_phones = n_phones + 1 ;
+            temp_models = (DecodingHMM **)Allocator::sysRealloc( temp_models ,
+                                                    max_n_phones * sizeof(DecodingHMM *) ) ;
+        }
+        
+        for ( int j=0 ; j<n_phones ; j++ )
+            temp_models[j] = phone_models->models[lex_info->entries[i].phones[j]] ;
+
+        if ( (lex_info->phone_info->pause_index >= 0) &&
+             (lex_info->entries[i].phones[n_phones-1] != lex_info->phone_info->pause_index) &&
+             (lex_info->entries[i].phones[n_phones-1] != lex_info->phone_info->sil_index) )
+        {
+            // If there is a pause phone defined, and the word does not already have a pause
+            //   or silence phone at the end, then add the pause model to the end of the list.
+            temp_models[n_phones] = phone_models->models[phone_models->phone_info->pause_index] ;
+            n_phones++ ;
+        }
+        
+        models[i] = new DecodingHMM( n_phones , temp_models ) ;
+
+        // Check that there is not an initial to final state transition
+        n_sucs = models[i]->states[0]->n_successors ;
+        sucs = models[i]->states[0]->successor_states ;
+        sucs_log_trans_probs = models[i]->states[0]->suc_log_trans_probs ;
+        if ( sucs[n_sucs-1] == (models[i]->n_states-1) )
+            error("LinearLexicon::createLinearLexicon - initial-final transition in word %d\n",i) ;
+        
+        // Scale the transition probs from the initial state of the new model
+        //   using the prior.
+        for ( int j=0 ; j<n_sucs ; j++ )
+            sucs_log_trans_probs[j] += lex_info->entries[i].log_prior ;
+    }
+ 
+    // Calculate the total number of states in all pronunciation models
+    for ( int i=0 ; i<n_models ; i++ )
+        total_states += models[i]->n_states ;
+
+    if ( temp_models != NULL )
+        free( temp_models ) ;
+}
+
+
+LinearLexicon::~LinearLexicon()
+{
+    if ( models != NULL )
+    {
+        for ( int i=0 ; i<n_models ; i++ )
+            delete models[i] ;
+        free( models ) ;
+    }
+}
+
+
+real LinearLexicon::calcEmissionProb( int word , int state )
+{
+#ifdef DEBUG
+    if ( (word < 0) || (word >= n_models) )
+        error("LinearLexicon::calcEmissionProb - word out of range\n") ;
+#endif
+
+    return phone_models->calcEmissionProb( models[word]->states[state]->emission_prob_vec_index ,
+                                           models[word]->states[state]->distribution ) ;
+}
+
+
+int LinearLexicon::nStatesInModel( int model )
+{
+#ifdef DEBUG
+    if ( (model < 0) || (model >= n_models) )
+        error("LinearLexicon::nStatesInModel - model out of range\n") ;
+#endif
+
+    return models[model]->n_states ;
+}
+
+
+void LinearLexicon::getSuccessorInfo( int word , int state , short *n_sucs , 
+                                      short **sucs , real **log_trans_probs )
+{
+#ifdef DEBUG
+    if ( (word < 0) || (word >= n_models) )
+        error("LinearLexicon::getSuccessorInfo - word out of range\n") ;
+    if ( (state < 0) || (state >= models[word]->n_states) )
+        error("LinearLexicon::getSuccessorInfo - state out of range\n") ;
+#endif    
+    *n_sucs = models[word]->states[state]->n_successors ;
+    *sucs = models[word]->states[state]->successor_states ;
+    *log_trans_probs = models[word]->states[state]->suc_log_trans_probs ;
+}
+
+
+#ifdef DEBUG
+void LinearLexicon::outputText()
+{
+	printf("LinearLexicon: Number of models = %d\n" , n_models) ;
+	for ( int i=0 ; i<n_models ; i++ )
+	{
+		printf( "LinearLexicon: Model %d, %s has %d states\n" , i , 
+                lex_info->vocabulary->getWord( lex_info->entries[i].vocab_index ) , 
+                models[i]->n_states ) ;
+        models[i]->outputText() ;
+	}
+}
+#endif
+
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LinearLexicon.h work/main.d/Torch-3/decoder/LinearLexicon.h
--- tmp/Torch-3/decoder/LinearLexicon.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LinearLexicon.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,105 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LINEARLEXICON_INC
+#define LINEARLEXICON_INC
+
+#include "general.h"
+#include "LexiconInfo.h"
+#include "PhoneModels.h"
+#include "DecodingHMM.h"
+#include "SpeechHMM.h"
+
+
+namespace Torch {
+
+
+/**
+    This class is essentially an array of DecodingHMM instances,
+    representing the HMM's for each pronunciation we can recognise.
+    The ordering of this array conforms to the ordering the 
+    LexInfo instance that is passed as a parameter to the
+    constructor.
+
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class LinearLexicon
+{
+public:
+    LexiconInfo *lex_info ;
+    PhoneModels *phone_models ;
+	int n_models ;
+    DecodingHMM **models ;
+    int total_states ;
+    
+	/* Constructors / destructor */
+
+    /// Uses the phoneme DecodingHMM instances in 'phone_models_',
+    ///   and the phonetic transcription info for the pronunciations
+    ///   as defined in 'lex_info_' and creates a complete DecodingHMM
+    ///   instance for each pronunciation.
+    LinearLexicon( LexiconInfo *lex_info_ , PhoneModels *phone_models_ ) ;
+
+    /// Extracts LexiconInfo pointer from 'speech_hmm' then proceeds
+    ///   in the same way as the first constructor.
+    LinearLexicon( SpeechHMM *speech_hmm , PhoneModels *phone_models_ ) ;
+	virtual ~LinearLexicon() ;
+	
+	/* Methods */
+    
+    /// Internal function. Both constructors call this to create the
+    ///   required data structures.
+    void createLinearLexicon( LexiconInfo *lex_info_ , PhoneModels *phone_models_ ) ;
+    
+    /// Returns the number of states in a particular model including
+    ///   non-emitting states.
+    int nStatesInModel( int model ) ;
+
+    /// Calculates the emission probability for a state in a particular
+    ///   word model using the current input vector. Only checks for 
+    ///   out of range input parameters in the debug version.
+    real calcEmissionProb( int model , int state ) ;
+
+    /// Returns the number of successor states, the successor states
+    ///   themselves and the associated log transition probabilities.
+    /// Does not copy data - just returns pointers to the originals.
+    void getSuccessorInfo( int model , int state , short *n_sucs , 
+                           short **sucs , real **log_trans_probs ) ;
+
+                          
+
+#ifdef DEBUG
+	void outputText() ;
+#endif
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LMCache.cc work/main.d/Torch-3/decoder/LMCache.cc
--- tmp/Torch-3/decoder/LMCache.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LMCache.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,155 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "LMCache.h"
+#include "log_add.h"
+
+namespace Torch {
+
+
+LMCache::LMCache( int max_entries_ , int lm_order , int n_vocab_words )
+{
+    if ( max_entries_ <= 0 )
+        error("LMCache::LMCache - max_entries_ cannot be <= 0\n") ;
+        
+    max_entries = max_entries_ ;
+    entries = (LMCacheEntry **)Allocator::sysAlloc( max_entries * sizeof(LMCacheEntry *) ) ;
+    for ( int i=0 ; i<max_entries ; i++ )
+        entries[i] = new LMCacheEntry( lm_order-1 , n_vocab_words ) ;
+    oldest = -1 ;
+    n_entries = 0 ;
+}
+
+
+LMCache::~LMCache()
+{
+    if ( entries != NULL )
+    {
+        for ( int i=0 ; i<max_entries ; i++ )
+            delete entries[i] ;
+        free( entries ) ;
+    }
+}
+
+
+void LMCache::addEntry( int order , int *words , real prob )
+{
+    // The ordering of the words must be W3 W2 W1 W4 (for a 4-gram LM)
+    //   where W4 is "next" word and remainder are prev words.
+    
+    int i , j , max_age=0 , n_prev_words=(order-1) ;
+    
+    // Do we already have an entry for this n-gram ?  Just do a linear search.
+    for ( i=0 ; i<n_entries ; i++ )
+    {
+        if ( n_prev_words == entries[i]->n_prev_words )
+        {
+            if ( memcmp( words , entries[i]->prev_words , n_prev_words*sizeof(int) ) == 0 )
+            {
+                // Yes we do - add the probability to the existing entry
+                entries[i]->addProb( words[n_prev_words] , prob ) ;
+
+                // Increase the age of all cache entries and keep track of the oldest
+                for ( j=0 ; j<n_entries ; j++ )
+                {
+                    if ( ++(entries[j]->age) > max_age )
+                    {
+                        max_age = entries[j]->age ;
+                        oldest = j ;
+                    }
+                }
+
+                return ;
+            }
+        }
+    }
+
+    // No we don't, we need to add this n-gram to the cache
+    if ( n_entries < max_entries )
+    {
+        // Our cache isn't full - we can simply add the new entry at the end
+        entries[n_entries]->addNewPrevWords( n_prev_words , words ) ;
+        entries[n_entries]->addProb( words[n_prev_words] , prob ) ;
+        n_entries++ ;
+    }
+    else
+    {
+        // The cache is full - we need to replace the oldest entry with the new one
+        entries[oldest]->addNewPrevWords( n_prev_words , words ) ;
+        entries[oldest]->addProb( words[n_prev_words] , prob ) ;
+    }
+    
+    // Increase the age of all cache entries and keep track of oldest
+    for ( i=0 ; i<n_entries ; i++ )
+    {
+        if ( ++(entries[i]->age) > max_age )
+        {
+            max_age = entries[i]->age ;
+            oldest = i ;
+        }
+    }
+}
+        
+
+real LMCache::getProb( int n_words , int *words )
+{
+    // The ordering of the words must be W3 W2 W1 W4 (for a 4-gram LM)
+    //   where W4 is "next" word and remainder are prev words.
+    
+    int max_age=0 , i , n_prev_words=(n_words-1) ;
+    real prob = -LOG_ZERO ;
+    
+    for ( i=0 ; i<n_entries ; i++ )
+    {
+        if ( entries[i]->n_prev_words == n_prev_words )
+        {
+            if ( memcmp( words , entries[i]->prev_words , n_prev_words*sizeof(int) ) == 0 )
+            {
+                prob = entries[i]->getProb( words[n_prev_words] ) ;
+                break ;
+            }
+        }
+    }
+    
+    // Increase the age of all cache entries and keep track of oldest
+    for ( i=0 ; i<n_entries ; i++ )
+    {
+        if ( ++(entries[i]->age) > max_age )
+        {
+            max_age = entries[i]->age ;
+            oldest = i ;
+        }
+    }
+
+    return prob ;
+}        
+
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LMCacheEntry.cc work/main.d/Torch-3/decoder/LMCacheEntry.cc
--- tmp/Torch-3/decoder/LMCacheEntry.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LMCacheEntry.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,108 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "LMCacheEntry.h"
+#include "log_add.h"
+
+namespace Torch {
+
+
+LMCacheEntry::LMCacheEntry( int max_n_prev_words_ , int n_vocab_words )
+{
+    max_n_prev_words = max_n_prev_words_ ;
+    prev_words = (int *)Allocator::sysAlloc( max_n_prev_words * sizeof(int) ) ;
+    n_probs = n_vocab_words ;
+    probs = (real *)Allocator::sysAlloc( n_probs * sizeof(real) ) ;
+
+    for ( int i=0 ; i<n_probs ; i++ )
+        probs[i] = -LOG_ZERO ;
+
+    age = 0 ;
+    n_prev_words = 0 ;
+}
+
+
+LMCacheEntry::~LMCacheEntry()
+{
+    if ( prev_words != NULL )
+        free( prev_words ) ;
+    if ( probs != NULL )
+        free( probs ) ;
+}
+
+
+void LMCacheEntry::resetProbs()
+{
+    // We use -LOG_ZERO to indicate that no entry has been added to the cache.
+    // LOG_ZERO would be for a word that doesn't exist in the n-gram
+    for ( int i=0 ; i<n_probs ; i++ )
+        probs[i] = -LOG_ZERO ;
+}
+
+
+void LMCacheEntry::addNewPrevWords( int n_prev_words_ , int *prev_words_ )
+{
+#ifdef DEBUG
+    if ( (n_prev_words_ > max_n_prev_words) || (n_prev_words_ <= 0) )
+        error("LMCacheEntry::addNewPrevWords - n_prev_words_ out of range\n") ;
+#endif
+    memcpy( prev_words , prev_words_ , n_prev_words_*sizeof(int) ) ;
+    n_prev_words = n_prev_words_ ;
+    resetProbs() ;
+    age = 0 ;
+}
+
+
+void LMCacheEntry::addProb( int vocab_word , real prob )
+{
+#ifdef DEBUG
+    if ( (vocab_word<0) || (vocab_word>=n_probs) )
+        error("LMCacheEntry::addProb - vocab word index out of range\n") ;
+    if ( probs[vocab_word] < -LOG_ZERO )
+        error("LMCacheEntry::addProb - entry already set\n") ;
+#endif
+
+    probs[vocab_word] = prob ;
+    age = 0 ;
+}
+
+
+real LMCacheEntry::getProb( int vocab_word )
+{
+#ifdef DEBUG
+    if ( (vocab_word<0) || (vocab_word>=n_probs) )
+        error("LMCacheEntry::getProb - vocab word index out of range\n") ;
+#endif
+
+    age = 0 ;
+    return probs[vocab_word] ;
+}
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LMCacheEntry.h work/main.d/Torch-3/decoder/LMCacheEntry.h
--- tmp/Torch-3/decoder/LMCacheEntry.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LMCacheEntry.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,85 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LMCACHEENTRY_INC
+#define LMCACHEENTRY_INC
+
+#include "general.h"
+
+namespace Torch {
+
+
+/**
+    This class implements the internal entries within the LMCache
+    class. Each entry consists of an array of previous words (eg.
+    2 previous words in a trigram entry), and a list of probabilities
+    of next words given the previous words. There is also an age
+    field that is used to keep track of how recently the entry was
+    accessed.
+    
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class LMCacheEntry
+{
+public:
+    int age ;
+    int max_n_prev_words ;
+    int n_prev_words ;
+    int *prev_words ;
+    int n_probs ;
+    real *probs ;
+
+    /// Creates the cache entry.
+    /// 'max_n_prev_words_' is the maximum number of prev words that will
+    ///   ever be used with the cache entry (eg. 2 for trigram LM)
+    /// 'n_vocab_words' is the number of words in the vocabulary.
+    LMCacheEntry( int max_n_prev_words_ , int n_vocab_words ) ;
+    virtual ~LMCacheEntry() ;
+
+    /// Replaces the current prev words with new ones. The new entry can
+    ///   a number of prev words that is <= max_n_prev_words (ie. can 
+    ///   cache unigram entries when using a trigram LM).
+    void addNewPrevWords( int n_prev_words_ , int *prev_words_ ) ;
+
+    /// Resets all of the next-word log probs to -LOG_ZERO (to indicate that
+    ///   we have no cached probs for all next words).
+    void resetProbs() ;
+
+    /// Adds a log probability for the next-word denoted by 'vocab_word'.
+    void addProb( int vocab_word , real prob ) ;
+
+    /// Returns the cached log probability for the next-word denoted by
+    ///   'vocab_word'.
+    real getProb( int word ) ;
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LMCache.h work/main.d/Torch-3/decoder/LMCache.h
--- tmp/Torch-3/decoder/LMCache.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LMCache.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,83 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LMCACHE_INC
+#define LMCACHE_INC
+
+#include "general.h"
+#include "LMCacheEntry.h"
+
+namespace Torch {
+
+
+/**
+    This class implements a rudimentary caching scheme for language
+    model lookup. It basically consists of a (small) list of the most 
+    recently accessed language model entries. A cache lookup entails 
+    a linear search of the list of entries. The oldest entry is 
+    overwritten when the cache is full and a new entry is added.
+      
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class LMCache
+{
+public:
+    int max_entries ;
+    int n_entries ;
+    LMCacheEntry **entries ;
+    int oldest ;
+
+    /// Creates an empty cache.
+    /// 'max_entries_' is the maximum number of entries in the cache.
+    /// 'lm_order' is the order of the language model n-gram (ie 3
+    ///   for a trigram LM)
+    /// 'n_vocab_words' is the number of words in the vocabulary.
+    LMCache( int max_entries_ , int lm_order , int n_vocab_words ) ;
+    virtual ~LMCache() ;
+
+    /// Adds an entry to the cache. If the cache is full and the new
+    ///   entry is not already in the cache, the oldest entry is
+    ///   overwritten.
+    /// 'order' is the order of the entry, which can be <= the lm_order
+    ///   used during cache creation.
+    /// 'words' are the words in the n-gram. The order is W3 W2 W1 W4
+    ///   for a 4-gram entry.
+    /// 'prob' is the log probability of the n-gram as calculated by the
+    ///   language model.
+    void addEntry( int order , int *words , real prob ) ;
+
+    /// Looks for the n-gram in 'words' within the cache and returns
+    ///   its probability if found, otherwise returns -LOG_ZERO.
+    real getProb( int order , int *words ) ;
+};
+ 
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LMInteriorLevelWordEntry.cc work/main.d/Torch-3/decoder/LMInteriorLevelWordEntry.cc
--- tmp/Torch-3/decoder/LMInteriorLevelWordEntry.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LMInteriorLevelWordEntry.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,245 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "LMInteriorLevelWordEntry.h"
+#include "log_add.h"
+
+
+namespace Torch {
+
+
+LMInteriorLevelWordEntry::LMInteriorLevelWordEntry( int word_ )
+{
+#ifdef DEBUG
+    if ( word_ < 0 )
+        error("LMInteriorLevelWordEntry::LMInteriorLevelWordEntry - word out of range\n") ;
+#endif
+    word = word_ ;
+    log_bo_weight = 0.0 ;
+    next_level = NULL ;
+    n_entries = 0 ;
+    entries = NULL ;
+}
+
+
+LMInteriorLevelWordEntry::~LMInteriorLevelWordEntry()
+{
+    if ( next_level != NULL )
+        delete next_level ;
+
+    if ( entries != NULL )
+        free( entries ) ;
+}
+
+
+void LMInteriorLevelWordEntry::addProbEntry( int list_level , int order , int *words , real prob ) 
+{
+    // There are 'order' entries in 'words'. The ordering is eg. W3,W2,W1,W4 for order=4.
+    if ( order == 1 )
+    {
+        entries = (LMWordEntry *)Allocator::sysRealloc( entries , 
+                                                        (n_entries+1)*sizeof(LMWordEntry) ) ;
+        
+        // Find the place in the list of words where we want to insert the new word
+        if ( (n_entries == 0) || ((*words) > entries[n_entries-1].word) )
+        {
+            entries[n_entries].word = *words ;
+            entries[n_entries].log_prob = prob ;
+        }
+        else
+        {
+            // The new word does not belong at the end of the list - find
+            //   correct position in list and insert there.
+            for ( int i=0 ; i<n_entries ; i++ )
+            {
+                if ( (*words) < entries[i].word ) 
+                {
+                    // Shuffle down all words from i onwards and place the
+                    //   new word in position i.
+                    memmove( entries+i+1 , entries+i , (n_entries-i)*sizeof(LMWordEntry) );
+                    entries[i].word = *words ;
+                    entries[i].log_prob = prob ;
+                    break ;
+                }
+                else if ( *words == entries[i].word )
+                    error("LMILWE::addProbEntry - duplicate entry encountered\n") ;
+            }
+        }
+
+        n_entries++ ;
+    }
+    else
+    {
+        // This entry needs to be added to the 'next_level' (interior) list.
+        if ( next_level == NULL )
+            next_level = new LMInteriorLevelWordList( list_level-1 ) ;
+
+        next_level->addProbEntry( order , words , prob ) ;
+    }
+}
+
+
+void LMInteriorLevelWordEntry::addBackoffEntry( int list_level , int order , 
+                                                int *words , real bo_wt ) 
+{
+    // There should be 'order' entries in 'prev_words' and the ordering should
+    //   be eg.  W3,W2,W1 if order == 3.
+    if ( order == 0 )
+        log_bo_weight = bo_wt ;
+    else
+    {
+        // This entry needs to be added to the 'next_level' (interior) list.
+        if ( next_level == NULL )
+            next_level = new LMInteriorLevelWordList( list_level-1 ) ;
+
+        next_level->addBackoffEntry( order , words , bo_wt ) ;
+    }
+}
+
+
+bool LMInteriorLevelWordEntry::getProbWithBackoff( int order , int *prev_words , real *prob )
+{
+    // There should be 'order' entries in 'prev_words' and the ordering should
+    //   be eg.  W3,W2,W1,W4 if order == 4.
+    real temp ;
+    
+#ifdef DEBUG
+    if ( order < 1 )
+        error("LMInteriorLevelWordEntry::getProbWithBackoff - order out of range\n") ;
+#endif
+
+    if ( order == 1 )
+    {
+        if ( (*prob = getWordProb( *prev_words )) <= LOG_ZERO )
+        {
+            *prob = log_bo_weight ;
+            return false ;
+        }
+        else
+            return true ;
+    }
+    else
+    {
+        if ( next_level == NULL )
+        {
+            if ( (*prob = getWordProb( prev_words[order-1] )) <= LOG_ZERO )
+            {
+                *prob = log_bo_weight ;
+                return false ;
+            }
+            else
+                return true ;
+        }
+        else
+        {
+            if ( next_level->getProbWithBackoff( order , prev_words , prob ) == true )
+                return true ;
+            else
+            {
+                if ( (temp = getWordProb( prev_words[order-1] )) <= LOG_ZERO )
+                {
+                    *prob += log_bo_weight ;
+                    return false ;
+                }
+                else
+                {
+                    *prob += temp ;
+                    return true ;
+                }
+            }
+        }
+    }
+}
+
+
+real LMInteriorLevelWordEntry::getWordProb( int word_ )
+{
+    // We assume that the list of words is in ascending order so 
+    //   that we can do a binary search.
+    int min=0 , max=(n_entries-1) , curr_pos=0 ;
+    
+    if ( n_entries == 0 )
+        return LOG_ZERO ;
+    
+    if ( n_entries <= 10 )
+    {
+        // just do a linear search
+        for ( int i=0 ; i<n_entries ; i++ )
+        {
+            if ( word_ < entries[i].word )
+                return LOG_ZERO ;
+            else if ( word_ == entries[i].word )
+                return entries[i].log_prob ;
+        }
+    }
+    else
+    {
+        // do a binary search
+        while (1)
+        {
+            curr_pos = min+(max-min)/2 ;
+            if ( word_ < entries[curr_pos].word )
+                max = curr_pos-1 ;
+            else if ( word_ > entries[curr_pos].word )
+                min = curr_pos+1 ;
+            else
+                return entries[curr_pos].log_prob ;
+
+            if ( min > max )
+                return LOG_ZERO ;
+        }
+    }
+    return LOG_ZERO ;
+}
+
+
+#ifdef DEBUG
+void LMInteriorLevelWordEntry::outputText( Vocabulary *vocab , int *words , int n_words )
+{
+    words[n_words++] = word ;
+    for ( int j=0 ; j<n_entries ; j++ )
+    {
+        printf("%.4f ",entries[j].log_prob) ;
+        for ( int i=0 ; i<n_words ; i++ )
+            printf("%s " , vocab->getWord( words[n_words-i-1] ) ) ;
+        printf("%s\n" , vocab->getWord( entries[j].word )) ;
+    }
+
+    printf("BACKOFF ") ;
+    for ( int i=0 ; i<n_words ; i++ )
+        printf("%s " , vocab->getWord( words[n_words-i-1] ) ) ;
+    printf("%f\n" , log_bo_weight ) ;
+
+    if ( next_level != NULL )
+        next_level->outputText( vocab , words , n_words ) ;
+}
+#endif
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LMInteriorLevelWordEntry.h work/main.d/Torch-3/decoder/LMInteriorLevelWordEntry.h
--- tmp/Torch-3/decoder/LMInteriorLevelWordEntry.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LMInteriorLevelWordEntry.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,91 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LMINTERIORLEVELWORDENTRY_INC
+#define LMINTERIORLEVELWORDENTRY_INC
+
+#include "general.h"
+#include "LMInteriorLevelWordList.h"
+
+#ifdef DEBUG
+#include "Vocabulary.h"
+#endif
+
+
+namespace Torch {
+
+
+typedef struct
+{
+    int word ;
+    real log_prob ;
+} LMWordEntry ;
+
+
+class LMInteriorLevelWordList ;
+
+/** 
+    This class is used internally within the language model n-gram
+    data structures.  It contains a list of LM probabilities relevant
+    to the level of the tree structure where it exists, and a link to 
+    the next level of the tree structure.
+    
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class LMInteriorLevelWordEntry
+{
+public:
+    int word ;
+    real log_bo_weight ;
+    LMInteriorLevelWordList *next_level ;
+    int n_entries ;
+    LMWordEntry *entries ;
+    
+    /* Constructors / destructor */
+    LMInteriorLevelWordEntry( int word_ ) ;
+    virtual ~LMInteriorLevelWordEntry() ;
+    
+    /* Methods */
+    void addProbEntry( int list_level , int order , int *words , real prob ) ;
+    void addBackoffEntry( int list_level , int order , int *words , real bo_wt ) ;
+    bool getProbWithBackoff( int order , int *prev_words , real *prob ) ;
+
+    // Internal function.
+    real getWordProb( int word ) ;
+
+#ifdef DEBUG
+    void outputText( Vocabulary *vocab , int *words , int n_words ) ;
+#endif
+};
+
+
+}
+
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LMInteriorLevelWordList.cc work/main.d/Torch-3/decoder/LMInteriorLevelWordList.cc
--- tmp/Torch-3/decoder/LMInteriorLevelWordList.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LMInteriorLevelWordList.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,225 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "LMInteriorLevelWordList.h"
+#include "log_add.h"
+
+
+namespace Torch {
+
+
+LMInteriorLevelWordList::LMInteriorLevelWordList( int level_ )
+{
+    if ( level_ < 1 )
+        error("LMInteriorLevelWordList::LMInteriorLevelWordList - cannot have level_ < 1\n") ;
+    level = level_ ;
+    n_entries = 0 ;
+    entries = NULL ;
+}
+
+
+LMInteriorLevelWordList::~LMInteriorLevelWordList()
+{
+    if ( entries != NULL )
+    {
+        for ( int i=0 ; i<n_entries ; i++ )
+            delete entries[i] ;
+        free( entries ) ;
+    }
+}
+
+
+void LMInteriorLevelWordList::addProbEntry( int order , int *words , real prob )
+{
+    // 'words' is an array of word indices.  There should be 'order' elements
+    //    in this array and the ordering should be, eg, [w3 w2 w1 w4] for 4-gram.
+
+    LMInteriorLevelWordEntry *new_word=NULL ;
+    
+#ifdef DEBUG
+    if ( (order-1) > level )
+        error("LMInteriorLevelWordList - addEntry - order of new entry must be <= level\n") ;
+#endif
+    
+    // Do we have an entry for the word at this level ?
+    if ( (new_word = findWord( *words )) == NULL )
+    { 
+        // No we don't so we need to create an entry and add it to our 'entries' array.
+        entries = (LMInteriorLevelWordEntry **)Allocator::sysRealloc( entries , 
+                             (n_entries+1)*sizeof(LMInteriorLevelWordEntry *) ) ;
+        new_word = new LMInteriorLevelWordEntry( *words ) ;
+
+        // If the list is empty, just insert it straight off.  Also
+        //   do an initial check to see if the word belongs at the end of the array
+        if ( (n_entries == 0) || (new_word->word > entries[n_entries-1]->word) )
+        {
+            entries[n_entries] = new_word ;
+        }
+        else
+        {
+            // Find the place in the list of words where we want to insert the new word
+            for ( int i=0 ; i<n_entries ; i++ )
+            {
+                if ( (*words) < entries[i]->word ) 
+                {
+                    // Shuffle down all words from i onwards and place the
+                    //   new word in position i.
+                    memmove( entries+i+1 , entries+i , 
+                             (n_entries-i)*sizeof(LMInteriorLevelWordEntry *) ) ;
+                    entries[i] = new_word ;
+                    break ;
+                }
+            }
+        }
+
+        n_entries++ ;
+    }
+
+    // 'new_word' now points to the entry for the word corresponding to this level.
+    // Continue adding our entry.
+    new_word->addProbEntry( level , order-1 , words+1 , prob ) ;
+}
+
+
+void LMInteriorLevelWordList::addBackoffEntry( int order , int *words , real bo_wt )
+{
+    LMInteriorLevelWordEntry *new_word ;
+    
+    // There should be 'order' entries in 'words' and the order should be
+    //   most-recent word first. eg. [w4 w3 w2 w1] for 4-gram
+#ifdef DEBUG
+    if ( (order > level) || (order < 1) )
+        error("LMInteriorLevelWordList::addBackoffEntry - order out of range\n") ;
+#endif
+
+    if ( (new_word = findWord( *words )) == NULL )
+    {
+        // No we don't so we need to create an entry and add it to our 'entries' array.
+        entries = (LMInteriorLevelWordEntry **)Allocator::sysRealloc( entries , 
+                                         (n_entries+1)*sizeof(LMInteriorLevelWordEntry *) ) ;
+        new_word = new LMInteriorLevelWordEntry( *words ) ;
+
+        // If the list is empty, just insert it straight off.  Also
+        //   do an initial check to see if the word belongs at the end of the array
+        if ( (n_entries == 0) || (new_word->word > entries[n_entries-1]->word) )
+        {
+            entries[n_entries] = new_word ;
+        }
+        else
+        {
+            // Find the place in the list of words where we want to insert the new word
+            for ( int i=0 ; i<n_entries ; i++ )
+            {
+                if ( entries[i]->word > new_word->word )
+                {
+                    // Shuffle down all words from i onwards and place the
+                    //   new word in position i.
+                    memmove( entries+i+1 , entries+i , 
+                             (n_entries-i)*sizeof(LMInteriorLevelWordEntry *) ) ;
+                    entries[i] = new_word ;
+                    break ;
+                }
+            }
+        }
+        n_entries++ ;
+    }
+
+    new_word->addBackoffEntry( level , order-1 , words+1 , bo_wt ) ;
+}
+
+
+bool LMInteriorLevelWordList::getProbWithBackoff( int order , int *words , real *prob )
+{
+    LMInteriorLevelWordEntry *word_entry ;
+    
+    // There should be 'order' entries in 'words'.  The ordering should be eg.
+    //   W3,W2,W1,W4 when order=4
+    if ( (word_entry = findWord( *words )) != NULL )
+        return word_entry->getProbWithBackoff( order-1 , words+1 , prob ) ;
+    else
+    {
+        *prob = 0.0 ;
+        return false ;
+    }
+}
+
+
+LMInteriorLevelWordEntry *LMInteriorLevelWordList::findWord( int word_ )
+{
+    // We assume that the list of words is in ascending order so 
+    //   that we can do a binary search.
+    int min=0 , max=(n_entries-1) , curr_pos=0 ;
+    
+    if ( n_entries == 0 )
+        return NULL ;
+
+    if ( n_entries <= 10 )
+    {
+        // just do a linear search
+        for ( int i=0 ; i<n_entries ; i++ )
+        {
+            if ( word_ < entries[i]->word )
+                return NULL ;
+            else if ( word_ == entries[i]->word )
+                return entries[i] ;
+        }
+    }
+    else
+    {
+        // do a binary search
+        while (1)
+        {
+            curr_pos = min+(max-min)/2 ;
+            if ( word_ < entries[curr_pos]->word )
+                max = curr_pos-1 ;
+            else if ( word_ > entries[curr_pos]->word )
+                min = curr_pos+1 ;
+            else
+                return entries[curr_pos] ;
+
+            if ( min > max )
+                return NULL ;
+        }
+    }
+    return NULL ;
+}
+
+
+#ifdef DEBUG
+void LMInteriorLevelWordList::outputText( Vocabulary *vocab , int *words , int n_words )
+{
+    for ( int i=0 ; i<n_entries ; i++ )
+        entries[i]->outputText( vocab , words , n_words ) ;
+}
+#endif
+
+
+}
+
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LMInteriorLevelWordList.h work/main.d/Torch-3/decoder/LMInteriorLevelWordList.h
--- tmp/Torch-3/decoder/LMInteriorLevelWordList.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LMInteriorLevelWordList.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,105 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LMINTERIORLEVELWORDLIST_INC
+#define LMINTERIORLEVELWORDLIST_INC
+
+#include "general.h"
+#include "LMInteriorLevelWordEntry.h"
+
+#ifdef DEBUG
+#include "Vocabulary.h"
+#endif
+
+namespace Torch {
+
+
+/** 
+    This class is used internally within the language model n-gram
+    data structures.  It is basically a list of LMInteriorLevelWordEntry
+    instances that are sorted by vocab word id.
+    
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class LMInteriorLevelWordEntry ;
+
+class LMInteriorLevelWordList
+{
+public:
+    int level ;
+    int n_entries ;
+    LMInteriorLevelWordEntry **entries ;
+
+    /* Constructors / destructor */
+
+    /// Creates the list. Instances of this object are used at different
+    ///   levels in the tree-like n-gram data structures.  
+    /// 'level_' denotes the level in the tree of this instance.
+    LMInteriorLevelWordList( int level_ ) ;
+    virtual ~LMInteriorLevelWordList() ;
+
+    /* Methods */
+
+    /// Adds a language model probability. 'order' denotes the order
+    ///   of the entry that is being added, and 'words' contains the
+    ///   vocabulary indices of the words in the n-gram. The ordering
+    ///   of 'words' should be eg. W3,W2,W1,W4 when 'order' is 4 and
+    ///   where W4 is the "most-recent" word.
+    void addProbEntry( int order , int *words , real prob ) ;
+    
+    /// Adds a language model backoff weight. 'order' denotes the order
+    ///   of the entry that is being added, and 'words' contains the
+    ///   vocabulary indices of the words in the n-gram. The ordering
+    ///   of 'words' should be eg. W4,W3,W2,W1 when 'order' is 4 and
+    ///   where W4 is the "most-recent" word.
+    void addBackoffEntry( int order , int *words , real bo_wt ) ;
+
+    /// Calculates a language model probability for a particular word
+    ///   sequence with backoff. 'order' denotes the number of words
+    ///   in the word sequence, and 'words' contains the vocabulary 
+    ///   indices of the words. The ordering of 'words' should be 
+    ///   eg. W3,W2,W1,W4 when 'order' is 4 and where W4 is the 
+    ///   "most-recent" word. Returns false if no entry was found,
+    ///   indicating that the value of prob contains only an
+    ///   accumulated backoff weight. Returns true if a valid
+    ///   LM prob has been determined.
+    bool getProbWithBackoff( int order , int *words , real *prob ) ;
+
+    /// Internal function.
+    LMInteriorLevelWordEntry *findWord( int word ) ;
+
+#ifdef DEBUG
+    void outputText( Vocabulary *vocab , int *words , int n_words ) ;
+#endif
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LMNGram.cc work/main.d/Torch-3/decoder/LMNGram.cc
--- tmp/Torch-3/decoder/LMNGram.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LMNGram.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,215 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "LMNGram.h"
+
+namespace Torch {
+
+
+LMNGram::LMNGram( int n_ , Vocabulary *vocab_ )
+{
+#ifdef DEBUG
+    if ( n_ < 1 )
+        error("LMNGram::LMNGram - n cannot be < 1\n") ;
+#endif
+    n = n_ ;
+    vocab = vocab_ ;
+
+    //  Create a unigram entry for every word in our vocabulary.
+    unigrams = (real *)Allocator::sysAlloc( vocab->n_words * sizeof(real) ) ;
+
+    for ( int i=0 ; i<vocab->n_words ; i++ )
+        unigrams[i] = LOG_ZERO ;
+
+    if ( n > 1 )
+        next_level = new LMInteriorLevelWordList( n-1 ) ;
+    else
+        next_level = NULL ;
+
+    // Configure the cache - TODO make the cache size configurable (?)
+    cache = new LMCache( 10 , n , vocab->n_words ) ;
+}
+
+
+LMNGram::~LMNGram()
+{
+    if ( unigrams != NULL )
+        free(unigrams) ;
+
+    if ( next_level != NULL )
+        delete next_level ;
+
+    if ( cache != NULL )
+        delete cache ;
+}
+
+
+void LMNGram::addEntry( int order , int *words , real prob , real bo_wt )
+{
+    // We assume that the 'words' array is in oldest-word-first order.
+    //   ie.  [w1 w2 w3] for trigram entry.
+    int r_words_1[30] ;   // rearranged words [w4,w3,w2,w1]
+    int r_words_2[30] ;   // rearranged words [w3,w2,w1,w4]
+    
+#ifdef DEBUG
+    if ( (order < 1) || (order > n) )
+        error("LMNGram::addEntry - order out of range\n") ;
+#endif
+
+    if ( order == 1 )
+    {
+        if ( unigrams[*words] > LOG_ZERO )
+            error("LMNGram::addEntry - duplicate unigram entry encountered\n") ;
+        unigrams[*words] = prob ;
+
+        if ( n > 1 )
+        {
+            // We are adding a unigram entry into a language model
+            //   of higher order, so the backoff weight is important.
+            // Add the backoff weight.
+            next_level->addBackoffEntry( order , words , bo_wt ) ;
+        }
+    }
+    else
+    {
+        // The first thing we want to do is to rearrange the words in the entry
+        //   so that the order is straight forward and matches the architecture
+        //   of the language model, for adding both probs and backoffs.
+        for ( int i=0 ; i<(order-1) ; i++ )
+        {
+            r_words_1[i] = words[order-1-i] ;   // backoff ordering
+            r_words_2[i] = words[order-2-i] ;   // prob ordering
+        }
+        r_words_1[order-1] = words[0] ;
+        r_words_2[order-1] = words[order-1] ;
+        
+        if ( prob > LOG_ZERO )
+            next_level->addProbEntry( order , r_words_2 , prob ) ;
+            
+        if ( order < n )
+        {
+            // Add the backoff - we don't have/need, eg, trigram backoffs in our
+            //   trigram language model.
+            next_level->addBackoffEntry( order , r_words_1 , bo_wt ) ;
+        }
+    }
+}
+
+
+real LMNGram::getLogProbBackoff( int order , int *words )
+{
+    // There are 'order' entries in 'words'.
+    // The ordering in words is W3,W2,W1,W4 for a 4-gram query.
+    //   ie. for the query : what is P(W4|W1,W2,W3) ?
+    real temp , prob ;
+    
+#ifdef DEBUG
+    if ( order < 1 )
+        error("LMNGram::getNextWordList - order out of range\n") ;
+
+    bool output_debug=false ;
+    if ( output_debug == true )
+    {
+        printf( "P( %s | " , vocab->words[words[order-1]] ) ;
+        for ( int i=0 ; i<(order-1) ; i++ )
+            printf( "%s " , vocab->words[words[i]] ) ;
+        printf(") = ") ;
+    }
+#endif
+
+    if ( order > n )
+        order = n ;
+
+    if ( order == 1 )
+    {
+        // Just return the unigrams prob - no need to backoff or to use the cache.
+#ifdef DEBUG
+        if ( output_debug == true )
+            printf("%f\n",unigrams[*words]);
+#endif
+        return unigrams[*words] ;
+    }
+    else
+    {
+        // look in the cache ...
+        prob = cache->getProb( order , words ) ;
+        if ( prob >= (-LOG_ZERO) )
+        {
+            // The n-gram entry is not in the cache, so we need to search for it
+            //   and then add it to the cache.
+            if ( next_level->getProbWithBackoff( order , words , &prob ) == false )
+            {
+                // No bigram, trigram, etc entries so backoff to unigram
+                temp = unigrams[words[order-1]] ;
+                if ( temp <= LOG_ZERO )
+                    prob = LOG_ZERO ;
+                else if ( prob <= LOG_ZERO )
+                    prob = temp ;
+                else
+                    prob += temp ;
+            }
+            
+            cache->addEntry( order , words , prob ) ;
+#ifdef DEBUG
+            if ( output_debug == true )
+                printf("%f\n",prob) ;
+#endif
+            return prob ;
+        }
+        else
+        {
+            // The entry was in the cache. Just return it
+#ifdef DEBUG
+            if ( output_debug == true )
+                printf("(c)%f\n",prob);
+#endif
+            return prob ;
+        }
+    }
+}
+
+
+#ifdef DEBUG
+void LMNGram::outputText()
+{
+    int words[30] ;
+    
+    // Print the unigrams
+    printf("\\1-gram\\\n") ;
+    for ( int i=0 ; i<vocab->n_words ; i++ )
+        printf("%s %f\n",vocab->words[i],unigrams[i]) ;
+   
+    // Print the rest
+    if ( next_level != NULL )
+        next_level->outputText( vocab , words , 0 ) ;
+}
+#endif
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/LMNGram.h work/main.d/Torch-3/decoder/LMNGram.h
--- tmp/Torch-3/decoder/LMNGram.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/LMNGram.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,97 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LMNGRAM_INC
+#define LMNGRAM_INC
+
+#include "general.h"
+#include "log_add.h"
+#include "LMInteriorLevelWordList.h"
+#include "Vocabulary.h"
+#include "LMCache.h"
+
+namespace Torch {
+
+
+/**
+    This class is the main class for N-gram language modelling.
+    After language model entries have been added, lookups with full
+    backoff can be performed.
+      
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+class LMNGram
+{
+public:
+    /// The order of the N-Gram
+    int n ;
+    Vocabulary *vocab ;
+    
+    /// The unigram probability entries, 1 for every vocab word.
+    real *unigrams ;
+
+    /// Points to the start of the language model tree structure.
+    LMInteriorLevelWordList *next_level ;
+
+    /// The cache used for fast LM lookup.
+    LMCache *cache ;
+
+    /* Constructors / destructor */
+
+    /// Creates an empty N-Gram data structure. 'n_' is the N-gram order.
+    LMNGram( int n_ , Vocabulary *vocab_ ) ;
+    virtual ~LMNGram() ;
+
+    /* Methods */
+
+    /// Adds a new entry to the N-gram.
+    /// 'order' is the order of the entry (ie. 2 for a bigram entry).
+    /// The 'words' array needs to be in oldest-word-first order.
+    ///   ([w1 w2 w3] for trigram entry).
+    /// 'prob' is the log probability for the entry
+    /// 'bo_wt' is the log back-off weight for the entry. If order is
+    ///   equal to the LMNGram order (n), then 'bo_wt' is ignored.
+    void addEntry( int order , int *words , real prob , real bo_wt=LOG_ZERO ) ;
+
+    /// Finds the N-gram probability of a given word sequence, with full
+    ///   backoff.
+    /// 'order' is the number of words in the 'words' array.
+    /// The ordering in 'words' is W3,W2,W1,W4 for a 4-gram query.
+    ///   (ie. for the query : what is P(W4|W1,W2,W3)?)
+    real getLogProbBackoff( int order , int *words ) ;
+
+#ifdef DEBUG
+    void outputText() ;
+#endif
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/Makefile work/main.d/Torch-3/decoder/Makefile
--- tmp/Torch-3/decoder/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/Makefile	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,42 @@
+# get user and architecture specific options
+OS := $(shell uname -s)
+TORCHDIR := $(shell cd ..; pwd)
+include ../Makefile_options_$(OS)
+
+CC_FILES := $(wildcard *.cc)
+OBJS := $(foreach f,$(CC_FILES),$(OBJS_DIR)/$(patsubst %.cc,%.o,$(f)))
+
+all:	$(LIBTORCH)
+
+$(LIBTORCH): $(OBJS)
+	@echo "Archiving..."
+	@$(AR) $(LIBTORCH) $(OBJS)
+
+$(OBJS_DIR)/%.o: %.cc
+	@echo $<
+	@$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $@ -c $<
+
+distclean:
+	@\rm -f .deps_*
+
+clean:
+	@echo "Remove objects file and dependencies..."
+	@\rm -Rf $(OBJS) $(LIBTORCH)
+	@\rm -f .deps_$(VERSION_KEY)
+
+depend:
+	@echo "Tracking dependencies..."
+	@\rm -f .deps_$(VERSION_KEY)
+	@for file in *.cc ; do printf "$(OBJS_DIR)/" >> .deps_$(VERSION_KEY); $(DEP) $(CFLAGS_$(MODE)) $(INCS) $$file >> .deps_$(VERSION_KEY); done
+
+.deps_$(VERSION_KEY):
+	@echo ">>> Please do a 'make depend' <<<"
+	exit 10
+
+ifneq ($(MAKECMDGOALS),distclean)
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),depend)
+include .deps_$(VERSION_KEY)
+endif
+endif
+endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/PhoneModels.cc work/main.d/Torch-3/decoder/PhoneModels.cc
--- tmp/Torch-3/decoder/PhoneModels.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/PhoneModels.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,849 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "PhoneModels.h"
+#include "DiagonalGMM.h"
+#include "log_add.h"
+#include "string_stuff.h"
+#include "SpeechMLP.h"
+#include "SpeechMLPDistr.h"
+
+
+namespace Torch {
+
+
+
+PhoneModels::PhoneModels( SpeechHMM *speech_hmm )
+{
+    short *emis_prob_indices ;
+    
+    if ( speech_hmm == NULL )
+        error("PhoneModels::PhoneModels(2) - speech_hmm is NULL\n") ;
+
+    phone_info = speech_hmm->lexicon->phone_info ;
+    n_models = speech_hmm->n_models ;
+    models = NULL ;
+    n_features = 0 ;
+    n_emission_probs = 0 ;
+    input_vecs_are_features = true ;
+    curr_input_vec = NULL ;
+    curr_emission_probs = NULL ;
+    log_phone_priors = NULL ;
+    log_phone_del_pen = 0.0 ;
+    acoustic_scale_factor = 1.0 ;
+    log_emission_prob_floor = 0.0 ;
+    apply_pause_del_pen = false ;
+    mlp = NULL ;
+
+    models = (DecodingHMM **)Allocator::sysAlloc( n_models * sizeof(DecodingHMM *) ) ;
+    log_phone_priors = (real *)Allocator::sysAlloc( n_models * sizeof(real) ) ;
+    for ( int i=0 ; i<n_models ; i++ )
+    {
+        emis_prob_indices = (short *)Allocator::sysAlloc( speech_hmm->models[i]->n_states *
+                                                          sizeof(short) ) ;
+        emis_prob_indices[0] = -1 ;
+        emis_prob_indices[speech_hmm->models[i]->n_states - 1] = -1 ;
+        for ( int j=1 ; j<(speech_hmm->models[i]->n_states - 1) ; j++ )
+            emis_prob_indices[j] = n_emission_probs++ ;
+        models[i] = new DecodingHMM( speech_hmm->models[i] , emis_prob_indices ) ;
+        log_phone_priors[i] = 0.0 ;
+        free( emis_prob_indices ) ;
+    }
+    
+    // The number of inputs for the Distribution of each state should be the number of features
+    if ( (n_features = models[0]->states[1]->distribution->n_inputs) <= 0 )
+        error("PhoneModels::PhoneModels(2) - n_features <= 0\n") ;
+
+    // Allocate memory to hold emission probs as they are calculated.
+    curr_emission_probs = (real *)Allocator::sysAlloc( n_emission_probs * sizeof(real) ) ;
+    for ( int i=0 ; i<n_emission_probs ; i++ )
+        curr_emission_probs[i] = LOG_ZERO ;
+}
+
+
+PhoneModels::PhoneModels( PhoneInfo *phone_info_ , char *phone_models_fname ,
+                          bool input_vecs_are_features_ , real phone_deletion_penalty , 
+                          bool apply_pause_deletion_penalty , char *phone_priors_fname , 
+                          char *neural_net_fname , int nn_cw_size , char *norms_fname , 
+                          bool online_norm_ , real alpha_m_ , real alpha_v_ )
+{
+    FILE *models_fd ;
+    char line[100] ;
+
+    if ( phone_info_ == NULL )
+        error("PhoneModels::PhoneModels - phone_info not defined\n") ;
+    if ( (phone_models_fname == NULL) || (strcmp(phone_models_fname,"")==0) )
+        error("PhoneModels::PhoneModels - phone_models_fname not defined\n") ;
+
+    phone_info = phone_info_ ;
+    n_models = 0 ;
+    models = NULL ;
+    n_features = 0 ;
+    n_emission_probs = 0 ;
+    input_vecs_are_features = input_vecs_are_features_ ;
+    curr_input_vec = NULL ;
+    curr_emission_probs = NULL ;
+    log_phone_priors = NULL ;
+    mlp = NULL ;
+
+    acoustic_scale_factor = 1.0 ;
+    log_emission_prob_floor = 0.0 ;   
+   
+    // Convert the phone deletion penalties to log domain.
+    log_phone_del_pen = (real)log( phone_deletion_penalty ) ;
+    apply_pause_del_pen = apply_pause_deletion_penalty ;
+    
+    // Open the phone models definition file.
+    if ( (models_fd = fopen( phone_models_fname , "r" )) == NULL )
+        error("PhoneModels::PhoneModels - error opening phone models file\n") ;
+
+    // Read the first line of the file and use it to determine the file type.
+    fgets( line , 100 , models_fd ) ;
+    if ( strstr( line , "~o" ) )
+    {
+        // This is a HTK model definition file
+        readModelsFromHTK( models_fd ) ;
+    }
+    else if ( strstr( line , "PHONE" ) ) 
+    {
+        // This is a NOWAY format phone models file
+        readModelsFromNoway( models_fd ) ;
+        readPhonePriors( phone_priors_fname ) ;
+
+        if ( input_vecs_are_features == true )
+        {
+            // We have features as input - therefore we need a neural net to
+            //   give us emission probabilities.
+            mlp = new SpeechMLP ( neural_net_fname , nn_cw_size , norms_fname , 
+                                  online_norm_ , alpha_m_ , alpha_v_ ) ;
+            n_features = mlp->n_features ;
+            if ( mlp->n_mlp_outputs != n_emission_probs )
+                error("PhoneModels::PhoneModels - n_mlp_outputs not match n_emission_probs\n") ;
+            
+            // Now we need a Distribution that can be associated with each emitting
+            //   state of each phone in our phoneset.
+            for ( int i=0 ; i<n_models ; i++ )
+            {
+                for ( int j=1 ; j<(models[i]->n_states)-1 ; j++ )
+                {
+                     models[i]->states[j]->distribution = 
+                        new SpeechMLPDistr( mlp , &curr_emission_probs , 
+                              models[i]->states[j]->emission_prob_vec_index , log_phone_priors ) ;
+                }
+            }
+        }
+    }
+    
+    // Check that we were able to determine the input vector size, and/or the
+    //   total number of emission probabilities.
+    if ( (input_vecs_are_features==true) && (n_features<=0) )
+        error("PhoneModels::PhoneModels - cannot have n_features <= 0\n") ;
+    if ( n_emission_probs <= 0 )
+        error("PhoneModels::PhoneModels - cannot have n_emission_probs <= 0\n") ;
+
+    // Now prepare for the type of input vectors
+    if ( input_vecs_are_features == true )
+    {
+        // Allocate memory to hold emission probs as they are calculated.
+        curr_emission_probs = (real *)Allocator::sysAlloc( n_emission_probs * sizeof(real) ) ;
+        for ( int i=0 ; i<n_emission_probs ; i++ )
+            curr_emission_probs[i] = LOG_ZERO ;
+    }
+}
+        
+        
+PhoneModels::~PhoneModels()
+{
+    if ( models != NULL )
+    {
+        for ( int i=0 ; i<n_models ; i++ )
+            delete models[i] ;
+        free( models ) ;
+    }
+    if ( input_vecs_are_features == true )
+        free( curr_emission_probs ) ;
+    if ( log_phone_priors != NULL )
+        free( log_phone_priors ) ;
+    if ( mlp != NULL )
+        free( mlp ) ;
+}
+
+
+DecodingHMM *PhoneModels::getModel( int index )
+{
+    if ( (index >= n_models) || (index < 0) )
+        error("PhoneModels::getModel - index out of range\n") ;
+    return models[index] ;
+}
+
+
+void PhoneModels::setInputVector( real *input_vec )
+{
+    curr_input_vec = input_vec ;
+    
+    if ( input_vecs_are_features == true )
+    {
+        // The current emission prob values are now out of date - reset.
+        for ( int j=0 ; j<n_emission_probs ; j++ )
+            curr_emission_probs[j] = LOG_ZERO ;
+    }
+    else
+    {
+        curr_emission_probs = curr_input_vec ;
+        
+        if ( log_emission_prob_floor < 0.0 )
+        {
+            for ( int j=0 ; j<n_emission_probs ; j++ )
+            {
+                if ( curr_emission_probs[j] < log_emission_prob_floor )
+                    curr_emission_probs[j] = LOG_ZERO / 2 ;
+            }
+        }
+        
+        // If we have prior probabilities, divide each emission prob by its
+        //    prior to give a scaled likelihood (or subtract in log domain).
+        if ( log_phone_priors != NULL )
+        {
+            for ( int j=0 ; j<n_emission_probs ; j++ )
+                curr_emission_probs[j] -= log_phone_priors[j] ;
+        }
+    }
+}
+
+
+real PhoneModels::calcEmissionProb( int prob_vec_index , Distribution *dist )
+{
+    if ( prob_vec_index < 0 )
+        error("PhoneModels::calcEmissionProb - prob_vec_index out of range\n") ;
+        
+    if ( input_vecs_are_features == true )
+    {
+#ifdef DEBUG
+        if ( dist == NULL )
+            error("PhoneModels::calcEmissionProb - distribution cannot be NULL\n") ;
+#endif
+        if ( curr_emission_probs[prob_vec_index] <= LOG_ZERO )
+        {
+            curr_emission_probs[prob_vec_index] = 
+                   dist->frameLogProbability( 0 , curr_input_vec ) ;
+        }
+    }
+    
+    return curr_emission_probs[prob_vec_index] * acoustic_scale_factor ;
+}
+
+
+void PhoneModels::readModelsFromHTK( FILE *models_fd )
+{
+    // Loads a HTK definition file containing multiple HMM definitions.
+    // Only supports limited format - each HMM MUST be exactly same format as 
+    //    Fig 7.3 in HTK manual.  Therefore each state distribution can only 
+    //    be a DiagonalGMM.
+    
+    char line[20000] , curr_model_name[100] , *value=NULL ;
+    int n_mixtures=0 , temp , phone_index=-1 , read_state=0 , curr_mixture=0 ;
+    real curr_mixture_weight=0.0 , **log_trans=NULL ;
+    Distribution **states=NULL ;
+    short curr_state=0 , curr_emis_prob_index=0 , *emis_prob_indices=NULL , n_states=0 ;
+   
+    // Allocate memory for the models
+    models = (DecodingHMM **)Allocator::sysAlloc( phone_info->n_phones * sizeof(DecodingHMM *) ) ;
+
+    // read the HMM model data from the HTK-format text file
+    n_models = 0 ;
+    curr_emis_prob_index = 0 ;
+    read_state = 0 ;
+    n_emission_probs = 0 ;
+
+    while ( fgets( line , 20000 , models_fd ) != NULL )
+    {
+        if ( strstr(line,"~h") )
+        {
+            if ( read_state != 1 )
+                error("PhoneModels::readModelsFromHTK - ~h out of order\n") ;
+            if ( sscanf( line , "%*s \"%[^\"]" , curr_model_name ) != 1 )
+                error("PhoneModels::readModelsFromHTK - error extracting phone name\n") ;
+            if ( (phone_index = phone_info->getIndex( curr_model_name )) < 0 )
+                error("PhoneModels::readModelsFromHTK - %s not in phone_info\n",curr_model_name) ;
+            n_models++ ;
+            n_states = 0 ;
+            read_state = 2 ;
+        }
+        else
+        {
+            strtoupper( line ) ;
+            if ( strstr( line , "<VECSIZE>" ) )
+            {
+                if ( read_state != 0 )
+                    error("PhoneModels::readModelsFromHTK - <VECSIZE> out of order\n") ;
+                if( sscanf( line , "%*s %d" , &n_features ) != 1 )
+                    error("PhoneModels::readModelsFromHTK - error reading n_features\n") ;
+                read_state = 1 ;
+            }
+            else if ( strstr( line , "<BEGINHMM>" ) )
+            {
+                if ( read_state != 2 )
+                    error("PhoneModels::readModelsFromHTK - <BEGINHMM> out of order\n") ;
+                read_state = 3 ;
+            }
+            else if ( strstr( line , "<NUMSTATES>" ) )
+            {
+                if ( read_state != 3 )
+                    error("PhoneModels::readModelsFromHTK - <NUMSTATES> out of order\n") ;
+                if ( sscanf( line , "%*s %hd" , &n_states ) != 1 )
+                    error("PhoneModels::readModelsFromHTK - error extracting n_states\n") ;
+                n_emission_probs += (n_states-2) ;
+                emis_prob_indices = (short *)Allocator::sysAlloc( n_states * sizeof(short) ) ;
+                emis_prob_indices[0] = -1 ;
+                emis_prob_indices[n_states-1] = -1 ;
+                for ( short j=1 ; j<(n_states-1) ; j++ )
+                    emis_prob_indices[j] = curr_emis_prob_index++ ;
+
+                // allocate memory for the array of Diagonal GMM's and the transitions
+                states = (Distribution **)Allocator::sysAlloc( n_states * sizeof(Distribution *) ) ;
+                log_trans = (real **)Allocator::sysAlloc( n_states * sizeof(real *) ) ;
+
+                for ( short j=0 ; j<n_states ; j++ )
+                {
+                    states[j] = NULL ;
+                    log_trans[j] = (real *)Allocator::sysAlloc( n_states * sizeof(real) ) ;
+                }
+                read_state = 4 ;
+            }
+            else if ( strstr(line,"<STATE>") )
+            {
+                if ( read_state != 4 )
+                {
+                    printf("%s %d %d\n",curr_model_name,curr_state,curr_mixture);
+                    error("PhoneModels::readModelsFromHTK - <STATE> out of order\n%s\n",line) ;
+                }
+
+                if ( sscanf( line , "%*s %hd" , &curr_state ) != 1 )
+                    error("PhoneModels::readModelsFromHTK - error reading curr_state\n") ;
+                curr_state-- ;  // index from 0
+                if ( (curr_state<1) || (curr_state>=(n_states-1)) )
+                    error("PhoneModels::readModelsFromHTK - invalid curr_state\n") ;
+
+                // There might be a <NUMMIXES> on the same line
+                if ( strstr(line,"<NUMMIXES>") )
+                {
+                    if ( sscanf( line , "%*s %*d %*s %d" , &n_mixtures ) != 1 )
+                        error("PhoneModels::readModelsFromHTK - error reading n_mixtures\n") ;
+                    curr_mixture = -1 ;
+                    read_state = 7 ;
+                }
+                else
+                    read_state = 5 ;
+            }
+            else if ( strstr(line,"<NUMMIXES>") )
+            {
+                if ( read_state != 5 )
+                    error("PhoneModels::readModelsFromHTK - <NUMMIXES> out of order\n") ;
+                if ( sscanf( line , "%*s %d" , &n_mixtures ) != 1 )
+                    error("PhoneModels::readModelsFromHTK - error reading n_mixtures (2)\n") ;
+                curr_mixture = -1 ;
+                read_state = 7 ;
+            }
+            else if ( strstr(line,"<MIXTURE>") )
+            {
+                if ( read_state != 7 )
+                    error("PhoneModels::readModelsFromHTK - <MIXTURE> out of order\n%s\n",line) ;
+
+                if ( states[curr_state] == NULL )
+                    states[curr_state] = new DiagonalGMM( n_features, n_mixtures ) ;
+
+#ifdef USE_DOUBLE
+                if ( sscanf( line , "%*s %*d %lf" , &curr_mixture_weight ) != 1 )
+#else
+                if ( sscanf( line , "%*s %*d %f" , &curr_mixture_weight ) != 1 )
+#endif
+                    error("PhoneModels::readModelsFromHTK - error reading curr_mix_wt\n") ;
+
+                curr_mixture++ ;
+                if ( (curr_mixture<0) || (curr_mixture>=n_mixtures) )
+                    error("PhoneModels::readModelsFromHTK - invalid curr_mixture\n") ;
+                if ( curr_mixture_weight == 0.0 )
+                    ((DiagonalGMM *)states[curr_state])->log_weights[curr_mixture] = LOG_ZERO ;
+                else
+                {
+                    ((DiagonalGMM *)states[curr_state])->log_weights[curr_mixture] = 
+                        log(curr_mixture_weight) ;
+                }
+                read_state = 8 ;
+            }
+            else if ( strstr(line,"<MEAN>") )
+            {
+                if ( (read_state != 5) && (read_state != 8) )
+                    error("PhoneModels::readModelsFromHTK - <MEAN> out of order\n") ;
+
+                // Check that the number of means matches the number of features
+                if ( sscanf( line , "%*s %d" , &temp ) != 1 )
+                    error("PhoneModels::readModelsFromHTK - error reading number of means\n") ;
+                if ( temp != n_features )
+                {
+                    error("PhoneModels::readModelsFromHTK - <MEAN> %d not match n_features=%d\n", 
+                            temp , n_features ) ;
+                }
+
+                // If the distribution has not already been created, then create it.
+                if ( states[curr_state] == NULL )
+                    states[curr_state] = new DiagonalGMM( n_features, n_mixtures, NULL ) ;
+
+                if ( (fgets(line,20000,models_fd)) == NULL )
+                    error("PhoneModels::loadHtkModels - error reading <MEAN> values\n") ;
+
+                value = strtok( line , " " ) ;
+                for ( short j=0 ; j<n_features ; j++ )
+                {
+                    ((DiagonalGMM *)states[curr_state])->means[curr_mixture][j]=(real)atof(value) ;
+                    value = strtok( NULL , " " ) ;
+                }
+
+                read_state++ ;
+            }
+            else if ( strstr(line,"<VARIANCE>") )
+            {
+                if ( (read_state != 6) && (read_state != 9) )
+                    error("PhoneModels::readModelsFromHTK - <VARIANCE> out of order\n") ;
+
+                // Check that the number of variances matches the number of features
+                if ( sscanf( line , "%*s %d" , &temp ) != 1 )
+                    error("PhoneModels::readModelsFromHTK - error reading number of variances\n") ;
+
+                if ( temp != n_features )
+                {
+                    error("PhoneModels::readModelsFromHTK - <VARIANCE> %d != n_features=%d\n" , 
+                          temp , n_features ) ;
+                }
+
+                // If the distribution has not already been created, then create it.
+                if ( states[curr_state] == NULL )
+                    states[curr_state] = new DiagonalGMM( n_features, n_mixtures, NULL ) ;
+
+                if ( (fgets(line,20000,models_fd)) == NULL )
+                    error("PhoneModels::loadHtkModels - error reading <VARIANCE> values\n") ;
+
+                value = strtok( line , " " ) ;
+                ((DiagonalGMM *)states[curr_state])->sum_log_var_plus_n_obs_log_2_pi[curr_mixture]= 
+                    n_features * LOG_2_PI ;
+                for ( short j=0 ; j<n_features ; j++ )
+                {
+                    ((DiagonalGMM *)states[curr_state])->var[curr_mixture][j] = (real)atof(value) ;
+                    ((DiagonalGMM *)states[curr_state])->minus_half_over_var[curr_mixture][j] = 
+                        -0.5 / (real)atof(value) ;
+                    ((DiagonalGMM *)states[curr_state])->sum_log_var_plus_n_obs_log_2_pi[curr_mixture] 
+                        += log( (real)atof(value) ) ;
+                    value = strtok( NULL , " " ) ;
+                }
+
+                ((DiagonalGMM *)states[curr_state])->sum_log_var_plus_n_obs_log_2_pi[curr_mixture] 
+                    *= -0.5 ;
+                if ( read_state == 6 )
+                    read_state = 4 ;
+                else if ( read_state == 9 )
+                {
+                    if ( curr_mixture == (n_mixtures-1) )
+                        read_state = 4 ;
+                    else
+                        read_state = 7 ;
+                }
+            }
+            else if ( strstr(line,"<TRANSP>") )
+            {
+                if ( read_state != 4 )
+                    error("PhoneModels::readModelsFromHTK - <TRANSP> out of order\n") ;
+
+                if ( curr_state != (n_states-2) )
+                    error("PhoneModels::readModelsFromHTK - not all states encountered\n") ;
+
+                for ( short j=0 ; j<n_states ; j++ )
+                {
+                    if ( (fgets(line,20000,models_fd)) == NULL )
+                        error("PhoneModels::readModelsFromHTK - error reading <TRANSP> values\n") ;
+
+                    value = strtok( line , " " ) ;
+                    for ( short k=0 ; k<n_states ; k++ )
+                    {
+                        log_trans[j][k] = (real)atof(value) ;
+                        if ( log_trans[j][k] == 0.0 )
+                            log_trans[j][k] = LOG_ZERO ;
+                        else
+                        {
+                            log_trans[j][k] = log( log_trans[j][k] ) ;
+
+                            // If this is a transition to the final state, apply the
+                            //   phone deletion penalty.
+                            if ( k==(n_states-1) )
+                            {
+                                if ( (phone_index != phone_info->pause_index) || 
+                                        ( (phone_index == phone_info->pause_index) && 
+                                          (apply_pause_del_pen == true) ) )
+                                {
+                                    log_trans[j][k] += log_phone_del_pen ;
+                                }
+                            }
+                        }
+                        value = strtok( NULL , " " ) ;
+                    }
+                }
+
+                // create the DecodingHMM
+                models[phone_index] = new DecodingHMM( n_states , states , log_trans ,
+                        emis_prob_indices ) ;
+                for ( short j=0 ; j<n_states ; j++ )
+                    free( log_trans[j] ) ;
+                free( log_trans ) ;
+                free( emis_prob_indices ) ;
+
+                read_state = 10 ;
+            }
+            else if ( strstr(line,"<ENDHMM>") )
+            {
+                if ( read_state != 10 )
+                    error("PhoneModels::readModelsFromHTK - <ENDHMM> out of order\n") ;
+                phone_index = -1 ;
+                read_state = 1 ;
+            }
+            else if ( strstr( line , "<GCONST>" ) )
+            {
+                // Ignore
+            }
+            else if ( strstr( line , "<STREAMINFO>" ) )
+            {
+                // Ignore
+            }
+            else
+                error("PhoneModels::readModelsFromHTK - unrecognised line\n%s\n",line) ;
+        }
+    }
+
+    if ( n_models != phone_info->n_phones )
+        error("PhoneModels::readModelsFromHTK - n_models n_phones mismatch\n") ;
+    fclose( models_fd ) ;
+}
+
+
+void PhoneModels::readModelsFromNoway( FILE *models_fd )
+{
+    // The model definitions in the input file must be in the same order
+    //   as the phone name file listing.
+    char line[20000] , phone_name[1000] ;
+    int phone_id=0 , phone_index=-1 ;
+    char *num=NULL ;
+    short n_states=0 , n_sucs , sucs[100] ,  temp_suc , state_id , prob_index=0 ;
+    real trans[100] , temp_tran ;
+    
+    // Read the number of models, and check against the expected number.
+    fgets( line , 20000 , models_fd ) ;
+    if ( sscanf( line , "%d" , &n_models ) != 1 )
+        error("PhoneModels::readModelsFromNoway - error reading n_models\n") ;
+    if ( n_models != phone_info->n_phones )
+        error("PhoneModels::readModelsFromNoway - n_models n_phones mismatch\n") ;
+        
+    // Allocate memory for the phone models and phone names
+    models = (DecodingHMM **)Allocator::sysAlloc( n_models * sizeof(DecodingHMM *) ) ;
+    for ( int i=0 ; i<n_models ; i++ )
+        models[i] = NULL ;
+    
+    for ( int i=0 ; i<n_models ; i++ )
+    {
+        // Read and process the line containing: <id> <num states> <label>
+        if ( fgets( line , 20000 , models_fd ) == NULL )
+            error("PhoneModels::readModelsFromNoway - error reading phone %d label line\n",i) ;
+
+        if ( sscanf( line , "%d %hd %s" , &phone_id , &n_states , phone_name ) != 3 )
+            error("PhoneModels::readModelsFromNoway - error interpret phone %d label line\n",i) ;
+
+        if ( (phone_index = phone_info->getIndex( phone_name )) < 0 )
+            error("PhoneModels::readModelsFromNoway - %s not in phone_info\n",phone_name) ;
+            
+        if ( models[phone_index] != NULL )
+            error("PhoneModels::readModelsFromNoway - phone %d already present\n",phone_index) ;
+            
+        models[phone_index] = new DecodingHMM() ;
+        models[phone_index]->n_states = n_states ;
+        models[phone_index]->states = (DecodingHMMState **)Allocator::sysAlloc( 
+                                             n_states * sizeof(DecodingHMMState *) ) ;
+        
+        // Read and process the line mapping each state to an element in the acoustic
+        //   probability vector.
+        if ( fgets( line , 20000 , models_fd ) == NULL )
+            error("PhoneModels::readModelsFromNoway - error reading phone %d label line\n",i) ;
+
+        if ( (int)atoi( strtok( line , " " ) ) != -1 )
+            error("PhoneModels::readModelsFromNoway - expect -1 on prob index mapping line\n",i) ;
+        if ( (int)atoi( strtok( NULL , " " ) ) != -2 )
+            error("PhoneModels::readModelsFromNoway - expect -2 on prob index mapping line\n",i) ;
+
+        models[phone_index]->states[0] = (DecodingHMMState *)Allocator::sysAlloc( 
+                                                                    sizeof(DecodingHMMState) ) ;
+        models[phone_index]->initState( models[phone_index]->states[0] , NULL , -1 ) ;
+        models[phone_index]->states[n_states-1] = 
+                        (DecodingHMMState *)Allocator::sysAlloc( sizeof(DecodingHMMState) ) ;
+        models[phone_index]->initState( models[phone_index]->states[n_states-1] , NULL , -1 ) ;
+        
+        for ( int j=0 ; j<(n_states-2) ; j++ )
+        {
+            char* cindex = strtok( NULL , " " );
+            if (!cindex)
+                error("PhoneModels::readModelsFromNoway - prob index line not enough indices\n") ;
+            prob_index = (int)atoi(cindex);
+
+            if ( prob_index >= n_emission_probs )
+                n_emission_probs = prob_index + 1 ;
+
+            models[phone_index]->states[j+1] = 
+                (DecodingHMMState *)Allocator::sysAlloc( sizeof(DecodingHMMState) ) ;
+            models[phone_index]->initState( models[phone_index]->states[j+1] , 
+                                            NULL , prob_index ) ;
+        }
+
+        // Read and process the line for each state that defines the transitions
+        //   to other states.
+        for ( int j=0 ; j<n_states ; j++ )
+        {
+            if ( fgets( line , 20000 , models_fd ) == NULL )
+                error("PhoneModels::readModelsFromNoway - error reading state transitions line\n") ;
+
+            if ( sscanf( line , "%hd %hd" , &state_id , &n_sucs ) != 2 )
+                error("PhoneModels::readModelsFromNoway - error sscanf state transitions line\n") ;
+
+            if ( state_id != j )
+                error("PhoneModels::readModelsFromNoway - state id has unexpected value\n") ;
+            
+            // Get past the state id & the number of successor states.
+            strtok( line , " " ) ;
+            strtok( NULL , " " ) ;
+            
+            // Read and process each of the successor states to the current state.
+            for ( int k=0 ; k<n_sucs ; k++ )
+            {
+                if ( (num = strtok( NULL , " " )) == NULL )
+                    error("PhoneModels::readModelsFromNoway - error reading successor state\n") ;
+                
+                sucs[k] = (short)atoi( num ) ;
+                if ( sucs[k] == 1 )
+                    sucs[k] = n_states-1 ;
+                else if ( sucs[k] > 1 )
+                    sucs[k] -= 1 ;
+                
+                if ( (num = strtok( NULL , " " )) == NULL )
+                    error("PhoneModels::readModelsFromNoway - error reading transition prob\n") ;
+                
+                trans[k] = (real)log( atof( num ) ) ;
+                
+                // If this is a transition to the final state of the model, apply
+                //   the phone deletion penalty.
+                if ( sucs[k] == (n_states-1) )
+                {
+                    if ( (phone_index != phone_info->pause_index) || 
+                         ( (phone_index == phone_info->pause_index) && 
+                           (apply_pause_del_pen == true) ) )
+                    {
+                        trans[k] += log_phone_del_pen ;
+                    }
+                }
+            }
+            
+            // Make sure that the sucs list is sorted according to successor state index
+            for ( int k=0 ; k<(n_sucs-1) ; k++ )
+            {
+                for ( int l=(k+1) ; l<n_sucs ; l++ )
+                {
+                    if ( sucs[l] < sucs[k] )
+                    {
+                        temp_suc = sucs[l] ;
+                        sucs[l] = sucs[k] ;
+                        sucs[k] = temp_suc ;
+                        temp_tran = trans[l] ;
+                        trans[l] = trans[k] ;
+                        trans[k] = temp_tran ;
+                    }
+                }
+            }
+                    
+            // Setup the successor states in the DecodingHMMState instance.
+            if ( state_id == 1 )
+            {
+                // This is actually the final state.  Make sure that it has no
+                //   successors and add it at the end of our list of states.
+                if ( n_sucs != 0 )
+                    error("PhoneModels::readModelsFromNoway - final state does not have 0 sucs\n") ;
+                models[phone_index]->setupSuccessorStates( 
+                            models[phone_index]->states[n_states-1] , n_sucs , sucs , trans ) ;
+            }
+            else if ( state_id > 1 )
+            {
+                models[phone_index]->setupSuccessorStates( 
+                            models[phone_index]->states[state_id-1] , n_sucs , sucs , trans ) ;
+            }
+            else if ( state_id == 0 )
+            {
+                models[phone_index]->setupSuccessorStates( 
+                            models[phone_index]->states[0] , n_sucs , sucs , trans ) ;
+            }
+        }
+    }
+
+    fclose( models_fd ) ;
+}
+
+
+void PhoneModels::readPhonePriors( char *phone_priors_fname )
+{
+    FILE *priors_fd ;
+    char line[1000] ;
+    real prob ;
+    int prior_cnt=0 ;
+    
+    if ( phone_priors_fname == NULL )
+        return ;
+
+    // Open the input file
+    if ( (priors_fd = fopen( phone_priors_fname , "r" )) == NULL )
+        error("PhoneModels::readPhonePriors - error opening priors file\n") ;
+
+    // Allocate memory for the prior probabilities
+    if ( n_emission_probs <= 0 )
+        error("PhoneModels::readPhonePriors - must load phone models before priors\n") ;
+    log_phone_priors = (real *)Allocator::sysAlloc( n_emission_probs * sizeof(real) ) ;
+    
+    while ( fgets( line , 1000 , priors_fd ) != NULL )
+    {
+#ifdef USE_DOUBLE
+        if ( (sscanf(line,"%lf",&prob)!=1) || (line[0] == '#') || (line[0] == '\n') ||
+             (line[0] == '\r') || (line[0] == ' ') || (line[0] == '\t') )
+#else
+        if ( (sscanf(line,"%f",&prob)!=1) || (line[0] == '#') || (line[0] == '\n') ||
+             (line[0] == '\r') || (line[0] == ' ') || (line[0] == '\t') )
+#endif
+        {
+            continue ;
+        }
+
+        if ( prior_cnt >= n_emission_probs )
+            error("PhoneModels::readPhonePriors - too many priors (>n_emission_probs)\n") ;
+
+        log_phone_priors[prior_cnt] = (real)log(prob) ;
+        prior_cnt++ ;
+    }
+
+    if ( prior_cnt != n_emission_probs )
+        error("PhoneModels::readPhonePriors - num priors and num emission probs mismatch\n") ;
+
+    fclose( priors_fd ) ;
+}
+
+
+void PhoneModels::calcEmissionProbsOneFrame( real *features )
+{
+    // This calculates all emission probabilities for all emitting states
+    //   of all phone models.
+    // The results are placed in the 'curr_emission_probs' member array.
+    
+    DecodingHMM *curr_model ;
+
+    if ( input_vecs_are_features == false )
+        error("PhoneModels::calcEmissionProbsOneFrame - invalid invocation\n") ;
+    
+    for ( int i=0 ; i<n_models ; i++ )
+    {
+        curr_model = models[i] ;
+        for ( int j=1 ; j<(curr_model->n_states-1) ; j++ )
+        {
+            if ( curr_emission_probs[curr_model->states[j]->emission_prob_vec_index] <= LOG_ZERO )
+            {
+                curr_model->states[j]->distribution->frameLogProbability( 0 , features ) ;
+            }
+        }
+    }
+}
+
+
+void PhoneModels::calcEmissionProbsAllFrames( int n_frames , real **features , 
+                                              real ***emission_probs )
+{
+    // For each feature vector in 'features', calculates the emission probabilities 
+    //   of all emitting states of all phones.
+    // Returns results in 'emission_probs'.
+
+    int prob_vector_index = 0 ;
+    
+#ifdef DEBUG
+    // Do a rudimentary check : that the number of features input to this function
+    //   matches the n_observations member variable of the first emitting state 
+    //   of the first phone model.
+    if ( n_features != models[0]->states[1]->distribution->n_inputs )
+        error("PhoneModels::calcEmissionProbsAllFrames - n_features does not match phone models\n") ;
+#endif
+
+    // allocate memory for the emission probabilities for all states for all frames
+    *emission_probs = (real **)Allocator::sysAlloc( n_frames * sizeof(real *) ) ;
+    for ( int t=0 ; t<n_frames ; t++ )
+        (*emission_probs)[t] = (real *)Allocator::sysAlloc( n_emission_probs * sizeof(real) ) ;
+
+    // do the calculations
+    for ( int t=0 ; t<n_frames ; t++ )
+    {
+        prob_vector_index=0 ;
+        for ( int phone=0 ; phone<n_models ; phone++ )
+        {
+            for ( int state=1 ; state<((models[phone]->n_states)-1) ; state++ )
+            {
+                (*emission_probs)[t][prob_vector_index++] =
+                    (models[phone]->states[state]->distribution)->frameLogProbability(
+                                                                       0 , features[t] ) ;
+            }
+        }
+
+        if ( prob_vector_index != n_emission_probs )
+            error("PhoneModels::calcEmissionProbsAllFrames - prob_vector_index incorrect\n") ;
+    }
+}
+
+
+#ifdef DEBUG
+void PhoneModels::outputText()
+{
+    printf("n_features = %d\n",n_features);
+    printf("n_emission_probs = %d\n",n_emission_probs);
+    printf("Number of models = %d\n***************************\n",n_models) ;
+    for (int i=0;i<n_models;i++)
+    {
+        printf("%s\n",phone_info->phone_names[i]);
+        models[i]->outputText() ;
+        printf("\n\n\n*******************************\n\n\n") ;
+    }
+}
+#endif
+
+
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/PhoneModels.h work/main.d/Torch-3/decoder/PhoneModels.h
--- tmp/Torch-3/decoder/PhoneModels.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/PhoneModels.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,92 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef PHONEMODELS_INC
+#define PHONEMODELS_INC
+
+#include "general.h"
+#include "PhoneInfo.h"
+#include "DecodingHMM.h"
+#include "SpeechMLP.h"
+#include "SpeechHMM.h"
+
+namespace Torch {
+
+/**
+   @author Darren Moore (moore@idiap.ch)
+*/
+class PhoneModels
+{
+public:
+    PhoneInfo *phone_info ;
+    int n_models ;
+    DecodingHMM **models ;
+    int n_features ;
+    int n_emission_probs ;
+    bool input_vecs_are_features ;
+    real *curr_input_vec ;
+    real *curr_emission_probs ;
+    real *log_phone_priors ;
+    real log_phone_del_pen ;
+    real acoustic_scale_factor ;
+    real log_emission_prob_floor ;
+    bool apply_pause_del_pen ;
+    SpeechMLP *mlp ;
+    
+    /* Constructors / destructor ***/
+    PhoneModels( SpeechHMM *speech_hmm ) ;
+    PhoneModels( PhoneInfo *phone_info_ , char *phone_models_fname ,
+                 bool input_vecs_are_features_ , real phone_deletion_penalty=1.0 , 
+                 bool apply_pause_deletion_penalty=false , char *phone_priors_fname=NULL , 
+                 char *neural_net_fname=NULL , int nn_cw_size=9 , char *norms_fname=NULL , 
+                 bool online_norm_=false , real alpha_m_=0.005 , real alpha_v_=0.005 ) ;
+    ~PhoneModels() ;
+
+    /* Methods */
+    DecodingHMM *getModel( int index ) ;
+    void setInputVector( real *input_vec ) ;
+    real calcEmissionProb( int prob_vec_index , Distribution *dist ) ;
+    void readModelsFromHTK( FILE *models_fd ) ;
+    void readModelsFromNoway( FILE *models_fd ) ;
+    void readPhonePriors( char *phone_priors_filename ) ;
+    void calcEmissionProbsOneFrame( real *features ) ;
+    void calcEmissionProbsAllFrames( int n_frames , real **features , real ***emission_probs ) ;
+
+#ifdef DEBUG
+    void outputText() ;
+#endif
+};
+
+
+
+}
+
+
+#endif
+    
+    
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/SpeechMLP.cc work/main.d/Torch-3/decoder/SpeechMLP.cc
--- tmp/Torch-3/decoder/SpeechMLP.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/SpeechMLP.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,767 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "SpeechMLP.h"
+#include "Tanh.h"
+#include "Sigmoid.h"
+#include "SoftMax.h"
+#include "LogSoftMax.h"
+#include "DiskXFile.h"
+#include "string_stuff.h"
+
+
+namespace Torch {
+
+
+SpeechMLP::SpeechMLP( char *quicknet_mlpw_filename , int n_cw_vecs_ , 
+                      char *quicknet_norms_filename , bool online_norm_ ,
+                      real alpha_m_ , real alpha_v_ , bool lna8_outputs_ )
+{
+    DiskXFile *mlpw_fd ;
+    int magic , ver_code , net_type , n_layers_ , n_sections ;
+    int sec_type , n_weights , data_type , bytes_per_weight , exponent ;
+    int *n_units ;
+    bool type_is_float ;
+    real *hid_weights=NULL , *hid_bias=NULL , *out_weights=NULL , *out_bias=NULL , *real_ptr ;
+    void *vals ;
+    MLPNonLinTransformType nl_type ;
+    
+#ifdef DEBUG
+    if ( (sizeof(int) != 4) || (sizeof(float) != 4) || (sizeof(double) != 8) || 
+         (sizeof(short) != 2) )
+        error("SpeechMLP::SpeechMLP(2) - data types are not expected sizes\n") ;
+#endif
+
+    lna8_outputs = lna8_outputs_ ;
+    n_cw_vecs = n_cw_vecs_ ;
+    if ( (n_cw_vecs % 2) == 0 )
+        error("SpeechMLP::SpeechMLP(2) - n_cw_vecs is not odd\n") ;
+
+    mlpw_fd = new DiskXFile( quicknet_mlpw_filename , "r" ) ;
+
+    // Read the magic number and make sure that it is ok
+    if ( mlpw_fd->read( &magic , sizeof(int) , 1 ) != 1 )
+        error("SpeechMLP::SpeechMLP(2) - error reading magic number\n") ;
+    if ( magic != 0x4d4c5057 )
+        error("SpeechMLP::SpeechMLP(2) - magic number 0x%X incorrect\n",magic) ;
+
+    // Read the version code and ignore
+    if ( mlpw_fd->read( &ver_code , sizeof(int) , 1 ) != 1 )
+        error("SpeechMLP::SpeechMLP(2) - error reading version code\n") ;
+
+    // Read the net type
+    if ( mlpw_fd->read( &net_type , sizeof(int) , 1 ) != 1 )
+        error("SpeechMLP::SpeechMLP(2) - error reading net type code\n") ;
+
+    // Interpret the net type according to the QuickNet "QN_MLPW_ntype" enumeration
+    if ( (net_type == 0) || (net_type == 3) )
+        nl_type = MLP_NONE ;
+    else if ( net_type == 1 )
+        nl_type = MLP_SOFTMAX ;
+    else if ( net_type == 2 )
+        nl_type = MLP_SIGMOID ;
+    else
+        nl_type = MLP_SOFTMAX ;   // default MLPW nettype
+    
+    // Read the number of layers in the neural network
+    if ( mlpw_fd->read( &n_layers_ , sizeof(int) , 1 ) != 1 )
+        error("SpeechMLP::SpeechMLP(2) - error reading number of layers code\n") ;
+    // We assume that the number of layers will be 3
+    if ( n_layers_ != 3 )
+        error("SpeechMLP::SpeechMLP(2) - number of layers is not 3\n") ;
+    n_units = (int *)Allocator::sysAlloc( n_layers_ * sizeof(int) ) ;
+    
+    // Read the number of sections in the neural network
+    if ( mlpw_fd->read( &n_sections , sizeof(int) , 1 ) != 1 )
+        error("SpeechMLP::SpeechMLP(2) - error reading number of sections\n") ;
+    // We assume that the number of sections will be 4
+    if ( n_sections != 4 )
+        error("SpeechMLP::SpeechMLP(2) - number of sections is not 4\n") ;
+    
+    // Read the number of units in each layer of the network
+    for ( int i=0 ; i<n_layers_ ; i++ )
+    {
+        if ( mlpw_fd->read( n_units+i , sizeof(int) , 1 ) != 1 )
+            error("SpeechMLP::SpeechMLP(2) - error reading number of units in %dth layer\n",i) ;
+    }
+
+    // We have read all of the information required to "Create" the neural net.
+    // QuickNet neural nets always use a Sigmoid transformation in the hidden layer.
+    createMLP( n_units[0] , n_units[1] , n_units[2] , MLP_SIGMOID , nl_type ) ;
+    
+    // Now read the data for each section
+    for ( int i=0 ; i<n_sections ; i++ )
+    {
+        // Read and process the header information
+        // Section Type
+        if ( mlpw_fd->read( &sec_type , sizeof(int) , 1 ) != 1 )
+            error("SpeechMLP::SpeechMLP(2) - error reading section type\n") ;
+        
+        // Number of weights in the section
+        if ( mlpw_fd->read( &n_weights , sizeof(int) , 1 ) != 1 )
+            error("SpeechMLP::SpeechMLP(2) - error reading number of weights\n") ;
+
+        // Read the 'datatype' field and determine what the data type is
+        if ( mlpw_fd->read( &data_type , sizeof(int) , 1 ) != 1 )
+            error("SpeechMLP::SpeechMLP(2) - error reading data type\n") ;
+        
+        if ( data_type > 32 )
+        {
+            // The data type is a floating point type
+            type_is_float = true ;
+            bytes_per_weight = data_type - 32 ;
+            if ( (bytes_per_weight != 4) && (bytes_per_weight != 8) )
+                error("SpeechMLP::SpeechMLP(2) - invalid bytes_per_weight for float type\n") ;
+        }
+        else
+        {
+            type_is_float = false ;
+            bytes_per_weight = data_type ;
+            if ( (bytes_per_weight != 1) && (bytes_per_weight != 2) && (bytes_per_weight != 4) )
+                error("SpeechMLP::SpeechMLP(2) - invalid bytes_per_weight for fixed type\n") ;
+            
+            // The data type is fixed point - read the 'exponent value'
+            if ( mlpw_fd->read( &exponent , sizeof(int) , 1 ) != 1 )
+                error("SpeechMLP::SpeechMLP(2) - error reading fixed point exponent\n") ;
+        }
+
+        // Allocate a temporary place to store values read from file
+        vals = Allocator::sysAlloc( n_weights * bytes_per_weight ) ;
+
+        // Now read the weights themselves
+        if ( mlpw_fd->read( vals , bytes_per_weight , n_weights ) != n_weights )
+            error("SpeechMLP::SpeechMLP(2) - error reading weights\n") ;
+            
+        switch( sec_type )
+        {
+            // Interpret the section type as per the QuickNet QN_SectionSelector enumeration.
+        case 0:
+            // Input-hidden layer weights.
+            // First check that the total number of weights is correct
+            if ( n_weights != (n_units[0] * n_units[1]) )
+            {
+                error( "SpeechMLP::SpeechMLP(2) - n_weights=%d wrong for inp-hid weights\n" , 
+                       n_weights ) ;
+            }
+            if ( hid_weights != NULL )
+                error( "SpeechMLP::SpeechMLP(2) - duplicate hidden layer weights section\n" ) ;
+             
+            // Allocate an array of floats to store the weights
+            hid_weights = (real *)Allocator::sysAlloc( n_weights * sizeof(real) ) ;
+
+            // Convert the weights to real format
+            convertWeightsToReal( n_weights , bytes_per_weight , type_is_float , exponent ,
+                                  vals , hid_weights ) ;
+            break ;
+        case 1:
+            // Hidden layer bias.
+            // First check that the total number of weights is correct
+            if ( n_weights != n_units[1] )
+            {
+                error( "SpeechMLP::SpeechMLP(2) - n_weights=%d wrong for hid bias weights\n" , 
+                       n_weights ) ;
+            }
+            if ( hid_bias != NULL )
+                error( "SpeechMLP::SpeechMLP(2) - duplicate hidden layer bias section\n" ) ;
+             
+            // Allocate an array of floats to store the weights
+            hid_bias = (real *)Allocator::sysAlloc( n_weights * sizeof(real) ) ;
+
+            // Convert the weights to real format
+            convertWeightsToReal( n_weights , bytes_per_weight , type_is_float , exponent ,
+                                  vals , hid_bias ) ;
+            break ;
+        case 2:
+            // Hidden-output layer weights
+            // First check that the total number of weights is correct
+            if ( n_weights != (n_units[1] * n_units[2]) )
+            {
+                error( "SpeechMLP::SpeechMLP(2) - n_weights=%d wrong for hid-out weights\n" , 
+                       n_weights ) ;
+            }
+            if ( out_weights != NULL )
+                error( "SpeechMLP::SpeechMLP(2) - duplicate output layer weights section\n" ) ;
+             
+            // Allocate an array of floats to store the weights
+            out_weights = (real *)Allocator::sysAlloc( n_weights * sizeof(real) ) ;
+
+            // Convert the weights to real format
+            convertWeightsToReal( n_weights , bytes_per_weight , type_is_float , exponent ,
+                                  vals , out_weights ) ;
+            break ;
+        case 3:
+            // Output layer bias.
+            // First check that the total number of weights is correct
+            if ( n_weights != n_units[2] )
+            {
+                error( "SpeechMLP::SpeechMLP(2) - n_weights=%d wrong for out bias weights\n" , 
+                       n_weights ) ;
+            }
+            if ( out_bias != NULL )
+                error( "SpeechMLP::SpeechMLP(2) - duplicate output layer bias section\n" ) ;
+             
+            // Allocate an array of floats to store the weights
+            out_bias = (real *)Allocator::sysAlloc( n_weights * sizeof(real) ) ;
+
+            // Convert the weights to real format
+            convertWeightsToReal( n_weights , bytes_per_weight , type_is_float , exponent ,
+                                  vals , out_bias ) ;
+            break ;
+        default:
+            error("SpeechMLP::SpeechMLP(2) - invalid section type\n") ;
+        }
+        
+        free( vals ) ;
+    }
+    
+    // Make sure that we read all sections
+    if ( (hid_weights==NULL)||(hid_bias==NULL)||(out_weights==NULL)||(out_bias==NULL) )
+         error("SpeechMLP::SpeechMLP(2) - not all sections were read correctly\n") ;
+
+    // Now fill in the weights and biases of our hidden layer linear transform
+    real_ptr = hidden_layer_lin->params->data[0];
+    for ( int i=0 ; i<n_units[1]*n_units[0] ; i++ )
+      real_ptr[i] = hid_weights[i];
+
+    real_ptr += n_units[1]*n_units[0];
+    for ( int i=0 ; i<n_units[1] ; i++ )
+        real_ptr[i] = hid_bias[i];
+            
+    // Now fill in the weights and biases of our output layer linear transform
+    real_ptr = output_layer_lin->params->data[0] ;
+    for ( int i=0 ; i<n_units[2]*n_units[1] ; i++ )
+      real_ptr[i] = out_weights[i];
+
+    real_ptr += n_units[2]*n_units[1];
+    for ( int i=0 ; i<n_units[1] ; i++ )
+        real_ptr[i] = out_bias[i];
+    
+    free( n_units ) ;
+    free( hid_weights ) ;
+    free( hid_bias ) ;
+    free( out_weights ) ;
+    free( out_bias ) ;
+
+    delete mlpw_fd ;
+
+    // Check that the number of MLP inputs corresponds to the number of features and
+    //   the context window size that we are using.
+    if ( (n_mlp_inputs % n_cw_vecs) != 0 )
+        error("SpeechMLP::SpeechMLP(2) - n_mlp_inputs is not a multiple of n_cw_vecs\n") ;
+    n_features = n_mlp_inputs / n_cw_vecs ;
+
+    // Allocate memory for the feature vectors in the context window.
+    // Create the 'List' object that can be passed to the 'forward' methods
+    mlp_input_seq = new Sequence(1, n_mlp_inputs);
+    context_window = mlp_input_seq->frames[0];
+    for ( int i=0 ; i<n_mlp_inputs ; i++ )
+        context_window[i] = 0.0 ;
+
+    // If a norms file was specified, read it
+    ftr_norms_means = NULL ;
+    ftr_norms_inv_stddevs = NULL ;
+    ftr_norms_vars = NULL ;
+    if ( (quicknet_norms_filename != NULL) && (strcmp(quicknet_norms_filename,"")!=0) )
+        loadFeatureNorms( quicknet_norms_filename ) ;
+
+    // Setup everything related to online normalisation of feature vectors
+    //   ie. adapting the means & stddevs used for normalisation.
+    online_norm = online_norm_ ;
+    if ( online_norm==true )
+    {
+        if ( (quicknet_norms_filename==NULL) || (strcmp(quicknet_norms_filename,"")==0) )
+            error("SpeechMLP::SpeechMLP(2) - cannot do online norm without a norms file\n") ;
+
+        alpha_m = alpha_m_ ;
+        alpha_v = alpha_v_ ;
+        
+        // Save the means and inv stddevs we read from file, so that we can re-init between
+        //   input files.
+        orig_ftr_norms_means = (real *)Allocator::sysAlloc( n_features * sizeof(real) ) ;
+        orig_ftr_norms_inv_stddevs = (real *)Allocator::sysAlloc( n_features * sizeof(real) ) ;
+        orig_ftr_norms_vars = (real *)Allocator::sysAlloc( n_features * sizeof(real) ) ;
+        
+        memcpy( orig_ftr_norms_means , ftr_norms_means , n_features*sizeof(real) ) ;
+        memcpy( orig_ftr_norms_inv_stddevs , ftr_norms_inv_stddevs , n_features*sizeof(real) ) ;
+        memcpy( orig_ftr_norms_vars , ftr_norms_vars , n_features*sizeof(real) ) ;
+    }
+    else
+    {
+        orig_ftr_norms_means = NULL ;
+        orig_ftr_norms_inv_stddevs = NULL ;
+        orig_ftr_norms_vars = NULL ;
+    }
+}
+
+
+void SpeechMLP::feedForwardOneFrame( real *features , real *mlp_outputs )
+{
+    int x ;
+    
+    // 'mlp_outputs' is assumed to be pre-allocated and assumed to have
+    //   enough (ie. n_mlp_outputs) memory allocated.
+
+    // Do we have means and stddevs so that we can normalise the input
+    //   feature vector ?
+    if ( ftr_norms_means != NULL )
+        normaliseFeatures( features ) ;
+
+    // Assemble the new context window.
+    // Shuffle the existing context window contents down to make room for the
+    //   new input vector.
+    memmove( context_window , context_window+n_features , 
+             (n_mlp_inputs-n_features)*sizeof(real) ) ;
+
+    // Copy the new input feature vector
+    memcpy( context_window+((n_cw_vecs-1)*n_features) , features , n_features*sizeof(real) ) ;
+
+    // Calculate the output of the MLP
+    forward( mlp_input_seq ) ;
+    
+    // Copy the outputs to the 'mlp_outputs' buffer.
+    memcpy( mlp_outputs , outputs->frames[0] , n_mlp_outputs*sizeof(real) ) ;
+
+    // Calculate the log of the output values if we haven't already get them from a
+    //   LOG_SOFTMAX nonlinear output layer transformation
+    if ( output_nl_transf != MLP_LOGSOFTMAX )
+    {
+        for ( int i=0 ; i<n_mlp_outputs ; i++ )
+        {
+            if ( lna8_outputs == true )
+            {
+                x = (int)floor( -24.0 * log( mlp_outputs[i] + 1e-37 ) ) ;
+                if ( x > 255 ) x = 255 ;
+                if ( x < 0 ) x = 0 ;
+                mlp_outputs[i] = -((real)x + 0.5) / 24.0 ;
+            }
+            else
+                mlp_outputs[i] = log( mlp_outputs[i] ) ;
+        }
+    }
+    else if ( lna8_outputs == true )
+    {
+        for ( int i=0 ; i<n_mlp_outputs ; i++ )
+        {
+            x = (int)floor( -24.0 * mlp_outputs[i] ) ;
+            if ( x > 255 ) x = 255 ;
+            if ( x < 0 ) x = 0 ;
+            mlp_outputs[i] = -((real)x + 0.5) / 24.0 ;
+        }
+    }
+}
+    
+
+void SpeechMLP::feedForward( int n_frames_ , real **features , int *n_out_frames , 
+                             real ***mlp_outputs )
+{
+    // Allocate memory for the MLP outputs here.
+    // The number of output frames is less than the number of input frames
+    //   if the context window size is greater than 1 (we wait until we have
+    //   a full context window before starting the MLP).
+
+    int j , start_index ;
+    
+    if ( n_frames_ < n_cw_vecs )
+        error("SpeechMLP::feedForward - not enough input frames to fill context window\n") ;
+        
+    *n_out_frames = n_frames_ - n_cw_vecs + 1 ;
+    *mlp_outputs = (real **)Allocator::sysAlloc( (*n_out_frames) * sizeof(real *) ) ;
+    
+    // Initialise the context window and online normalisation.
+    start_index = initContextWindow( features ) ;
+
+    for ( j=0 ; j<(*n_out_frames) ; j++ )
+    {
+        (*mlp_outputs)[j] = (real *)Allocator::sysAlloc( n_mlp_outputs * sizeof(real) ) ;
+        feedForwardOneFrame( features[start_index++] , (*mlp_outputs)[j] ) ;
+    }
+}
+
+
+void SpeechMLP::convertWeightsToReal( int n_weights , int bytes_per_weight , 
+                                      bool weights_are_float , int exponent , 
+                                      void *inputs_ , real *outputs_ )
+{
+    // If the inputs are fixed point, figure out how each value will be 
+    //   scaled using the exponent value.
+    real scale=0.0 ;
+    if ( weights_are_float == false )
+    {
+        if ( bytes_per_weight == 1 )
+            scale = (real)pow( 2.0 , exponent - 7 ) ;
+        else if ( bytes_per_weight == 2 )
+            scale = (real)pow( 2.0 , exponent - 15 ) ;
+        else if ( bytes_per_weight == 4 )
+            scale = (real)pow( 2.0 , exponent - 31 ) ;
+        else
+            scale = 0.0 ;
+    }
+
+    // Convert the input values.
+    for ( int j=0 ; j<n_weights ; j++ )
+    {
+        if ( weights_are_float == true )
+        {
+            if ( bytes_per_weight == 4 )
+                outputs_[j] = (real)((float *)inputs_)[j] ;
+            else if ( bytes_per_weight == 8 )
+                outputs_[j] = (real)((double *)inputs_)[j] ;
+        }
+        else
+        {
+            if ( bytes_per_weight == 1 )
+                outputs_[j] = scale * (int)(((char *)inputs_)[j]) ;
+            else if ( bytes_per_weight == 2 )
+                outputs_[j] = scale * (int)(((short *)inputs_)[j]) ;
+            else if ( bytes_per_weight == 4 )
+                outputs_[j] = scale * ((int *)inputs_)[j] ;
+        }
+    }
+}
+
+
+void SpeechMLP::createMLP( int n_inputs_ , int n_hidden_ , int n_outputs_ ,
+                           MLPNonLinTransformType hidden_nl_transf_ ,
+                           MLPNonLinTransformType output_nl_transf_ ) 
+{
+    n_mlp_inputs = n_inputs_ ;
+    n_mlp_hidden = n_hidden_ ;
+    n_mlp_outputs = n_outputs_ ;
+    hidden_nl_transf = hidden_nl_transf_ ;
+    output_nl_transf = output_nl_transf_ ;
+    
+    // Setup the linear transformation associated with the hidden layer.
+    hidden_layer_lin = new Linear( n_mlp_inputs , n_mlp_hidden ) ;
+    addFCL( hidden_layer_lin ) ;
+
+    // Setup the non-linear transformation associated with the hidden layer
+    //   and connect it to the linear transformation.
+    switch ( hidden_nl_transf )
+    {
+    case MLP_TANH:
+        hidden_layer_nonlin = new Tanh( n_mlp_hidden ) ;
+        break ;
+    case MLP_SIGMOID:
+        hidden_layer_nonlin = new Sigmoid( n_mlp_hidden ) ;
+        break ;
+    case MLP_SOFTMAX:
+        hidden_layer_nonlin = new SoftMax( n_mlp_hidden ) ;
+        break ;
+    case MLP_LOGSOFTMAX:
+        hidden_layer_nonlin = new LogSoftMax( n_mlp_hidden ) ;
+        break ;
+    case MLP_NONE:
+        error("SpeechMLP::SpeechMLP - must have a hidden layer non-linear transformation\n") ;
+        break ;
+    default:
+        error("SpeechMLP::SpeechMLP - invalid hidden_nl_transf\n") ;
+    }
+    
+    addFCL( hidden_layer_nonlin ) ;
+
+    // Setup the linear transformation associated with the output layer
+    output_layer_lin = new Linear( n_mlp_hidden , n_mlp_outputs ) ;
+    addFCL( output_layer_lin ) ;
+
+    // Setup the non-linear transformation associated with the output layer
+    //   and connect it to the linear transformation.
+    switch ( output_nl_transf )
+    {
+    case MLP_TANH:
+        output_layer_nonlin = new Tanh( n_mlp_outputs ) ;
+        break ;
+    case MLP_SIGMOID:
+        output_layer_nonlin = new Sigmoid( n_mlp_outputs ) ;
+        break ;
+    case MLP_SOFTMAX:
+        output_layer_nonlin = new SoftMax( n_mlp_outputs ) ;
+        break ;
+    case MLP_LOGSOFTMAX:
+        output_layer_nonlin = new LogSoftMax( n_mlp_outputs ) ;
+        break ;
+    case MLP_NONE:
+        output_layer_nonlin = NULL ;
+        break ;
+    default:
+        error("SpeechMLP::SpeechMLP - invalid output_nl_transf\n") ;
+    }
+    
+    if ( output_layer_nonlin != NULL )
+        addFCL( output_layer_nonlin ) ;
+    
+    ConnectedMachine::build() ;
+}
+
+
+int SpeechMLP::initContextWindow( real **frames )
+{
+    // There are assumed to be at least 'n_cw_vecs' frames in 'frames'.
+    // Copy the first '(n_cw_vecs-1)/2' vectors into 'context_window'
+    //   and return the index into 'frames' for the next vector.
+    //   (ie. the first vector we will input into the MLP)
+ 
+    // Reset the means, inv stddevs and vars used for feature normalisation
+    if ( online_norm == true )
+    {
+        memcpy( ftr_norms_means , orig_ftr_norms_means , n_features*sizeof(real) ) ;
+        memcpy( ftr_norms_inv_stddevs , orig_ftr_norms_inv_stddevs , n_features*sizeof(real) ) ;
+        memcpy( ftr_norms_vars , orig_ftr_norms_vars , n_features*sizeof(real) ) ;
+    }
+
+    for ( int i=1 ; i<n_cw_vecs ; i++ )
+    {
+        if ( ftr_norms_means != NULL )
+            normaliseFeatures( frames[i-1] ) ;
+        memcpy( context_window+(i*n_features) , frames[i-1] , n_features*sizeof(real) ) ;
+    }
+
+    return (n_cw_vecs-1) ;
+}
+
+
+void SpeechMLP::loadFeatureNorms( char *norms_filename )
+{
+    FILE *norms_fd ;
+    char line[1000] , str[100] ;
+    int n_vals ;
+    
+    // The input file is in the format as output by the QuickNet qnnorm utility.
+    if ( (norms_filename == NULL) || (strcmp(norms_filename,"")==0) )
+        return ;
+
+    if ( n_features <= 0 )
+        error("SpeechMLP::loadFeatureNorms - n_features not defined\n") ;
+    
+    // Open the input file
+    if ( (norms_fd = fopen( norms_filename , "r" )) == NULL )
+        error("SpeechMLP::loadFeatureNorms - error opening norms file\n") ;
+
+    // Load the means header line "vec <num_features>" and check validity
+    fgets( line , 1000 , norms_fd ) ;
+    if ( sscanf( line , "%s %d" , str , &n_vals ) != 2 )
+        error("SpeechMLP::loadFeatureNorms - error reading means header line\n") ;
+    if ( (strcmp( str , "VEC" ) != 0) && (strcmp( str , "vec" ) != 0) )
+        error("SpeechMLP::loadFeatureNorms - VEC not found on means header line\n") ;
+    if ( n_vals != n_features )
+        error("SpeechMLP::loadFeatureNorms - feature vector size does not match norms file\n") ;
+    
+    // Allocate memory for the means and inv stddevs
+    ftr_norms_means = (real *)Allocator::sysAlloc( n_features * sizeof(real) ) ;
+    ftr_norms_inv_stddevs = (real *)Allocator::sysAlloc( n_features * sizeof(real) ) ;
+    ftr_norms_vars = (real *)Allocator::sysAlloc( n_features * sizeof(real) ) ;
+
+    // Read in the means
+    for ( int i=0 ; i<n_vals ; i++ )
+    {
+        fgets( line , 1000 , norms_fd ) ;
+#ifdef USE_DOUBLE
+        if ( sscanf( line , "%lf" , ftr_norms_means+i ) != 1 )
+#else
+        if ( sscanf( line , "%f" , ftr_norms_means+i ) != 1 )
+#endif
+            error("SpeechMLP::loadFeatureNorms - error reading means value\n") ;
+    }
+
+    // Read the inv stddevs header line
+    fgets( line , 1000 , norms_fd ) ;
+    if ( sscanf( line , "%s %d" , str , &n_vals ) != 2 )
+        error("SpeechMLP::loadFeatureNorms - error reading inv stddevs header line\n") ;
+    if ( (strcmp( str , "VEC" ) != 0) && (strcmp( str , "vec" ) != 0) )
+        error("SpeechMLP::loadFeatureNorms - VEC not found on inv stddevs header line\n") ;
+    if ( n_vals != n_features )
+        error("SpeechMLP::loadFeatureNorms - feature vector size does not match norms file\n") ;
+
+    // Read in the inv stddevs
+    for ( int i=0 ; i<n_vals ; i++ )
+    {
+        fgets( line , 1000 , norms_fd ) ;
+#ifdef USE_DOUBLE
+        if ( sscanf( line , "%lf" , ftr_norms_inv_stddevs+i ) != 1 )
+#else
+        if ( sscanf( line , "%f" , ftr_norms_inv_stddevs+i ) != 1 )
+#endif
+            error("SpeechMLP::loadFeatureNorms - error reading inv stddev value\n") ;
+        ftr_norms_vars[i] = 1.0 / (ftr_norms_inv_stddevs[i] * ftr_norms_inv_stddevs[i]) ;
+    }
+
+    fclose( norms_fd ) ;
+}
+
+
+SpeechMLP::~SpeechMLP()
+{
+    if ( hidden_layer_lin != NULL )
+        delete hidden_layer_lin ;
+    if ( hidden_layer_nonlin != NULL )
+        delete hidden_layer_nonlin ;
+    if ( output_layer_lin != NULL )
+        delete output_layer_lin ; 
+    if ( output_layer_nonlin != NULL )
+        delete output_layer_nonlin ;
+    if ( ftr_norms_means != NULL )
+        free( ftr_norms_means ) ;
+    if ( ftr_norms_inv_stddevs != NULL )
+        free( ftr_norms_inv_stddevs ) ;
+    if ( ftr_norms_vars != NULL )
+        free( ftr_norms_vars ) ;
+    if ( orig_ftr_norms_means != NULL )
+        free( orig_ftr_norms_means ) ;
+    if ( orig_ftr_norms_vars != NULL )
+        free( orig_ftr_norms_vars ) ;
+    if ( orig_ftr_norms_inv_stddevs != NULL )
+        free( orig_ftr_norms_inv_stddevs ) ;
+    if ( mlp_input_seq != NULL )
+        delete mlp_input_seq ;
+}
+
+
+void SpeechMLP::normaliseFeatures( real *features )
+{
+    real mean , var , x ;
+    
+    for ( int i=0 ; i<n_features ; i++ )
+    {
+        if ( online_norm == true )
+        {
+            mean = ftr_norms_means[i] ;
+            var = ftr_norms_vars[i] ;
+            x = features[i] ;
+
+            // update recursive estimate of mean 
+            mean = (1.0 - alpha_m) * mean + alpha_m * x ;
+
+            // subtract latest mean from the value 
+            x -= mean ;
+
+            // update recursive estimate of variance 
+            var = (1.0 - alpha_v) * var + alpha_v * x * x ;
+
+            // save the new bias and scale estimates (for the next frame) 
+            ftr_norms_means[i] = mean ;
+            ftr_norms_vars[i] = var ;
+            ftr_norms_inv_stddevs[i] = 1.0 / sqrt(var) ;
+            x *= ftr_norms_inv_stddevs[i] ;
+            features[i] = x ;
+        }
+        else
+        {
+            // Subtract the mean
+            features[i] -= ftr_norms_means[i] ;
+
+            // Scale the difference by the inverse stddev
+            features[i] *= ftr_norms_inv_stddevs[i] ;
+        }
+    }
+}
+
+
+#ifdef DEBUG
+void SpeechMLP::outputText()
+{
+    real *real_ptr ;
+
+    printf("num input units = %d\n",n_mlp_inputs);
+    printf("num hidden units = %d\n",n_mlp_hidden);
+    printf("num output units = %d\n",n_mlp_outputs);
+    printf("\n");
+    printf("hidden layer non-linear transformation is: ");
+    switch ( hidden_nl_transf )
+    {
+    case MLP_TANH:
+        printf("TANH\n") ;
+        break ;
+    case MLP_SIGMOID:
+        printf("SIGMOID\n") ;
+        break ;
+    case MLP_SOFTMAX:
+        printf("SOFTMAX\n") ;
+        break ;
+    case MLP_LOGSOFTMAX:
+        printf("LOGSOFTMAX\n") ;
+        break ;
+    case MLP_NONE:
+        printf("NONE\n") ;
+        break ;
+    default:
+        printf("UNKNOWN!!\n") ;
+    }
+    printf("output layer non-linear transformation is: ");
+    switch ( output_nl_transf )
+    {
+    case MLP_TANH:
+        printf("TANH\n") ;
+        break ;
+    case MLP_SIGMOID:
+        printf("SIGMOID\n") ;
+        break ;
+    case MLP_SOFTMAX:
+        printf("SOFTMAX\n") ;
+        break ;
+    case MLP_LOGSOFTMAX:
+        printf("LOGSOFTMAX\n") ;
+        break ;
+    case MLP_NONE:
+        printf("NONE\n") ;
+        break ;
+    default:
+        printf("UNKNOWN!!\n") ;
+    }
+
+    printf("HIDDEN LAYER WEIGHTS\n\n") ;
+    if ( hidden_layer_lin != NULL )
+    {
+        real_ptr = hidden_layer_lin->params->data[0] ;
+        for ( int i=0 ; i<n_mlp_hidden ; i++ )
+        {
+            for ( int j=0 ; j<n_mlp_inputs ; j++ )
+                printf("%f\n",*(real_ptr++));
+        }
+        printf("\nHIDDEN LAYER BIASES\n\n") ;
+        for ( int i=0 ; i<n_mlp_hidden ; i++ )
+            printf("%f\n",*(real_ptr++));
+    }
+    if ( output_layer_lin != NULL )
+    {
+        printf("OUTPUT LAYER WEIGHTS\n\n") ;
+        real_ptr = output_layer_lin->params->data[0] ;
+        for ( int i=0 ; i<n_mlp_outputs ; i++ )
+        {
+            for ( int j=0 ; j<n_mlp_hidden ; j++ )
+                printf("%f\n",*(real_ptr++));
+        }
+        printf("\nOUTPUT LAYER BIASES\n\n") ;
+        for ( int i=0 ; i<n_mlp_outputs ; i++ )
+            printf("%f\n",*(real_ptr++));
+    }
+    fflush(stdout) ;
+}
+#endif
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/SpeechMLPDistr.cc work/main.d/Torch-3/decoder/SpeechMLPDistr.cc
--- tmp/Torch-3/decoder/SpeechMLPDistr.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/SpeechMLPDistr.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,75 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "SpeechMLPDistr.h"
+
+
+namespace Torch {
+
+
+SpeechMLPDistr::SpeechMLPDistr( SpeechMLP *mlp_ , real **outputs_ , int prob_vec_index_ , 
+                                real *log_priors_ ) : Distribution(0,0)
+{
+#ifdef DEBUG
+    if ( mlp_ == NULL )
+        error("SpeechMLPDistr::SpeechMLPDistr - mlp_ is NULL\n") ;
+    if ( outputs_ == NULL )
+        error("SpeechMLPDistr::SpeechMLPDistr - outputs_ is NULL\n") ;
+    if ( (prob_vec_index_ < 0) || (prob_vec_index_ >= mlp_->n_mlp_outputs) )
+        error("SpeechMLPDistr::SpeechMLPDistr - prob_vec_index out of range\n") ;
+#endif
+    mlp = mlp_ ;
+    mlp_outputs = outputs_ ;
+    prob_vec_index = prob_vec_index_ ;
+    log_priors = log_priors_ ;
+}
+
+
+SpeechMLPDistr::~SpeechMLPDistr()
+{
+}
+
+
+real SpeechMLPDistr::frameLogProbability( int t , real *f_inputs )
+{
+    mlp->feedForwardOneFrame( f_inputs , *mlp_outputs ) ;
+//for ( int i=0 ; i<mlp->n_mlp_outputs ; i++ )
+//    printf("%6.3f ",(*mlp_outputs)[i]);
+//printf("\n\n");
+
+    if ( log_priors != NULL )
+    {
+        for ( int i=0 ; i<mlp->n_mlp_outputs ; i++ )
+            (*mlp_outputs)[i] -= log_priors[i] ;
+    }
+
+    return (*mlp_outputs)[prob_vec_index] ;
+}
+    
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/SpeechMLPDistr.h work/main.d/Torch-3/decoder/SpeechMLPDistr.h
--- tmp/Torch-3/decoder/SpeechMLPDistr.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/SpeechMLPDistr.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,63 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SPEECHMLPDISTR_INC
+#define SPEECHMLPDISTR_INC
+
+#include "general.h"
+#include "Distribution.h"
+#include "SpeechMLP.h"
+
+
+namespace Torch {
+
+/**
+   @author Darren Moore (moore@idiap.ch)
+*/
+class SpeechMLPDistr : public Distribution
+{
+public:
+    SpeechMLP *mlp ;
+    real **mlp_outputs ;
+    int prob_vec_index ;
+    
+    real *log_priors ;
+
+    /* Constructors / destructor */
+    SpeechMLPDistr( SpeechMLP *mlp_ , real **outputs_ , int prob_vec_index_ , 
+                    real *log_priors_=NULL ) ;
+    virtual ~SpeechMLPDistr() ;
+
+    /* Methods */
+    real frameLogProbability( int t , real *f_inputs ) ;    
+} ;    
+    
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/SpeechMLP.h work/main.d/Torch-3/decoder/SpeechMLP.h
--- tmp/Torch-3/decoder/SpeechMLP.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/SpeechMLP.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,118 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SPEECHMLP_INC
+#define SPEECHMLP_INC
+
+#include "general.h"
+#include "Sequence.h"
+#include "ConnectedMachine.h"
+#include "Linear.h"
+#include "GradientMachine.h"
+
+
+namespace Torch {
+
+typedef enum
+{
+    MLP_TANH=0 ,
+    MLP_SIGMOID ,
+    MLP_SOFTMAX ,
+    MLP_LOGSOFTMAX ,
+    MLP_NONE
+} MLPNonLinTransformType ;
+
+/**
+   @author Darren Moore (moore@idiap.ch)
+*/
+class SpeechMLP : public ConnectedMachine
+{
+  public:
+    /// the first #Linear# layer
+    Linear *hidden_layer_lin ;
+    /// the first #Tanh# or #Sigmoid# layer
+    GradientMachine *hidden_layer_nonlin ;
+    /// the second #Linear# layer
+    Linear *output_layer_lin ;
+    /// the optional second #Softmax#, #Sigmoid# or #Tanh# layer
+    GradientMachine *output_layer_nonlin ;
+    
+    MLPNonLinTransformType hidden_nl_transf ;
+    MLPNonLinTransformType output_nl_transf ;
+    
+    /// the number of hidden units
+    int n_mlp_hidden ;
+    /// the number of inputs
+    int n_mlp_inputs ;
+    /// the number of outputs
+    int n_mlp_outputs ;
+
+    int n_features ;
+    int n_cw_vecs ;
+    real *context_window ;
+    Sequence *mlp_input_seq ;
+
+    real *ftr_norms_means ;
+    real *orig_ftr_norms_means ;
+    real *ftr_norms_inv_stddevs ;
+    real *orig_ftr_norms_inv_stddevs ;
+    real *ftr_norms_vars ;
+    real *orig_ftr_norms_vars ;
+    bool online_norm ;
+    real alpha_m ;
+    real alpha_v ;
+    bool lna8_outputs ;
+    
+    /// Constructor for the SpeechMLP class - reads a Quicknet MLPW format file
+    SpeechMLP( char *quicknet_mlpw_filename , int n_cw_vecs_=9 , 
+               char *quicknet_norms_filename=NULL , bool online_norm=false ,
+               real alpha_m_=0.005 , real alpha_v_=0.005 , bool lna8_outputs_=false ) ; 
+    virtual ~SpeechMLP();
+
+    void createMLP( int n_inputs_ , int n_hidden_ , int n_outputs_ ,
+                    MLPNonLinTransformType hidden_nl_transf_ ,
+                    MLPNonLinTransformType output_nl_transf_ ) ;
+    
+    void convertWeightsToReal( int n_weights , int bytes_per_weight , bool weights_are_float , 
+                               int exponent , void *inputs , real *outputs ) ;
+
+    void feedForwardOneFrame( real *features , real *mlp_outputs ) ;
+    void feedForward( int n_frames_ , real **features , int *n_out_frames , real ***mlp_outputs ) ;
+    int initContextWindow( real **frames ) ;
+    void loadFeatureNorms( char *norms_filename ) ;
+    void normaliseFeatures( real *features ) ;
+
+#ifdef DEBUG
+    void outputText() ;
+#endif
+} ;
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/string_stuff.cc work/main.d/Torch-3/decoder/string_stuff.cc
--- tmp/Torch-3/decoder/string_stuff.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/string_stuff.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,84 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "string_stuff.h"
+#include "Allocator.h"
+#include "string.h"
+#include "ctype.h"
+
+namespace Torch {
+
+
+char *myfgets( FILE *fd )
+{
+    int step_size=1000 , max_size ;
+    char *ptr , *buf ;
+    
+#ifdef DEBUG
+    if ( fd==NULL )
+        error("myfgets - invalid input parameter\n") ;
+#endif
+
+    // initially allocate 1000 bytes
+    max_size = step_size ;
+    buf = (char *)Allocator::sysAlloc( max_size * sizeof(char) ) ;
+    ptr = buf ;
+        
+    if ( fgets( buf , step_size , fd ) == NULL )
+    {
+        free( buf ) ;
+        return NULL ;
+    }
+    
+    while ( ((int)strlen( ptr ) >= (step_size-1)) && (ptr[step_size-2] != '\n') )
+    {
+        // The buffer was not big enough to read the whole line.
+        // We now have max_size-1 chars + the NULL char
+        // Reallocate and keep reading (overwrite the NULL).
+        max_size += (step_size-1) ;
+        buf = (char *)Allocator::sysRealloc( buf , max_size*sizeof(char) ) ;
+        ptr = buf + max_size - step_size ;
+        if ( fgets( ptr , step_size , fd ) == NULL )
+            error("myfgets - unexpected EOF\n") ;
+    }
+
+    return buf ;
+}
+
+
+void strtoupper( char *str )
+{
+    if ( str == NULL )
+        return ;
+
+    for ( int i=0 ; i<(int)strlen(str) ; i++ )
+        str[i] = toupper( str[i] ) ;
+}
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/string_stuff.h work/main.d/Torch-3/decoder/string_stuff.h
--- tmp/Torch-3/decoder/string_stuff.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/string_stuff.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,45 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef STRING_STUFF_INC
+#define STRING_STUFF_INC
+
+#include "general.h"
+
+namespace Torch {
+
+/*
+   @author Darren Moore (moore@idiap.ch)
+*/
+
+char *myfgets( FILE *fd ) ;
+void strtoupper( char *str ) ;
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/WordChainElemPool.cc work/main.d/Torch-3/decoder/WordChainElemPool.cc
--- tmp/Torch-3/decoder/WordChainElemPool.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/WordChainElemPool.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,118 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Allocator.h"
+#include "WordChainElemPool.h"
+
+namespace Torch {
+
+
+WordChainElemPool::WordChainElemPool( int max_size , int realloc_amount_ )
+{
+    n_allocs = 0 ;
+    allocs = (WordChainElem **)Allocator::sysAlloc( (n_allocs+1) * sizeof(WordChainElem *) ) ;
+    allocs[n_allocs] = (WordChainElem *)Allocator::sysAlloc( max_size * sizeof(WordChainElem) ) ;
+    free_elems = (WordChainElem **)Allocator::sysAlloc( max_size * sizeof(WordChainElem *) ) ;
+    for ( int i=0 ; i<max_size ; i++ )
+        free_elems[i] = allocs[n_allocs] + i ;
+    n_total = max_size ;
+    n_free = n_total ;
+    n_used = 0 ;
+    n_allocs++ ;
+
+    if ( realloc_amount_ <= 0 )
+        realloc_amount = max_size ;
+    else
+        realloc_amount = realloc_amount_ ;
+}
+
+
+WordChainElemPool::~WordChainElemPool()
+{
+    if ( allocs != NULL )
+    {
+        for ( int i=0 ; i<n_allocs ; i++ )
+            free( allocs[i] ) ;
+        free( allocs ) ;
+    }
+
+    if ( free_elems != NULL )
+        free( free_elems ) ;
+}
+
+
+WordChainElem *WordChainElemPool::getElem( int word_ , WordChainElem *prev_elem_ , 
+                                           int word_start_frame_ )
+{
+    WordChainElem *temp ;
+    if ( n_free == 0 )
+    {
+        free_elems = (WordChainElem **)Allocator::sysRealloc( free_elems , 
+                                          (n_total+realloc_amount) * sizeof(WordChainElem *) ) ;
+        allocs = (WordChainElem **)Allocator::sysRealloc( allocs , 
+                                          (n_allocs+1) * sizeof(WordChainElem *) ) ;
+        allocs[n_allocs] = (WordChainElem *)Allocator::sysAlloc( 
+                                          realloc_amount * sizeof(WordChainElem) ) ;
+        for ( int i=0 ; i<realloc_amount ; i++ )
+            free_elems[i] = allocs[n_allocs] + i ;
+        n_total += realloc_amount ;
+        n_free += realloc_amount ;
+        n_allocs++ ;
+    }
+
+    n_free-- ;
+    n_used++ ;
+
+    temp = free_elems[n_free] ;
+    temp->word = word_ ;
+    temp->word_start_frame = word_start_frame_ ;
+    temp->prev_elem = prev_elem_ ;
+    if ( temp->prev_elem != NULL )
+        temp->prev_elem->n_connected++ ;
+    temp->n_connected = 0 ;
+    return temp ;
+}
+
+
+void WordChainElemPool::returnElem( WordChainElem *elem )
+{
+    // unlink the returned element from the previous element in the chain
+    if ( elem->prev_elem != NULL )
+    {
+        if ( --(elem->prev_elem->n_connected) <= 0 )
+            returnElem( elem->prev_elem ) ;
+        elem->prev_elem = NULL ;
+    }
+
+    free_elems[n_free] = elem ;
+    n_free++ ;
+    n_used-- ;
+}
+
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/decoder/WordChainElemPool.h work/main.d/Torch-3/decoder/WordChainElemPool.h
--- tmp/Torch-3/decoder/WordChainElemPool.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/decoder/WordChainElemPool.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,93 @@
+// Copyright (C) 2003--2004 Darren Moore (moore@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef WORDCHAINELEMPOOL_INC
+#define WORDCHAINELEMPOOL_INC
+
+#include "general.h"
+
+namespace Torch {
+
+
+struct WCEStruct
+{
+    int word ;
+    int word_start_frame ;
+    struct WCEStruct *prev_elem ;
+    int n_connected ;
+} ;
+typedef struct WCEStruct WordChainElem ;
+
+/** 
+    This class is a pool of pre-allocated WordChainElem structures. It's
+    purpose is to enable fast access to the WordChainElem instances during
+    decoding. If the pool is empty, and something asks for a WordChainElem 
+    instance then a block of new instances are allocated before the requested
+    instance is returned.
+    
+    @author Darren Moore (moore@idiap.ch)
+*/
+
+
+class WordChainElemPool
+{
+public:
+    int n_total ;
+    int n_free ;
+    int n_used ;
+    int realloc_amount ;
+    int n_allocs ;
+    WordChainElem **allocs ;
+    WordChainElem **free_elems ;
+
+    /* Constructors / destructor */
+    
+    /// Creates the pool. 
+    /// 'max_size' is the initial size of the pool.
+    /// 'realloc_amount_' is the number of additional WordChainElem instances 
+    ///   that are to be allocated each time the pool empties.
+    /// If 'realloc_amount_' is undefined, then 'max_size' elements are
+    ///   allocated each time the pool empties.
+    WordChainElemPool( int max_size , int realloc_amount_=-1 ) ;
+    virtual ~WordChainElemPool() ;
+
+    /* Methods */
+
+    /// Gets the next free WordChainElem instance from the pool. Allocates
+    ///   new instances if the pool is empty.
+    WordChainElem *getElem( int word_ , WordChainElem *prev_elem_ , int word_start_frame_=-1) ;
+
+    /// Returns a WordChainElem instance that is no longer required to the pool.
+    void returnElem( WordChainElem *elem ) ;
+} ;
+
+
+}
+
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/BayesClassifier.cc work/main.d/Torch-3/distributions/BayesClassifier.cc
--- tmp/Torch-3/distributions/BayesClassifier.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/BayesClassifier.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,102 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                and Bison Ravi (francois.belisle@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "BayesClassifier.h"
+#include "log_add.h"
+
+namespace Torch {
+
+
+BayesClassifier::BayesClassifier(BayesClassifierMachine* machine_) : Trainer(machine_)
+{
+
+  bayesmachine = (BayesClassifierMachine*)machine;
+  n_classes = bayesmachine->n_trainers;
+  
+  classes = (int**) allocator->alloc(n_classes * sizeof(int*));
+  for(int i = 0;i < n_classes ;i++)
+    classes[i] = (int*) allocator->alloc(1 * sizeof(int));
+  classes_n = (int*)allocator->alloc(n_classes * sizeof(int));
+}
+
+BayesClassifier::~BayesClassifier()
+{
+}
+
+void BayesClassifier::train(DataSet *data, MeasurerList *measurers)
+{
+  message("BayesClassifier: Training");
+
+  // attribute the classes
+  for (int i=0;i<n_classes;i++) {
+    classes_n[i] = 0;
+    classes[i] = (int*) allocator->realloc(classes[i],data->n_examples * sizeof(int));
+  }
+
+  machine->setDataSet(data);
+
+  for (int i=0;i<data->n_examples;i++) {
+    data->setExample(i);
+    int c = bayesmachine->class_format->getClass(data->targets->frames[0]);
+    classes[c][classes_n[c]++] = i;
+  }
+
+  // eventually compute prior given training set
+  if (bayesmachine->allocated_log_priors) {
+    real log_n = log((real)data->n_examples);
+    for (int i=0;i<n_classes;i++)
+      if (classes_n[i] > 0)
+        bayesmachine->log_priors[i] = log((real)classes_n[i]) - log_n;
+      else
+        bayesmachine->log_priors[i] = LOG_ZERO;
+  }
+  
+  for(int c = 0;c < n_classes;c++) {
+    data->pushSubset(classes[c],classes_n[c]);
+    bayesmachine->trainers[c]->machine->reset();
+    if (data->n_examples > 0) {
+      if (bayesmachine->trainers_measurers)
+        bayesmachine->trainers[c]->train(data,bayesmachine->trainers_measurers[c]);
+      else
+        bayesmachine->trainers[c]->train(data,NULL);
+    } else {
+      warning("BayesClassifier: there was no examples to train class %d",c);
+    }
+    data->popSubset();
+  }
+
+  if (measurers) {
+    test(measurers);
+  }
+}
+
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/BayesClassifier.h work/main.d/Torch-3/distributions/BayesClassifier.h
--- tmp/Torch-3/distributions/BayesClassifier.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/BayesClassifier.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,73 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                and Bison Ravi (francois.belisle@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef BAYES_CLASSIFIER_INC
+#define BAYES_CLASSIFIER_INC
+
+
+#include "Trainer.h"
+#include "BayesClassifierMachine.h"
+
+namespace Torch {
+
+/** A multi class bayes classifier -- maximizes the likelihood of each class
+    separately using a trainer for distribution. When testing, the predicted 
+    class corresponds to the trainer giving the maximum output, weighted by
+    its prior probability.
+ 
+    @author Samy Bengio (bengio@idiap.ch)
+    @author Bison Ravi (francois.belisle@idiap.ch)
+*/
+class BayesClassifier : public Trainer
+{
+  public:
+    
+    /// the bayes machine
+    BayesClassifierMachine* bayesmachine; 
+    
+    /// the number of different classes
+    int n_classes;
+    
+    /// all the example indices of each class.
+    int** classes; 
+    ///the number of examples per class.
+    int* classes_n; 
+
+    /// you need to define a BayesClassifierMachine to use this class
+    BayesClassifier( BayesClassifierMachine* );
+    virtual ~BayesClassifier();
+
+    virtual void train( DataSet *data, MeasurerList *measurers);
+
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/BayesClassifierMachine.cc work/main.d/Torch-3/distributions/BayesClassifierMachine.cc
--- tmp/Torch-3/distributions/BayesClassifierMachine.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/BayesClassifierMachine.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,101 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                and Bison Ravi (francois.belisle@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "BayesClassifierMachine.h"
+
+namespace Torch {
+
+BayesClassifierMachine::BayesClassifierMachine(EMTrainer** trainers_, int n_trainers_, MeasurerList** trainers_measurers_, ClassFormat* class_format_,real* log_priors_)
+{
+  allocated_log_priors = false;
+
+  trainers = trainers_;
+  n_trainers = n_trainers_;
+  trainers_measurers = trainers_measurers_;
+  class_format = class_format_;
+
+  log_probabilities = new(allocator) Sequence(1,n_trainers);
+
+  //if we are not given any log_prior class probabilities, 
+  //then we will assume training set proportions.
+  
+  if(log_priors_ != NULL)
+    log_priors = log_priors_;
+  else {
+    allocated_log_priors = true;
+    log_priors = (real*) allocator->alloc (n_trainers * sizeof(real));
+    //as a first approximation
+    for(int i = 0;i < n_trainers;i++)
+      log_priors[i] = -log((real)n_trainers);
+  }
+
+  n_outputs = class_format->getOutputSize();
+  outputs = new(allocator)Sequence(1,n_outputs);
+}
+ 
+BayesClassifierMachine::~BayesClassifierMachine()
+{
+}
+
+void BayesClassifierMachine::forward(Sequence *inputs)
+{
+
+  for(int trainer = 0;trainer < n_trainers;trainer++) {
+    trainers[trainer]->machine->forward(inputs);
+    log_probabilities->frames[0][trainer] = 
+      trainers[trainer]->distribution->log_probability + log_priors[trainer];
+  }
+  //transform the output from one_hot representation to class_format
+  class_format->fromOneHot(outputs->frames[0],log_probabilities->frames[0]);
+}
+
+void BayesClassifierMachine::reset()
+{
+/* I think this is not necessary as it is done in the train method...
+  for(int i = 0;i < n_trainers;i++)
+    trainers[i]->machine->reset();
+*/
+}
+
+void BayesClassifierMachine::loadXFile(XFile* file)
+{
+  for(int i = 0;i < n_trainers;i++)
+    trainers[i]->loadXFile(file);
+}
+
+void BayesClassifierMachine::saveXFile(XFile* file)
+{
+  for(int i = 0;i < n_trainers;i++)
+    trainers[i]->saveXFile(file);
+}
+
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/BayesClassifierMachine.h work/main.d/Torch-3/distributions/BayesClassifierMachine.h
--- tmp/Torch-3/distributions/BayesClassifierMachine.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/BayesClassifierMachine.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,96 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                and Bison Ravi (francois.belisle@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef BAYES_CLASSIFIER_MACHINE_INC
+#define BAYES_CLASSIFIER_MACHINE_INC
+
+#include "Machine.h"
+#include "EMTrainer.h"
+#include "ClassFormat.h"
+
+namespace Torch {
+
+/** BayesClassifierMachine is the machine used by the #BayesClassifier#
+    trainer to perform a Bayes Classification using different distributions.
+    The output corresponds to the class that is the most probable
+    (using prior AND posterior information).
+
+    @author Samy Bengio (bengio@idiap.ch)
+    @author Bison Ravi (francois.belisle@idiap.ch)
+ */
+class BayesClassifierMachine : public Machine
+{
+  public:
+    
+    /// the number of classes corresponds to the number of #Trainer#
+    int n_trainers; 
+
+    /// the number of outputs in this machine
+    int n_outputs; 
+
+    /// the actual trainers (EMTrainer since we are training distributions).
+    EMTrainer** trainers; 
+
+    /** the log_prior probabilities of each class. default: log_priors are
+        taken as the log of the proportions in the training set.
+    */
+    real* log_priors; 
+    
+		/// it contains the log posterior probability plus the log prior of the class.
+		Sequence* log_probabilities;
+
+    /// used to know if log_priors where given or allocated
+    bool allocated_log_priors;
+
+    /// the class format of the output
+    ClassFormat* class_format;
+
+    /// the measurers for each individual trainer
+    MeasurerList** trainers_measurers; 
+
+    /** creates a machine for BayesClassifier trainers, given a vector of
+        trainers (one per class), an associate measurer for each trainer,
+        a class_format that explains how the classes are coded, and an eventual
+        vector (of size #n_trainers_#) containing the log of the class priors.
+    */
+    BayesClassifierMachine( EMTrainer**, int n_trainers_, MeasurerList** trainers_measurers_ , ClassFormat* class_format_, real* log_priors_=NULL);
+    virtual ~BayesClassifierMachine();
+
+    /** definition of virtual functions of #Machine# */
+    virtual void forward(Sequence *inputs);
+    virtual void reset();
+    virtual void loadXFile( XFile* );
+    virtual void saveXFile( XFile* );
+
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/DiagonalGMM.cc work/main.d/Torch-3/distributions/DiagonalGMM.cc
--- tmp/Torch-3/distributions/DiagonalGMM.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/DiagonalGMM.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,425 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "DiagonalGMM.h"
+#include "MeanVarNorm.h"
+#include "log_add.h"
+#include "Random.h"
+
+namespace Torch {
+
+DiagonalGMM::DiagonalGMM(int n_inputs_, int n_gaussians_, EMTrainer* initial_kmeans_trainer_) : Distribution(n_inputs_,(n_inputs_*n_gaussians_)*2+n_gaussians_)
+{
+  n_gaussians = n_gaussians_;
+  initial_kmeans_trainer = initial_kmeans_trainer_;
+  
+  initial_kmeans_trainer_measurers = NULL;
+
+  var_threshold = (real*)allocator->alloc(sizeof(real)*n_inputs);
+  for (int i=0;i<n_inputs;i++)
+    var_threshold[i] = 1e-10; 
+
+  addOOption("initial kmeans trainer measurers", (Object**) &initial_kmeans_trainer_measurers, NULL, "initial kmeans trainer measurers");
+  addROption("prior weights", &prior_weights , 1e-3, "minimum weights for each gaussians");
+
+  log_probabilities_g = new(allocator)Sequence(1,n_gaussians);
+  real* p = (real*)params->data[0];
+  real* dp = (real*)der_params->data[0];
+  log_weights = p;
+  dlog_weights = dp;
+  p += n_gaussians;
+  dp += n_gaussians;
+  means = (real**)allocator->alloc(sizeof(real*)*n_gaussians);
+  dmeans = (real**)allocator->alloc(sizeof(real*)*n_gaussians);
+  var = (real**)allocator->alloc(sizeof(real*)*n_gaussians);
+  dvar = (real**)allocator->alloc(sizeof(real*)*n_gaussians);
+  means_acc = (real**)allocator->alloc(sizeof(real*)*n_gaussians);
+  var_acc = (real**)allocator->alloc(sizeof(real*)*n_gaussians);
+  weights_acc = (real*)allocator->alloc(sizeof(real)*n_gaussians);
+  minus_half_over_var = (real**)allocator->alloc(sizeof(real*)*n_gaussians);
+  for (int i=0;i<n_gaussians;i++) {
+    means[i] = p;
+    dmeans[i] = dp;
+    p += n_inputs;
+    dp += n_inputs;
+    var[i] = p;
+    dvar[i] = dp;
+    p += n_inputs;
+    dp += n_inputs;
+    means_acc[i] = (real*)allocator->alloc(sizeof(real)*n_inputs);
+    var_acc[i] = (real*)allocator->alloc(sizeof(real)*n_inputs);
+    minus_half_over_var[i] = (real*)allocator->alloc(sizeof(real)*n_inputs);
+  }
+  sum_log_var_plus_n_obs_log_2_pi = (real*)allocator->alloc(sizeof(real)*n_gaussians);
+	
+	best_gauss = -1;
+  best_gauss_per_frame = new(allocator)Sequence(1,1);
+}
+
+void DiagonalGMM::setVarThreshold(real* var_threshold_){
+  for (int i=0;i<n_inputs;i++)
+    var_threshold[i] = var_threshold_[i];
+}
+
+void DiagonalGMM::reset(){
+  // initialize randomly
+  // first the weights
+  if (!initial_kmeans_trainer) {
+    real sum = 0.;
+    for (int i=0;i<n_gaussians;i++) {
+      log_weights[i] = Random::boundedUniform(0.1,1);
+      sum += log_weights[i];
+    }
+    for (int i=0;i<n_gaussians;i++) {
+      log_weights[i] = log(log_weights[i]/sum);
+    }
+
+    // then the means and variances
+    for (int i=0;i<n_gaussians;i++) {
+      for (int j=0;j<n_inputs;j++) {
+        means[i][j] = Random::boundedUniform(0,1);
+        var[i][j] = Random::boundedUniform(var_threshold[j],var_threshold[j]*10);
+      }
+    }
+  }
+}
+
+
+void DiagonalGMM::setDataSet(DataSet* data_)
+{
+  // here, initialize the parameters somehow...
+  if (initial_kmeans_trainer) {
+      initial_kmeans_trainer->train(data_,initial_kmeans_trainer_measurers);
+      params->copy(initial_kmeans_trainer->distribution->params);
+  }
+  //check variance flooring
+  for (int i=0;i<n_gaussians;i++) {
+    real* p_var_i = var[i];
+    for (int j=0;j<n_inputs;j++,p_var_i++)
+      if(*p_var_i < var_threshold[j])
+        *p_var_i = var_threshold[j];
+  }
+  // check the weights
+  real log_sum = LOG_ZERO;
+  for (int i=0;i<n_gaussians;i++)
+    log_sum = logAdd(log_sum,log_weights[i]);
+  for (int i=0;i<n_gaussians;i++)
+    log_weights[i] -= log_sum;
+}
+
+void DiagonalGMM::eMSequenceInitialize(Sequence* inputs)
+{
+  if (!inputs)
+    return;
+	best_gauss_per_frame->resize(inputs->n_frames);
+  log_probabilities_g->resize(inputs->n_frames);
+  log_probabilities->resize(inputs->n_frames);
+}
+
+void DiagonalGMM::display()
+{
+  for(int i=0;i<n_gaussians;i++){
+    printf("Mixture %d %.3g\n",i+1,exp(log_weights[i]));
+    printf("Mean %d\n",i);
+    for(int j=0;j<n_inputs;j++){
+       printf("%.3g ",means[i][j]);
+    }
+    printf("\nVar\n");
+    for(int j=0;j<n_inputs;j++){
+       printf("%.3g ",var[i][j]);
+    }
+    printf("\n"); 
+ }
+}
+
+void DiagonalGMM::sequenceInitialize(Sequence* inputs)
+{
+  // initialize the accumulators to 0 and compute pre-computed value
+  eMSequenceInitialize(inputs);
+  for (int i=0;i<n_gaussians;i++) {
+    real *sum = &sum_log_var_plus_n_obs_log_2_pi[i];
+    *sum = n_inputs * LOG_2_PI;
+    real *mh_i = minus_half_over_var[i];
+    real *v = var[i];
+    real *vt = var_threshold;
+    for (int j=0;j<n_inputs;j++,vt++) {
+      if (*v < *vt)
+        *v = *vt;
+      *mh_i++ = -0.5 / *v;
+      *sum += log(*v++);
+    }
+    *sum *= -0.5;
+  }
+}
+
+void DiagonalGMM::generateSequence(Sequence* sequence)
+{
+  for(int i=0;i<sequence->n_frames;i++)
+    generateObservation(sequence->frames[i]);
+}
+
+void DiagonalGMM::generateObservation(real* observation)
+{
+  real v_tot,v_partial;
+  v_tot = Random::uniform();
+  v_partial = 0.;
+  real* lw = log_weights; 
+  int j;
+  for (j=0;j<n_gaussians;j++) {
+    v_partial += exp(*lw++);
+    if (v_partial > v_tot) break;
+  }
+  if(j>=n_gaussians)
+    j = n_gaussians - 1;
+  real* v = var[j];
+  real* m = means[j];
+  real* obs = observation;
+
+  for (int i=0;i<n_inputs;i++) {
+    *obs++ = Random::normal(*m++, sqrt(*v++));
+  }
+}
+
+
+real DiagonalGMM::frameLogProbabilityOneGaussian(int g, real *inputs)
+{
+  real* means_g = means[g];
+  real* mh_g = minus_half_over_var[g];
+  real sum_xmu = 0.;
+  real *x = inputs;
+  for(int j = 0; j < n_inputs; j++) {
+    real xmu = (*x++ - *means_g++);
+    sum_xmu += xmu*xmu * *mh_g++;
+  }
+  real lp = sum_xmu + sum_log_var_plus_n_obs_log_2_pi[g];
+  return lp;
+}
+
+
+real DiagonalGMM::viterbiFrameLogProbability(int t, real *inputs)
+{
+  real *p_log_w = log_weights;
+  real *lpg = log_probabilities_g->frames[t];
+  real max_lpg = LOG_ZERO;
+  real max_lp = LOG_ZERO;
+  real lpg_w = 0;
+  for (int i=0;i<n_gaussians;i++,lpg++) {
+    *lpg = frameLogProbabilityOneGaussian(i, inputs);
+    lpg_w = *lpg + *p_log_w++;
+    if(lpg_w > max_lpg){
+			max_lpg = lpg_w;
+			best_gauss = i;
+     max_lp = *lpg;
+		 }
+  }
+  log_probabilities->frames[t][0] = max_lp;
+	best_gauss_per_frame->frames[t][0] = (real)best_gauss;
+  return max_lp;
+}
+
+real DiagonalGMM::frameLogProbability(int t, real *inputs)
+{
+  real *p_log_w = log_weights;
+  real *lpg = log_probabilities_g->frames[t];
+  real log_prob = LOG_ZERO;
+  for (int i=0;i<n_gaussians;i++) {
+    *lpg = frameLogProbabilityOneGaussian(i, inputs);
+    log_prob = logAdd(log_prob, *lpg++ + *p_log_w++);
+  }
+  log_probabilities->frames[t][0] = log_prob;
+  return log_prob;
+}
+
+void DiagonalGMM::frameViterbiAccPosteriors(int t, real *inputs, real log_posterior)
+{
+  real *p_weights_acc = weights_acc;
+  real *lp_i = log_probabilities_g->frames[t];
+  real *log_w_i = log_weights;
+  real max_lpg = LOG_ZERO;
+  int best_g = 0;
+  //findmax
+  for (int i=0;i<n_gaussians;i++) {
+    real post_i =  *log_w_i++ + *lp_i++;
+    if(post_i > max_lpg){
+      best_g = i;
+      max_lpg = post_i;
+    }
+  }
+  p_weights_acc[best_g] += 1;
+  real* means_acc_i = means_acc[best_g];
+  real* var_acc_i = var_acc[best_g];
+  real *x = inputs;
+  for(int j = 0; j < n_inputs; j++) {
+    *var_acc_i++ +=  *x * *x;
+    *means_acc_i++ +=  *x++;
+  }
+}
+
+void DiagonalGMM::frameEMAccPosteriors(int t, real *inputs, real log_posterior)
+{
+  real log_prob = log_probabilities->frames[t][0];
+  real *p_weights_acc = weights_acc;
+  real *lp_i = log_probabilities_g->frames[t];
+  real *log_w_i = log_weights;
+  for (int i=0;i<n_gaussians;i++) {
+    real post_i = exp(log_posterior + *log_w_i++ + *lp_i++ - log_prob);
+    *p_weights_acc++ += post_i;
+    real* means_acc_i = means_acc[i];
+    real* var_acc_i = var_acc[i];
+    real *x = inputs;
+    for(int j = 0; j < n_inputs; j++) {
+      *var_acc_i++ += post_i * *x * *x;
+      *means_acc_i++ += post_i * *x++;
+    }
+  }
+}
+
+void DiagonalGMM::eMUpdate()
+{
+  // first the gaussians
+  real* p_weights_acc = weights_acc;
+  for (int i=0;i<n_gaussians;i++,p_weights_acc++) {
+    if (*p_weights_acc == 0) {
+      warning("Gaussian %d of GMM is not used in EM",i);
+    } else {
+      real* p_means_i = means[i];
+      real* p_var_i = var[i];
+      real* p_means_acc_i = means_acc[i];
+      real* p_var_acc_i = var_acc[i];
+      for (int j=0;j<n_inputs;j++) {
+        *p_means_i = *p_means_acc_i++ / *p_weights_acc;
+        real v = *p_var_acc_i++ / *p_weights_acc - *p_means_i * *p_means_i++;
+        *p_var_i++ = v >= var_threshold[j] ? v : var_threshold[j];
+      }
+    }
+  }
+  // then the weights
+  real sum_weights_acc = 0;
+  p_weights_acc = weights_acc;
+  for (int i=0;i<n_gaussians;i++)
+    sum_weights_acc += *p_weights_acc++;
+  real *p_log_weights = log_weights;
+  real log_sum = log(sum_weights_acc);
+  p_weights_acc = weights_acc;
+  for (int i=0;i<n_gaussians;i++)
+    *p_log_weights++ = log(*p_weights_acc++) - log_sum;
+}
+
+void DiagonalGMM::update()
+{
+  // normalize log_weights
+  real log_sum = LOG_ZERO;
+  for (int i=0;i<n_gaussians;i++)
+    log_sum = logAdd(log_sum,log_weights[i]);
+  for (int i=0;i<n_gaussians;i++)
+    log_weights[i] -= log_sum;
+}
+
+void DiagonalGMM::eMIterInitialize()
+{
+  // initialize the accumulators to 0 and compute pre-computed value
+  for (int i=0;i<n_gaussians;i++) {
+    real *pm = means_acc[i];
+    real *ps = var_acc[i];
+    real *v = var[i];
+    real *sum = &sum_log_var_plus_n_obs_log_2_pi[i];
+    *sum = n_inputs * LOG_2_PI;
+    real *mh_i = minus_half_over_var[i];
+    for (int j=0;j<n_inputs;j++) {
+      *pm++ = 0.;
+      *ps++ = 0.;
+      *mh_i++ = -0.5 / *v;
+      *sum += log(*v++);
+    }
+    *sum *= -0.5;
+    weights_acc[i] = prior_weights;
+  }
+}
+
+void DiagonalGMM::iterInitialize()
+{
+}
+
+void DiagonalGMM::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  real log_prob = log_probabilities->frames[t][0];
+  real *lp_i = log_probabilities_g->frames[t];
+  real *lw = log_weights;
+  real* dlw = dlog_weights;
+  for (int i=0;i<n_gaussians;i++,lw++,lp_i++) {
+    real post_i =  *alpha_ * exp(*lw + *lp_i - log_prob);
+    *dlw++ += post_i;
+    real *dlw2 = dlog_weights;
+    real *lw2 = log_weights;
+    for (int j=0;j<n_gaussians;j++) {
+      *dlw2++ -= post_i * exp(*lw2++);
+    }
+    real* obs = f_inputs;
+    real* means_i = means[i];
+    real* dmeans_i = dmeans[i];
+    real* var_i = var[i];
+    real* dvar_i = dvar[i];
+    for (int j=0;j<n_inputs;j++,var_i++,obs++,means_i++,dmeans_i++,dvar_i++) {
+      real xmuvar = (*obs - *means_i) / *var_i;
+      //real xmuvar = (*obs - *means_i);
+      real dm = post_i * 2. * xmuvar;
+      *dmeans_i += dm;
+      *dvar_i += post_i * 0.5 * (xmuvar*xmuvar - 1./ *var_i);
+    }
+  }
+}
+
+void DiagonalGMM::frameDecision(int t, real *decision)
+{
+  real *obs = decision;
+  for (int i=0;i<n_inputs;i++) {
+    *obs++ = 0;
+  }
+  real *lw = log_weights;
+  for (int i=0;i<n_gaussians;i++) {
+    obs = decision;
+    real *means_i = means[i];
+    real w = exp(*lw++);
+    for (int j=0;j<n_inputs;j++) {
+      *obs++ += w * *means_i++;
+    }
+  }
+}
+
+void DiagonalGMM::setNGaussians(int n_gaussians_)
+{
+  n_gaussians = n_gaussians_;
+}
+
+DiagonalGMM::~DiagonalGMM()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/DiagonalGMM.h work/main.d/Torch-3/distributions/DiagonalGMM.h
--- tmp/Torch-3/distributions/DiagonalGMM.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/DiagonalGMM.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,184 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DIAGONAL_GMM_INC
+#define DIAGONAL_GMM_INC
+
+#include "Distribution.h"
+#include "EMTrainer.h"
+
+namespace Torch {
+
+/** This class can be used to model Diagonal Gaussian Mixture Models.
+    They can be trained using either EM (with EMTrainer) or gradient descent
+    (with GMTrainer).
+
+    @author Samy Bengio (bengio@idiap.ch)
+    @author Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+*/
+class DiagonalGMM : public Distribution
+{
+
+  public:
+    /// number of Gaussians in the mixture
+    int n_gaussians;
+
+    /** prior weights of the Gaussians, used in EM to give 
+        a small prior on each Gaussian
+    */
+    real prior_weights;
+
+    /** optional initializations
+        if nothing is given, then random calling by reset(), 
+				at your own risks or model loaded by the user...
+        one can give a initial trainer containing a kmeans
+    */
+    EMTrainer* initial_kmeans_trainer;
+
+    /// as well as a measurer of this trainer
+    MeasurerList* initial_kmeans_trainer_measurers;
+
+    /// the pointers to the parameters
+    real* log_weights;
+    real** means;
+    real** var;
+
+    /// the pointers to the derivative of the parameters
+    real* dlog_weights;
+    real** dmeans;
+    real** dvar;
+
+    /// this contains the minimal value of each variance
+    real* var_threshold;
+
+    /// for each frame, for each gaussian, keep its log probability
+    Sequence* log_probabilities_g;
+
+
+		/// gaussian that maximize the observed frame
+		int best_gauss;
+
+
+		/// gaussian that maximize the observed frame
+		Sequence* best_gauss_per_frame; 
+
+    /** in order to faster the computation, we can do some "pre-computation"
+        pre-computed sum_log_var + n_obs * log_2_pi
+    */
+    real* sum_log_var_plus_n_obs_log_2_pi;
+
+    /// pre-computed -0.5 / var
+    real** minus_half_over_var;
+
+    /// accumulators for EM
+    real** means_acc;
+    real** var_acc;
+    real*  weights_acc;
+
+    ///
+		DiagonalGMM(int n_inputs_, int n_gaussians_, EMTrainer* initial_kmeans_trainer_ = NULL);
+
+    void generateObservation(real* inputs_);
+    void generateSequence(Sequence* sequence);
+
+		/**
+       This methods have to call by the user to initialized the
+			 random parameters.
+		*/
+		virtual void reset();
+
+
+		/**
+		   If the KmeanTrainer has been given to the constructor, Kmeans algorithm
+			 is perform.
+		*/
+		virtual void setDataSet(DataSet* data_);
+
+		/**
+		   Set the minimum value for the variances
+		*/
+		virtual void setVarThreshold(real* var_threshold_);
+
+    virtual void display();
+
+    /** Methods used to initialize the model at the beginning of each
+        EM iteration
+    */
+    virtual void eMIterInitialize();
+
+    /** Methods used to initialize the model at the beginning of each
+        gradient descent iteration
+    */
+    virtual void iterInitialize();
+
+    /// Returns the log probability of a frame of a sequence
+    virtual real frameLogProbability(int t, real *inputs);
+    
+		/// Returns the log probability of a frame of a sequence on viterbi mode
+		virtual real viterbiFrameLogProbability(int t, real *inputs);
+
+    /// this method returns the log probability of the "g" Gaussian
+    virtual real frameLogProbabilityOneGaussian(int g, real *inputs);
+
+    /** Methods used to initialize the model at the beginning of each
+        example during gradient descent training
+    */
+    virtual void sequenceInitialize(Sequence* inputs);
+
+    /** Methods used to initialize the model at the beginning of each
+        example during EM training
+    */
+    virtual void eMSequenceInitialize(Sequence* inputs);
+    
+		/// The backward step of EM for a frame
+    virtual void frameEMAccPosteriors(int t, real *inputs, real log_posterior);
+    
+		/// The backward step of Viterbi for a frame
+		virtual void frameViterbiAccPosteriors(int t, real *inputs, real log_posterior);
+    
+		/// The update after each iteration for EM
+    virtual void eMUpdate();
+		/// The update after each iteration for gradient
+    virtual void update();
+
+    /// Same as backward, but for one frame only
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+    
+		/// Returns the expected value in #decision#
+    virtual void frameDecision(int t, real *decision);
+
+    virtual void setNGaussians(int n_gaussians_);
+
+    virtual ~DiagonalGMM();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/Distribution.cc work/main.d/Torch-3/distributions/Distribution.cc
--- tmp/Torch-3/distributions/Distribution.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/Distribution.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,186 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "Distribution.h"
+#include "log_add.h"
+
+namespace Torch {
+
+Distribution::Distribution(int n_inputs_,int n_params_) : GradientMachine(n_inputs_,1,n_params_)
+{
+  log_probabilities = new(allocator)Sequence(1,n_outputs);
+  outputs->resize(n_outputs);
+}
+
+
+real Distribution::logProbability(Sequence *inputs)
+{
+  real ll = 0;
+  for (int i=0;i<inputs->n_frames;i++) {
+    ll += frameLogProbability(i,inputs->frames[i]);
+  }
+  return ll;
+}
+
+real Distribution::viterbiLogProbability(Sequence *inputs)
+{
+  real ll = 0;
+  for (int i=0;i<inputs->n_frames;i++) {
+    ll += viterbiFrameLogProbability(i,inputs->frames[i]);
+  }
+  return ll;
+}
+
+real Distribution::viterbiFrameLogProbability(int t, real *inputs)
+{
+	return	frameLogProbability(t, inputs);
+}
+
+real Distribution::frameLogProbability(int t, real *inputs)
+{
+  return LOG_ZERO;
+}
+
+void Distribution::frameGenerate(int t, real *inputs)
+{
+}
+
+void Distribution::iterInitialize()
+{
+  eMIterInitialize();
+}
+
+void Distribution::eMIterInitialize()
+{
+}
+
+void Distribution::eMSequenceInitialize(Sequence* inputs)
+{
+  log_probabilities->resize(inputs->n_frames);
+}
+
+void Distribution::sequenceInitialize(Sequence* inputs)
+{
+  log_probabilities->resize(inputs->n_frames);
+}
+
+void Distribution::eMAccPosteriors(Sequence *inputs, real log_posterior)
+{
+  for (int i=0;i<inputs->n_frames;i++) {
+    frameEMAccPosteriors(i, inputs->frames[i], log_posterior);
+  }
+}
+
+void Distribution::viterbiAccPosteriors(Sequence *inputs, real log_posterior)
+{
+  for (int i=0;i<inputs->n_frames;i++) {
+    frameViterbiAccPosteriors(i, inputs->frames[i], log_posterior);
+  }
+}
+
+void Distribution::frameEMAccPosteriors(int t, real *inputs, real log_posterior)
+{
+}
+
+void Distribution::frameViterbiAccPosteriors(int t, real *inputs, real log_posterior)
+{
+}
+
+void Distribution::eMUpdate()
+{
+}
+
+void Distribution::update()
+{
+}
+
+void Distribution::decode(Sequence *inputs)
+{
+}
+
+void Distribution::forward(Sequence *inputs)
+{
+ sequenceInitialize(inputs);
+ log_probability = logProbability(inputs);
+ outputs->frames[0][0] = log_probability;
+}
+
+
+void Distribution::eMForward(Sequence *inputs)
+{
+  eMSequenceInitialize(inputs);
+  log_probability = logProbability(inputs);
+}
+
+void Distribution::viterbiForward(Sequence *inputs)
+{
+   eMSequenceInitialize(inputs);
+   log_probability = viterbiLogProbability(inputs);
+}
+
+void Distribution::backward(Sequence *inputs, Sequence *alpha)
+{
+  for (int i=0;i<inputs->n_frames;i++) {
+    frameBackward(i, inputs->frames[i], NULL, NULL, alpha->frames[0]);
+  }
+}
+
+void Distribution::viterbiBackward(Sequence *inputs, Sequence *alpha)
+{
+  backward(inputs,alpha);
+}
+
+
+void Distribution::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+}
+
+void Distribution::loadXFile(XFile *file)
+{
+  params->loadXFile(file);
+  eMIterInitialize();
+}
+
+void Distribution::decision(Sequence* decision)
+{
+  for (int i=0;i<decision->n_frames;i++) {
+    frameDecision(i,decision->frames[i]);
+  }
+}
+
+void Distribution::frameDecision(int t, real *decision)
+{
+}
+
+Distribution::~Distribution()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/Distribution.h work/main.d/Torch-3/distributions/Distribution.h
--- tmp/Torch-3/distributions/Distribution.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/Distribution.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,128 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DISTRIBUTION_INC
+#define DISTRIBUTION_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** This class is designed to handle generative distribution models
+    such as Gaussian Mixture Models and Hidden Markov Models. As 
+    distribution inherits from GradientMachine, they can be trained 
+    by gradient descent or by Expectation Maximization (EM) or even
+    Viterbi.
+
+    Note that the output of a distribution is the negative log likelihood.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class Distribution : public GradientMachine
+{
+  public:
+
+    /// the log likelihood
+    real log_probability;
+
+    /// the log likelihood for each frame when available
+    Sequence* log_probabilities;
+
+    /// 
+    Distribution(int n_inputs_,int n_params_=0);
+
+    /// Returns the log probability of a sequence represented by #inputs#
+    virtual real logProbability(Sequence* inputs);
+    /// Returns the viterbi score of a sequence represented by #inputs#
+    virtual real viterbiLogProbability(Sequence* inputs);
+    /// Returns the log probability of a frame of a sequence
+    virtual real frameLogProbability(int t, real *f_inputs);
+    /// Returns the log probability of a frame of a sequence on viterbi mode
+		virtual real viterbiFrameLogProbability(int t, real *f_inputs);
+    virtual void frameGenerate(int t, real *inputs);
+
+    /** Methods used to initialize the model at the beginning of each
+        EM iteration
+    */
+    virtual void eMIterInitialize();
+    /** Methods used to initialize the model at the beginning of each
+        gradient descent iteration
+    */
+    virtual void iterInitialize();
+    /** Methods used to initialize the model at the beginning of each
+        example during EM training
+    */
+    virtual void eMSequenceInitialize(Sequence* inputs);
+    /** Methods used to initialize the model at the beginning of each
+        example during gradient descent training
+    */
+    virtual void sequenceInitialize(Sequence* inputs);
+    /// The backward step of EM for a sequence
+    virtual void eMAccPosteriors(Sequence *inputs, real log_posterior);
+    /// The backward step of EM for a frame
+    virtual void frameEMAccPosteriors(int t, real *f_inputs, real log_posterior);
+    /// The backward step of Viterbi learning for a sequence
+    virtual void viterbiAccPosteriors(Sequence *inputs, real log_posterior);
+    /// The backward step of Viterbi for a frame
+    virtual void frameViterbiAccPosteriors(int t, real *f_inputs, real log_posterior);
+    /// The update after each iteration for EM
+    virtual void eMUpdate();
+    /// The update after each gradient iteration
+    virtual void update();
+
+    /// For some distribution like SpeechHMM, decodes the most likely path
+    virtual void decode(Sequence *inputs);
+
+    virtual void forward(Sequence *inputs);
+
+
+    /// Same as forward, but for EM
+    virtual void eMForward(Sequence *inputs);
+    /// Same as forward, but for Viterbi
+    virtual void viterbiForward(Sequence *inputs);
+    virtual void backward(Sequence *inputs, Sequence *alpha);
+    /// Same as backward, but for one frame only
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+    /// Same as backward, but for Viterbi 
+    virtual void viterbiBackward(Sequence *inputs, Sequence *alpha);
+    virtual void loadXFile(XFile *file);
+
+    /// Returns the decision of the distribution
+    /// decision is expectation for regression, class likelihoods for classif
+    virtual void decision(Sequence* decision);
+    /// Returns the decision of a frame of a sequence
+    virtual void frameDecision(int t, real *decision);
+
+    virtual ~Distribution();
+};
+
+
+}
+
+#endif
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/EMTrainer.cc work/main.d/Torch-3/distributions/EMTrainer.cc
--- tmp/Torch-3/distributions/EMTrainer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/EMTrainer.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,243 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "EMTrainer.h"
+#include "log_add.h"
+
+namespace Torch {
+
+EMTrainer::EMTrainer(Distribution *distribution_) : Trainer(distribution_)
+{
+  distribution = distribution_;
+
+  addROption("end accuracy", &end_accuracy, 0.0001,"end accuracy");
+  addIOption("max iter", &max_iter, 100, "maximum number of iterations");
+  addBOption("viterbi", &viterbi, false, "Viterbi training");
+}
+
+void EMTrainer::train(DataSet* data, MeasurerList *measurers)
+{
+  int iter = 0;
+  int n_train = data->n_examples;
+
+  real prev_nll = INF;
+  real nll = INF;
+
+  DataSet **datas;
+  Measurer ***mes;
+  int *n_mes;
+  int n_datas;
+
+  machine->setDataSet(data);
+  
+	message("EMTrainer: training");
+
+  if(measurers)
+  {
+    for(int i = 0; i < measurers->n_nodes; i++)
+      measurers->nodes[i]->reset();
+  }
+
+  Allocator *allocator_ = extractMeasurers(measurers, data, &datas, &mes, &n_mes, &n_datas);
+
+  while (1) {
+    distribution->eMIterInitialize();
+    nll = 0;
+    int tot_n_frames = 0;
+    for (int t=0;t<n_train;t++) {
+      data->setExample(t);
+
+      if (viterbi) {
+        distribution->viterbiForward(data->inputs);
+        nll -= distribution->log_probability;
+        distribution->viterbiAccPosteriors(data->inputs,LOG_ONE);
+      } else {
+        distribution->eMForward(data->inputs);
+        nll -= distribution->log_probability;
+        distribution->eMAccPosteriors(data->inputs,LOG_ONE);
+      }
+      tot_n_frames += data->inputs->n_frames;
+
+      for(int i = 0; i < n_mes[0]; i++)
+        mes[0][i]->measureExample();
+    }
+    nll /= tot_n_frames;
+    
+    distribution->eMUpdate();
+
+    for(int i = 0; i < n_mes[0]; i++)
+      mes[0][i]->measureIteration();
+
+    // for each supplementary dataset given, simply compute
+    // test llr (not used for training)
+    for(int julie = 1; julie < n_datas; julie++) {
+      DataSet *dataset = datas[julie];
+
+      for(int t=0;t<dataset->n_examples;t++) {
+        dataset->setExample(t);
+        if (viterbi) {
+          distribution->viterbiForward(dataset->inputs);
+        } else {
+          distribution->eMForward(dataset->inputs);
+        }
+
+        for(int i = 0; i < n_mes[julie]; i++)
+          mes[julie][i]->measureExample();
+      }
+      for(int i = 0; i < n_mes[julie]; i++)
+        mes[julie][i]->measureIteration();
+    }
+
+    // stopping criterion
+    if ((prev_nll == nll) || fabs((prev_nll - nll)/prev_nll) < end_accuracy) {
+      print("\n");
+      break;
+    }
+    prev_nll = nll;
+    print(".");
+    iter++;
+    if ((iter >= max_iter) && (max_iter > 0)) {
+      print("\n");
+      warning("EMTrainer: you have reached the maximum number of iterations");
+      break;
+    }
+  }
+  for(int i=0;i<n_datas;i++) {
+    for(int j=0;j<n_mes[i];j++)
+      mes[i][j]->measureEnd();
+  }
+  delete allocator_;
+}
+
+void EMTrainer::test(MeasurerList *measurers)
+{
+  DataSet **datas;
+  Measurer ***mes;
+  int *n_mes;
+  int n_datas;
+
+  print("# EMTrainer: testing [");
+
+  //message("emtrainer: testing");
+
+  Allocator *allocator_ = extractMeasurers(measurers, NULL, &datas, &mes, &n_mes, &n_datas);
+
+  ////
+  int n_ex = 0;
+  for(int andrea = 0; andrea < n_datas; andrea++)
+    n_ex += datas[andrea]->n_examples;
+  real n_ex_mod = ((n_ex == 0)? 0. : 10.1/((real)n_ex));
+  real ex_curr = 0;
+  real n_dots = 0;
+  ////
+
+  for(int andrea = 0; andrea < n_datas; andrea++)
+  {
+    DataSet *dataset = datas[andrea];
+
+    for(int i = 0; i < n_mes[andrea]; i++)
+      mes[andrea][i]->reset();
+
+    distribution->eMIterInitialize();
+    for(int t = 0; t < dataset->n_examples; t++)
+    {
+      dataset->setExample(t);
+      if (viterbi) {
+        distribution->viterbiForward(dataset->inputs);
+      } else {
+        distribution->eMForward(dataset->inputs);
+      }
+
+      for(int i = 0; i < n_mes[andrea]; i++)
+        mes[andrea][i]->measureExample();
+      if(++ex_curr * n_ex_mod >= (n_dots+1))
+      {
+        if(n_ex < 10)
+          print("_");
+        else
+          print(".");
+        n_dots++;
+      }
+    }
+
+    for(int i = 0; i < n_mes[andrea]; i++)
+      mes[andrea][i]->measureIteration();
+
+    for(int i = 0; i < n_mes[andrea]; i++)
+      mes[andrea][i]->measureEnd();
+  }
+
+  print("]\n");
+  delete allocator_;
+}
+
+void EMTrainer::decode(MeasurerList *measurers)
+{
+  DataSet **datas;
+  Measurer ***mes;
+  int *n_mes;
+  int n_datas;
+
+  message("emtrainer: decoding");
+
+  Allocator *allocator_ = extractMeasurers(measurers, NULL, &datas, &mes, &n_mes, &n_datas);
+
+  for(int andrea = 0; andrea < n_datas; andrea++)
+  {
+    DataSet *dataset = datas[andrea];
+    distribution->setDataSet(dataset);
+
+    for(int i = 0; i < n_mes[andrea]; i++)
+      mes[andrea][i]->reset();
+
+    distribution->eMIterInitialize();
+    for(int t = 0; t < dataset->n_examples; t++)
+    {
+      dataset->setExample(t);
+      distribution->decode(dataset->inputs);
+
+      for(int i = 0; i < n_mes[andrea]; i++)
+        mes[andrea][i]->measureExample();
+    }
+
+    for(int i = 0; i < n_mes[andrea]; i++)
+      mes[andrea][i]->measureIteration();
+
+    for(int i = 0; i < n_mes[andrea]; i++)
+      mes[andrea][i]->measureEnd();
+  }
+
+  delete allocator_;
+}
+
+EMTrainer::~EMTrainer()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/EMTrainer.h work/main.d/Torch-3/distributions/EMTrainer.h
--- tmp/Torch-3/distributions/EMTrainer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/EMTrainer.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,71 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef EMTRAINER_INC
+#define EMTRAINER_INC
+
+#include "Trainer.h"
+#include "Distribution.h"
+
+namespace Torch {
+
+/** This class is used to train any distribution using the EM algorithm.
+    It can also train using the Viterbi training algorithm.
+    
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class EMTrainer : public Trainer
+{
+  public:
+    /// the distribution to train
+    Distribution *distribution;
+    /// the stopping criterion regarding the accuracy for EM
+    real end_accuracy;
+    /// the stopping criterion regarding the number of iterations for EM
+    int max_iter;
+    /// when viterbi is true, use Viterbi training instead of EM training
+    bool viterbi;
+
+    ///
+    EMTrainer(Distribution *distribution_);
+
+    virtual void train(DataSet* data, MeasurerList *measurers);
+    virtual void test(MeasurerList *measurers);
+
+    /** this method computes the most likely path into the distribution.
+        mainly used for sequential distribution such as HMMs.
+    */
+    virtual void decode(MeasurerList *measurers);
+
+    virtual ~EMTrainer();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/HMM.cc work/main.d/Torch-3/distributions/HMM.cc
--- tmp/Torch-3/distributions/HMM.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/HMM.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,564 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "HMM.h"
+#include "FrameSelectorDataSet.h"
+#include "Random.h"
+#include "log_add.h"
+#include "XFile.h"
+
+namespace Torch {
+
+HMM::HMM(int n_states_, Distribution **states_, real** transitions_, int n_shared_states_,Distribution **shared_states_) : Distribution(states_[1]->n_inputs,n_states_*n_states_)
+{
+  n_states = n_states_;
+  states = states_;
+  transitions = transitions_;
+
+  // if given, these represent the "real" states, while "states" are
+  // only pointers to shared_states. note that shared_states should all
+  // exist (not like states which is null for states[0] and states[n_states-1])
+  shared_states = shared_states_;
+  n_shared_states = n_shared_states_;
+  
+  addBOption("initialize", &initialize , true, "initialize the model before training");
+	addBOption("linear segmentation", &linear_segmentation, false, "linear segmentation to initialize the states");
+	addROption("prior transitions", &prior_transitions , 1e-3, "minimum weights for each gaussians");
+  
+  if (n_states > 0) {
+
+    log_transitions = (real**)allocator->alloc(sizeof(real*)*n_states);
+    dlog_transitions = (real**)allocator->alloc(sizeof(real*)*n_states);
+    transitions_acc = (real**)allocator->alloc(sizeof(real*)*n_states);
+    for (int i=1;i<n_states-1;i++) {
+      params->add(states[i]->params);
+      der_params->add(states[i]->der_params);
+    }
+    for (int i=0;i<n_states;i++) {
+      transitions_acc[i] = (real*)allocator->alloc(sizeof(real)*n_states);;
+      log_transitions[i] = ((real*)params->data[0]) + i*n_states;
+      dlog_transitions[i] = ((real*)der_params->data[0]) + i*n_states;
+    }
+    log_probabilities_s = new (allocator)Sequence(1,n_states);
+    log_alpha = new (allocator)Sequence(1,n_states);
+    log_beta = new (allocator)Sequence(1,n_states);
+    arg_viterbi = new (allocator)Sequence(1,n_states);
+    viterbi_sequence = new (allocator)Sequence(1,1);
+  }
+}
+
+void HMM::loadXFile(XFile *file)
+{
+  // first the transitions
+  file->taggedRead(params->data[0], sizeof(real), n_states*n_states,"HMM");
+  for (int i=0;i<n_states;i++)
+    log_transitions[i] = params->data[0] + i*n_states;
+  // then the emissions
+  for (int i=1;i<n_states-1;i++) {
+    states[i]->loadXFile(file);
+  }
+}
+
+void HMM::saveXFile(XFile *file)
+{
+  // first the transitions
+  file->taggedWrite(params->data[0], sizeof(real), n_states*n_states,"HMM");
+  // then the emissions
+  for (int i=1;i<n_states-1;i++) {
+    states[i]->saveXFile(file);
+  }
+}
+
+void HMM::setDataSet(DataSet* data_)
+{
+  if (initialize) {
+    // the emission distributions
+    int* selected_frames = (int*)allocator->alloc(sizeof(int)*1);
+    for (int i=1;i<n_states-1;i++){
+		  FrameSelectorDataSet frame_sel(data_);
+		  int n = data_->n_examples;
+      if (linear_segmentation) {
+        for (int j=0;j<n;j++) {
+			    data_->setExample(j);
+          int n_frames = data_->inputs->n_frames;
+          real n_frames_per_state = (real)n_frames/(n_states-2);
+          int from = (int)((i-1)*n_frames_per_state);
+          int to = (i == n_states-2 ? n_frames : (int)(i*n_frames_per_state));
+          int n_selected_frames = to - from;
+          selected_frames = (int*)allocator->realloc(selected_frames,sizeof(int)*n_selected_frames);
+          int k = 0;
+          for (int l=from;l<to;l++,k++)
+            selected_frames[k] = l;
+          frame_sel.selectInputFrames(j,selected_frames,n_selected_frames);
+        }
+      } else {
+        // select a bootstrap
+        for (int j=0;j<n;j++) {
+			    data_->setExample(j);
+          int n_frames = data_->inputs->n_frames;
+          int n_selected_frames = n_frames;
+          selected_frames = (int*)allocator->realloc(selected_frames,sizeof(int)*n_selected_frames);
+          for (int l=0;l<n_frames;l++)
+            selected_frames[l] = (int)floor(Random::boundedUniform(0,n_frames));
+          frame_sel.selectInputFrames(j,selected_frames,n_selected_frames);
+        }
+      }
+		  states[i]->setDataSet(&frame_sel);
+	  }
+  
+    // for the transitions, re-initialize to initial values given in constructor
+    for (int i=0;i<n_states;i++) {
+      real *p = transitions[i];
+      real *lp = log_transitions[i];
+      for (int j=0;j<n_states;j++,lp++,p++) {
+        if (*p > 0)
+          *lp = log(*p);
+        else
+          *lp = LOG_ZERO;
+      }
+    }
+  } else {
+    // we still need to set the dataset of the emission distributions
+    for (int i=1;i<n_states-1;i++) 
+		  states[i]->setDataSet(data_);
+  }
+}
+
+void HMM::printTransitions(bool real_values, bool transitions_only)
+{
+  print("transitions: %d x %d\n",n_states,n_states);
+  for (int i=0;i<n_states;i++) {
+    for (int j=0;j<n_states;j++) {
+      if (transitions_only) {
+        if (log_transitions[j][i] != LOG_ZERO) {
+          print("%d -> %d = %f\n",i,j,exp(log_transitions[j][i]));
+        }
+      } else if (real_values) {
+        print("%f ",exp(log_transitions[j][i]));
+      } else {
+        print("%d ",(log_transitions[j][i] != LOG_ZERO));
+      }
+    }
+    print("\n");
+  }
+}
+
+void HMM::logAlpha(Sequence* inputs)
+{
+  // first, initialize everything to LOG_ZERO
+  for (int f=0;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      log_alpha->frames[f][i] = LOG_ZERO;
+    }
+  }
+  // case for first frame
+  for (int i=1;i<n_states-1;i++) {
+    if (log_transitions[i][0] != LOG_ZERO)
+      log_alpha->frames[0][i] = log_probabilities_s->frames[0][i] + 
+        log_transitions[i][0];
+  }
+  // other cases
+  for (int f=1;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      for (int j=1;j<n_states-1;j++) {
+        log_alpha->frames[f][i] = logAdd(log_alpha->frames[f][i],
+          log_transitions[i][j] + 
+          log_probabilities_s->frames[f][i] +
+          log_alpha->frames[f-1][j]);
+      }
+    }
+  }
+  // last case
+  log_probability = LOG_ZERO;
+  int f = inputs->n_frames-1;
+  int i = n_states-1;
+  for (int j=1;j<n_states-1;j++) {
+    log_probability = logAdd(log_probability,
+      log_alpha->frames[f][j]+log_transitions[i][j]);
+  }
+}
+
+void HMM::logBeta(Sequence* inputs)
+{
+  // first, initialize everything to LOG_ZERO
+  for (int f=0;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      log_beta->frames[f][i] = LOG_ZERO;
+    }
+  }
+  // case for last frame
+  int f_final = inputs->n_frames-1;
+  for (int i=1;i<n_states-1;i++) {
+      log_beta->frames[f_final][i] = log_transitions[n_states-1][i];
+  }
+  // other cases
+  for (int f=inputs->n_frames-2;f>=0;f--) {
+    for (int i=1;i<n_states-1;i++) {
+      for (int j=1;j<n_states-1;j++) {
+        log_beta->frames[f][j] = logAdd(log_beta->frames[f][j],
+          log_transitions[i][j] +
+          log_probabilities_s->frames[f+1][i] +
+          log_beta->frames[f+1][i]);
+      }
+    }
+  }
+}
+
+void HMM::logViterbi(Sequence* inputs)
+{
+  // first, initialize everything to LOG_ZERO
+  for (int f=0;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      log_alpha->frames[f][i] = LOG_ZERO;
+    }
+  }
+  // case for first frame
+  for (int i=1;i<n_states-1;i++) {
+    real v = log_probabilities_s->frames[0][i] + log_transitions[i][0];
+    if (v > log_alpha->frames[0][i]) {
+      log_alpha->frames[0][i] = v;
+      arg_viterbi->frames[0][i] = 0.0;
+    }
+  }
+  // other cases
+  for (int f=1;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      for (int j=1;j<n_states-1;j++) {
+        real v = log_transitions[i][j] + log_probabilities_s->frames[f][i] +
+          log_alpha->frames[f-1][j];
+        if (v > log_alpha->frames[f][i]) {
+          log_alpha->frames[f][i] = v;
+          arg_viterbi->frames[f][i] = (real)j;
+        }
+      }
+    }
+  }
+  // last case
+  log_probability = LOG_ZERO;
+  int f = inputs->n_frames-1;
+  int i = n_states-1;
+  for (int j=1;j<n_states-1;j++) {
+    real v = log_alpha->frames[f][j]+log_transitions[i][j];
+    if (v > log_probability) {
+      log_probability = v;
+      last_arg_viterbi = j;
+    }
+  }
+  // now recall the state sequence
+  if (log_probability > LOG_ZERO) {
+    viterbi_sequence->frames[inputs->n_frames-1][0] = last_arg_viterbi;
+    for (int f=inputs->n_frames-2;f>=0;f--) {
+      viterbi_sequence->frames[f][0] = (real)(arg_viterbi->frames[f+1][(int)(viterbi_sequence->frames[f+1][0])]);
+    }
+  } else {
+    warning("sequence impossible to train: probably too short for target");
+    for (int f=0;f<inputs->n_frames;f++)
+      viterbi_sequence->frames[f][0] = -1;
+    log_probability = 0;
+  }
+}
+
+void HMM::logProbabilities(Sequence *inputs)
+{
+  if (n_shared_states == 0) {
+    for (int f=0;f<inputs->n_frames;f++) {
+      for (int i=1;i<n_states-1;i++) {
+        log_probabilities_s->frames[f][i] = states[i]->frameLogProbability(f, inputs->frames[f]);
+      }
+    }
+  } else {
+    for (int f=0;f<inputs->n_frames;f++) {
+      for (int i=0;i<n_shared_states;i++) {
+        shared_states[i]->frameLogProbability(f, inputs->frames[f]);
+      }
+      for (int i=1;i<n_states-1;i++) {
+        log_probabilities_s->frames[f][i] = states[i]->log_probabilities->frames[f][0];
+      }
+    }
+  }
+}
+
+real HMM::logProbability(Sequence *inputs)
+{
+  logProbabilities(inputs);
+  logAlpha(inputs);
+	log_probabilities->frames[0][0] = log_probability;
+  return log_probability;
+}
+
+real HMM::viterbiLogProbability(Sequence *inputs)
+{
+  logProbabilities(inputs);
+  logViterbi(inputs);
+	log_probabilities->frames[0][0] = log_probability;
+  return log_probability;
+}
+
+
+void HMM::eMSequenceInitialize(Sequence* inputs)
+{
+	log_probabilities_s->resize(inputs->n_frames);
+	log_alpha->resize(inputs->n_frames);
+	log_beta->resize(inputs->n_frames);
+	arg_viterbi->resize(inputs->n_frames);
+	viterbi_sequence->resize(inputs->n_frames);
+
+	for (int i=1;i<n_states-1;i++)
+		states[i]->eMSequenceInitialize(inputs);
+}
+
+void HMM::sequenceInitialize(Sequence* inputs)
+{
+	log_probabilities_s->resize(inputs->n_frames);
+	log_alpha->resize(inputs->n_frames);
+	log_beta->resize(inputs->n_frames);
+	arg_viterbi->resize(inputs->n_frames);
+	viterbi_sequence->resize(inputs->n_frames);
+
+	for (int i=1;i<n_states-1;i++)
+		states[i]->sequenceInitialize(inputs);
+}
+
+void HMM::eMIterInitialize()
+{
+  for (int i=1;i<n_states-1;i++)
+    states[i]->eMIterInitialize();
+  for (int i=0;i<n_states;i++)
+    for (int j=0;j<n_states;j++)
+      transitions_acc[i][j] = prior_transitions;
+}
+
+void HMM::iterInitialize()
+{
+  for (int i=1;i<n_states-1;i++)
+    states[i]->iterInitialize();
+  for (int i=0;i<n_states;i++)
+    for (int j=0;j<n_states;j++)
+      transitions_acc[i][j] = prior_transitions;
+}
+
+void HMM::eMAccPosteriors(Sequence *inputs, real log_posterior)
+{
+  // compute the beta by backward recursion
+  logBeta(inputs);
+
+  // accumulate the emission and transition posteriors
+  for (int f=0;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      if (log_alpha->frames[f][i] != LOG_ZERO && 
+          log_beta->frames[f][i] != LOG_ZERO) {
+        real log_posterior_i_f = log_posterior + log_alpha->frames[f][i] + 
+          log_beta->frames[f][i] - log_probability;
+        states[i]->frameEMAccPosteriors(f, inputs->frames[f],log_posterior_i_f);
+      }
+    }
+  }
+  for (int f=1;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      real log_emit_i = log_probabilities_s->frames[f][i];
+      for (int j=1;j<n_states-1;j++) {
+        if (log_transitions[i][j] != LOG_ZERO && log_alpha->frames[f-1][j] != LOG_ZERO && log_beta->frames[f][i] != LOG_ZERO && log_emit_i != LOG_ZERO)
+          transitions_acc[i][j] += exp(log_posterior + 
+            log_alpha->frames[f-1][j] + 
+            log_transitions[i][j] + log_emit_i + log_beta->frames[f][i] - 
+            log_probability);
+      }
+    }
+  }
+  // particular case of transitions from initial state
+  for (int j=1;j<n_states-1;j++) {
+    if (log_transitions[j][0] != LOG_ZERO && log_beta->frames[0][j] != LOG_ZERO && log_probabilities_s->frames[0][j] != LOG_ZERO)
+      transitions_acc[j][0] += exp(log_posterior + log_beta->frames[0][j] + 
+        log_probabilities_s->frames[0][j] +
+        log_transitions[j][0] - log_probability);
+  }
+  // particular case of transitions to last state
+  int f = inputs->n_frames-1;
+  int i = n_states-1;
+  for (int j=1;j<n_states-1;j++) {
+    if (log_transitions[i][j] != LOG_ZERO && log_alpha->frames[f][j] != LOG_ZERO)
+      transitions_acc[i][j] += exp(log_posterior + log_alpha->frames[f][j] + 
+        log_transitions[i][j] - log_probability);
+  }
+}
+
+void HMM::viterbiAccPosteriors(Sequence *inputs, real log_posterior)
+{
+  // accumulate the emission and transition posteriors
+  real p = exp(log_posterior);
+  for (int f=0;f<inputs->n_frames;f++) {
+    int i = (int)(viterbi_sequence->frames[f][0]);
+    if (i>=0) {
+      states[i]->frameEMAccPosteriors(f, inputs->frames[f],log_posterior);
+      int j = (int)arg_viterbi->frames[f][i];
+      if (j>0) {
+        transitions_acc[i][j] += p;
+      }
+    }
+  }
+  // attention, il me manque le premier et le dernier arg_viterbi...
+}
+
+void HMM::eMUpdate()
+{
+  // first the states
+  for (int i=1;i<n_states-1;i++) {
+    states[i]->eMUpdate();
+  }
+  // then the transitions;
+  for (int i=0;i<n_states-1;i++) {
+    real log_sum = 0;
+    for (int j=1;j<n_states;j++) {
+      if (log_transitions[j][i] != LOG_ZERO)
+        log_sum += transitions_acc[j][i];
+    }
+    log_sum = log(log_sum);
+    for (int j=0;j<n_states;j++) {
+      if (log_transitions[j][i] != LOG_ZERO) {
+        log_transitions[j][i] = log(transitions_acc[j][i]) - log_sum;
+      }
+    }
+  }
+}
+
+void HMM::update()
+{
+  // first the states
+  for (int i=1;i<n_states-1;i++) {
+    states[i]->update();
+  }
+  // then the transitions;
+  for (int i=0;i<n_states-1;i++) {
+    real log_sum = LOG_ZERO;
+    for (int j=1;j<n_states;j++) {
+      if (log_transitions[j][i] != LOG_ZERO)
+        log_sum += logAdd(log_sum,log_transitions[j][i]);
+    }
+    for (int j=0;j<n_states;j++) {
+      if (log_transitions[j][i] != LOG_ZERO)
+        log_transitions[j][i] -= log_sum;
+    }
+  }
+}
+
+
+void HMM::backward(Sequence *inputs, Sequence *alpha)
+{
+  // compute the beta by backward recursion
+  logBeta(inputs);
+
+  // accumulate the emission posteriors
+  for (int f=0;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      if (log_alpha->frames[f][i] != LOG_ZERO &&
+        log_beta->frames[f][i] != LOG_ZERO) {
+        real posterior_i_f = *alpha->frames[0] * exp(log_alpha->frames[f][i] + 
+          log_beta->frames[f][i] - log_probability);
+        states[i]->frameBackward(f,inputs->frames[f],NULL,NULL,&posterior_i_f);
+      }
+    }
+  }
+  // accumulate the transition posteriors
+  for (int f=1;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      real log_emit_i = log_probabilities_s->frames[f][i];
+      for (int j=1;j<n_states;j++) {
+        if (log_transitions[i][j] == LOG_ZERO || log_alpha->frames[f-1][j] == LOG_ZERO || log_emit_i == LOG_ZERO || log_beta->frames[f][i] == LOG_ZERO)
+          continue;
+        real posterior_i_j_f = *alpha->frames[0] * exp(log_alpha->frames[f-1][j] + 
+          log_transitions[i][j] + log_emit_i + 
+          log_beta->frames[f][i] - log_probability);
+        dlog_transitions[i][j] += posterior_i_j_f;
+        for (int k=1;k<n_states;k++) {
+          if (log_transitions[k][j] != LOG_ZERO)
+            dlog_transitions[k][j] -= posterior_i_j_f * exp(log_transitions[k][j]);
+        }
+      }
+    }
+  }
+  // particular case of transitions from initial state
+  for (int j=1;j<n_states-1;j++) {
+    if (log_transitions[j][0] == LOG_ZERO || log_beta->frames[0][j] == LOG_ZERO || log_probabilities_s->frames[0][j] == LOG_ZERO)
+      continue;
+    real posterior_i_j_f = *alpha->frames[0] * exp(log_beta->frames[0][j] +
+      log_probabilities_s->frames[0][j] + log_transitions[j][0] - 
+      log_probability);
+    dlog_transitions[j][0] += posterior_i_j_f;
+    for (int k=1;k<n_states;k++) {
+      if (log_transitions[k][0] != LOG_ZERO)
+        dlog_transitions[k][0] -= posterior_i_j_f * exp(log_transitions[k][0]);
+    }
+  }
+  // particular case of transitions to last state
+  int f = inputs->n_frames-1;
+  int i = n_states-1;
+  for (int j=1;j<n_states-1;j++) {
+    if (log_transitions[i][j] == LOG_ZERO || log_alpha->frames[f][j] == LOG_ZERO)
+      continue;
+    real posterior_i_j_f = *alpha->frames[0] * exp(log_alpha->frames[f][j] +
+      log_transitions[i][j] - log_probability);
+    dlog_transitions[i][j] += posterior_i_j_f;
+    for (int k=1;k<n_states;k++) {
+      if (log_transitions[k][j] != LOG_ZERO)
+        dlog_transitions[k][j] -= posterior_i_j_f * exp(log_transitions[k][j]);
+    }
+  }
+}
+
+void HMM::viterbiBackward(Sequence *inputs, Sequence *alpha)
+{
+  // accumulate the emission and transition posteriors
+  for (int f=0;f<=inputs->n_frames;f++) {
+    int i = (int)viterbi_sequence->frames[f][0];
+    if (f<inputs->n_frames) {
+      states[i]->frameBackward(f, inputs->frames[f], NULL, NULL, alpha->frames[0]);
+    }
+    int j = (int)arg_viterbi->frames[f][i];
+    dlog_transitions[i][j] -= *alpha->frames[0];
+    for (int k=1;k<n_states;k++) {
+      if (log_transitions[k][j] != LOG_ZERO)
+        dlog_transitions[k][j] += *alpha->frames[0] *exp(log_transitions[k][j]);
+    }
+  }
+}
+
+void HMM::decode(Sequence* inputs)
+{
+  eMSequenceInitialize(inputs);
+  logProbabilities(inputs);
+  logViterbi(inputs);
+}
+
+
+HMM::~HMM()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/HMM.h work/main.d/Torch-3/distributions/HMM.h
--- tmp/Torch-3/distributions/HMM.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/HMM.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,143 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef HMM_INC
+#define HMM_INC
+
+#include "Distribution.h"
+#include "Trainer.h"
+
+namespace Torch {
+
+/** This class implements a Hidden Markov Model distribution. It can be trained
+    either by EM, Viterbi, or Gradient Descent.
+
+    Note that this kind of HMM always contain one initial state and
+    one final state. Both are non-emitting.
+
+		Note that the log_probabilities is the average over all frames of the 
+		log_probability of the example.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class HMM : public Distribution
+{
+  public:
+
+    /** The number of states of the HMM.
+        the first model is the initial state,
+        the last model is the final (absorbing) state,
+        (neither of them are emitting).
+        hence, n_states > 2
+    */
+    int n_states;
+
+    /// a prior on the transition probabilities
+    real prior_transitions;
+    
+    /// keep the emission distributions
+    Distribution** states;
+
+    /// if the states are in fact shared in some way or another, the original ones are in shared_states
+    Distribution** shared_states;
+    int n_shared_states;
+
+		bool linear_segmentation;
+
+    /// the initial transitions between states are kept as a matrix
+    real** transitions;
+    /// in fact, we keep the transitions in log
+    real** log_transitions;
+    /// the derivative of the log transitions for gradient descent
+    real** dlog_transitions;
+    /// the accumulators of the transitions for EM
+    real** transitions_acc;
+    
+    /// accumulator used in the forward phase to compute log likelihood 
+    Sequence* log_alpha;
+    /// accumulator used in the backward phase to compute log likelihood 
+    Sequence* log_beta;
+    /// for each state, for each time step, keep the best predecessor 
+    Sequence* arg_viterbi;
+    /// arg_viterbi of the finishing state
+    int last_arg_viterbi;
+    /// for each time step, keep the best state 
+    Sequence* viterbi_sequence;
+
+    /// keep for each time step and each model its emission log probability
+    Sequence* log_probabilities_s;
+
+    /// do we need to initialize the model?
+    bool initialize;
+
+    HMM(int n_states_, Distribution **states_, real** transitions_, int n_shared_states = 0, Distribution **shared_states_ = NULL);
+
+    virtual void setDataSet(DataSet* data_);
+    virtual void loadXFile(XFile *file);
+    virtual void saveXFile(XFile *file);
+
+    /// this method can be used for debugging purpose to see the transitions
+    virtual void printTransitions(bool real_values=false,bool transitions_only=false);
+
+    /// computes the log_alpha during forward phase of EM
+    virtual void logAlpha(Sequence* inputs);
+    /// computes the log_beta during backward phase of EM
+    virtual void logBeta(Sequence* inputs);
+    /// computes the log_viterbi during forward phase of Viterbi
+    virtual void logViterbi(Sequence* inputs);
+
+    /// this method returns the state sequence associated to the input
+    virtual void decode(Sequence* input);
+
+    /** computes for each state and each time step of the sequence #inputs#
+        its associated emission probability.
+    */
+    virtual void logProbabilities(Sequence *inputs);
+
+    virtual real logProbability(Sequence *inputs);
+    virtual real viterbiLogProbability(Sequence *inputs);
+
+    virtual void  iterInitialize();
+    virtual void  eMIterInitialize();
+    virtual void  eMSequenceInitialize(Sequence* inputs);
+    virtual void  sequenceInitialize(Sequence* inputs);
+    virtual void  eMAccPosteriors(Sequence *inputs, real log_posterior);
+    virtual void  viterbiAccPosteriors(Sequence *inputs, real log_posterior);
+    virtual void  eMUpdate();
+    virtual void  update();
+
+    virtual void backward(Sequence *inputs, Sequence *alpha);
+    virtual void viterbiBackward(Sequence *inputs, Sequence *alpha);
+
+    virtual ~HMM();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/KMeans.cc work/main.d/Torch-3/distributions/KMeans.cc
--- tmp/Torch-3/distributions/KMeans.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/KMeans.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,200 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "KMeans.h"
+#include "log_add.h"
+#include "Random.h"
+
+namespace Torch {
+
+KMeans::KMeans(int n_inputs_, int n_gaussians_) : DiagonalGMM(n_inputs_, n_gaussians_)
+{
+  min_cluster = new (allocator)Sequence(1,1);
+	addBOption("intitialize parameters", &initialize_parameters , true, "initialize the kmeans parameters from the data");
+}
+
+void KMeans::setDataSet(DataSet* data_)
+{
+  // initialize the parameters using some examples in the dataset randomly
+	int tot_n_frames = 0;
+	int* example_size = (int*) allocator->alloc(sizeof(int)*data_->n_examples);
+	int* ex_s = example_size;
+	for(int i=0; i<data_->n_examples; i++){
+		data_->getNumberOfFrames(i, ex_s, NULL);
+		tot_n_frames += *ex_s++;
+	}
+/*
+	if(tot_n_frames < n_gaussians)
+		error("The number of frame: %d is smaller than the number of gaussians: %d",tot_n_frames, n_gaussians);
+*/
+  int n_part = (int)(tot_n_frames/(real)n_gaussians);
+
+	int sum = 0;
+	int ex = 0;
+  for (int i=0;i<n_gaussians;i++) {
+    int from = (int)(i*n_part);
+    int to = (int)((i+1)*n_part);
+    int diff = max(to - from,1);
+		int index = (int)from + (int)(Random::uniform()*(real)diff);
+		while(sum <= index){
+			sum += example_size[ex++];
+		}
+		sum -= example_size[--ex];
+		data_->setExample(ex);
+    real *x = data_->inputs->frames[index - sum];
+    real *means_i = means[i];
+    real *var_i = var[i];
+    real *thresh = var_threshold;
+    for(int j = 0; j < n_inputs; j++) {
+      *means_i++ = *x++;
+      *var_i++ = *thresh++;
+    }
+    log_weights[i] = log(1./n_gaussians);
+  }
+	allocator->free(example_size);
+}
+
+
+void KMeans::eMIterInitialize()
+{
+  // initialize the accumulators to 0
+  for (int i=0;i<n_gaussians;i++) {
+    real *pm = means_acc[i];
+    real *ps = var_acc[i];
+    for (int j=0;j<n_inputs;j++) {
+      *pm++ = 0.;
+      *ps++ = 0.;
+    }
+    weights_acc[i] = prior_weights;
+  }
+}
+
+void KMeans::eMSequenceInitialize(Sequence* inputs)
+{
+	min_cluster->resize(inputs->n_frames);
+  DiagonalGMM::eMSequenceInitialize(inputs);
+}
+
+real KMeans::frameLogProbability(int t, real *inputs)
+{
+  real min_dist = INF;
+  int min_i = -1;
+  for (int i=0;i<n_gaussians;i++) {
+    real dist = 0;
+    real* means_i = means[i];
+    real *x = inputs;
+    for(int j = 0; j < n_inputs; j++) {
+      real diff = *x++ - *means_i++;
+      dist += diff*diff;
+    }
+    if (dist < min_dist) {
+      min_dist = dist;
+      min_i = i;
+    }
+  }
+  log_probabilities->frames[t][0] = -min_dist;
+  min_cluster->frames[t][0] = (real)min_i;
+  return -min_dist;
+}
+
+real KMeans::frameLogProbabilityOneGaussian(int g, real *inputs)
+{ 
+  real dist = 0;
+  real* means_g = means[g];
+  real *x = inputs;
+  for(int j = 0; j < n_inputs; j++) {
+    real diff = *x++ - *means_g++;
+    dist += diff*diff;
+  }
+  return dist;
+}
+
+void KMeans::frameEMAccPosteriors(int t, real *inputs, real log_posterior)
+{
+  int min_i = (int)min_cluster->frames[t][0];
+  real* means_acc_i = means_acc[min_i];
+  real* var_acc_i = var_acc[min_i];
+  real *x = inputs;
+  for(int j = 0; j < n_inputs; j++) {
+    *var_acc_i++ += *x * *x;
+    *means_acc_i++ += *x++;
+  }
+  weights_acc[min_i] ++;
+}
+
+void KMeans::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  int min_i = (int)min_cluster->frames[t][0];
+  real* min_means = means[min_i];
+  real* min_dmeans = dmeans[min_i];
+  for (int i=0;i<n_inputs;i++) {
+    min_dmeans[i] += (f_inputs[i] - min_means[i]) * *alpha_;
+  }
+}
+
+void KMeans::eMUpdate()
+{
+   // first the weights and var
+  real* p_weights_acc = weights_acc;
+  for (int i=0;i<n_gaussians;i++,p_weights_acc++) {
+    if (*p_weights_acc == 0) {
+      warning("Gaussian %d of KMeans is not used in EM",i);
+    } else {
+      real* p_means_i = means[i];
+      real* p_var_i = var[i];
+      real* p_means_acc_i = means_acc[i];
+      real* p_var_acc_i = var_acc[i];
+      for (int j=0;j<n_inputs;j++,p_means_i++) {
+        *p_means_i = *p_means_acc_i++ / *p_weights_acc;
+        real v = *p_var_acc_i++ / *p_weights_acc - *p_means_i * *p_means_i;
+        *p_var_i++ = v >= var_threshold[j] ? v : var_threshold[j];
+      }
+    }
+  }
+  // then the weights
+  real sum_weights_acc = 0;
+  p_weights_acc = weights_acc;
+  for (int i=0;i<n_gaussians;i++)
+    sum_weights_acc += *p_weights_acc++;
+  if (sum_weights_acc == 0)
+    warning("the posteriors of weights of KMeans are not used");
+  else {
+    real *p_log_weights = log_weights;
+    real log_sum = log(sum_weights_acc);
+    p_weights_acc = weights_acc;
+    for (int i=0;i<n_gaussians;i++)
+      *p_log_weights++ = log(*p_weights_acc++) - log_sum;
+  }
+}
+
+KMeans::~KMeans()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/KMeans.h work/main.d/Torch-3/distributions/KMeans.h
--- tmp/Torch-3/distributions/KMeans.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/KMeans.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,87 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef KMEANS_INC
+#define KMEANS_INC
+
+#include "DiagonalGMM.h"
+
+namespace Torch {
+
+/** This class can be used to do a "kmeans" on a given set of data.
+    It has been implemented in the framework of a Distribution that can
+    be trained with EM. This means that the kmeans distance is in fact
+    returned by the method logProbability.
+
+    Note that as KMeans is a subclass of DiagonalGMM, they share the same
+    parameter structure. Hence, a DiagonalGMM can be easily initialized by
+    a KMeans.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class KMeans : public DiagonalGMM
+{
+  public:
+
+    /// for each example, keep the index of the neirest cluster
+    Sequence* min_cluster;
+
+    /// initialize the parameters from the data set to false if you
+		/// load the data.
+    bool initialize_parameters;
+    ///
+    KMeans(int n_inputs, int n_gaussians_);
+
+    virtual void setDataSet(DataSet* data_);
+
+    virtual void eMIterInitialize();
+    virtual void frameEMAccPosteriors(int t, real *inputs, real log_posterior);
+    virtual void eMUpdate();
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+
+    virtual void eMSequenceInitialize(Sequence* inputs);
+
+    /** note that this method returns in fact the euclidean distance between 
+        the observation and the neirest cluster
+    */
+    virtual real frameLogProbability(int t, real *inputs);
+
+		/** similarly to frameLogProbability, this method returns the euclidean
+			  distance between cluster g and the given observation
+		*/
+		virtual real frameLogProbabilityOneGaussian(int g, real *inputs);
+
+
+    virtual ~KMeans();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/LICENSE work/main.d/Torch-3/distributions/LICENSE
--- tmp/Torch-3/distributions/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/LICENSE	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,28 @@
+
+Copyright (c) 2003--2004 Ronan Collobert
+Copyright (c) 2003--2004 Samy Bengio
+Copyright (c) 2003--2004 Johnny Mariéthoz
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/LogRBF.cc work/main.d/Torch-3/distributions/LogRBF.cc
--- tmp/Torch-3/distributions/LogRBF.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/LogRBF.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,121 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "LogRBF.h"
+#include "Random.h"
+#include "KMeans.h"
+
+namespace Torch {
+
+LogRBF::LogRBF(int n_inputs_, int n_outputs_, EMTrainer* kmeans_trainer_) : GradientMachine(n_inputs_, n_outputs_, 2*n_inputs_*n_outputs_)
+{
+  initial_kmeans_trainer = kmeans_trainer_;
+  mu = params->data[0];
+  gamma = params->data[0] + n_inputs*n_outputs;
+  der_mu = der_params->data[0];
+  der_gamma = der_params->data[0] + n_inputs*n_outputs;
+}
+
+void LogRBF::setDataSet(DataSet* data_)
+{
+  if(initial_kmeans_trainer)
+  {
+    initial_kmeans_trainer->train(data_, NULL);
+
+    KMeans *kmeans = (KMeans *)initial_kmeans_trainer->distribution;
+    for(int i = 0; i < n_outputs; i++)
+    {
+      real *src = kmeans->means[i];
+      real *dest = mu + i*n_inputs;
+      for(int j = 0; j < n_inputs; j++)
+        dest[j] = src[j];
+    }
+  }
+  else
+  {  
+    for(int i = 0; i < n_inputs*n_outputs; i++)
+      mu[i] = Random::uniform();
+  }
+
+  for(int i = 0; i < n_inputs*n_outputs; i++)
+    gamma[i] = 1./sqrt((real)n_inputs);
+}
+
+void LogRBF::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  real *mu_ = mu;
+  real *gamma_ = gamma;
+  for(int i = 0; i < n_outputs; i++)
+  {
+    real out = 0;
+    for(int j = 0; j < n_inputs; j++)
+    {
+      real z = (f_inputs[j] - mu_[j]) * gamma_[j];
+      out += z*z;
+    }
+    f_outputs[i] = -0.5*out;
+    mu_ += n_inputs;
+    gamma_ += n_inputs;
+  }
+}
+
+void LogRBF::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  for(int i = 0; i < n_inputs; i++)
+    beta_[i] = 0;
+
+  real *mu_ = mu;
+  real *gamma_ = gamma;
+  real *der_mu_ = der_mu;
+  real *der_gamma_ = der_gamma;
+  for(int i = 0; i < n_outputs; i++)
+  {
+    real z = alpha_[i];
+    for(int j = 0; j < n_inputs; j++)
+    {
+      real gamma__ = gamma_[j];
+      real diff = f_inputs[j] - mu_[j];
+
+      real zz = z * diff * gamma__ * gamma__;
+      der_mu_[j] += zz;
+      beta_[j] -= zz;
+
+      der_gamma_[j] -= z * diff*diff * gamma__;
+    }
+    mu_ += n_inputs;
+    gamma_ += n_inputs;
+    der_mu_ += n_inputs;
+    der_gamma_ += n_inputs;
+  }
+}
+
+LogRBF::~LogRBF()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/LogRBF.h work/main.d/Torch-3/distributions/LogRBF.h
--- tmp/Torch-3/distributions/LogRBF.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/LogRBF.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,72 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LOG_RBF_INC
+#define LOG_RBF_INC
+
+#include "GradientMachine.h"
+#include "EMTrainer.h"
+
+namespace Torch {
+
+/** LogRBF layer for #GradientMachine#.
+    Formally speaking, $ouputs[i] = -0.5 \sum_j gamma_ij^2 * (inputs[j] - mu_ij)^2$.\\
+    $mu_ij$ and $gamma_ij$ are in #params#, with the following structure:\\
+    $mu_00... mu_0n, gamma_00.. gamma_0n,..., $\\
+
+    For a better initialization, one can provide a #EMTrainer# using a
+    #Kmeans# distribution that will be used to initialize the means and
+    gamma.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class LogRBF : public GradientMachine
+{
+  public:
+    real *gamma;
+    real *mu;
+    real *der_gamma;
+    real *der_mu;
+
+    /// optional initialization using a Kmeans
+    EMTrainer* initial_kmeans_trainer;
+
+    ///
+    LogRBF(int n_inputs_, int n_outputs_, EMTrainer* kmeans_trainer=NULL);
+
+    //-----
+
+    virtual void setDataSet(DataSet* data_);
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+    virtual ~LogRBF();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/Makefile work/main.d/Torch-3/distributions/Makefile
--- tmp/Torch-3/distributions/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/Makefile	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,42 @@
+# get user and architecture specific options
+OS := $(shell uname -s)
+TORCHDIR := $(shell cd ..; pwd)
+include ../Makefile_options_$(OS)
+
+CC_FILES := $(wildcard *.cc)
+OBJS := $(foreach f,$(CC_FILES),$(OBJS_DIR)/$(patsubst %.cc,%.o,$(f)))
+
+all:	$(LIBTORCH)
+
+$(LIBTORCH): $(OBJS)
+	@echo "Archiving..."
+	@$(AR) $(LIBTORCH) $(OBJS)
+
+$(OBJS_DIR)/%.o: %.cc
+	@echo $<
+	@$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $@ -c $<
+
+distclean:
+	@\rm -f .deps_*
+
+clean:
+	@echo "Remove objects file and dependencies..."
+	@\rm -Rf $(OBJS) $(LIBTORCH)
+	@\rm -f .deps_$(VERSION_KEY)
+
+depend:
+	@echo "Tracking dependencies..."
+	@\rm -f .deps_$(VERSION_KEY)
+	@for file in *.cc ; do printf "$(OBJS_DIR)/" >> .deps_$(VERSION_KEY); $(DEP) $(CFLAGS_$(MODE)) $(INCS) $$file >> .deps_$(VERSION_KEY); done
+
+.deps_$(VERSION_KEY):
+	@echo ">>> Please do a 'make depend' <<<"
+	exit 10
+
+ifneq ($(MAKECMDGOALS),distclean)
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),depend)
+include .deps_$(VERSION_KEY)
+endif
+endif
+endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/MAPDiagonalGMM.cc work/main.d/Torch-3/distributions/MAPDiagonalGMM.cc
--- tmp/Torch-3/distributions/MAPDiagonalGMM.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/MAPDiagonalGMM.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,198 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "MAPDiagonalGMM.h"
+#include "log_add.h"
+
+namespace Torch {
+
+MAPDiagonalGMM::MAPDiagonalGMM(DiagonalGMM* prior_distribution_) : DiagonalGMM(prior_distribution_->n_inputs, prior_distribution_->n_gaussians)
+{
+  prior_distribution = prior_distribution_;
+	addROption("weight on prior", &weight_on_prior , 0.5, "weight for the prior distribution for MAP adaptation");
+  addBOption("learn weights", &learn_weights, false, "learn the weights of gaussians");
+  addBOption("learn variances", &learn_variances, false, "learn the variances of gaussians");
+  addBOption("learn means", &learn_means, false, "learn the variances of gaussians");
+}
+
+void MAPDiagonalGMM::setDataSet(DataSet* data_)
+{
+  // here, initialize the parameters to the parameters of the prior
+  // distribution
+  if (prior_distribution)
+		params->copy(prior_distribution->params);
+  else
+    DiagonalGMM::reset();
+}
+
+void MAPDiagonalGMM::frameViterbiAccPosteriors(int t, real *inputs, real log_posterior)
+{
+	if(learn_variances){
+		DiagonalGMM::frameViterbiAccPosteriors(t, inputs, log_posterior);
+		return;
+	}
+	real *p_weights_acc = weights_acc;
+	real *lp_i = log_probabilities_g->frames[t];
+	real *log_w_i = log_weights;
+	real max_lpg = LOG_ZERO;
+	int best_g = 0;
+	//findmax
+	for (int i=0;i<n_gaussians;i++) {
+		real post_i =  *log_w_i++ + *lp_i++;
+		if(post_i > max_lpg){
+			best_g = i;
+			max_lpg = post_i;
+		}
+	}
+	p_weights_acc[best_g] += 1;
+	real* means_acc_i = means_acc[best_g];
+	real *x = inputs;
+	for(int j = 0; j < n_inputs; j++) {
+		*means_acc_i++ +=  *x++;
+	}
+}
+
+
+void MAPDiagonalGMM::frameEMAccPosteriors(int t, real *inputs, real log_posterior)
+{
+	if(learn_variances){
+	  DiagonalGMM::frameEMAccPosteriors(t, inputs, log_posterior);
+	  return;
+	}
+
+  real log_prob = log_probabilities->frames[t][0];
+  real *p_weights_acc = weights_acc;
+  real *lp_i = log_probabilities_g->frames[t];
+  real *log_w_i = log_weights;
+  for (int i=0;i<n_gaussians;i++) {
+    real post_i = exp(log_posterior + *log_w_i++ + *lp_i++ - log_prob);
+    *p_weights_acc++ += post_i;
+    real* means_acc_i = means_acc[i];
+    real *x = inputs;
+    for(int j = 0; j < n_inputs; j++) {
+      *means_acc_i++ += post_i * *x++;
+    }
+  }
+}
+
+void MAPDiagonalGMM::eMUpdate()
+{
+  // just the means
+	real epsilon = 10*REAL_EPSILON;
+  //real* p_weights_acc = weights_acc;
+	//real sum = .0;
+	 //for (int i=0;i<n_gaussians;i++)
+		// sum += *p_weights_acc++;
+	 real* p_weights_acc = weights_acc;
+	 if(learn_means)
+		 for (int i=0;i<n_gaussians;i++,p_weights_acc++) {
+				 //printf("%g ",*p_weights_acc);
+			 if (*p_weights_acc <= (prior_weights + epsilon)){
+				 //warning("Gaussian %d of GMM is not used in EM (w=%g)",i,*p_weights_acc);
+				 real* p_means_prior_i = prior_distribution->means[i];
+				 real* p_means_i = means[i];
+				 for (int j=0;j<n_inputs;j++) 
+					 *p_means_i++ = *p_means_prior_i++;
+			 }else{
+				 real* p_means_prior_i = prior_distribution->means[i];
+				 real* p_means_i = means[i];
+				 real* p_means_acc_i = means_acc[i];
+				 for (int j=0;j<n_inputs;j++) {
+					 *p_means_i++ = (weight_on_prior * *p_means_prior_i++) + ((1 - weight_on_prior) * *p_means_acc_i++ / *p_weights_acc);
+				 }
+			 }
+		 }
+
+  p_weights_acc = weights_acc;
+	if(learn_variances)
+		for (int i=0;i<n_gaussians;i++,p_weights_acc++) {
+			if (*p_weights_acc <= (prior_weights + epsilon)) {
+				warning("Gaussian %d of GMM is not used in EM",i);
+			} else {
+				real* p_var_i = var[i];
+				real* p_means_acc_i = means_acc[i];
+				real* p_var_acc_i = var_acc[i];
+				real* p_means_prior_i = prior_distribution->means[i];
+				real* p_var_prior_i = prior_distribution->var[i];
+				for (int j=0;j<n_inputs;j++) {
+					real means_ml = *p_means_acc_i++ / *p_weights_acc;
+					real means_map = weight_on_prior * *p_means_prior_i +
+						                        (1 - weight_on_prior) * means_ml;
+					real var_ml = *p_var_acc_i++ / *p_weights_acc - means_map * means_map;
+					real map_prior_2 = (means_map - *p_means_prior_i) * (means_map - *p_means_prior_i++);
+          real map_ml_2 = (means_map - means_ml) * (means_map - means_ml);
+					real var_map = weight_on_prior * (*p_var_prior_i++ + map_prior_2) +
+					          (1 - weight_on_prior) * (var_ml + map_ml_2);
+					*p_var_i++ = var_map >= var_threshold[j] ? var_map : var_threshold[j];
+				}
+			}
+		}
+
+	if(learn_weights){
+		// then the weights
+		real sum_weights_acc = 0;
+		p_weights_acc = weights_acc;
+		for (int i=0;i<n_gaussians;i++)
+			sum_weights_acc += *p_weights_acc++;
+		real *p_log_weights = log_weights;
+		real *prior_log_weights = prior_distribution->log_weights;
+		real log_sum = log(sum_weights_acc);
+		p_weights_acc = weights_acc;
+		for (int i=0;i<n_gaussians;i++)
+			*p_log_weights++ = log(weight_on_prior * exp( *prior_log_weights++) + (1-weight_on_prior) * exp(log(*p_weights_acc++) - log_sum));
+	}
+}
+
+
+/*
+void MAPDiagonalGMM::frameBackward(real *observations, real *alpha, real *inputs, int t)
+{
+  real log_prob = log_probabilities[t];
+  real *lp_i = log_probabilities_g[t];
+  real *lw = log_weights;
+  for (int i=0;i<n_gaussians;i++,lw++,lp_i++) {
+    real post_i =  *alpha * exp(*lw + *lp_i - log_prob);
+    real* obs = observations;
+    real* means_i = means[i];
+    real* dmeans_i = dmeans[i];
+    real* var_i = var[i];
+    for (int j=0;j<n_observations;j++,var_i++,obs++,means_i++,dmeans_i++) {
+      real xmuvar = (*obs - *means_i) / *var_i;
+      real dm = post_i * 2. * xmuvar;
+      *dmeans_i += dm;
+    }
+  }
+}
+*/
+MAPDiagonalGMM::~MAPDiagonalGMM()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/MAPDiagonalGMM.h work/main.d/Torch-3/distributions/MAPDiagonalGMM.h
--- tmp/Torch-3/distributions/MAPDiagonalGMM.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/MAPDiagonalGMM.h	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,91 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MAP_DIAGONAL_GMM_INC
+#define MAP_DIAGONAL_GMM_INC
+
+#include "DiagonalGMM.h"
+
+namespace Torch {
+
+/** This class is a special case of a DiagonalGMM that implements the
+    MAP algorithm instead of the EM algorithm. This means that the
+    mean parameters will be changed according to the Maximum A Posteriori
+    algorithm, given a prior value of the means (through a prior DiagonalGMM
+    given in the constructor). Moreover, the variances and weights are
+    not changed, as experimental results tend to show that there is no
+    effects when they are changed.
+
+    @author Samy Bengio (bengio@idiap.ch)
+    @author Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+*/
+class MAPDiagonalGMM : public DiagonalGMM
+{
+  public:
+
+    /// The prior distribution used in MAP
+    DiagonalGMM* prior_distribution;
+
+    /// The weight to give to the prior parameters during update
+    real weight_on_prior;
+
+		/// update Gaussian's weights
+		bool learn_weights;
+		
+		/// update Gaussian's variances
+		bool learn_variances;
+
+   /// update Gaussian's means 
+		bool learn_means;
+
+    ///
+    MAPDiagonalGMM(DiagonalGMM* prior_distribution_);
+
+
+		/// The backward step of Viterbi for a frame
+    virtual void frameViterbiAccPosteriors(int t, real* inputs, real log_posterior);
+
+		/// The backward step of EM for a frame
+    virtual void frameEMAccPosteriors(int t, real *inputs, real log_posterior);
+
+		/// The update after each iteration for EM
+    virtual void eMUpdate();
+
+		/**
+       Copy the parameters of the prior distribution
+		 */
+		virtual void setDataSet(DataSet* data_);
+
+    virtual ~MAPDiagonalGMM();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/MAPHMM.cc work/main.d/Torch-3/distributions/MAPHMM.cc
--- tmp/Torch-3/distributions/MAPHMM.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/MAPHMM.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,76 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (marietho@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "MAPHMM.h"
+#include "log_add.h"
+
+namespace Torch {
+
+MAPHMM::MAPHMM(int n_states_, Distribution **states_, real** transitions_,HMM* prior_distribution_) : 
+	HMM(n_states_,states_, transitions_){
+  prior_distribution = prior_distribution_;
+	setWeightOnPrior(0.5);
+}
+
+void MAPHMM::setWeightOnPrior(real weight_on_prior_){
+	weight_on_prior = weight_on_prior_;
+  log_weight_on_prior = log(weight_on_prior);
+  log_1_weight_on_prior = log(1-weight_on_prior);
+}
+
+void MAPHMM::eMUpdate()
+{
+  // first the states
+  for (int i=1;i<n_states-1;i++) {
+    states[i]->eMUpdate();
+  }
+  // then the transitions;
+  for (int i=0;i<n_states-1;i++) {
+    real sum_trans_acc = 0;
+    for (int j=0;j<n_states;j++) {
+      if (log_transitions[j][i] == LOG_ZERO)
+        continue;
+      sum_trans_acc += transitions_acc[j][i];
+    }
+    real log_sum = log(sum_trans_acc);
+    for (int j=0;j<n_states;j++) {
+      if (log_transitions[j][i] == LOG_ZERO)
+        continue;
+      log_transitions[j][i] = logAdd(log_weight_on_prior + prior_distribution->log_transitions[j][i],
+	                              log_1_weight_on_prior + log(transitions_acc[j][i]) - log_sum);
+    }
+  }
+}
+
+MAPHMM::~MAPHMM()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/MAPHMM.h work/main.d/Torch-3/distributions/MAPHMM.h
--- tmp/Torch-3/distributions/MAPHMM.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/MAPHMM.h	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,74 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (marietho@idiap.ch)
+//                and Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MAP_HMM_INC
+#define MAP_HMM_INC
+
+#include "HMM.h"
+
+namespace Torch {
+
+/** This class is a special case of a HMM that implements the
+    MAP algorithm for HMM transitions probabilities.
+    
+    @author Samy Bengio (bengio@idiap.ch)
+    @author Johnny Mariethoz (marietho@idiap.ch)
+*/
+class MAPHMM : public HMM
+{
+  public:
+     
+    /// The prior distribution used in MAP
+    HMM* prior_distribution;
+     
+    /// The weight to give to the prior parameters during update
+    real weight_on_prior;
+     
+    ///log(weight_on_prior)
+    real log_weight_on_prior;
+     
+    ///log(1-weight_on_prior_
+    real log_1_weight_on_prior;
+    
+    ///
+    MAPHMM(int n_states_, Distribution **states_, real** transitions_, HMM* prior_distribution_);
+
+		void setWeightOnPrior(real weight_on_prior_);
+
+    /// map adaptation method for transitions probabilities
+    virtual void eMUpdate();
+
+    virtual ~MAPHMM();
+    
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/Multinomial.cc work/main.d/Torch-3/distributions/Multinomial.cc
--- tmp/Torch-3/distributions/Multinomial.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/Multinomial.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,161 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Multinomial.h"
+#include "log_add.h"
+#include "Random.h"
+
+namespace Torch {
+
+Multinomial::Multinomial(int n_values_) : Distribution(1,n_values_)
+{
+  n_values = n_values_;
+	addROption("prior weights", &prior_weights , 1e-3, "minimum weights for each gaussians");
+  addBOption("equal initialization", &equal_initialization , false, "equal initialization");
+
+  log_weights = (real*)params->data[0];
+  dlog_weights = (real*)der_params->data[0];
+  weights_acc = (real*)allocator->alloc(sizeof(real)*n_values);
+}
+
+void Multinomial::setDataSet(DataSet* data_)
+{
+  // here, initialize the parameters somehow...
+
+	real sum = 0.;
+  if (equal_initialization) {
+    // initialize the weights with equal values
+      for (int i=0;i<n_values;i++)  {
+        log_weights[i] = 1.0 / (float) n_values;
+      sum += log_weights[i];
+    }
+  } else {
+	  // initialize randomly the weights
+	  for (int i=0;i<n_values;i++) {
+		  log_weights[i] = Random::boundedUniform(0.1,1);
+		  sum += log_weights[i];
+	  }
+  }
+	for (int i=0;i<n_values;i++) {
+		log_weights[i] = log(log_weights[i]/sum);
+	}
+}
+
+void Multinomial::eMSequenceInitialize(Sequence* inputs)
+{
+  if (!inputs)
+    return;
+	log_probabilities->resize(inputs->n_frames);
+}
+
+void Multinomial::sequenceInitialize(Sequence* inputs)
+{
+  eMSequenceInitialize(inputs);
+}
+
+real Multinomial::frameLogProbability(int t, real *inputs)
+{
+  int obs = (int)inputs[0];
+  if (obs < 0 || obs >= n_values)
+    error("Multinomial::frameLogProbability observed an non-realistic value: %d\n",obs);
+  real log_prob = log_weights[obs];
+  log_probabilities->frames[t][0] = log_prob;
+  return log_prob;
+}
+
+void Multinomial::frameEMAccPosteriors(int t, real *inputs, real log_posterior)
+{
+  int obs = (int)inputs[0];
+  if (obs < 0 || obs >= n_values)
+    error("Multinomial::frameEMAccPosteriors observed an non-realistic value: %d\n",obs);
+  weights_acc[obs] += exp(log_posterior);
+}
+
+void Multinomial::eMUpdate()
+{
+  real* p_weights_acc = weights_acc;
+  real sum_weights_acc = 0;
+  for (int i=0;i<n_values;i++)
+    sum_weights_acc += *p_weights_acc++;
+  real *p_log_weights = log_weights;
+  real log_sum = log(sum_weights_acc);
+  p_weights_acc = weights_acc;
+  for (int i=0;i<n_values;i++)
+    *p_log_weights++ = log(*p_weights_acc++) - log_sum;
+}
+
+void Multinomial::eMIterInitialize()
+{
+  // initialize the accumulators to 0 and compute pre-computed value
+  for (int i=0;i<n_values;i++) {
+    weights_acc[i] = prior_weights;
+  }
+}
+
+void Multinomial::iterInitialize()
+{
+}
+
+void Multinomial::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  int obs = (int)f_inputs[0];
+  if (obs < 0 || obs >= n_values)
+    error("Multinomial::frameBackward observed an non-realistic value: %d\n",obs);
+  dlog_weights[obs] += *alpha_;
+  for (int i=0;i<n_values;i++) {
+    dlog_weights[i] -= *alpha_ * exp(log_weights[i]);
+    if (isnan(dlog_weights[i]))
+      error("Multinomial::frameBackward dlog_weights (%d) is nan!",i);
+  }
+}
+
+void Multinomial::update()
+{
+  // normalize log_weights
+  real log_sum = LOG_ZERO;
+  for (int i=0;i<n_values;i++)
+    log_sum = logAdd(log_sum,log_weights[i]);
+  for (int i=0;i<n_values;i++)
+    log_weights[i] -= log_sum;
+}
+
+void Multinomial::frameDecision(int t, real *decision)
+{
+  for(int i = 0 ; i < n_values ; i++) {
+    real class_target = (real)i;
+    decision[i] = frameLogProbability(t, &class_target);
+  }
+}
+
+
+Multinomial::~Multinomial()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/Multinomial.h work/main.d/Torch-3/distributions/Multinomial.h
--- tmp/Torch-3/distributions/Multinomial.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/Multinomial.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,87 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MULTINOMIAL_INC
+#define MULTINOMIAL_INC
+
+#include "Distribution.h"
+
+namespace Torch {
+
+/** This class can be used to model Multinomial Distributions.
+    They can be trained using either EM (with EMTrainer) or gradient descent
+    (with GMTrainer).
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class Multinomial : public Distribution
+{
+  public:
+    /// number of values this multinomial can take
+    int n_values;
+
+    /// the prior weight given to each value. kind of smoother
+    real prior_weights;
+
+    /// if true then does equal initialization of the weights
+    bool equal_initialization;
+
+    /// the pointers to the parameters
+    real* log_weights;
+
+    /// the pointers to the d_parameters
+    real* dlog_weights;
+
+    /// accumulators for EM
+    real*  weights_acc;
+
+    Multinomial(int n_values_);
+
+    virtual void setDataSet(DataSet* data_);
+
+    virtual void eMIterInitialize();
+    virtual void iterInitialize();
+
+    virtual real frameLogProbability(int t, real *inputs);
+
+    virtual void sequenceInitialize(Sequence* inputs);
+    virtual void eMSequenceInitialize(Sequence* inputs);
+    virtual void frameEMAccPosteriors(int t, real *inputs, real log_posterior);
+    virtual void eMUpdate();
+    virtual void update();
+
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+    virtual void frameDecision(int t, real *decision);
+
+    virtual ~Multinomial();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/NLLCriterion.cc work/main.d/Torch-3/distributions/NLLCriterion.cc
--- tmp/Torch-3/distributions/NLLCriterion.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/NLLCriterion.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,61 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "NLLCriterion.h"
+#include "log_add.h"
+
+namespace Torch {
+
+NLLCriterion::NLLCriterion() : Criterion(1)
+{
+  beta->resize(n_outputs);
+  outputs->resize(n_outputs);
+}
+
+void NLLCriterion::reset()
+{
+}
+
+void NLLCriterion::forward(Sequence *inputs)
+{
+  outputs->frames[0][0] = 0;
+  for (int i=0;i<inputs->n_frames;i++)
+    outputs->frames[0][0] -= inputs->frames[i][0];
+}
+
+void NLLCriterion::backward(Sequence *inputs, Sequence *alpha)
+{
+  beta->frames[0][0] = -1;
+}
+
+NLLCriterion::~NLLCriterion()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/NLLCriterion.h work/main.d/Torch-3/distributions/NLLCriterion.h
--- tmp/Torch-3/distributions/NLLCriterion.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/NLLCriterion.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,64 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// nll criterion.
+// simply returns the negative log likelihood
+
+#ifndef NLL_CRITERION_INC
+#define NLL_CRITERION_INC
+
+#include "Criterion.h"
+
+namespace Torch {
+
+/** This criterion can be used to train #Distribution# object using
+    the #GMTrainer# trainer. It then maximizes the log likelihood of the
+    data.
+
+    The #forward# method always return its input, which is the negative log
+    likelihood, while the #backward# method sets the gradient to -1.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class NLLCriterion : public Criterion
+{
+  public:
+
+    ///
+    NLLCriterion();
+
+    virtual void reset();
+    virtual void forward(Sequence *inputs);
+    virtual void backward(Sequence *inputs, Sequence *alpha);
+    virtual ~NLLCriterion();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/NLLMeasurer.cc work/main.d/Torch-3/distributions/NLLMeasurer.cc
--- tmp/Torch-3/distributions/NLLMeasurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/NLLMeasurer.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,80 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "NLLMeasurer.h"
+
+namespace Torch {
+
+NLLMeasurer::NLLMeasurer(Sequence *inputs_, DataSet *data_, XFile *file_) : Measurer(data_, file_)
+{
+  inputs = inputs_;
+  addBOption("average examples", &average_examples, true, "divided by the number of examples");
+  addBOption("average frames", &average_frames, true, "divided by the number of frames");
+
+	//reset()
+  internal_error = 0;
+}
+
+void NLLMeasurer::measureExample()
+{
+  real sum = .0;
+  for(int i = 0; i < inputs->n_frames; i++)
+		sum -= inputs->frames[i][0];
+
+  // we divide by the number of input frames in the data (and not the
+  // number of output frames)
+  if(average_frames)
+     sum /= data->inputs->n_frames;
+  internal_error += sum;
+}
+
+void NLLMeasurer::measureIteration()
+{
+  if(average_examples)
+    internal_error /= data->n_examples;
+
+  if(binary_mode)
+    file->write(&internal_error, sizeof(real), 1);
+  else
+    file->printf("%g\n", internal_error);
+  file->flush();
+  reset();
+}
+
+void NLLMeasurer::reset()
+{
+  internal_error = 0;
+}
+
+NLLMeasurer::~NLLMeasurer()
+{
+}
+
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/NLLMeasurer.h work/main.d/Torch-3/distributions/NLLMeasurer.h
--- tmp/Torch-3/distributions/NLLMeasurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/NLLMeasurer.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,65 @@
+// Copyright (C) 2003--2004 Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef NLL_MEASURER_INC
+#define NLL_MEASURER_INC
+
+#include "Measurer.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+/** This class measures the negative log likelihood. In fact, it supposes
+    that the input given is the positive log likelihood. It can 
+    then normalized by the total number of frames and/or the number of total
+		of examples.
+
+    @author Johnny Mariethoz (Johnny.Mariethoz@idiap.ch)
+*/
+class NLLMeasurer : public Measurer
+{
+  public:
+    bool average_examples;
+    bool average_frames;
+    real internal_error;
+    /// contains a pointer to the negative log likelihood to measure
+    Sequence *inputs;
+    ///
+    NLLMeasurer(Sequence *inputs_, DataSet* data_, XFile *file_);
+
+    virtual void reset();
+    virtual void measureExample();
+    virtual void measureIteration();
+
+    virtual ~NLLMeasurer();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/ParzenDistribution.cc work/main.d/Torch-3/distributions/ParzenDistribution.cc
--- tmp/Torch-3/distributions/ParzenDistribution.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/ParzenDistribution.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,121 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "ParzenDistribution.h"
+#include "log_add.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+ParzenDistribution::ParzenDistribution(int n_inputs_, real var_) : Distribution(n_inputs_,0)
+{
+  data = NULL;
+
+  setVar(var_);
+
+  n_train_examples_index = 0;
+  train_examples_index = NULL;
+}
+
+void ParzenDistribution::setVar(real var_)
+{
+  var = var_;
+
+  sum_log_var_plus_n_obs_log_2_pi = -0.5 * n_inputs*(LOG_2_PI + log(var));
+  minus_half_over_var = -0.5 / var;
+}
+
+void ParzenDistribution::setDataSet(DataSet* dataset_)
+{
+  data = dataset_;
+  n_train_examples_index = data->n_examples;
+  train_examples_index = (int*)allocator->realloc(train_examples_index,n_train_examples_index*sizeof(int));
+  for (int i=0;i<data->n_examples;i++) {
+    train_examples_index[i] = data->selected_examples[i];
+  }
+}
+
+void ParzenDistribution::eMSequenceInitialize(Sequence* inputs)
+{
+  if (!inputs)
+    return;
+	log_probabilities->resize(inputs->n_frames);
+}
+
+void ParzenDistribution::sequenceInitialize(Sequence* inputs)
+{
+  eMSequenceInitialize(inputs);
+}
+
+real ParzenDistribution::frameLogProbability(int t, real *inputs)
+{
+  // first keep the current pointers...
+  Sequence *current_seq = data->inputs;
+  data->pushExample();
+
+  // then compute the likelihood...
+  real lp = 0;
+  int tot_n_frames = 0;
+  int *i_ptr = train_examples_index;
+  for (int i=0;i<n_train_examples_index;i++) {
+    data->setRealExample(*i_ptr++);
+    Sequence* seq = data->inputs;
+    tot_n_frames += seq->n_frames;
+    for (int j=0;j<seq->n_frames;j++) {
+      real lp_ij = frameLogProbabilityOneFrame(seq->frames[j],current_seq->frames[t]);
+      lp += lp_ij;
+    }
+  }
+  lp -= log((real)tot_n_frames);
+	log_probabilities->frames[t][0] = lp;
+
+  // restore the dataset status
+  data->popExample();
+
+  return lp;
+}
+
+real ParzenDistribution::frameLogProbabilityOneFrame(real *inputs, real *mean)
+{
+  real sum_xmu = 0.;
+  real *x = inputs;
+  real *m = mean;
+  for(int j = 0; j < n_inputs; j++) {
+    real xmu = (*x++ - *m++);
+    sum_xmu += xmu*xmu;
+  }
+  real lp = sum_xmu*minus_half_over_var + sum_log_var_plus_n_obs_log_2_pi;
+  return lp;
+}
+
+ParzenDistribution::~ParzenDistribution()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/ParzenDistribution.h work/main.d/Torch-3/distributions/ParzenDistribution.h
--- tmp/Torch-3/distributions/ParzenDistribution.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/ParzenDistribution.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,83 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef PARZEN_DISTRIBUTION_INC
+#define PARZEN_DISTRIBUTION_INC
+
+#include "Distribution.h"
+
+namespace Torch {
+
+/** This class can be used to model a Parzen density estimator with
+    a Gaussian kernel:
+
+    $ p(x) = \frac{1}{N}\sum_i \frac{1}{(2 \Pi var)^{d/2}} \exp(- \frac{||x - x_i||^2}{2 var})$
+
+    where the sum is done on the whole training set.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class ParzenDistribution : public Distribution
+{
+  public:
+    /// the variance used
+    real var;
+
+    /// the dataset
+    DataSet* data;
+
+    /// the indices of the training examples
+    int *train_examples_index;
+    int n_train_examples_index;
+
+    /** in order to faster the computation, we can do some "pre-computation"
+        pre-computed sum_log_var + n_obs * log_2_pi
+    */
+    real sum_log_var_plus_n_obs_log_2_pi;
+    /// pre-computed -0.5 / var
+    real minus_half_over_var;
+
+    ParzenDistribution(int n_inputs_, real var_);
+
+    virtual void setDataSet(DataSet* dataset_);
+
+    virtual void setVar(real var_);
+
+    virtual real frameLogProbability(int t, real *inputs);
+    virtual real frameLogProbabilityOneFrame(real *inputs, real *mean);
+
+    virtual void eMSequenceInitialize(Sequence* inputs);
+    virtual void sequenceInitialize(Sequence* inputs);
+
+    virtual ~ParzenDistribution();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/TableLookupDistribution.cc work/main.d/Torch-3/distributions/TableLookupDistribution.cc
--- tmp/Torch-3/distributions/TableLookupDistribution.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/TableLookupDistribution.cc	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,59 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "TableLookupDistribution.h"
+
+namespace Torch {
+
+TableLookupDistribution::TableLookupDistribution(int column_, bool apply_log_, real prior_) : Distribution(column_+1,0)
+{
+  column = column_;
+  apply_log = apply_log_;
+  prior = prior_;
+  if (!apply_log)
+    prior = log(prior);
+}
+
+real TableLookupDistribution::frameLogProbability(int t, real *inputs)
+{
+  real lp = inputs[column];
+  if (apply_log) 
+    lp = log(lp / prior) ;
+  else
+    lp -= prior;
+  log_probabilities->frames[t][0] = lp;
+  return lp;
+}
+
+TableLookupDistribution::~TableLookupDistribution()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/distributions/TableLookupDistribution.h work/main.d/Torch-3/distributions/TableLookupDistribution.h
--- tmp/Torch-3/distributions/TableLookupDistribution.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/distributions/TableLookupDistribution.h	2004-08-11 12:34:38.000000000 -0400
@@ -0,0 +1,71 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef TABLE_LOOKUP_DISTRIBUTION_INC
+#define TABLE_LOOKUP_DISTRIBUTION_INC
+
+#include "Distribution.h"
+
+namespace Torch {
+
+/** This class outputs one of the observations as the logProbability. It
+    can eventually apply a log transformation and/or normalize by a given
+    prior. It can therefore
+    be used in conjunction with HMMs to implement the HMM/ANN hybrid model...
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class TableLookupDistribution : public Distribution
+{
+  public:
+
+    /** The column in the observation vector that corresponds to the
+        logProbability.
+    */
+    int column;
+
+    /// do we apply a log transformation
+    bool apply_log;
+
+    /// do we normalize by a given prior
+    real prior;
+
+    /** The column number corresponds to the logProbability which can
+        be normalized by an eventual prior.
+    */
+    TableLookupDistribution(int column_ = 0, bool apply_log_ = true, real prior_ = 1.);
+
+    virtual real frameLogProbability(int t, real *inputs);
+
+    virtual ~TableLookupDistribution();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/decoder/Makefile work/main.d/Torch-3/examples/decoder/Makefile
--- tmp/Torch-3/examples/decoder/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/decoder/Makefile	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,20 @@
+#
+# Torch user Makefile example
+#
+
+# Torch location.
+# Make sure to specify correct location...
+
+TORCHDIR := $(shell cd ../..; pwd)
+
+#
+# All that follows you can probably keep as is...
+#
+
+OS := $(shell uname -s)
+include $(TORCHDIR)/Makefile_options_$(OS)
+
+%: %.cc
+	cd $(TORCHDIR); ${MAKE}
+	mkdir -p $(VERSION_KEY)
+	$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $(VERSION_KEY)/$@ $< $(LIBS)
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/decoder/README work/main.d/Torch-3/examples/decoder/README
--- tmp/Torch-3/examples/decoder/README	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/decoder/README	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,34 @@
+README for TODE
+---------------
+
+This is the main program for TODE (TOrch DEcoder).
+
+./tode.cc - the main program source
+
+After the executable has been built, a summary of
+available options can be displayed by typing
+
+tode -help
+
+A comprehensive user manual can be obtained from
+the Torch website (http://www.torch.ch/documentation.php)
+
+For assistance, suggestions, etc. please contact 
+Darren Moore (moore@idiap.ch).
+
+
+Features of TODE
+----------------
+
+- Efficient beam search decoder.
+- Can be used with both ANN and GMM-based acoustic models.
+- Accepts features or emission probabilities as input.
+- N-gram language modelling with full back-off and caching.
+- Supports many commonly used file formats (model definition, 
+  ANN weights, features, language model, etc).
+- Uses a linear lexicon
+- Implementation is straightforward, and can be readily 
+  modified/upgraded to meet the needs of researchers.
+- Easily adapted for use in non-speech decoding applications.
+- Fully supported with development ongoing.
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/decoder/tode.cc work/main.d/Torch-3/examples/decoder/tode.cc
--- tmp/Torch-3/examples/decoder/tode.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/decoder/tode.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,221 @@
+#include "LinearLexicon.h"
+#include "LanguageModel.h"
+#include "DecoderBatchTest.h"
+#include "BeamSearchDecoder.h"
+#include "Vocabulary.h"
+#include "DiskXFile.h"
+#include "CmdLine.h"
+#include "PhoneInfo.h"
+#include "PhoneModels.h"
+#include "LexiconInfo.h"
+
+using namespace Torch ;
+
+// Acoustic Modelling Parameters
+bool am_input_vecs_are_ftrs=false ;
+char *am_models_fname=NULL ;
+char *am_sil_phone=NULL ;
+char *am_pause_phone=NULL ;
+real am_phone_del_pen=1.0 ;
+bool am_apply_pause_del_pen=false ;
+char *am_priors_fname=NULL ;
+char *am_mlp_fname=NULL ;
+int am_mlp_cw_size=9 ;
+char *am_norms_fname=NULL ;
+bool am_online_norm_ftrs=false ;
+real am_online_norm_alpha_m=0.005 ;
+real am_online_norm_alpha_v=0.005 ;
+
+// Lexicon Parameters
+char *lex_dict_fname=NULL ;
+char *lex_sent_start_word=NULL ;
+char *lex_sent_end_word=NULL ;
+char *lex_sil_word=NULL ;
+
+// Language Model Parameters
+int lm_ngram_order=0 ;
+char *lm_fname=NULL ;
+real lm_scaling_factor=1.0 ;
+
+// Beam Search Decoder Parameters
+real dec_int_prune_window=LOG_ZERO ;
+real dec_end_prune_window=LOG_ZERO ;
+real dec_word_entr_pen=0.0 ;
+bool dec_verbose=false ;
+bool dec_delayed_lm=true ;
+
+// Batch Test Parameters
+char *input_fname=NULL ;
+char *input_format_s=NULL ;
+DSTDataFileFormat input_format=DST_PROBS_LNA8BIT ;
+char *wrdtrns_fname=NULL ;
+char *output_fname=NULL ;
+bool output_ctm=false ;
+real msec_step_size=10.0 ;
+
+
+void processCmdLine( CmdLine *cmd , int argc , char *argv[] )
+{
+    // Phoneset Options
+    cmd->addText("\nPhoneset Options:") ;
+    cmd->addSCmdOption( "-am_models_fname" , &am_models_fname , "" ,
+                        "the file with the HMM definitions for the phone models" ) ;
+    cmd->addSCmdOption( "-am_sil_phone" , &am_sil_phone , "" ,
+                        "the name of silence phoneme" ) ;
+    cmd->addSCmdOption( "-am_pause_phone" , &am_pause_phone , "" ,
+                        "the name of pause phoneme" ) ;
+    cmd->addRCmdOption( "-am_phone_del_pen" , &am_phone_del_pen , 1.0 , 
+                        "the (non-log) phone deletion penalty" ) ;
+    cmd->addBCmdOption( "-am_apply_pause_del_pen" , &am_apply_pause_del_pen , false ,
+                        "indicates whether the phone deletion penalty is applied to pause phone" ) ;
+    cmd->addSCmdOption( "-am_priors_fname" , &am_priors_fname , "" ,
+                        "the (priors format) file containing the phone prior probabilities" ) ;
+    cmd->addSCmdOption( "-am_mlp_fname" , &am_mlp_fname , "" ,
+                        "the file (MLPW binary format) containing MLP weights" ) ;
+    cmd->addICmdOption( "-am_mlp_cw_size" , &am_mlp_cw_size , 9 ,
+                        "the number of frames in the context window input to the MLP" ) ;
+    cmd->addSCmdOption( "-am_norms_fname" , &am_norms_fname , "" ,
+                        "the (norms format) file with means & inv stddevs for ftr normalisation") ;
+    cmd->addBCmdOption( "-am_online_norm_ftrs" , &am_online_norm_ftrs , false , 
+                        "indicates whether online normalisation of features is to be performed") ;
+    cmd->addRCmdOption( "-am_online_norm_alpha_m" , &am_online_norm_alpha_m , 0.005 ,
+                        "parameter used to control adaptation of feature means" ) ;
+    cmd->addRCmdOption( "-am_online_norm_alpha_v" , &am_online_norm_alpha_v , 0.005 ,
+                        "parameter used to control adaptation of feature variances" ) ;
+
+    // Lexicon Parameters
+    cmd->addText("\nLexicon Options:") ;
+    cmd->addSCmdOption( "-lex_dict_fname" , &lex_dict_fname , "" ,
+                        "the dictionary file" ) ;
+    cmd->addSCmdOption( "-lex_sent_start_word" , &lex_sent_start_word , "" ,
+                        "the name of the dictionary word that will start every sentence" ) ;
+    cmd->addSCmdOption( "-lex_sent_end_word" , &lex_sent_end_word , "" ,
+                        "the name of the dictionary word that will end every sentence" ) ;
+    cmd->addSCmdOption( "-lex_sil_word" , &lex_sil_word , "" ,
+                        "the name of the silence dictionary word" ) ;
+
+    // Language Model Parameters
+    cmd->addText("\nLanguage Model Options:") ;
+    cmd->addSCmdOption( "-lm_fname" , &lm_fname , "" ,
+                        "the file (ARPA LM format) containing the LM probabilities" ) ;
+    cmd->addICmdOption( "-lm_ngram_order" , &lm_ngram_order , 0 , 
+                        "the order of the n-gram language model" ) ;
+    cmd->addRCmdOption( "-lm_scaling_factor" , &lm_scaling_factor , 1.0 ,
+                        "the factor by which log LM probs are scaled during decoding" ) ;
+
+    // Beam Search Decoder Parameters
+    cmd->addText("\nBeam Search Decoding Options:") ;
+    cmd->addRCmdOption( "-dec_int_prune_window" , &dec_int_prune_window , LOG_ZERO ,
+                        "the (+ve log) window used for pruning word-interior state hypotheses" ) ;
+    cmd->addRCmdOption( "-dec_end_prune_window" , &dec_end_prune_window , LOG_ZERO ,
+                        "the (+ve log) window used for pruning word-end state hypotheses" ) ;
+    cmd->addRCmdOption( "-dec_word_entr_pen" , &dec_word_entr_pen , 0.0 ,
+                        "the log word entrance penalty" ) ;
+    cmd->addBCmdOption( "-dec_delayed_lm" , &dec_delayed_lm , false ,
+                        "indicates whether LM probabilities are applied in a delayed fashion" ) ;
+    cmd->addBCmdOption( "-dec_verbose" , &dec_verbose , false ,
+                        "indicates whether frame-by-frame decoding info is printed (to stderr)" ) ;
+
+    // General Parameters
+    cmd->addText("\nGeneral Options:") ;
+    cmd->addSCmdOption( "-input_fname" , &input_fname , "" ,
+                        "the file containing the list of files to be decoded (or an archive)" ) ;
+    cmd->addSCmdOption( "-input_format" , &input_format_s , "" , 
+        "the format of the input files (htk,lna,lna_archive,online_ftrs,online_ftrs_archive)" ) ;
+    cmd->addSCmdOption( "-output_fname" , &output_fname , "" ,
+                        "the file where decoding results are written" ) ;
+    cmd->addSCmdOption( "-wrdtrns_fname" , &wrdtrns_fname , "" ,
+                        "the file containing word-level reference transcriptions" ) ;
+    cmd->addBCmdOption( "-output_ctm" , &output_ctm , false ,
+                        "indicates whether output is to be written in CTM format" ) ;
+    cmd->addRCmdOption( "-msec_step_size" , &msec_step_size , 10.0 ,
+                        "the frame step size in msec used with CTM output" ) ;
+
+    cmd->read( argc , argv ) ;
+    
+    // First interpret the input_format
+    if ( strcmp( input_format_s , "" ) == 0 )
+        error("input_format undefined\n") ;
+    if ( strcmp( input_format_s , "htk" ) == 0 )
+    {
+        am_input_vecs_are_ftrs = true ;
+        input_format = DST_FEATS_HTK ;
+    }
+    else if ( strcmp( input_format_s , "lna" ) == 0 )
+    {
+        am_input_vecs_are_ftrs = false ;
+        input_format = DST_PROBS_LNA8BIT ;
+    }
+    else if ( strcmp( input_format_s , "lna_archive" ) == 0 )
+    {
+        am_input_vecs_are_ftrs = false ;
+        input_format = DST_PROBS_LNA8BIT_ARCHIVE ;
+    }
+    else if ( strcmp( input_format_s , "online_ftrs" ) == 0 )
+    {
+        am_input_vecs_are_ftrs = true ;
+        input_format = DST_FEATS_ONLINE_FTRS ;
+    }
+    else if ( strcmp( input_format_s , "online_ftrs_archive" ) == 0 )
+    {
+        am_input_vecs_are_ftrs = true ;
+        input_format = DST_FEATS_ONLINE_FTRS_ARCHIVE ;
+    }
+    else
+        error("-input_format %s : unrecognised format\n",input_format_s) ;
+        
+    // Basic parameter checks
+    if ( strcmp( input_fname , "" ) == 0 )
+        error("input_fname undefined\n") ;
+    if ( strcmp( am_models_fname , "" ) == 0 )
+        error("am_models_fname undefined\n") ;
+    if ( strcmp( lex_dict_fname , "" ) == 0 )
+        error("lex_dict_fname undefined\n") ;
+    
+    // Some 2 parameter dependencies
+    if ( (strcmp(am_mlp_fname,"") != 0) && (am_input_vecs_are_ftrs == false) )
+        error("am_mlp_fname specified but input vectors are not features\n") ;
+    if ( (lm_ngram_order > 0) && (strcmp(lm_fname,"") == 0) )
+        error("lm_ngram_order > 0 but no LM file specified\n") ;
+}
+
+
+int main( int argc , char *argv[] )
+{
+    CmdLine cmd ;
+    DiskXFile::setBigEndianMode() ;
+
+    processCmdLine( &cmd , argc , argv ) ;
+    LexiconInfo lex_info( am_models_fname , am_sil_phone , am_pause_phone , lex_dict_fname , 
+                          lex_sent_start_word , lex_sent_end_word , lex_sil_word ) ;
+
+    PhoneModels phone_models ( lex_info.phone_info , am_models_fname ,
+                               am_input_vecs_are_ftrs , am_phone_del_pen , 
+                               am_apply_pause_del_pen , am_priors_fname , am_mlp_fname , 
+                               am_mlp_cw_size , am_norms_fname , am_online_norm_ftrs , 
+                               am_online_norm_alpha_m , am_online_norm_alpha_v ) ;
+
+    LinearLexicon lexicon( &lex_info , &phone_models ) ;
+
+    LanguageModel *lang_model ;
+    if ( lm_ngram_order <= 0 )
+        lang_model = NULL ;
+    else
+    {
+        lang_model = new LanguageModel( lm_ngram_order , lex_info.vocabulary , 
+                                        lm_fname , lm_scaling_factor ) ;
+    }
+
+    BeamSearchDecoder bs_decoder( &lexicon , lang_model , dec_word_entr_pen ,
+                                  dec_int_prune_window , dec_end_prune_window , 
+                                  dec_delayed_lm , dec_verbose ) ;
+
+    DecoderBatchTest batch_tester( input_fname , input_format , wrdtrns_fname , &bs_decoder , 
+                                   true , true , output_fname , output_ctm , msec_step_size ) ;
+    batch_tester.run() ;
+
+    if ( lang_model != NULL )
+        delete lang_model ; 
+    return(0) ;
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/discriminatives/boosting.cc work/main.d/Torch-3/examples/discriminatives/boosting.cc
--- tmp/Torch-3/examples/discriminatives/boosting.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/discriminatives/boosting.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,220 @@
+const char *help = "\
+BoostingTorch III (c) Trebolloc & Co 2002\n\
+\n\
+This program will boost a MLP (for classification) with log-softmax outputs.\n";
+
+#include "MatDataSet.h"
+#include "ClassFormatDataSet.h"
+#include "ClassNLLCriterion.h"
+#include "OneHotClassFormat.h"
+#include "ClassMeasurer.h"
+
+#include "StochasticGradient.h"
+#include "KFold.h"
+
+#include "MeanVarNorm.h"
+#include "DiskXFile.h"
+#include "CmdLine.h"
+#include "Random.h"
+
+#include "MLP.h"
+#include "WeightedSumMachine.h"
+#include "Boosting.h"
+
+using namespace Torch;
+
+int main(int argc, char **argv)
+{
+  char *valid_file;
+  char *file;
+
+  int n_inputs;
+  int n_targets;
+  int n_hu;
+
+  int max_load;
+  int max_load_valid;
+  real accuracy;
+  real learning_rate;
+  real decay;
+  int max_iter;
+  int the_seed;
+
+  char *dir_name;
+  char *model_file;
+  int k_fold;
+  bool binary_mode;
+  real weight_decay;
+  int n_trainers;
+
+  Allocator *allocator = new Allocator;
+  DiskXFile::setLittleEndianMode();
+
+  //=================== The command-line ==========================
+
+  // Construct the command line
+  CmdLine cmd;
+
+  // Put the help line at the beginning
+  cmd.info(help);
+
+  // Train mode
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("file", &file, "the train file");
+  cmd.addICmdArg("n_inputs", &n_inputs, "input dimension of the data", true);
+  cmd.addICmdArg("n_targets", &n_targets, "output dimension of the data or # of classes", true);
+
+  cmd.addText("\nModel Options:");
+  cmd.addICmdOption("-nhu", &n_hu, 25, "number of hidden units", true);
+  cmd.addICmdOption("-n", &n_trainers, 25, "maximum number of boosting step", true);
+
+  cmd.addText("\nLearning Options:");
+  cmd.addICmdOption("-iter", &max_iter, 25, "max number of iterations");
+  cmd.addRCmdOption("-lr", &learning_rate, 0.01, "learning rate");
+  cmd.addRCmdOption("-e", &accuracy, 0.00001, "end accuracy");
+  cmd.addRCmdOption("-lrd", &decay, 0, "learning rate decay");
+  cmd.addICmdOption("-kfold", &k_fold, -1, "number of folds, if you want to do cross-validation");
+  cmd.addRCmdOption("-wd", &weight_decay, 0, "weight decay", true);
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-seed", &the_seed, -1, "the random seed");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addICmdOption("-load_valid", &max_load_valid, -1, "max number of examples to load for valid");
+  cmd.addSCmdOption("-valid", &valid_file, "", "validation file, if you want it");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addSCmdOption("-save", &model_file, "", "the model file");
+  cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+  // Test mode
+  cmd.addMasterSwitch("--test");
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("model", &model_file, "the model file");
+  cmd.addSCmdArg("file", &file, "the test file");
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+  // Read the command line
+  int mode = cmd.read(argc, argv);
+
+  DiskXFile *model = NULL;
+  if(mode == 1)
+  {
+    model = new(allocator) DiskXFile(model_file, "r");
+    cmd.loadXFile(model);
+  }
+
+  // If the user didn't give any random seed,
+  // generate a random random seed...
+  if(mode == 0)
+  {
+    if(the_seed == -1)
+      Random::seed();
+    else
+      Random::manualSeed((long)the_seed);
+  }
+  cmd.setWorkingDirectory(dir_name);
+
+
+  //=================== Create the MLP... =========================
+
+  OneHotClassFormat *class_format = new(allocator) OneHotClassFormat(n_targets);
+  Trainer **trainers = (Trainer **)allocator->alloc(sizeof(Trainer *)*n_trainers);
+  for(int i = 0; i < n_trainers; i++)
+  {
+    // MLP
+    MLP *mlp = NULL;
+    if(n_hu > 0)
+      mlp = new(allocator) MLP(4, n_inputs, "linear", n_hu,
+                               "tanh", n_hu, "linear", n_targets, "log-softmax", n_targets);
+    else
+      mlp = new(allocator) MLP(2, n_inputs, "linear", n_targets, "log-softmax", n_targets);
+    mlp->setWeightDecay(weight_decay);
+    mlp->setPartialBackprop();
+
+    // Criterion
+    ClassNLLCriterion *cllc = new(allocator) ClassNLLCriterion(class_format);
+
+    // Trainer
+    trainers[i] = new(allocator) StochasticGradient(mlp, cllc);
+    if(mode == 0)
+    {
+      trainers[i]->setIOption("max iter", max_iter);
+      trainers[i]->setROption("end accuracy", accuracy);
+      trainers[i]->setROption("learning rate", learning_rate);
+      trainers[i]->setROption("learning rate decay", decay);
+    }
+  }
+
+  WeightedSumMachine wsm(trainers, n_trainers, NULL);
+  if(mode == 1)
+    wsm.loadXFile(model);
+
+  //=================== DataSets & Measurers... ===================
+
+  // Create the training dataset (normalize inputs)
+  MatDataSet *mat_data = new(allocator) MatDataSet(file, n_inputs, 1, false, max_load, binary_mode);
+  MeanVarNorm *mv_norm = new(allocator) MeanVarNorm(mat_data);
+  if(mode == 1)
+    mv_norm->loadXFile(model);
+  mat_data->preProcess(mv_norm);
+  DataSet *data = new(allocator) ClassFormatDataSet(mat_data, n_targets);
+  
+  // The list of measurers...
+  MeasurerList measurers;
+
+  // The validation set...
+  if(mode == 0)
+  {
+    // Create a validation set, if any
+    if(strcmp(valid_file, ""))
+    {
+      // Load the validation set and normalize it with the
+      // values in the train dataset
+      MatDataSet *valid_mat_data = new(allocator) MatDataSet(valid_file, n_inputs, 1, false, max_load_valid, binary_mode);
+      valid_mat_data->preProcess(mv_norm);
+      DataSet *valid_data = new(allocator) ClassFormatDataSet(valid_mat_data, n_targets);
+      
+      ClassMeasurer *valid_class_meas = new(allocator) ClassMeasurer(wsm.outputs, valid_data, class_format, cmd.getXFile("the_valid_class_err"));
+      measurers.addNode(valid_class_meas);
+    }
+  }
+  
+  // Measurers on the training dataset
+  ClassMeasurer *class_meas = new(allocator) ClassMeasurer(wsm.outputs, data, class_format, cmd.getXFile("the_class_err"));
+  measurers.addNode(class_meas);
+  
+  //=================== The Trainer ===============================
+
+  Boosting boosting(&wsm, class_format);
+
+  //=================== Let's go... ===============================
+
+  if(mode == 0)
+  {
+    if(k_fold <= 0)
+    {
+      boosting.train(data, &measurers);
+      
+      if(strcmp(model_file, ""))
+      {
+        DiskXFile model_(model_file, "w");
+        cmd.saveXFile(&model_);
+        wsm.saveXFile(&model_);
+        mv_norm->saveXFile(&model_);
+      }
+    }
+    else
+    {
+      KFold k(&boosting, k_fold);
+      k.crossValidate(data, NULL, &measurers);
+    }
+  }
+  else
+    boosting.test(&measurers);
+
+  delete allocator;
+  return(0);
+}
Binary files tmp/Torch-3/examples/discriminatives/data/test_data.gz and work/main.d/Torch-3/examples/discriminatives/data/test_data.gz differ
Binary files tmp/Torch-3/examples/discriminatives/data/train_data.gz and work/main.d/Torch-3/examples/discriminatives/data/train_data.gz differ
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/discriminatives/knn.cc work/main.d/Torch-3/examples/discriminatives/knn.cc
--- tmp/Torch-3/examples/discriminatives/knn.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/discriminatives/knn.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,210 @@
+const char *help = "\
+KNNTorch III (c) Trebolloc & Co 2002\n\
+\n\
+This program will train a KNN.\n";
+
+#include "MatDataSet.h"
+#include "ClassFormatDataSet.h"
+#include "ClassNLLCriterion.h"
+#include "MSECriterion.h"
+#include "OneHotClassFormat.h"
+#include "ClassMeasurer.h"
+#include "MSEMeasurer.h"
+
+#include "NPTrainer.h"
+#include "KFold.h"
+#include "KNN.h"
+
+#include "MeanVarNorm.h"
+#include "CmdLine.h"
+#include "Random.h"
+
+using namespace Torch;
+
+int main(int argc, char **argv)
+{
+  char *file;
+  char *test_file;
+
+  int n_inputs;
+  int n_targets;
+
+  int max_load;
+  int test_max_load;
+
+  char *dir_name;
+  int k_fold;
+  bool binary_mode;
+  bool regression_mode;
+  bool normalize;
+  int k_n;
+
+  Allocator *allocator = new Allocator;
+
+  //=================== The command-line ==========================
+
+  // Construct the command line
+  CmdLine cmd;
+
+  // Put the help line at the beginning
+  cmd.info(help);
+
+  // Train mode
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("file", &file, "the 'train' file");
+  cmd.addICmdArg("n_inputs", &n_inputs, "input dimension of the data");
+  cmd.addICmdArg("n_targets", &n_targets, "output dimension of the data or # of classes");
+
+  cmd.addText("\nModel Options:");
+  cmd.addICmdOption("-K", &k_n, 3, "number of neighboors");
+  cmd.addBCmdOption("-rm", &regression_mode, false, "regression mode ?");
+
+  cmd.addText("\nLearning Options:");
+  cmd.addBCmdOption("-norm", &normalize, false, "want to normalize data ?");
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-kfold", &k_fold, -1, "number of folds, if you want to do cross-validation");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addICmdOption("-load_valid", &test_max_load, -1, "max number of examples to load for test");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+  // Test mode
+  cmd.addMasterSwitch("--test");
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("file", &file, "the 'train' file");
+  cmd.addSCmdArg("test file", &test_file, "the test file");
+  cmd.addICmdArg("n_inputs", &n_inputs, "input dimension of the data");
+  cmd.addICmdArg("n_targets", &n_targets, "output dimension of the data or # of classes");
+
+  cmd.addText("\nModel Options:");
+  cmd.addICmdOption("-K", &k_n, 3, "number of neighboors");
+  cmd.addBCmdOption("-rm", &regression_mode, false, "regression mode ?");
+
+  cmd.addText("\nLearning Options:");
+  cmd.addBCmdOption("-norm", &normalize, false, "want to normalize data ?");
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addICmdOption("-load_test", &test_max_load, -1, "max number of examples to load for test");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+  // Read the command line
+  int mode = cmd.read(argc, argv);
+
+  cmd.setWorkingDirectory(dir_name);
+
+  //=================== DataSets... ===============================
+
+  // 'Train'
+  DataSet *data = NULL;
+  MeanVarNorm *mv_norm = NULL;
+  if(regression_mode)
+  {
+    data = new(allocator) MatDataSet(file, n_inputs, n_targets, false, max_load, binary_mode);
+    if(normalize)
+    {
+      mv_norm = new(allocator) MeanVarNorm(data);
+      data->preProcess(mv_norm);
+    }
+  }
+  else
+  {
+    MatDataSet *mat_data = new(allocator) MatDataSet(file, n_inputs, 1, false, max_load, binary_mode);
+    if(normalize)
+    {
+      mv_norm = new(allocator) MeanVarNorm(mat_data);
+      mat_data->preProcess(mv_norm);
+    }
+    data = new(allocator) ClassFormatDataSet(mat_data, n_targets);
+  }
+
+  // 'Test'
+  DataSet *test_data = NULL;
+  if(mode == 1)
+  {
+    if(regression_mode)
+    {
+      test_data = new(allocator) MatDataSet(test_file, n_inputs, n_targets, false, test_max_load, binary_mode);
+      if(normalize)
+        data->preProcess(mv_norm);
+    }
+    else
+    {
+      MatDataSet *test_mat_data = new(allocator) MatDataSet(test_file, n_inputs, 1, false, test_max_load, binary_mode);
+      if(normalize)
+        test_mat_data->preProcess(mv_norm);
+      test_data = new(allocator) ClassFormatDataSet(test_mat_data, n_targets);
+    }
+  }
+
+  //=================== The beast... ==============================
+  
+  KNN knn(n_targets, k_n);
+
+  //=================== Measurers... ==============================
+
+  // The list of measurers...
+  MeasurerList measurers;
+
+  // The class format
+  OneHotClassFormat *class_format = NULL;
+  if(!regression_mode)
+    class_format = new(allocator) OneHotClassFormat(n_targets);
+
+  // Measurers on the training dataset
+  if(regression_mode)
+  {
+    MSEMeasurer *mse_meas = new(allocator) MSEMeasurer(knn.outputs, data, cmd.getXFile("the_mse_err"));
+    measurers.addNode(mse_meas);
+  }
+  else
+  {
+    ClassMeasurer *class_meas = new(allocator) ClassMeasurer(knn.outputs, data, class_format, cmd.getXFile("the_class_err"));
+    measurers.addNode(class_meas);
+  }
+
+  // Measurers on the test dataset
+  if(mode == 1)
+  {
+    if(regression_mode)
+    {
+      MSEMeasurer *mse_meas = new(allocator) MSEMeasurer(knn.outputs, test_data, cmd.getXFile("the_test_mse_err"));
+      measurers.addNode(mse_meas);
+    }
+    else
+    {
+      ClassMeasurer *class_meas = new(allocator) ClassMeasurer(knn.outputs, test_data, class_format, cmd.getXFile("the_test_class_err"));
+      measurers.addNode(class_meas);
+    }
+  }
+  
+  //=================== The Trainer ===============================
+  
+  NPTrainer trainer(&knn);
+
+  //=================== Let's go... ===============================
+
+  if(mode == 0)
+  {
+    if(k_fold <= 0)
+    {
+      trainer.train(data, NULL);
+      trainer.test(&measurers);
+    }
+    else
+    {
+      KFold k(&trainer, k_fold);
+      k.crossValidate(data, NULL, &measurers);
+    }
+  }
+  else
+  {
+    trainer.train(data, NULL);
+    trainer.test(&measurers);
+  }
+
+  delete allocator;
+  return(0);
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/discriminatives/Makefile work/main.d/Torch-3/examples/discriminatives/Makefile
--- tmp/Torch-3/examples/discriminatives/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/discriminatives/Makefile	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,20 @@
+#
+# Torch user Makefile example
+#
+
+# Torch location.
+# Make sure to specify correct location...
+
+TORCHDIR := $(shell cd ../..; pwd)
+
+#
+# All that follows you can probably keep as is...
+#
+
+OS := $(shell uname -s)
+include $(TORCHDIR)/Makefile_options_$(OS)
+
+%: %.cc
+	cd $(TORCHDIR); ${MAKE}
+	mkdir -p $(VERSION_KEY)
+	$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $(VERSION_KEY)/$@ $< $(LIBS)
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/discriminatives/mlp.cc work/main.d/Torch-3/examples/discriminatives/mlp.cc
--- tmp/Torch-3/examples/discriminatives/mlp.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/discriminatives/mlp.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,328 @@
+const char *help = "\
+MLPTorch III (c) Trebolloc & Co 2003\n\
+\n\
+This program will train a MLP with log-softmax outputs\n\
+for classification and linear outputs for regression.\n\
+For classification, the criterion will be a cross-entropy criterion.\n\
+For regression, it uses a mean-squared error criterion.\n";
+
+#include "MatDataSet.h"
+#include "ClassFormatDataSet.h"
+#include "ClassNLLCriterion.h"
+#include "MSECriterion.h"
+#include "OneHotClassFormat.h"
+#include "ClassMeasurer.h"
+#include "MSEMeasurer.h"
+
+#include "StochasticGradient.h"
+#include "KFold.h"
+
+#include "ConnectedMachine.h"
+#include "Linear.h"
+#include "Tanh.h"
+#include "LogSoftMax.h"
+
+#include "MeanVarNorm.h"
+#include "DiskXFile.h"
+#include "CmdLine.h"
+#include "Random.h"
+
+using namespace Torch;
+
+int main(int argc, char **argv)
+{
+  char *valid_file;
+  char *file;
+
+  int n_inputs;
+  int n_targets;
+  int n_hu;
+
+  int max_load;
+  int max_load_valid;
+  real accuracy;
+  real learning_rate;
+  real decay;
+  int max_iter;
+  int the_seed;
+
+  char *dir_name;
+  char *model_file;
+  int k_fold;
+  bool binary_mode;
+  real weight_decay;
+  bool regression_mode;
+  int class_against_the_others;
+  int n_outputs;
+
+  Allocator *allocator = new Allocator;
+  DiskXFile::setLittleEndianMode();
+
+  //=================== The command-line ==========================
+
+  // Construct the command line
+  CmdLine cmd;
+
+  // Put the help line at the beginning
+  cmd.info(help);
+
+  // Train mode
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("file", &file, "the train file");
+  cmd.addICmdArg("n_inputs", &n_inputs, "input dimension of the data", true);
+  cmd.addICmdArg("n_targets", &n_targets, "output dim. (regression) or # of classes (classification)", true);
+
+  cmd.addText("\nModel Options:");
+  cmd.addICmdOption("-class", &class_against_the_others, -1, "train the given class against the others", true);
+  cmd.addICmdOption("-nhu", &n_hu, 25, "number of hidden units", true);
+  cmd.addBCmdOption("-rm", &regression_mode, false, "regression mode ?", true);
+
+  cmd.addText("\nLearning Options:");
+  cmd.addICmdOption("-iter", &max_iter, 25, "max number of iterations");
+  cmd.addRCmdOption("-lr", &learning_rate, 0.01, "learning rate");
+  cmd.addRCmdOption("-e", &accuracy, 0.00001, "end accuracy");
+  cmd.addRCmdOption("-lrd", &decay, 0, "learning rate decay");
+  cmd.addICmdOption("-kfold", &k_fold, -1, "number of folds, if you want to do cross-validation");
+  cmd.addRCmdOption("-wd", &weight_decay, 0, "weight decay", true);
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-seed", &the_seed, -1, "the random seed");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addICmdOption("-load_valid", &max_load_valid, -1, "max number of examples to load for valid");
+  cmd.addSCmdOption("-valid", &valid_file, "", "validation file, if you want it");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addSCmdOption("-save", &model_file, "", "the model file");
+  cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+  // Test mode
+  cmd.addMasterSwitch("--test");
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("model", &model_file, "the model file");
+  cmd.addSCmdArg("file", &file, "the test file");
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+  // Read the command line
+  int mode = cmd.read(argc, argv);
+
+  DiskXFile *model = NULL;
+  if(mode == 1)
+  {
+    model = new(allocator) DiskXFile(model_file, "r");
+    cmd.loadXFile(model);
+  }
+
+  // If the user didn't give any random seed,
+  // generate a random random seed...
+  if(mode == 0)
+  {
+    if(the_seed == -1)
+      Random::seed();
+    else
+      Random::manualSeed((long)the_seed);
+  }
+  cmd.setWorkingDirectory(dir_name);
+
+  if( (class_against_the_others >= 0) && (!regression_mode) )
+    n_outputs = 2;
+  else
+    n_outputs = n_targets;
+
+  //=================== Create the MLP... =========================
+  ConnectedMachine mlp;
+
+  if(n_hu > 0)
+  {
+    Linear *c1 = new(allocator) Linear(n_inputs, n_hu);
+    c1->setROption("weight decay", weight_decay);
+    Tanh *c2 = new(allocator) Tanh(n_hu);
+    Linear *c3 = new(allocator) Linear(n_hu, n_outputs);
+    c3->setROption("weight decay", weight_decay);
+
+    mlp.addFCL(c1);    
+    mlp.addFCL(c2);
+    mlp.addFCL(c3);
+
+    if(!regression_mode)
+    {
+      LogSoftMax *c4 = new(allocator) LogSoftMax(n_outputs);
+      mlp.addFCL(c4);
+    }
+  }
+  else
+  {
+    Linear *c1 = new(allocator) Linear(n_inputs, n_outputs);
+    c1->setROption("weight decay", weight_decay);
+    mlp.addFCL(c1);
+
+    if(!regression_mode)
+    {
+      LogSoftMax *c2 = new(allocator) LogSoftMax(n_outputs);    
+      mlp.addFCL(c2);
+    }
+  }
+
+  // Initialize the MLP
+  mlp.build();
+  mlp.setPartialBackprop();
+
+  //=================== DataSets & Measurers... ===================
+
+  // Create the training dataset (normalize inputs)
+  DataSet *data = NULL;
+  MeanVarNorm *mv_norm = NULL;
+  Sequence *class_labels = NULL;
+  if(regression_mode)
+  {
+    data = new(allocator) MatDataSet(file, n_inputs, n_targets, false, max_load, binary_mode);
+    mv_norm = new(allocator) MeanVarNorm(data);
+    if(mode == 1)
+      mv_norm->loadXFile(model);
+    data->preProcess(mv_norm);
+  }
+  else
+  {
+    MatDataSet *mat_data = new(allocator) MatDataSet(file, n_inputs, 1, false, max_load, binary_mode);
+    mv_norm = new(allocator) MeanVarNorm(mat_data);
+    if(mode == 1)
+      mv_norm->loadXFile(model);
+    mat_data->preProcess(mv_norm);
+
+    if(class_against_the_others >= 0)
+    {
+      class_labels = new(allocator) Sequence(n_targets, n_outputs);
+      for(int i = 0; i < n_targets; i++)
+      {
+        if(i == class_against_the_others)
+        {
+          class_labels->frames[i][0] =  1;
+          class_labels->frames[i][1] =  0;
+        }
+        else
+        {
+          class_labels->frames[i][0] =  0;
+          class_labels->frames[i][1] =  1;
+        }
+      }
+      message("Training/Testing class %d against the others", class_against_the_others);
+      data = new(allocator) ClassFormatDataSet(mat_data, class_labels);
+    }
+    else
+      data = new(allocator) ClassFormatDataSet(mat_data, n_targets);
+  }
+
+  if(mode == 1)
+    mlp.loadXFile(model);
+
+  // The list of measurers...
+  MeasurerList measurers;
+
+  // The class format
+  OneHotClassFormat *class_format = NULL;
+  if(!regression_mode)
+    class_format = new(allocator) OneHotClassFormat(n_outputs);
+
+  // The validation set...
+  if(mode == 0)
+  {
+    // Create a validation set, if any
+    if(strcmp(valid_file, ""))
+    {
+      // Load the validation set and normalize it with the
+      // values in the train dataset
+      DataSet *valid_data = NULL;
+      if(regression_mode)
+      {
+        valid_data = new(allocator) MatDataSet(valid_file, n_inputs, n_targets, false, max_load_valid, binary_mode);
+        valid_data->preProcess(mv_norm);
+      }
+      else
+      {
+        MatDataSet *valid_mat_data = new(allocator) MatDataSet(valid_file, n_inputs, 1, false, max_load_valid, binary_mode);
+        valid_mat_data->preProcess(mv_norm);
+
+        if(class_against_the_others >= 0)
+          valid_data = new(allocator) ClassFormatDataSet(valid_mat_data, class_labels);
+        else
+          valid_data = new(allocator) ClassFormatDataSet(valid_mat_data, n_targets);
+      }
+      
+      if(regression_mode)
+      {
+        MSEMeasurer *valid_mse_meas = new(allocator) MSEMeasurer(mlp.outputs, valid_data, cmd.getXFile("the_valid_mse_err"));
+        measurers.addNode(valid_mse_meas);
+      }
+      else
+      {
+        ClassMeasurer *valid_class_meas = new(allocator) ClassMeasurer(mlp.outputs, valid_data, class_format, cmd.getXFile("the_valid_class_err"));
+        measurers.addNode(valid_class_meas);
+      }
+    }
+  }
+  
+  // Measurers on the training dataset
+  if(regression_mode)
+  {
+    MSEMeasurer *mse_meas = new(allocator) MSEMeasurer(mlp.outputs, data, cmd.getXFile("the_mse_err"));
+    measurers.addNode(mse_meas);
+  }
+  else
+  {
+    ClassMeasurer *class_meas = new(allocator) ClassMeasurer(mlp.outputs, data, class_format, cmd.getXFile("the_class_err"));
+    measurers.addNode(class_meas);
+  }
+  
+  //=================== The Trainer ===============================
+  
+  // The criterion for the StochasticGradient (MSE criterion or NLL criterion)
+  Criterion *criterion = NULL;
+  if(regression_mode)
+    criterion = new(allocator) MSECriterion(n_outputs);
+  else
+    criterion = new(allocator) ClassNLLCriterion(class_format);
+
+  // The Gradient Machine Trainer
+  StochasticGradient trainer(&mlp, criterion);
+  if(mode == 0)
+  {
+    trainer.setIOption("max iter", max_iter);
+    trainer.setROption("end accuracy", accuracy);
+    trainer.setROption("learning rate", learning_rate);
+    trainer.setROption("learning rate decay", decay);
+  }
+
+  //=================== Let's go... ===============================
+
+  // Print the number of parameter of the MLP (just for fun)
+  message("Number of parameters: %d", mlp.params->n_params);
+
+  if(mode == 0)
+  {
+    if(k_fold <= 0)
+    {
+      trainer.train(data, &measurers);
+      
+      if(strcmp(model_file, ""))
+      {
+        DiskXFile model_(model_file, "w");
+        cmd.saveXFile(&model_);
+        mv_norm->saveXFile(&model_);
+        mlp.saveXFile(&model_);
+      }
+    }
+    else
+    {
+      KFold k(&trainer, k_fold);
+      k.crossValidate(data, NULL, &measurers);
+    }
+  }
+  else
+    trainer.test(&measurers);
+
+  delete allocator;
+
+  return(0);
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/discriminatives/README work/main.d/Torch-3/examples/discriminatives/README
--- tmp/Torch-3/examples/discriminatives/README	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/discriminatives/README	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,46 @@
+---------------------------------------------------
+
+Some examples to learn how to *program* in Torch3.
+Of course you can use them without any changes,
+but you will not use 1/10 of the library if you
+don't want to code something!
+
+boosting.cc:  adaboost with MLP in classification.
+knn.cc:       K-nearest-neighbors algorithm.
+mlp.cc:       multi-layered perceptron.
+svm.cc:       support vector machines.
+svm_multi.cc: SVM with more than two classes.
+
+---------------------------------------------------
+
+You will find two examples of datasets in data/.
+Torch3 is able to deal directly with gziped data,
+but you can uncompress them if you want to have a
+look. (Or do a zless, zcat, zmore).
+
+These data are classification data: there is 784
+inputs (the first 784 columns) and the 1 target
+which can take values between 0..9. (10 classes).
+
+---------------------------------------------------
+
+Examples of command line:
+
+Linux_OPT_FLOAT/boosting -nhu 5 -iter 20 -n 5 -valid data/test_data.gz data/train_data.gz 784 10
+
+Linux_OPT_FLOAT/knn -kfold 10 -K 3 data/train_data.gz 784 10
+
+Linux_OPT_FLOAT/mlp -nhu 10 -iter 20 -save model data/train_data.gz 784 10
+Linux_OPT_FLOAT/mlp --test model data/test_data.gz
+Linux_OPT_FLOAT/mlp -kfold 10 -nhu 10 -iter 20 data/train_data.gz 784 10
+
+Linux_OPT_FLOAT/svm -std 1650 -class 9 data/train_data.gz model
+Linux_OPT_FLOAT/svm --test model data/test_data.gz
+Linux_OPT_FLOAT/svm --kfold -std 1650 -class 9 data/train_data.gz 10
+
+Linux_OPT_FLOAT/svm_multi -std 1650 data/train_data.gz model 10
+Linux_OPT_FLOAT/svm_multi --test model data/test_data.gz
+
+For each command line, results are in the_class_err or the_valid_class_err.
+
+---------------------------------------------------
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/discriminatives/svm.cc work/main.d/Torch-3/examples/discriminatives/svm.cc
--- tmp/Torch-3/examples/discriminatives/svm.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/discriminatives/svm.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,281 @@
+const char *help = "\
+SVMTorch III (c) Trebolloc & Co 2002\n\
+\n\
+This program will train a SVM for classification or regression\n\
+with a gaussian kernel (default) or a polynomial kernel.\n\
+It supposes that the file you provide contains two classes,\n\
+except if you use the '-class' option which trains one class\n\
+against the others.\n";
+
+#include "MatDataSet.h"
+#include "TwoClassFormat.h"
+#include "ClassMeasurer.h"
+#include "MSEMeasurer.h"
+#include "QCTrainer.h"
+#include "CmdLine.h"
+#include "Random.h"
+#include "SVMRegression.h"
+#include "SVMClassification.h"
+#include "KFold.h"
+#include "DiskXFile.h"
+#include "ClassFormatDataSet.h"
+#include "MeanVarNorm.h"
+
+using namespace Torch;
+
+int main(int argc, char **argv)
+{
+  char *file;
+  real c_cst, stdv, eps_regression;
+  bool regression;
+  real accuracy, cache_size;
+  int iter_shrink, k_fold;
+  int the_seed;
+  int max_load;
+  char *dir_name;
+  char *model_file;
+  bool binary_mode;
+  int class_against_the_others;
+  int degree;
+  real a_cst, b_cst;
+  bool normalize;
+
+  Allocator *allocator = new Allocator;
+
+  //=================== The command-line ==========================
+
+  // Construct the command line
+  CmdLine cmd;
+
+  // Put the help line at the beginning
+  cmd.info(help);
+
+  // Train mode
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("file", &file, "the train file");
+  cmd.addSCmdArg("model", &model_file, "the model file");
+
+  cmd.addText("\nModel Options:");
+  cmd.addRCmdOption("-c", &c_cst, 100., "trade off cst between error/margin");
+  cmd.addRCmdOption("-std", &stdv, 10., "the std parameter in the gaussian kernel [exp(-|x-y|^2/std^2)]", true);
+
+  cmd.addICmdOption("-degree", &degree, -1, "if positive, use a polynomial kernel [(a xy + b)^d] with the specified degree", true);
+  cmd.addRCmdOption("-a", &a_cst, 1., "constant a in the polynomial kernel", true);
+  cmd.addRCmdOption("-b", &b_cst, 1., "constant b in the polynomial kernel", true);
+
+  cmd.addBCmdOption("-rm", &regression, false, "regression mode", true);
+  cmd.addRCmdOption("-eps", &eps_regression, 0.7, "eps tube in regression");
+  cmd.addICmdOption("-class", &class_against_the_others, -1, "train the given class against the others", true);
+
+  cmd.addText("\nLearning Options:");
+  cmd.addBCmdOption("-norm", &normalize, false, "normalize the data (mean/stdv)?", true);
+  cmd.addRCmdOption("-e", &accuracy, 0.01, "end accuracy");
+  cmd.addRCmdOption("-m", &cache_size, 50., "cache size in Mo");
+  cmd.addICmdOption("-h", &iter_shrink, 100, "minimal number of iterations before shrinking");
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-seed", &the_seed, -1, "the random seed");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+  // KFold mode (one difference with previous mode: no model is available)
+  cmd.addMasterSwitch("--kfold");
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("file", &file, "the train file");
+  cmd.addICmdArg("k", &k_fold, "number of folds");
+
+  cmd.addText("\nModel Options:");
+  cmd.addRCmdOption("-c", &c_cst, 100., "trade off cst between error/margin");
+  cmd.addRCmdOption("-std", &stdv, 10., "the std parameter in the gaussian kernel", true);
+
+  cmd.addICmdOption("-degree", &degree, -1, "if positive, use a polynomial kernel [(a xy + b)^d] with the specified degree", true);
+  cmd.addRCmdOption("-a", &a_cst, 1., "constant a in the polynomial kernel", true);
+  cmd.addRCmdOption("-b", &b_cst, 1., "constant b in the polynomial kernel", true);
+
+  cmd.addBCmdOption("-rm", &regression, false, "regression mode", true);
+  cmd.addRCmdOption("-eps", &eps_regression, 0.7, "eps tube in regression");
+  cmd.addICmdOption("-class", &class_against_the_others, -1, "train the given class against the others", true);
+
+  cmd.addText("\nLearning Options:");
+  cmd.addBCmdOption("-norm", &normalize, false, "normalize the data (mean/stdv)?", true);
+  cmd.addRCmdOption("-e", &accuracy, 0.01, "end accuracy");
+  cmd.addRCmdOption("-m", &cache_size, 50., "cache size in Mo");
+  cmd.addICmdOption("-h", &iter_shrink, 100, "minimal number of iterations before shrinking");
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-seed", &the_seed, -1, "the random seed");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+  // Test mode
+  cmd.addMasterSwitch("--test");
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("model", &model_file, "the model file");
+  cmd.addSCmdArg("file", &file, "the test file");
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for test");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+  // Read the command line
+  int mode = cmd.read(argc, argv);
+
+  DiskXFile *model = NULL;
+  if(mode == 2)
+  {
+    model = new(allocator) DiskXFile(model_file, "r");
+    cmd.loadXFile(model);
+  }
+
+  // If the user didn't give any random seed,
+  // generate a random random seed...
+  if(mode < 2)
+  {
+    if(the_seed == -1)
+      Random::seed();
+    else
+      Random::manualSeed((long)the_seed);
+  }
+  cmd.setWorkingDirectory(dir_name);
+
+  //=================== Create the SVM... =========================
+  SVM *svm = NULL;
+  Kernel *kernel = NULL;
+
+  if(degree > 0)
+    kernel = new(allocator) PolynomialKernel(degree, a_cst, b_cst);
+  else
+    kernel = new(allocator) GaussianKernel(1./(stdv*stdv));
+
+  if(regression)
+    svm = new(allocator) SVMRegression(kernel);
+  else
+    svm = new(allocator) SVMClassification(kernel);
+
+  if(mode < 2)
+  {
+    svm->setROption("C", c_cst);
+    svm->setROption("cache size", cache_size);
+    if(regression)
+      svm->setROption("eps regression", eps_regression);
+  }
+  //=================== DataSets & Measurers... ===================
+
+  // Create the training dataset
+  DataSet *data = NULL;
+  MeanVarNorm *mv_norm = NULL;
+  
+  if(regression)
+  {
+    data = new(allocator) MatDataSet(file, -1, 1, false, max_load, binary_mode);
+    if(normalize)
+    {
+      mv_norm = new(allocator) MeanVarNorm(data);
+      if(mode == 2)
+        mv_norm->loadXFile(model);
+      data->preProcess(mv_norm);
+    }
+  }
+  else
+  {
+    MatDataSet *mat_data = new(allocator) MatDataSet(file, -1, 1, false, max_load, binary_mode);
+    if(normalize)
+    {
+      mv_norm = new(allocator) MeanVarNorm(mat_data);
+      if(mode == 2)
+        mv_norm->loadXFile(model);
+      mat_data->preProcess(mv_norm);
+    }
+    Sequence *class_labels = NULL;
+    if(class_against_the_others >= 0)
+    {
+      int n_classes = -1;
+      for(int t = 0; t < mat_data->n_examples; t++)
+      {
+        mat_data->setExample(t);
+        int z =  (int)mat_data->targets->frames[0][0];
+        if(z > n_classes)
+          n_classes = z;
+      }
+      n_classes++;
+      message("Training/testing class %d against the others (%d classes detected)", class_against_the_others, n_classes);
+
+      class_labels = new(allocator) Sequence(n_classes, 1);
+      for(int i = 0; i < n_classes; i++)
+      {
+        if(i == class_against_the_others)
+          class_labels->frames[i][0] =  1;
+        else
+          class_labels->frames[i][0] = -1;
+      }
+    }
+    else
+    {
+      class_labels = new(allocator) Sequence(2, 1);
+      class_labels->frames[0][0] = -1;
+      class_labels->frames[1][0] = 1;
+    }
+    data = new(allocator) ClassFormatDataSet(mat_data, class_labels);
+  }
+
+  // The list of measurers...
+  MeasurerList measurers;
+  if(mode > 0)
+  {
+    if(regression)
+    {
+      MSEMeasurer *mse_meas = new(allocator) MSEMeasurer(svm->outputs, data, cmd.getXFile("the_mse_err"));
+      measurers.addNode(mse_meas);
+    }
+    else
+    {
+      TwoClassFormat *class_format = new(allocator) TwoClassFormat(data);
+      ClassMeasurer *class_meas = new(allocator) ClassMeasurer(svm->outputs, data, class_format, cmd.getXFile("the_class_err"));
+      measurers.addNode(class_meas);
+    }
+  }
+
+  // Reload the model in test mode
+  if(mode == 2)
+    svm->loadXFile(model);
+  
+  //=================== The Trainer ===============================
+
+  QCTrainer trainer(svm);
+  if(mode == 0)
+  {
+    trainer.setROption("end accuracy", accuracy);
+    trainer.setIOption("iter shrink", iter_shrink);
+  }
+
+  //=================== Let's go... ===============================
+
+  // Train
+  if(mode == 0)
+  {
+    trainer.train(data, NULL);
+    message("%d SV with %d at bounds", svm->n_support_vectors, svm->n_support_vectors_bound);
+    DiskXFile model_(model_file, "w");
+    cmd.saveXFile(&model_);
+    if(normalize)
+      mv_norm->saveXFile(&model_);
+    svm->saveXFile(&model_);
+  }
+
+  // KFold
+  if(mode == 1)
+  {
+    KFold k(&trainer, k_fold);
+    k.crossValidate(data, NULL, &measurers);
+  }
+
+  // Test
+  if(mode == 2)
+    trainer.test(&measurers);
+
+  delete allocator;
+  return(0);
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/discriminatives/svm_multi.cc work/main.d/Torch-3/examples/discriminatives/svm_multi.cc
--- tmp/Torch-3/examples/discriminatives/svm_multi.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/discriminatives/svm_multi.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,190 @@
+const char *help = "\
+SVMTorch Multi III (c) Trebolloc & Co 2002\n\
+\n\
+This program will train several SVMs, for classification with\n\
+more than two classes, using a one-against-all approach.\n\
+It uses a gaussian kernel (default) or a polynomial kernel.\n";
+
+#include "MatDataSet.h"
+#include "OneHotClassFormat.h"
+#include "ClassMeasurer.h"
+#include "MSEMeasurer.h"
+#include "QCTrainer.h"
+#include "CmdLine.h"
+#include "Random.h"
+#include "SVMClassification.h"
+#include "DiskXFile.h"
+#include "ClassFormatDataSet.h"
+
+using namespace Torch;
+
+int main(int argc, char **argv)
+{
+  char *file;
+  real c_cst, stdv;
+  real accuracy, cache_size;
+  int iter_shrink;
+  int the_seed;
+  int max_load;
+  char *dir_name;
+  char *model_file;
+  bool binary_mode;
+  int degree;
+  real a_cst, b_cst;
+  int n_classes;
+
+  Allocator *allocator = new Allocator;
+
+  //=================== The command-line ==========================
+
+  // Construct the command line
+  CmdLine cmd;
+
+  // Put the help line at the beginning
+  cmd.info(help);
+
+  // Train mode
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("file", &file, "the train file");
+  cmd.addSCmdArg("model", &model_file, "the model file");
+  cmd.addICmdArg("# classes", &n_classes, "the number of classes", true);
+
+  cmd.addText("\nModel Options:");
+  cmd.addRCmdOption("-c", &c_cst, 100., "trade off cst between error/margin");
+  cmd.addRCmdOption("-std", &stdv, 10., "the std parameter in the gaussian kernel [exp(-|x-y|^2/std^2)]", true);
+
+  cmd.addICmdOption("-degree", &degree, -1, "if positive, use a polynomial kernel [(a xy + b)^d] with the specified degree", true);
+  cmd.addRCmdOption("-a", &a_cst, 1., "constant a in the polynomial kernel", true);
+  cmd.addRCmdOption("-b", &b_cst, 1., "constant b in the polynomial kernel", true);
+
+  cmd.addText("\nLearning Options:");
+  cmd.addRCmdOption("-e", &accuracy, 0.01, "end accuracy");
+  cmd.addRCmdOption("-m", &cache_size, 50., "cache size in Mo");
+  cmd.addICmdOption("-h", &iter_shrink, 100, "minimal number of iterations before shrinking");
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-seed", &the_seed, -1, "the random seed");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+  // Test mode
+  cmd.addMasterSwitch("--test");
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("model", &model_file, "the model file");
+  cmd.addSCmdArg("file", &file, "the test file");
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for test");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+  // Read the command line
+  int mode = cmd.read(argc, argv);
+
+  DiskXFile *model = NULL;
+  if(mode == 1)
+  {
+    model = new(allocator) DiskXFile(model_file, "r");
+    cmd.loadXFile(model);
+  }
+
+  // If the user didn't give any random seed,
+  // generate a random random seed...
+  if(mode == 0)
+  {
+    if(the_seed == -1)
+      Random::seed();
+    else
+      Random::manualSeed((long)the_seed);
+  }
+  cmd.setWorkingDirectory(dir_name);
+
+  //=================== Create the SVMs... =========================
+  Kernel *kernel = NULL;
+  if(degree > 0)
+    kernel = new(allocator) PolynomialKernel(degree, a_cst, b_cst);
+  else
+    kernel = new(allocator) GaussianKernel(1./(stdv*stdv));
+
+  SVM **svms = (SVM **)allocator->alloc(sizeof(SVM *)*n_classes);
+  for(int i = 0; i < n_classes; i++)
+  {
+    svms[i] = new(allocator) SVMClassification(kernel);
+
+    if(mode == 0)
+    {
+      svms[i]->setROption("C", c_cst);
+      svms[i]->setROption("cache size", cache_size);
+    }
+  }
+
+  //=================== DataSets & Measurers... ===================
+
+  // Create the training dataset
+  MatDataSet *mat_data = new(allocator) MatDataSet(file, -1, 1, false, max_load, binary_mode);
+
+  // Reload the model in test mode
+  if(mode == 1)
+  {
+    for(int i = 0; i < n_classes; i++)
+      svms[i]->loadXFile(model);
+  }
+  
+  //=================== Let's go... ===============================
+
+  // Train
+  if(mode == 0)
+  {
+    DiskXFile model_(model_file, "w");
+    cmd.saveXFile(&model_);
+
+    for(int i = 0; i < n_classes; i++)
+    {
+      message("Training class %d against the others", i);
+      QCTrainer trainer(svms[i]);
+      trainer.setROption("end accuracy", accuracy);
+      trainer.setIOption("iter shrink", iter_shrink);
+
+      Sequence class_labels(n_classes, 1);
+      for(int j = 0; j < n_classes; j++)
+      {
+        if(j == i)
+          class_labels.frames[j][0] =  1;
+        else
+          class_labels.frames[j][0] = -1;
+      }
+      ClassFormatDataSet data(mat_data, &class_labels);
+
+      trainer.train(&data, NULL);
+      message("%d SV with %d at bounds", svms[i]->n_support_vectors, svms[i]->n_support_vectors_bound);
+      svms[i]->saveXFile(&model_);
+    }
+  }
+
+  // Test
+  if(mode == 1)
+  {
+    OneHotClassFormat class_format(n_classes);
+    int n_errors = 0;
+    real *buffer = (real *)allocator->alloc(sizeof(real)*n_classes);
+    for(int t = 0; t < mat_data->n_examples; t++)
+    {
+      mat_data->setExample(t);
+      for(int i = 0; i < n_classes; i++)
+      {
+        svms[i]->forward(mat_data->inputs);
+        buffer[i] = svms[i]->outputs->frames[0][0];
+      }
+      
+      int the_class = (int)mat_data->targets->frames[0][0];
+      if(the_class != class_format.getClass(buffer))
+        n_errors++;
+    }
+
+    message("%g%% of missclassification. (%d errors)", ((real)n_errors)/((real)mat_data->n_examples)*100., n_errors);
+  }
+
+  delete allocator;
+  return(0);
+}
Binary files tmp/Torch-3/examples/generatives/data/test.amat.gz and work/main.d/Torch-3/examples/generatives/data/test.amat.gz differ
Binary files tmp/Torch-3/examples/generatives/data/train.amat.gz and work/main.d/Torch-3/examples/generatives/data/train.amat.gz differ
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/generatives/gmm.cc work/main.d/Torch-3/examples/generatives/gmm.cc
--- tmp/Torch-3/examples/generatives/gmm.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/generatives/gmm.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,335 @@
+const char *help = "\
+GMM (c) Samy Bengio & Co 2001\n\
+\n\
+This program will maximize the likelihood of data given a Diagonal GMM \n";
+
+#include "EMTrainer.h"
+#include "MeanVarNorm.h"
+#include "DiagonalGMM.h"
+#include "KFold.h"
+#include "KMeans.h"
+#include "DiskMatDataSet.h"
+#include "MatDataSet.h"
+#include "CmdLine.h"
+#include "NLLMeasurer.h"
+#include "Random.h"
+#include "FileListCmdOption.h"
+
+using namespace Torch;
+
+
+// create a vector of variance flooring
+void initializeThreshold(DataSet* data,real* thresh, real threshold);
+
+int main(int argc, char **argv)
+{
+	real accuracy;
+	real threshold;
+	int max_iter_kmeans;
+	int max_iter_gmm;
+	int n_gaussians;
+	int n_inputs;
+	real prior;
+
+	int max_load;
+	int the_seed;
+
+	bool norm;
+	char *dir_name;
+	char *model_file;
+	char *save_model_file;
+	int k_fold;
+	bool binary_mode;
+
+	Allocator *allocator = new Allocator;
+	
+	FileListCmdOption file_list("file name", "the list files or one data file");
+	file_list.isArgument(true);
+	
+	//=============================================================== 
+	//=================== The command-line ==========================
+	//=============================================================== 
+
+	// Construct the command line
+	CmdLine cmd;
+
+	// Put the help line at the beginning
+	cmd.info(help);
+
+	// Train mode
+	cmd.addText("\nArguments:");
+	cmd.addCmdOption(&file_list);
+
+	cmd.addText("\nModel Options:");
+	cmd.addICmdOption("-n_gaussians", &n_gaussians, 10, "number of Gaussians");
+
+	cmd.addText("\nLearning Options:");
+	cmd.addRCmdOption("-threshold", &threshold, 0.001, "variance threshold");
+	cmd.addRCmdOption("-prior", &prior, 0.001, "prior on the weights");
+	cmd.addICmdOption("-iterk", &max_iter_kmeans, 25, "max number of iterations of KMeans");
+	cmd.addICmdOption("-iterg", &max_iter_gmm, 25, "max number of iterations of GMM");
+	cmd.addRCmdOption("-e", &accuracy, 0.00001, "end accuracy");
+	cmd.addICmdOption("-kfold", &k_fold, -1, "number of folds, if you want to do cross-validation");
+
+	cmd.addText("\nMisc Options:");
+	cmd.addICmdOption("-seed", &the_seed, -1, "the random seed");
+	cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+	cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+	cmd.addSCmdOption("-save", &save_model_file, "", "the model file");
+	cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+	cmd.addBCmdOption("-norm", &norm, false, "normalize the datas");
+
+	// Retrain mode
+	cmd.addMasterSwitch("--retrain");
+	cmd.addText("\nArguments:");
+	cmd.addSCmdArg("model", &model_file, "the model file");
+	cmd.addCmdOption(&file_list);
+
+	cmd.addRCmdOption("-threshold", &threshold, 0.001, "variance threshold");
+	cmd.addRCmdOption("-prior", &prior, 0.001, "prior on the weights");
+	cmd.addICmdOption("-iterg", &max_iter_gmm, 25, "max number of iterations of GMM");
+	cmd.addRCmdOption("-e", &accuracy, 0.00001, "end accuracy");
+
+	cmd.addText("\nMisc Options:");
+	cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+	cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+	cmd.addSCmdOption("-save", &save_model_file, "", "the model file");
+	cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+	cmd.addBCmdOption("-norm", &norm, false, "normalize the datas");
+
+	// Test mode
+	cmd.addMasterSwitch("--test");
+	cmd.addText("\nArguments:");
+	cmd.addSCmdArg("model", &model_file, "the model file");
+	cmd.addCmdOption(&file_list);
+
+	cmd.addText("\nMisc Options:");
+	cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+	cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+	cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+	cmd.addBCmdOption("-norm", &norm, false, "normalize the datas");
+
+
+	// Read the command line
+	int mode = cmd.read(argc, argv);
+	cmd.setWorkingDirectory(dir_name);
+	//DiskXFile::setBigEndianMode();
+
+	//==================================================================== 
+	//=================== Create the DataSet ... =========================
+	//==================================================================== 
+	
+	MatDataSet data(file_list.file_names, file_list.n_files, -1, 0, true, max_load, binary_mode);
+	MeanVarNorm* mv_norm = NULL;
+	if(norm)
+		mv_norm = new(allocator)MeanVarNorm (&data);
+
+
+
+	//==================================================================== 
+	//=================== Training Mode  =================================
+	//==================================================================== 
+
+	if(mode == 0)
+	{
+		if(the_seed == -1)
+			Random::seed();
+		else
+			Random::manualSeed((long)the_seed);
+
+
+	if(norm)
+		data.preProcess(mv_norm);
+
+		//=================== Create the GMM... =========================
+
+
+		// create a KMeans object to initialize the GMM
+		KMeans kmeans(data.n_inputs, n_gaussians);
+		kmeans.setROption("prior weights",prior);
+
+		// the kmeans trainer
+		EMTrainer kmeans_trainer(&kmeans);
+		kmeans_trainer.setROption("end accuracy", accuracy);
+		kmeans_trainer.setIOption("max iter", max_iter_kmeans);
+
+		// the kmeans measurer
+		MeasurerList kmeans_measurers;
+		NLLMeasurer nll_kmeans_measurer(kmeans.log_probabilities,&data,cmd.getXFile("kmeans_train_val"));
+		kmeans_measurers.addNode(&nll_kmeans_measurer);
+
+		// create the GMM
+		DiagonalGMM gmm(data.n_inputs,n_gaussians,&kmeans_trainer);
+		
+		// set the training options
+		real* thresh = (real*)allocator->alloc(data.n_inputs*sizeof(real));
+		initializeThreshold(&data,thresh,threshold);	
+		gmm.setVarThreshold(thresh);
+		gmm.setROption("prior weights",prior);
+		gmm.setOOption("initial kmeans trainer measurers", &kmeans_measurers);
+
+
+		//=================== Measurers and Trainer  ===============================
+
+		// Measurers on the training dataset
+		MeasurerList measurers;
+		NLLMeasurer nll_meas(gmm.log_probabilities, &data, cmd.getXFile("gmm_train_val"));
+		measurers.addNode(&nll_meas);
+
+		// The Gradient Machine Trainer
+		EMTrainer trainer(&gmm);
+		trainer.setIOption("max iter", max_iter_gmm);
+		trainer.setROption("end accuracy", accuracy);
+
+		//=================== Let's go... ===============================
+
+		if(k_fold <= 0)
+		{
+			trainer.train(&data, &measurers);
+
+			if(strcmp(save_model_file, ""))
+			{
+				DiskXFile model_(save_model_file, "w");
+				cmd.saveXFile(&model_);
+				if(norm)
+         mv_norm->saveXFile(&model_);
+				model_.taggedWrite(&n_gaussians, sizeof(int), 1, "n_gaussians");
+				model_.taggedWrite(&data.n_inputs, sizeof(int), 1, "n_inputs");
+				gmm.saveXFile(&model_);
+			}
+		}
+		else
+		{
+			KFold k(&trainer, k_fold);
+			k.crossValidate(&data, NULL, &measurers);
+		}
+	}
+
+
+	//==================================================================== 
+	//=================== Retraining Mode  ===============================
+	//==================================================================== 
+
+	if(mode == 1){
+
+		DiskXFile model(model_file, "r");
+		cmd.loadXFile(&model);
+		if(norm){
+			mv_norm->loadXFile(&model);
+			data.preProcess(mv_norm);
+		}
+		model.taggedRead(&n_gaussians, sizeof(int), 1, "n_gaussians");
+		model.taggedRead(&n_inputs, sizeof(int), 1, "n_inputs");
+
+		if(n_inputs != data.n_inputs)
+			error("gmm: the input number of the GMM (%d) do not correspond to the input number of the dataset (%d)", n_inputs, data.n_inputs);
+
+		DiagonalGMM gmm(data.n_inputs,n_gaussians);
+
+		// set the training options
+		real* thresh = (real*)allocator->alloc(data.n_inputs*sizeof(real));
+		initializeThreshold(&data,thresh,threshold);	
+		gmm.setVarThreshold(thresh);
+		gmm.setROption("prior weights",prior);
+
+		gmm.loadXFile(&model);
+
+
+		//=================== Measurers and Trainer ===================
+
+		// Measurers on the training dataset
+		MeasurerList measurers;
+		NLLMeasurer nll_meas(gmm.log_probabilities, &data, cmd.getXFile("gmm_retrain_val"));
+		measurers.addNode(&nll_meas);
+
+
+		//=================== The Trainer ===============================
+
+		// The Gradient Machine Trainer
+		EMTrainer trainer(&gmm);
+		trainer.setIOption("max iter", max_iter_gmm);
+		trainer.setROption("end accuracy", accuracy);
+
+		//=================== Let's go... ===============================
+
+		trainer.train(&data, &measurers);
+
+		if(strcmp(save_model_file, ""))
+		{
+			DiskXFile model_(save_model_file, "w");
+			cmd.saveXFile(&model_);
+			if(norm)
+				mv_norm->saveXFile(&model_);
+			model_.taggedWrite(&n_gaussians, sizeof(int), 1, "n_gaussians");
+			model_.taggedWrite(&n_inputs, sizeof(int), 1, "n_inputs");
+			gmm.saveXFile(&model_);
+		}
+
+	}
+
+
+	//==================================================================== 
+	//====================== Testing Mode  ===============================
+	//==================================================================== 
+
+	if(mode == 2){
+
+		DiskXFile model(model_file, "r");
+		cmd.loadXFile(&model);
+		if(norm){
+			mv_norm->loadXFile(&model);
+			data.preProcess(mv_norm);
+		}
+		model.taggedRead(&n_gaussians, sizeof(int), 1, "n_gaussians");
+		model.taggedRead(&n_inputs, sizeof(int), 1, "n_inputs");
+
+		if(n_inputs != data.n_inputs)
+			error("gmm: the input number of the GMM (%d) do not correspond to the input number of the dataset (%d)", n_inputs, data.n_inputs);
+
+		DiagonalGMM gmm(data.n_inputs,n_gaussians);
+
+		// set the training options
+
+		gmm.loadXFile(&model);
+
+
+		//=================== DataSets & Measurers... ===================
+
+		// Measurers on the training dataset
+		MeasurerList measurers;
+		NLLMeasurer nll_meas(gmm.log_probabilities, &data, cmd.getXFile("gmm_test_val"));
+		measurers.addNode(&nll_meas);
+
+
+		//=================== The Trainer ===============================
+
+		// The Gradient Machine Trainer
+		EMTrainer trainer(&gmm);
+
+		//=================== Let's go... ===============================
+
+		trainer.test(&measurers);
+	}
+	delete allocator;
+
+	return(0);
+}
+
+
+
+
+
+//==================================================================================================== 
+//==================================== Functions ===================================================== 
+//==================================================================================================== 
+
+
+void initializeThreshold(DataSet* data,real* thresh, real threshold)
+{
+	MeanVarNorm norm(data);
+	real*	ptr = norm.inputs_stdv;
+	real* p_var = thresh;
+	for(int i=0;i<data->n_inputs;i++)
+		*p_var++ = *ptr * *ptr++ * threshold;
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/generatives/hmm.cc work/main.d/Torch-3/examples/generatives/hmm.cc
--- tmp/Torch-3/examples/generatives/hmm.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/generatives/hmm.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,384 @@
+const char *help = "\
+GMM (c) Samy Bengio & Co 2001\n\
+\n\
+This program will maximize the likelihood of data given a Diagonal GMM \n";
+
+#include "EMTrainer.h"
+#include "HMM.h"
+#include "KFold.h"
+#include "KMeans.h"
+#include "HTKDataSet.h"
+#include "MatDataSet.h"
+#include "CmdLine.h"
+#include "NLLMeasurer.h"
+#include "Random.h"
+#include "FileListCmdOption.h"
+#include <unistd.h>
+
+using namespace Torch;
+
+
+// create a vector of variance flooring
+void initializeThreshold(DataSet* data,real* thresh, real threshold);
+
+//create the transitions probabilities matrix
+void setTransitions(real** transistions, int n_states, bool left_right);
+
+int main(int argc, char **argv)
+{
+	int n_gaussians;
+	int n_states;
+  bool left_right;
+
+	real accuracy;
+	real threshold;
+	int max_iter_kmeans;
+	int max_iter_hmm;
+	real prior;
+
+	int max_load;
+	int the_seed;
+
+	char *dir_name;
+	char *model_file;
+	char *save_model_file;
+	int k_fold;
+	bool binary_mode;
+
+	Allocator *allocator = new Allocator;
+	
+	FileListCmdOption file_list("file name", "the list files or one data file");
+	file_list.isArgument(true);
+	//=============================================================== 
+	//=================== The command-line ==========================
+	//=============================================================== 
+
+	// Construct the command line
+	CmdLine cmd;
+
+	// Put the help line at the beginning
+	cmd.info(help);
+
+	// Train mode
+	cmd.addText("\nArguments:");
+	cmd.addCmdOption(&file_list);
+
+	cmd.addText("\nModel Options:");
+	cmd.addICmdOption("-n_gaussians", &n_gaussians, 10, "number of Gaussians");
+  cmd.addICmdOption("-n_states", &n_states, 5, "number of states");
+  cmd.addBCmdOption("-left_right", &left_right, false, "left-right connectivity (otherwise: full-connect)");
+
+	cmd.addText("\nLearning Options:");
+	cmd.addRCmdOption("-threshold", &threshold, 0.001, "variance threshold");
+	cmd.addRCmdOption("-prior", &prior, 0.001, "prior on the weights");
+	cmd.addICmdOption("-iterk", &max_iter_kmeans, 25, "max number of iterations of KMeans");
+	cmd.addICmdOption("-iterh", &max_iter_hmm, 25, "max number of iterations of HMM");
+	cmd.addRCmdOption("-e", &accuracy, 0.00001, "end accuracy");
+	cmd.addICmdOption("-kfold", &k_fold, -1, "number of folds, if you want to do cross-validation");
+
+	cmd.addText("\nMisc Options:");
+	cmd.addICmdOption("-seed", &the_seed, -1, "the random seed");
+	cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+	cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+	cmd.addSCmdOption("-save", &save_model_file, "", "the model file");
+	cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+	// Retrain mode
+	cmd.addMasterSwitch("--retrain");
+	cmd.addText("\nArguments:");
+	cmd.addSCmdArg("model", &model_file, "the model file");
+	cmd.addCmdOption(&file_list);
+
+	cmd.addRCmdOption("-threshold", &threshold, 0.001, "variance threshold");
+	cmd.addRCmdOption("-prior", &prior, 0.001, "prior on the weights");
+	cmd.addICmdOption("-iterh", &max_iter_hmm, 25, "max number of iterations of HMM");
+	cmd.addRCmdOption("-e", &accuracy, 0.00001, "end accuracy");
+
+	cmd.addText("\nMisc Options:");
+	cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+	cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+	cmd.addSCmdOption("-save", &save_model_file, "", "the model file");
+	cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+	// Test mode
+	cmd.addMasterSwitch("--test");
+	cmd.addText("\nArguments:");
+	cmd.addSCmdArg("model", &model_file, "the model file");
+	cmd.addCmdOption(&file_list);
+
+	cmd.addText("\nMisc Options:");
+	cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+	cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+	cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+
+
+	// Read the command line
+	int mode = cmd.read(argc, argv);
+	cmd.setWorkingDirectory(dir_name);
+	//DiskXFile::setBigEndianMode();
+
+	//==================================================================== 
+	//=================== Create the DataSet ... =========================
+	//==================================================================== 
+
+	//MatDataSet data(file, -1, 0, true, max_load);
+	MatDataSet data(file_list.file_names, file_list.n_files, -1,0,true, max_load, binary_mode);
+	//HTKDataSet data(files, NULL, n_files, true, max_load);
+	message("data loaded\n");
+
+
+	//==================================================================== 
+	//=================== Training Mode  =================================
+	//==================================================================== 
+
+	if(mode == 0)
+	{
+
+		if (the_seed == -1)
+			Random::seed();
+		else
+			Random::manualSeed((long)the_seed);
+
+		//=================== Create the HMM... =========================
+
+
+		// create a KMeans object to initialize the GMM
+		KMeans kmeans(data.n_inputs, n_gaussians);
+
+		// the kmeans trainer
+		EMTrainer kmeans_trainer(&kmeans);
+		kmeans_trainer.setROption("end accuracy", accuracy);
+		kmeans_trainer.setIOption("max iter", max_iter_kmeans);
+
+		real* thresh = (real*)allocator->alloc(data.n_inputs*sizeof(real));
+		initializeThreshold(&data,thresh,threshold);	
+
+		// create the GMM
+		DiagonalGMM** gmms = (DiagonalGMM **)allocator->alloc(sizeof(DiagonalGMM*)*n_states);
+		for (int i=1;i<n_states-1;i++) {
+
+			DiagonalGMM* gmm = new(allocator)DiagonalGMM(data.n_inputs,n_gaussians,&kmeans_trainer);
+
+			// set the training options
+			gmm->setVarThreshold(thresh);
+			gmm->setROption("prior weights",prior);
+			gmms[i] = gmm;
+		}
+
+		// note that HMMs have two non-emitting states: the initial and final states
+		gmms[0] = NULL;
+		gmms[n_states-1] = NULL;
+
+		// we create the transition matrix with initial transition probabilities
+		real** transitions = (real**)allocator->alloc(n_states*sizeof(real*));
+		for (int i=0;i<n_states;i++) {
+			transitions[i] = (real*)allocator->alloc(n_states*sizeof(real));
+		}
+		// ... the left_right transition matrix
+		setTransitions(transitions, n_states, left_right);
+		HMM hmm(n_states, (Distribution**)gmms, transitions);
+		hmm.setROption("prior transitions",prior);
+		hmm.setBOption("linear segmentation", left_right);
+		//=================== Measurers and Trainer  ===============================
+
+		// Measurers on the training dataset
+		MeasurerList measurers;
+		NLLMeasurer nll_meas(hmm.log_probabilities, &data, cmd.getXFile("hmm_train_val"));
+		measurers.addNode(&nll_meas);
+
+		// The Gradient Machine Trainer
+		EMTrainer trainer(&hmm);
+		trainer.setIOption("max iter", max_iter_hmm);
+		trainer.setROption("end accuracy", accuracy);
+		trainer.setBOption("viterbi",true);
+
+		//=================== Let's go... ===============================
+
+		if(k_fold <= 0)
+		{
+			trainer.train(&data, &measurers);
+
+			if(strcmp(save_model_file, ""))
+			{
+				DiskXFile model_(save_model_file, "w");
+				cmd.saveXFile(&model_);
+				model_.taggedWrite(&n_states, sizeof(int), 1, "n_states");
+				model_.taggedWrite(&n_gaussians, sizeof(int), 1, "n_gaussians");
+				bool l_r  = (int) left_right;
+				model_.taggedWrite(&l_r, sizeof(int), 1, "left_right");
+				hmm.saveXFile(&model_);
+			}
+		}
+		else
+		{
+			KFold k(&trainer, k_fold);
+			k.crossValidate(&data, NULL, &measurers);
+		}
+	}
+
+
+	//==================================================================== 
+	//=================== Retraining Mode  ===============================
+	//==================================================================== 
+
+	if(mode == 1){
+
+		bool l_r;
+		DiskXFile model(model_file, "r");
+		cmd.loadXFile(&model);
+		model.taggedRead(&n_states, sizeof(int), 1, "n_states");
+		model.taggedRead(&n_gaussians, sizeof(int), 1, "n_gaussians");
+		model.taggedRead(&l_r, sizeof(int), 1, "left_right");
+		left_right = (bool) l_r;
+
+		real* thresh = (real*)allocator->alloc(data.n_inputs*sizeof(real));
+		initializeThreshold(&data,thresh,threshold);	
+
+		// create the GMM
+		DiagonalGMM** gmms = (DiagonalGMM **)allocator->alloc(sizeof(DiagonalGMM*)*n_states);
+		for (int i=1;i<n_states-1;i++) {
+
+			DiagonalGMM* gmm = new(allocator)DiagonalGMM(data.n_inputs,n_gaussians);
+
+			// set the training options
+			gmm->setVarThreshold(thresh);
+			gmm->setROption("prior weights",prior);
+			gmms[i] = gmm;
+		}
+
+		// note that HMMs have two non-emitting states: the initial and final states
+		gmms[0] = NULL;
+		gmms[n_states-1] = NULL;
+
+		// we create the transition matrix with initial transition probabilities
+		real** transitions = (real**)allocator->alloc(n_states*sizeof(real*));
+		for (int i=0;i<n_states;i++) {
+			transitions[i] = (real*)allocator->alloc(n_states*sizeof(real));
+		}
+		// ... the left_right transition matrix
+		setTransitions(transitions, n_states, left_right);
+		HMM hmm(n_states, (Distribution**)gmms, transitions);
+		hmm.setROption("prior transitions",prior);
+		hmm.loadXFile(&model);
+
+		//=================== Measurers and Trainer  ===============================
+
+		// Measurers on the training dataset
+		MeasurerList measurers;
+		NLLMeasurer nll_meas(hmm.log_probabilities, &data, cmd.getXFile("hmm_retrain_val"));
+		measurers.addNode(&nll_meas);
+
+		// The Gradient Machine Trainer
+		EMTrainer trainer(&hmm);
+		trainer.setIOption("max iter", max_iter_hmm);
+		trainer.setROption("end accuracy", accuracy);
+
+		//=================== Let's go... ===============================
+
+		trainer.train(&data, &measurers);
+
+		if(strcmp(save_model_file, ""))
+		{
+			DiskXFile model_(save_model_file, "w");
+			cmd.saveXFile(&model_);
+			model_.taggedWrite(&n_states, sizeof(int), 1, "n_states");
+			model_.taggedWrite(&n_gaussians, sizeof(int), 1, "n_gaussians");
+			bool l_r  = (int) left_right;
+			model_.taggedWrite(&l_r, sizeof(int), 1, "left_right");
+			hmm.saveXFile(&model_);
+		}
+	}
+
+
+	//==================================================================== 
+	//====================== Testing Mode  ===============================
+	//==================================================================== 
+
+	if(mode == 2){
+
+		bool l_r;
+		DiskXFile model(model_file, "r");
+		cmd.loadXFile(&model);
+		model.taggedRead(&n_states, sizeof(int), 1, "n_states");
+		model.taggedRead(&n_gaussians, sizeof(int), 1, "n_gaussians");
+		model.taggedRead(&l_r, sizeof(int), 1, "left_right");
+		left_right = (bool) l_r;
+
+		// create the GMM
+		DiagonalGMM** gmms = (DiagonalGMM **)allocator->alloc(sizeof(DiagonalGMM*)*n_states);
+		for (int i=1;i<n_states-1;i++) {
+
+			DiagonalGMM* gmm = new(allocator)DiagonalGMM(data.n_inputs,n_gaussians);
+
+			// set the training options
+			gmms[i] = gmm;
+		}
+
+		// note that HMMs have two non-emitting states: the initial and final states
+		gmms[0] = NULL;
+		gmms[n_states-1] = NULL;
+
+		// we create the transition matrix with initial transition probabilities
+		real** transitions = (real**)allocator->alloc(n_states*sizeof(real*));
+		for (int i=0;i<n_states;i++) {
+			transitions[i] = (real*)allocator->alloc(n_states*sizeof(real));
+		}
+		// ... the left_right transition matrix
+		setTransitions(transitions, n_states, left_right);
+		HMM hmm(n_states, (Distribution**)gmms, transitions);
+		hmm.setROption("prior transitions",prior);
+		hmm.loadXFile(&model);
+
+		//=================== Measurers and Trainer  ===============================
+
+		// Measurers on the training dataset
+		MeasurerList measurers;
+		NLLMeasurer nll_meas(hmm.log_probabilities, &data, cmd.getXFile("hmm_test_val"));
+		measurers.addNode(&nll_meas);
+
+		// The Gradient Machine Trainer
+		EMTrainer trainer(&hmm);
+		//=================== Let's go... ===============================
+
+		trainer.test(&measurers);
+	}
+	delete allocator;
+
+	return(0);
+}
+
+void setTransitions(real** transitions, int n_states, bool left_right){
+		for (int i=0;i<n_states;i++) {
+			for (int j=0;j<n_states;j++)
+				transitions[i][j] = 0;
+		}
+	if (left_right) {
+		transitions[1][0] = 1;
+		for (int i=1;i<n_states-1;i++) {
+			transitions[i][i] = 0.5;
+			transitions[i+1][i] = 0.5;
+		}
+	} else {
+		// ... the full_connect transition matrix
+		for (int i=1;i<n_states-1;i++) {
+			transitions[i][0] = 1./(n_states-2);
+			for (int j=1;j<n_states;j++) {
+				transitions[j][i] = 1./(n_states-1);
+			}
+		}
+	}
+}
+
+
+
+
+
+
+void initializeThreshold(DataSet* data,real* thresh, real threshold)
+{
+	MeanVarNorm norm(data);
+	real*	ptr = norm.inputs_stdv;
+	real* p_var = thresh;
+	for(int i=0;i<data->n_inputs;i++)
+		*p_var++ = *ptr * *ptr++ * threshold;
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/generatives/kmeans.cc work/main.d/Torch-3/examples/generatives/kmeans.cc
--- tmp/Torch-3/examples/generatives/kmeans.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/generatives/kmeans.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,244 @@
+const char *help = "\
+KMeans (c) Samy Bengio & Co 2001\n\
+\n\
+This program will maximize the kmeans criterion of a dataset\n";
+
+#include "EMTrainer.h"
+#include "StochasticGradient.h"
+#include "MeanVarNorm.h"
+#include "KFold.h"
+#include "KMeans.h"
+#include "DiskMatDataSet.h"
+#include "MatDataSet.h"
+#include "CmdLine.h"
+#include "NLLMeasurer.h"
+#include "NLLCriterion.h"
+#include "Random.h"
+#include "FileListCmdOption.h"
+#include <unistd.h>
+
+using namespace Torch;
+
+
+// create a vector of variance flooring
+void initializeThreshold(DataSet* data,real* thresh, real threshold);
+
+int main(int argc, char **argv)
+{
+	real accuracy;
+	real threshold;
+	int max_iter;
+	int n_clusters;
+	int n_inputs;
+	real prior;
+
+  bool stochastic;
+  real lrate;
+  real lrate_decay;
+
+	int max_load;
+	int the_seed;
+
+	bool norm;
+	char *dir_name;
+	char *model_file;
+	char *save_model_file;
+	int k_fold;
+	bool binary_mode;
+
+	Allocator *allocator = new Allocator;
+	
+	FileListCmdOption file_list("file name", "the list files or one data file");
+	file_list.isArgument(true);
+
+	//=============================================================== 
+	//=================== The command-line ==========================
+	//=============================================================== 
+
+	// Construct the command line
+	CmdLine cmd;
+
+	// Put the help line at the beginning
+	cmd.info(help);
+
+	// Train mode
+	cmd.addText("\nArguments:");
+	cmd.addCmdOption(&file_list);
+
+	cmd.addText("\nModel Options:");
+	cmd.addICmdOption("-n_clusters", &n_clusters, 10, "number of clusters");
+
+	cmd.addText("\nLearning Options:");
+	cmd.addRCmdOption("-threshold", &threshold, 0.001, "variance threshold");
+	cmd.addRCmdOption("-prior", &prior, 0.001, "prior on the weights");
+	cmd.addICmdOption("-iter", &max_iter, 25, "max number of iterations of KMeans");
+	cmd.addRCmdOption("-e", &accuracy, 0.00001, "end accuracy");
+	cmd.addICmdOption("-kfold", &k_fold, -1, "number of folds, if you want to do cross-validation");
+	cmd.addBCmdOption("-stochastic", &stochastic, false, "train by stochastic gradient instead of EM");
+	cmd.addRCmdOption("-lrate", &lrate, 0.1, "learning rate for stochastic gradient");
+	cmd.addRCmdOption("-lrate_decay", &lrate_decay, 0.001, "learning rate decay for stochastic gradient");
+
+	cmd.addText("\nMisc Options:");
+	cmd.addICmdOption("-seed", &the_seed, -1, "the random seed");
+	cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+	cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+	cmd.addSCmdOption("-save", &save_model_file, "", "the model file");
+	cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+	cmd.addBCmdOption("-norm", &norm, false, "normalize the datas");
+
+	// Test mode
+	cmd.addMasterSwitch("--test");
+	cmd.addText("\nArguments:");
+	cmd.addSCmdArg("model", &model_file, "the model file");
+	cmd.addCmdOption(&file_list);
+
+	cmd.addText("\nMisc Options:");
+	cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+	cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+	cmd.addBCmdOption("-bin", &binary_mode, false, "binary mode for files");
+	cmd.addBCmdOption("-norm", &norm, false, "normalize the datas");
+
+
+	// Read the command line
+	int mode = cmd.read(argc, argv);
+	cmd.setWorkingDirectory(dir_name);
+	//DiskXFile::setBigEndianMode();
+
+
+	//==================================================================== 
+	//=================== Create the DataSet ... =========================
+	//==================================================================== 
+
+	MatDataSet data(file_list.file_names, file_list.n_files, -1, 0, true, max_load, binary_mode);
+	MeanVarNorm* mv_norm = NULL;
+	if(norm)
+		mv_norm = new(allocator)MeanVarNorm (&data);
+
+
+
+	//==================================================================== 
+	//=================== Training Mode  =================================
+	//==================================================================== 
+
+	if(mode == 0) {
+		if (the_seed == -1)
+			Random::seed();
+		else
+			Random::manualSeed((long)the_seed);
+
+	  if(norm)
+		  data.preProcess(mv_norm);
+
+		//=================== Create the KMeans... =========================
+
+		real* thresh = (real*)allocator->alloc(data.n_inputs*sizeof(real));
+		initializeThreshold(&data,thresh,threshold);	
+
+		KMeans kmeans(data.n_inputs, n_clusters);
+		kmeans.setVarThreshold(thresh);
+		kmeans.setROption("prior weights",prior);
+
+		// the kmeans measurer
+		MeasurerList measurers;
+		NLLMeasurer nll_measurer(kmeans.log_probabilities,&data,cmd.getXFile("kmeans_train_val"));
+		measurers.addNode(&nll_measurer);
+
+		// the trainer
+    Trainer* trainer = NULL;
+    Criterion* criterion = NULL;
+    if (stochastic) {
+      criterion = new(allocator) NLLCriterion();
+      StochasticGradient* sg_t = new(allocator) StochasticGradient(&kmeans,criterion);
+		  sg_t->setROption("end accuracy", accuracy);
+		  sg_t->setIOption("max iter", max_iter);
+      sg_t->setROption("learning rate", lrate);
+      sg_t->setROption("learning rate decay", lrate_decay);
+      trainer = sg_t;
+    } else {
+		  EMTrainer* em_t = new(allocator) EMTrainer(&kmeans);
+		  em_t->setROption("end accuracy", accuracy);
+		  em_t->setIOption("max iter", max_iter);
+      trainer = em_t;
+    }
+
+		//=================== Let's go... ===============================
+
+		if(k_fold <= 0)
+		{
+			trainer->train(&data, &measurers);
+
+			if(strcmp(save_model_file, ""))
+			{
+				DiskXFile model_(save_model_file, "w");
+				cmd.saveXFile(&model_);
+				if(norm)
+         mv_norm->saveXFile(&model_);
+				model_.taggedWrite(&n_clusters, sizeof(int), 1, "n_clusters");
+				model_.taggedWrite(&data.n_inputs, sizeof(int), 1, "n_inputs");
+				kmeans.saveXFile(&model_);
+			}
+		}
+		else
+		{
+			KFold k(trainer, k_fold);
+			k.crossValidate(&data, NULL, &measurers);
+		}
+	}
+
+
+	//==================================================================== 
+	//====================== Testing Mode  ===============================
+	//==================================================================== 
+
+	if(mode == 1){
+
+		DiskXFile model(model_file, "r");
+		cmd.loadXFile(&model);
+		if(norm){
+			mv_norm->loadXFile(&model);
+			data.preProcess(mv_norm);
+		}
+		model.taggedRead(&n_clusters, sizeof(int), 1, "n_clusters");
+		model.taggedRead(&n_inputs, sizeof(int), 1, "n_inputs");
+
+		if(n_inputs != data.n_inputs)
+			error("kmeans: the input number of the KMeans (%d) do not correspond to the input number of the dataset (%d)", n_inputs, data.n_inputs);
+
+		KMeans kmeans(data.n_inputs,n_clusters);
+
+		// set the training options
+
+		kmeans.loadXFile(&model);
+
+
+		//=================== DataSets & Measurers... ===================
+
+		// Measurers on the training dataset
+		MeasurerList measurers;
+		NLLMeasurer nll_meas(kmeans.min_cluster, &data, cmd.getXFile("kmeans_test_val"));
+		measurers.addNode(&nll_meas);
+
+
+		//=================== The Trainer ===============================
+
+		// The Gradient Machine Trainer
+		EMTrainer trainer(&kmeans);
+
+		//=================== Let's go... ===============================
+
+		trainer.test(&measurers);
+	}
+	delete allocator;
+
+	return(0);
+}
+
+void initializeThreshold(DataSet* data,real* thresh, real threshold)
+{
+	MeanVarNorm norm(data);
+	real*	ptr = norm.inputs_stdv;
+	real* p_var = thresh;
+	for(int i=0;i<data->n_inputs;i++)
+		*p_var++ = *ptr * *ptr++ * threshold;
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/generatives/Makefile work/main.d/Torch-3/examples/generatives/Makefile
--- tmp/Torch-3/examples/generatives/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/generatives/Makefile	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,20 @@
+#
+# Torch user Makefile example
+#
+
+# Torch location.
+# Make sure to specify correct location...
+
+TORCHDIR := $(shell cd ../..; pwd)
+
+#
+# All that follows you can probably keep as is...
+#
+
+OS := $(shell uname -s)
+include $(TORCHDIR)/Makefile_options_$(OS)
+
+%: %.cc
+	cd $(TORCHDIR); ${MAKE}
+	mkdir -p $(VERSION_KEY)
+	$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $(VERSION_KEY)/$@ $< $(LIBS)
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/generatives/README work/main.d/Torch-3/examples/generatives/README
--- tmp/Torch-3/examples/generatives/README	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/generatives/README	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,43 @@
+---------------------------------------------------
+
+Some examples to learn how to *program* in Torch3.
+Of course you can use them without any changes,
+but you will not use 1/10 of the library if you
+don't want to code something!
+
+kmeans.cc  : simple K-means models
+gmm.cc     : simple Gaussians Mixtures Models
+hmm.cc     : simple Hidden Markov Models (see speech and 
+             decoder example for speech recognition)
+
+---------------------------------------------------
+
+You will find two examples of datasets in data/.
+Torch3 is able to deal directly with gziped data,
+but you can uncompress them if you want to have a
+look. (Or do a zless, zcat, zmore).
+
+---------------------------------------------------
+
+Examples of command line:
+
+
+echo "GMM"
+./Linux_OPT_FLOAT/gmm -save gmm_model -one_file data/train.amat.gz
+
+or
+echo data/train.amat.gz>list;./Linux_OPT_FLOAT/gmm -save gmm_model list
+
+./Linux_OPT_FLOAT/gmm --retrain gmm_model -one_file data/train.amat.gz
+./Linux_OPT_FLOAT/gmm --test gmm_model -one_file data/test.amat.gz
+
+echo "HMM"
+./Linux_OPT_FLOAT/hmm -save hmm_model -one_file data/train.amat.gz
+./Linux_OPT_FLOAT/hmm --retrain hmm_model -one_file data/train.amat.gz
+./Linux_OPT_FLOAT/hmm --test hmm_model -one_file data/test.amat.gz
+
+echo "KMeans"
+./Linux_OPT_FLOAT/kmeans -save kmeans_model -one_file data/train.amat.gz
+./Linux_OPT_FLOAT/kmeans --test kmeans_model -one_file data/test.amat.gz
+
+---------------------------------------------------
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/LICENSE work/main.d/Torch-3/examples/LICENSE
--- tmp/Torch-3/examples/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/LICENSE	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,28 @@
+
+Copyright (c) 2003--2004 Ronan Collobert
+Copyright (c) 2003--2004 Samy Bengio
+Copyright (c) 2003--2004 Johnny Mariéthoz
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/data/aligned_tri_targets/NU-1002.streetaddr.lab work/main.d/Torch-3/examples/speech/data/aligned_tri_targets/NU-1002.streetaddr.lab
--- tmp/Torch-3/examples/speech/data/aligned_tri_targets/NU-1002.streetaddr.lab	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/data/aligned_tri_targets/NU-1002.streetaddr.lab	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,11 @@
+0 2250000 h#
+2250000 3625000 th+r
+3625000 4375000 th-r+iy
+4375000 6500000 r-iy
+6500000 6750000 h#
+6750000 8875000 s+ih
+8875000 10000000 s-ih+kcl
+10000000 10875000 ih-kcl+k
+10875000 11375000 kcl-k+s
+11375000 15500000 k-s
+15500000 17500000 h#
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/data/aligned_tri_targets/NU-1002.zipcode.lab work/main.d/Torch-3/examples/speech/data/aligned_tri_targets/NU-1002.zipcode.lab
--- tmp/Torch-3/examples/speech/data/aligned_tri_targets/NU-1002.zipcode.lab	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/data/aligned_tri_targets/NU-1002.zipcode.lab	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,19 @@
+0 1500000 h#
+1500000 2750000 w+ah
+2750000 3625000 w-ah+n
+3625000 4375000 ah-n
+4375000 4625000 h#
+4625000 6125000 th+r
+6125000 6625000 th-r+iy
+6625000 9250000 r-iy
+9250000 10125000 h#
+10125000 10875000 n+ay
+10875000 12000000 n-ay+n
+12000000 12625000 ay-n
+12625000 12875000 h#
+12875000 14625000 ow
+14625000 14875000 h#
+14875000 16000000 w+ah
+16000000 16875000 w-ah+n
+16875000 17250000 ah-n
+17250000 18375000 h#
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/data/aligned_tri_targets/NU-1007.streetaddr.lab work/main.d/Torch-3/examples/speech/data/aligned_tri_targets/NU-1007.streetaddr.lab
--- tmp/Torch-3/examples/speech/data/aligned_tri_targets/NU-1007.streetaddr.lab	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/data/aligned_tri_targets/NU-1007.streetaddr.lab	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,14 @@
+0 875000 h#
+875000 2375000 s+ih
+2375000 2750000 s-ih+kcl
+2750000 3125000 ih-kcl+k
+3125000 3500000 kcl-k+s
+3500000 3875000 k-s+tcl
+3875000 4250000 s-tcl+t
+4250000 4625000 tcl-t+iy
+4625000 5000000 t-iy
+5000000 5250000 h#
+5250000 6000000 f+ao
+6000000 7250000 f-ao+r
+7250000 8125000 ao-r
+8125000 8375000 h#
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/data/aligned_tri_targets/NU-1007.zipcode.lab work/main.d/Torch-3/examples/speech/data/aligned_tri_targets/NU-1007.zipcode.lab
--- tmp/Torch-3/examples/speech/data/aligned_tri_targets/NU-1007.zipcode.lab	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/data/aligned_tri_targets/NU-1007.zipcode.lab	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,19 @@
+0 2250000 h#
+2250000 3500000 ow
+3500000 3750000 h#
+3750000 4375000 w+ah
+4375000 4750000 w-ah+n
+4750000 5125000 ah-n
+5125000 5375000 h#
+5375000 6625000 ey+tcl
+6625000 7125000 ey-tcl+t
+7125000 7500000 tcl-t
+7500000 10125000 h#
+10125000 11375000 f+ao
+11375000 12250000 f-ao+r
+12250000 12875000 ao-r
+12875000 13125000 h#
+13125000 14125000 f+ay
+14125000 15625000 f-ay+v
+15625000 16500000 ay-v
+16500000 18125000 h#
Binary files tmp/Torch-3/examples/speech/data/inputs/NU-1002.streetaddr.mfcSC and work/main.d/Torch-3/examples/speech/data/inputs/NU-1002.streetaddr.mfcSC differ
Binary files tmp/Torch-3/examples/speech/data/inputs/NU-1002.zipcode.mfcSC and work/main.d/Torch-3/examples/speech/data/inputs/NU-1002.zipcode.mfcSC differ
Binary files tmp/Torch-3/examples/speech/data/inputs/NU-1007.streetaddr.mfcSC and work/main.d/Torch-3/examples/speech/data/inputs/NU-1007.streetaddr.mfcSC differ
Binary files tmp/Torch-3/examples/speech/data/inputs/NU-1007.zipcode.mfcSC and work/main.d/Torch-3/examples/speech/data/inputs/NU-1007.zipcode.mfcSC differ
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/data/targets/NU-1002.streetaddr.lab work/main.d/Torch-3/examples/speech/data/targets/NU-1002.streetaddr.lab
--- tmp/Torch-3/examples/speech/data/targets/NU-1002.streetaddr.lab	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/data/targets/NU-1002.streetaddr.lab	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,2 @@
+three
+six
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/data/targets/NU-1002.zipcode.lab work/main.d/Torch-3/examples/speech/data/targets/NU-1002.zipcode.lab
--- tmp/Torch-3/examples/speech/data/targets/NU-1002.zipcode.lab	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/data/targets/NU-1002.zipcode.lab	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,5 @@
+one
+three
+nine
+oh
+one
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/data/targets/NU-1007.streetaddr.lab work/main.d/Torch-3/examples/speech/data/targets/NU-1007.streetaddr.lab
--- tmp/Torch-3/examples/speech/data/targets/NU-1007.streetaddr.lab	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/data/targets/NU-1007.streetaddr.lab	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,2 @@
+sixty
+four
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/data/targets/NU-1007.zipcode.lab work/main.d/Torch-3/examples/speech/data/targets/NU-1007.zipcode.lab
--- tmp/Torch-3/examples/speech/data/targets/NU-1007.zipcode.lab	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/data/targets/NU-1007.zipcode.lab	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,5 @@
+oh
+one
+eight
+four
+five
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/dict_mono work/main.d/Torch-3/examples/speech/dict_mono
--- tmp/Torch-3/examples/speech/dict_mono	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/dict_mono	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,33 @@
+sil		h#
+<s>		h#
+</s>		h#
+eight           ey tcl t h#
+eighteen        ey tcl t iy n h#
+eighty          ey tcl t iy h#
+eleven          ih l eh v ah n h#
+fifteen         f ih f tcl t iy n h#
+fifty           f ih f tcl t iy h#
+five            f ay v h#
+forty           f ao r tcl t iy h#
+four            f ao r h#
+fourteen        f ao r tcl t iy n h#
+hundred         hh ah n dcl d r ah dcl d h#
+nine            n ay n h#
+nineteen        n ay n tcl t iy n h#
+ninety          n ay n tcl t iy h#
+oh              ow h#
+one             w ah n h#
+seven           s eh v ah n h#
+seventeen       s eh v ah n tcl t iy n h#
+seventy         s eh v ah n tcl t iy h#
+six             s ih kcl k s h#
+sixteen         s ih kcl k s tcl t iy n h#
+sixty           s ih kcl k s tcl t iy h#
+ten             tcl t eh n h#
+thirteen        th er tcl t iy n h#
+thirty          th er dcl d iy h#
+three           th r iy h#
+twelve          tcl t w eh l v h#
+twenty          tcl t w eh n tcl t iy h#
+two             tcl t uw h#
+zero            z ih r ow h#
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/dict_tri work/main.d/Torch-3/examples/speech/dict_tri
--- tmp/Torch-3/examples/speech/dict_tri	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/dict_tri	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,34 @@
+sil		h#
+<s>             h#
+</s>            h#
+eight           ey+tcl ey-tcl+t tcl-t h#
+eight           ey+tcl tcl-t h#
+eighteen        ey+tcl ey-tcl+t tcl-t+iy t-iy+n iy-n h#
+eighty          ey+tcl ey-tcl+t tcl-t+iy t-iy h#
+eleven          ih+l ih-l+eh l-eh+v eh-v+ah v-ah+n ah-n h#
+fifteen         f+ih f-ih+f ih-f+tcl f-tcl+t tcl-t+iy t-iy+n iy-n h#
+fifty           f+ih f-ih+f ih-f+tcl f-tcl+t tcl-t+iy t-iy h#
+five            f+ay f-ay+v ay-v h#
+forty           f+ao f-ao+r ao-r+tcl r-tcl+t tcl-t+iy t-iy h#
+four            f+ao f-ao+r ao-r h#
+fourteen        f+ao f-ao+r ao-r+tcl r-tcl+t tcl-t+iy t-iy+n iy-n h#
+hundred         hh+ah hh-ah+n ah-n+dcl n-dcl+d dcl-d+r d-r+ah r-ah+dcl ah-dcl+d dcl-d h#
+nine            n+ay n-ay+n ay-n h#
+nineteen        n+ay n-ay+n ay-n+tcl n-tcl+t tcl-t+iy t-iy+n iy-n h#
+ninety          n+ay n-ay+n ay-n+tcl n-tcl+t tcl-t+iy t-iy h#
+oh              ow h#
+one             w+ah w-ah+n ah-n h#
+seven           s+eh s-eh+v eh-v+ah v-ah+n ah-n h#
+seventeen       s+eh s-eh+v eh-v+ah v-ah+n ah-n+tcl n-tcl+t tcl-t+iy t-iy+n iy-n h#
+seventy         s+eh s-eh+v eh-v+ah v-ah+n ah-n+tcl n-tcl+t tcl-t+iy t-iy h#
+six             s+ih s-ih+kcl ih-kcl+k kcl-k+s k-s h#
+sixteen         s+ih s-ih+kcl ih-kcl+k kcl-k+s k-s+tcl s-tcl+t tcl-t+iy t-iy+n iy-n h#
+sixty           s+ih s-ih+kcl ih-kcl+k kcl-k+s k-s+tcl s-tcl+t tcl-t+iy t-iy h#
+ten             tcl+t tcl-t+eh t-eh+n eh-n h#
+thirteen        th+er th-er+tcl er-tcl+t tcl-t+iy t-iy+n iy-n h#
+thirty          th+er th-er+dcl er-dcl+d dcl-d+iy d-iy h#
+three           th+r th-r+iy r-iy h#
+twelve          tcl+t tcl-t+w t-w+eh w-eh+l eh-l+v l-v h#
+twenty          tcl+t tcl-t+w t-w+eh w-eh+n eh-n+tcl n-tcl+t tcl-t+iy t-iy h#
+two             tcl+t tcl-t+uw t-uw h#
+zero            z+ih z-ih+r ih-r+ow r-ow h#
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/Makefile work/main.d/Torch-3/examples/speech/Makefile
--- tmp/Torch-3/examples/speech/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/Makefile	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,20 @@
+#
+# Torch user Makefile example
+#
+
+# Torch location.
+# Make sure to specify correct location...
+
+TORCHDIR := $(shell cd ../..; pwd)
+
+#
+# All that follows you can probably keep as is...
+#
+
+OS := $(shell uname -s)
+include $(TORCHDIR)/Makefile_options_$(OS)
+
+%: %.cc
+	cd $(TORCHDIR); ${MAKE}
+	mkdir -p $(VERSION_KEY)
+	$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $(VERSION_KEY)/$@ $< $(LIBS)
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/phonemes_mono work/main.d/Torch-3/examples/speech/phonemes_mono
--- tmp/Torch-3/examples/speech/phonemes_mono	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/phonemes_mono	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,27 @@
+ah
+ao
+ay
+d
+dcl
+eh
+er
+ey
+f
+h#
+hh
+ih
+iy
+k
+kcl
+l
+n
+ow
+r
+s
+t
+tcl
+th
+uw
+v
+w
+z
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/phonemes_tri work/main.d/Torch-3/examples/speech/phonemes_tri
--- tmp/Torch-3/examples/speech/phonemes_tri	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/phonemes_tri	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,80 @@
+h#
+s+ih
+s-ih+kcl
+ih-kcl+k
+kcl-k+s
+k-s+tcl
+s-tcl+t
+tcl-t+iy
+t-iy
+f+ao
+f-ao+r
+ao-r
+w+ah
+w-ah+n
+ah-n
+s+eh
+s-eh+v
+eh-v+ah
+v-ah+n
+tcl+t
+tcl-t+uw
+t-uw
+k-s
+f+ay
+f-ay+v
+ay-v
+th+r
+th-r+iy
+r-iy
+n+ay
+n-ay+n
+ay-n
+ow
+th+er
+th-er+dcl
+er-dcl+d
+dcl-d+iy
+d-iy
+tcl-t+w
+t-w+eh
+w-eh+l
+eh-l+v
+l-v
+w-eh+n
+eh-n+tcl
+n-tcl+t
+ey+tcl
+ey-tcl+t
+tcl-t
+ay-n+tcl
+t-iy+n
+iy-n
+f+ih
+f-ih+f
+ih-f+tcl
+f-tcl+t
+ao-r+tcl
+r-tcl+t
+z+ih
+z-ih+r
+ih-r+ow
+r-ow
+ih+l
+ih-l+eh
+l-eh+v
+th-er+tcl
+er-tcl+t
+tcl-t+eh
+t-eh+n
+eh-n
+ah-n+tcl
+hh+ah
+hh-ah+n
+ah-n+dcl
+n-dcl+d
+dcl-d+r
+d-r+ah
+r-ah+dcl
+ah-dcl+d
+dcl-d
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/README work/main.d/Torch-3/examples/speech/README
--- tmp/Torch-3/examples/speech/README	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/README	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,43 @@
+README: how to use the example mains for speech recognition
+-----
+
+Files:
+
+phonemes_*: contain the list of acceptable phonemes for the problem
+dict_*: contains the list of acceptable words for the problem: they should
+  of course be constituted of acceptable phonemes. special words <s> and </s>
+  are start and end words
+train_files: contains the list of training files, in HTK format
+train_word and train_aligned_word: contains the list of target files, 
+  using HTK standards: either one word per line, or something like this:
+    0 2250000 h#
+    2250000 3625000 th+r
+    3625000 4375000 th-r+iy
+    4375000 6500000 r-iy
+    6500000 6750000 h#
+    6750000 8875000 s+ih
+    8875000 10000000 s-ih+kcl
+    10000000 10875000 ih-kcl+k
+    10875000 11375000 kcl-k+s
+    11375000 15500000 k-s
+    15500000 17500000 h#
+  which also contains the alignment. This helps the initialization step.
+
+Programs:
+
+speech_hmm_init.cc: to initialize models using KMeans. Example of usage:
+
+Linux_OPT_FLOAT/speech_hmm_init -train_separate -threshold 0.2 -iter 100 -htk_model -save hmm_init_model -n_gaussians 10 phonemes_tri dict_tri train_files train_align_tri
+
+speech_hmm_train.cc: to train the models. Example of usage:
+
+Linux_OPT_FLOAT/speech_hmm_train -add_sil_to_targets -iter 40 -viterbi -htk_model -save hmm_model_viterbi -threshold 0.2 phonemes_tri dict_tri train_files train_word hmm_init_model
+
+speech_hmm_simple_decode.cc: to decode using simple decoder (no large vocab):
+
+Linux_OPT_FLOAT/speech_hmm_simple_decode -htk_model -log_word_entrance_penalty -15 -add_sil_to_targets hmm_model_viterbi phonemes_tri dict_tri train_files train_word
+
+speech_hmm_tode_decode.cc: to decode using TODE decoder (for large vocab):
+
+Linux_OPT_FLOAT/speech_hmm_tode_decode -htk_model -log_word_entrance_penalty -15 hmm_model_viterbi phonemes_tri dict_tri train_files train_word
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/speech_hmm_init.cc work/main.d/Torch-3/examples/speech/speech_hmm_init.cc
--- tmp/Torch-3/examples/speech/speech_hmm_init.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/speech_hmm_init.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,235 @@
+const char *help = "\
+speech_hmm_init (c) Samy Bengio & Co 2001\n\
+\n\
+This program is used to do speech recognition \n";
+
+#include "LexiconInfo.h"
+#include "EMTrainer.h"
+#include "HMM.h"
+#include "KMeans.h"
+#include "MatDataSet.h"
+#include "CmdLine.h"
+#include "NLLMeasurer.h"
+#include "Random.h"
+#include "DiskHTKDataSet.h"
+#include "HTKDataSet.h"
+#include "SpeechHMM.h"
+#include "string_utils.h"
+#include "FileListCmdOption.h"
+
+using namespace Torch;
+
+#ifdef _MSC_VER
+#include "speech_include.cpp"
+#else
+#include "speech_include.cc"
+#endif
+
+int main(int argc, char **argv)
+{
+  char* phoneme_name;
+  char* lex_name;
+
+  int n_gaussians;
+  int n_states;
+  char* file_states;
+
+  char* silence_name;
+  char* silence_phone;
+  char* sp_name;
+  char* sp_phone;
+
+  real accuracy;
+  real threshold;
+  int max_iter;
+  real prior;
+
+  int max_load;
+  int the_seed;
+
+  char *dir_name;
+  char *model_file;
+  bool htk_model;
+  bool train_separate;
+  bool disk;
+  bool is_word;
+  bool add_sil_to_targets;
+  bool full_connect;
+
+  Allocator *allocator = new Allocator;
+	
+	FileListCmdOption input_file_list("file name", "the list of inputs files or one data file");
+	input_file_list.isArgument(true);
+  
+	FileListCmdOption target_file_list("file name", "the list of target files or one target file");
+	target_file_list.isArgument(true);
+
+	//=============================================================== 
+  //=================== The command-line ==========================
+  //=============================================================== 
+
+  // Construct the command line
+  CmdLine cmd;
+
+  // Put the help line at the beginning
+  cmd.info(help);
+
+  // Train mode
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("phoneme_name", &phoneme_name, "the list of phonemes file");
+  cmd.addSCmdArg("lex_name", &lex_name, "the lexicon file");
+	cmd.addCmdOption(&input_file_list);
+	cmd.addCmdOption(&target_file_list);
+
+  cmd.addText("\nModel Options:");
+  cmd.addBCmdOption("-word", &is_word, false, "targets are in word format");
+  cmd.addICmdOption("-n_gaussians", &n_gaussians, 10, "number of Gaussians");
+  cmd.addICmdOption("-n_states", &n_states, 5, "number of states");
+  cmd.addSCmdOption("-file_states", &file_states, "", "file containing n_states per model");
+  cmd.addSCmdOption("-silence_word", &silence_name,"sil", "name of silence word");
+  cmd.addSCmdOption("-silence_phone", &silence_phone,"h#", "name of silence phone");
+  cmd.addSCmdOption("-sp_word", &sp_name,"", "name of short pause word");
+  cmd.addSCmdOption("-sp_phone", &sp_phone,"", "name of short pause phoneme");
+  cmd.addBCmdOption("-add_sil_to_targets", &add_sil_to_targets, false, "add silence at begining of targets");
+  cmd.addBCmdOption("-full_connect", &full_connect, false, "models are full connect");
+
+  cmd.addText("\nLearning Options:");
+  cmd.addBCmdOption("-train_separate", &train_separate, false, "first train separate models");
+  cmd.addRCmdOption("-threshold", &threshold, 0.001, "variance threshold");
+  cmd.addRCmdOption("-prior", &prior, 0.001, "prior on the weights");
+  cmd.addICmdOption("-iter", &max_iter, 25, "max number of init iterations");
+  cmd.addRCmdOption("-e", &accuracy, 0.00001, "end accuracy");
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-seed", &the_seed, -1, "the random seed");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addSCmdOption("-save", &model_file, "", "the model file");
+  cmd.addBCmdOption("-htk_model", &htk_model, false, "save in HTK model format");
+  cmd.addBCmdOption("-disk", &disk, false, "keep data on disk");
+
+  // Read the command line
+  cmd.read(argc, argv);
+  cmd.setWorkingDirectory(dir_name);
+
+  DiskXFile::setBigEndianMode();
+
+  //==================================================================== 
+  //=================== Training Mode  =================================
+  //==================================================================== 
+
+  if(the_seed == -1)
+    Random::seed();
+  else
+    Random::manualSeed((long)the_seed);
+
+  // read lexicon
+  if (strlen(sp_phone) == 0)
+    sp_phone = NULL;
+  if (strlen(silence_phone) == 0)
+    silence_phone = NULL;
+  LexiconInfo lex(phoneme_name,silence_phone,sp_phone,lex_name,add_sil_to_targets ? silence_name : NULL,NULL);
+
+  //==================================================================== 
+  //=================== Create the DataSet ... =========================
+  //==================================================================== 
+
+
+  // some basic tests on the files
+  if (input_file_list.n_files != target_file_list.n_files) {
+    error("the input and target files should have the same number of files (%d != %d)\n",input_file_list.n_files,target_file_list.n_files);
+  }
+  for (int i=0;i<input_file_list.n_files;i++) {
+    char* si = strRemoveSuffix(input_file_list.file_names[i]);
+    char* st = strRemoveSuffix(target_file_list.file_names[i]);
+    if (strcmp(strBaseName(si),strBaseName(st)))
+      warning("input file (%s) do not correspond to target file (%s)",input_file_list.file_names[i],target_file_list.file_names[i]);
+    free(si);
+    free(st);
+  }
+
+  DataSet* data;
+  if (disk)
+    data = (DataSet*)new(allocator) DiskHTKDataSet(input_file_list.file_names,target_file_list.file_names, input_file_list.n_files, true, max_load, &lex,is_word);
+  else
+    data = (DataSet*)new(allocator) HTKDataSet(input_file_list.file_names,target_file_list.file_names, input_file_list.n_files, true, max_load, &lex,is_word);
+
+  //=================== Create the HMM... =========================
+
+  real* thresh = (real*)allocator->alloc(data->n_inputs*sizeof(real));
+  initializeThreshold(data,thresh,threshold);  
+
+  int n_phonemes = lex.phone_info->n_phones;
+  int* states = read_states(file_states,n_phonemes,n_states,
+    lex.phone_info->pause_index,allocator);
+
+  // create the GMM
+  DiagonalGMM*** gmms = (DiagonalGMM ***)allocator->alloc(sizeof(DiagonalGMM**)*n_phonemes);
+  EMTrainer** hmm_trainer = (EMTrainer **)allocator->alloc(sizeof(EMTrainer*)*n_phonemes);
+  HMM** hmm = (HMM**)allocator->alloc(sizeof(HMM*)*n_phonemes);
+  KMeans*** kmeans = (KMeans***)allocator->alloc(sizeof(KMeans**)*n_phonemes);
+  EMTrainer*** kmeans_trainer = (EMTrainer***)allocator->alloc(sizeof(EMTrainer**)*n_phonemes);
+  real*** transitions = (real***)allocator->alloc(n_phonemes*sizeof(real**));
+  for (int i=0;i<n_phonemes;i++) {
+    gmms[i] = (DiagonalGMM**)allocator->alloc(sizeof(DiagonalGMM*)*states[i]);
+    kmeans[i] = (KMeans**)allocator->alloc(sizeof(KMeans*)*states[i]);
+    kmeans_trainer[i] = (EMTrainer**)allocator->alloc(sizeof(EMTrainer*)*states[i]);
+    for (int j=1;j<states[i]-1;j++) {
+      // create a KMeans object to initialize the GMM
+      kmeans[i][j] = new(allocator)KMeans(data->n_inputs, n_gaussians);
+      kmeans[i][j]->setVarThreshold(thresh);
+      // the kmeans trainer
+      kmeans_trainer[i][j] = new(allocator) EMTrainer(kmeans[i][j]);
+      kmeans_trainer[i][j]->setROption("end accuracy", accuracy);
+      kmeans_trainer[i][j]->setIOption("max iter", max_iter);
+
+      gmms[i][j] = new(allocator)DiagonalGMM(data->n_inputs,n_gaussians,kmeans_trainer[i][j]);
+
+      // set the training options
+      gmms[i][j]->setVarThreshold(thresh);
+      gmms[i][j]->setROption("prior weights",prior);
+    }
+
+    gmms[i][0] = NULL;
+    gmms[i][states[i]-1] = NULL;
+
+    // the transition table probability: left-right topology or full connect
+    transitions[i] = (real**)allocator->alloc(states[i]*sizeof(real*));
+    for (int j=0;j<states[i];j++) {
+      transitions[i][j] = (real*)allocator->alloc(states[i]*sizeof(real));
+    }
+    setTransitions(transitions[i], states[i], i, lex.phone_info->pause_index, lex.phone_info->sil_index, full_connect);
+
+    hmm[i] = new (allocator)HMM(states[i],(Distribution**)gmms[i],transitions[i]);
+    hmm[i]->setROption("prior transitions",prior);
+    hmm[i]->setBOption("linear segmentation", true);
+    hmm_trainer[i] = new(allocator)EMTrainer(hmm[i]);
+    hmm_trainer[i]->setIOption("max iter", max_iter);
+    hmm_trainer[i]->setROption("end accuracy", accuracy);
+  }
+
+  EMTrainer** hmm_trainer_ = NULL;
+  if (train_separate)
+    hmm_trainer_ = hmm_trainer;
+
+  SpeechHMM shmm(n_phonemes,hmm,&lex,hmm_trainer_);
+  shmm.setBOption("targets are phonemes",!is_word);
+  shmm.setDataSet(data);
+
+  if(strcmp(model_file, "")) {
+    if (htk_model) {
+      save_htk_model(cmd.getPath(model_file),&shmm,lex.phone_info->phone_names);
+    } else {
+      DiskXFile model_(cmd.getPath(model_file), "w");
+      cmd.saveXFile(&model_);
+      model_.taggedWrite(&n_gaussians, sizeof(int), 1, "n_gaussians");
+      model_.taggedWrite(&n_phonemes, sizeof(int), 1, "n_phonemes");
+      model_.taggedWrite(states, sizeof(int), n_phonemes, "n_states");
+      model_.taggedWrite(&data->n_inputs, sizeof(int), 1, "n_inputs");
+      shmm.saveXFile(&model_);
+    }
+  }
+  delete allocator;
+  return(0);
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/speech_hmm_simple_decode.cc work/main.d/Torch-3/examples/speech/speech_hmm_simple_decode.cc
--- tmp/Torch-3/examples/speech/speech_hmm_simple_decode.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/speech_hmm_simple_decode.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,207 @@
+const char *help = "\
+  GMM (c) Samy Bengio & Co 2001\n\
+  \n\
+  This program is used to do decode simple speech recognition \n";
+
+#include "LexiconInfo.h"
+#include "EMTrainer.h"
+#include "HMM.h"
+#include "CmdLine.h"
+#include "Random.h"
+#include "DiskHTKDataSet.h"
+#include "HTKDataSet.h"
+#include "SimpleDecoderSpeechHMM.h"
+#include "WordSegMeasurer.h"
+#include "FrameSegMeasurer.h"
+#include "Grammar.h"
+#include "DiagonalGMM.h"
+#include "string_utils.h"
+#include "FileListCmdOption.h"
+
+using namespace Torch;
+
+#include "speech_include.cc"
+
+int main(int argc, char **argv)
+{
+  char* saved_model;
+  char* phoneme_name;
+  char* lex_name;
+
+
+  char* silence_name;
+  char* silence_phone;
+  char* sp_name;
+  char* sp_phone;
+  real log_word_entrance_penalty;
+  bool add_sil_to_targets;
+  bool no_self_transitions;
+  bool force;
+
+  int max_load;
+
+  char *dir_name;
+  bool htk_model;
+  bool disk;
+  bool isolated;
+  int min_duration;
+  bool confusion;
+
+  Allocator *allocator = new Allocator;
+	
+	FileListCmdOption input_file_list("file name", "the list of inputs files or one data file");
+	input_file_list.isArgument(true);
+  
+	FileListCmdOption target_file_list("file name", "the list of target files or one target file");
+	target_file_list.isArgument(true);
+  
+	//=============================================================== 
+  //=================== The command-line ==========================
+  //=============================================================== 
+
+  // Construct the command line
+  CmdLine cmd;
+
+  // Put the help line at the beginning
+  cmd.info(help);
+
+  // Train mode
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("saved_model", &saved_model, "the saved model");
+  cmd.addSCmdArg("phoneme_name", &phoneme_name, "the list of phonemes file");
+  cmd.addSCmdArg("lex_name", &lex_name, "the lexicon file");
+	cmd.addCmdOption(&input_file_list);
+	cmd.addCmdOption(&target_file_list);
+
+  cmd.addText("\nModel Options:");
+  cmd.addSCmdOption("-silence_word", &silence_name,"sil", "name of silence word");
+  cmd.addSCmdOption("-silence_phone", &silence_phone,"h#", "name of silence phone");
+  cmd.addSCmdOption("-sp_word", &sp_name,"", "name of short pause word");
+  cmd.addSCmdOption("-sp_phone", &sp_phone,"", "name of short pause phoneme");
+  cmd.addRCmdOption("-log_word_entrance_penalty", &log_word_entrance_penalty, -15., "log of the word entrance penalty");
+  cmd.addBCmdOption("-add_sil_to_targets", &add_sil_to_targets, false, "add silence at begining of targets");
+  cmd.addBCmdOption("-no_self_transitions", &no_self_transitions, false, "do not admit grammar self transitions");
+  cmd.addBCmdOption("-isolated", &isolated, false, "isolated word recognition");
+  cmd.addBCmdOption("-force", &force, false, "do a forced alignment decoding");
+  cmd.addICmdOption("-min_duration", &min_duration, -1, "use minimum duration models");
+
+  cmd.addText("\nMisc Options:");
+
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addBCmdOption("-confusion", &confusion, false, "print confusion matrix");
+  cmd.addBCmdOption("-htk_model", &htk_model, false,"model file is in HTK format");
+  cmd.addBCmdOption("-disk", &disk, false, "keep data on disk");
+
+  // Read the command line
+  cmd.read(argc, argv);
+  cmd.setWorkingDirectory(dir_name);
+
+  DiskXFile::setBigEndianMode();
+
+  //==================================================================== 
+  //=================== Testing Mode  =================================
+  //==================================================================== 
+
+  Random::seed();
+
+  // read lexicon
+  if (strlen(sp_phone) == 0)                                                        sp_phone = NULL;
+  if (strlen(silence_phone) == 0)
+    silence_phone = NULL;
+  LexiconInfo lex(phoneme_name,silence_phone,sp_phone,lex_name,"<s>","</s>",silence_name);
+
+  // create grammar
+  int n_words = lex.vocabulary->n_words;
+  int silence_word = lex.vocabulary->sil_index;
+  Grammar grammar(n_words+3);
+  grammar.words[0] = -1; // initial state
+  grammar.words[1] = silence_word; // initial silence
+  grammar.words[n_words+1] = silence_word; // final silence
+  grammar.words[n_words+2] = -1; // final state
+  int* gw = &grammar.words[2];
+  for (int i=0;i<n_words;i++) {
+    if (i != silence_word)
+      *gw++ = i;
+  }
+  grammar.transitions[1][0] = true;
+  for (int i=0;i<n_words-1;i++) {
+    grammar.transitions[i+2][1] = true;
+    grammar.transitions[n_words+1][i+2] = true;
+    if (!isolated) {
+      for (int j=0;j<n_words-1;j++)
+        if (!no_self_transitions || i!=j)
+          grammar.transitions[j+2][i+2] = true;
+    }
+  }
+  grammar.transitions[n_words+2][n_words+1] = true;
+
+  //==================================================================== 
+  //=================== Create the DataSet ... =========================
+  //==================================================================== 
+
+  // some basic tests on the files
+  if (input_file_list.n_files != target_file_list.n_files) {
+    error("the input and target files should have the same number of files (%d != %d)\n",input_file_list.n_files,target_file_list.n_files);
+  }
+  for (int i=0;i<input_file_list.n_files;i++) {
+    char* si = strRemoveSuffix(input_file_list.file_names[i]);
+    char* st = strRemoveSuffix(target_file_list.file_names[i]);
+    if (strcmp(strBaseName(si),strBaseName(st)))
+      warning("input file (%s) do not correspond to target file (%s)",input_file_list.file_names[i],target_file_list.file_names[i]);
+    free(si);
+    free(st);
+  }
+
+  DataSet* data;
+  int n_per_frame;
+  if (disk) {
+    data = (DataSet*)new(allocator) DiskHTKDataSet(input_file_list.file_names,target_file_list.file_names, input_file_list.n_files, true, max_load, &lex);
+    n_per_frame = ((DiskHTKDataSet*)data)->n_per_frame;
+  } else {
+    data = (DataSet*)new(allocator) HTKDataSet(input_file_list.file_names,target_file_list.file_names, input_file_list.n_files, true, max_load, &lex);
+    n_per_frame = ((HTKDataSet*)data)->n_per_frame;
+  }
+
+  //=================== Create the HMM... =========================
+
+  SpeechHMM* shmm = NULL;
+  if (htk_model)
+    shmm = newSpeechHMMFromHTK(saved_model,&lex,NULL,0,allocator);
+  else
+    shmm = newSpeechHMMFromTorch(saved_model,&lex,NULL,0,allocator,&cmd);
+
+  if (min_duration > 0) {
+    int silence_model = silence_phone ? lex.phone_info->getIndex(silence_phone) : -1;
+    shmm = extend_SpeechHMM_to_min_duration(shmm,min_duration,allocator,silence_model);
+  }
+
+  SimpleDecoderSpeechHMM dhmm(shmm,&grammar);
+  dhmm.setROption("log word entrance penalty",log_word_entrance_penalty);
+  dhmm.setBOption("forced alignment",force);
+
+  //=================== Measurers and Trainer  ===============================
+
+  // Measurers on the training dataset
+  MeasurerList measurers;
+  WordSegMeasurer word_m(dhmm.wordseg,data,cmd.getXFile("decoder_word"),new(allocator)EditDistance(confusion));
+  word_m.setIOption("n per frame",n_per_frame);
+  word_m.setBOption("print timing",true);
+  measurers.addNode(&word_m);
+  FrameSegMeasurer frame_m(dhmm.frameseg,data,cmd.getXFile("decoder_frame"));
+  frame_m.setIOption("n per frame",n_per_frame);
+  frame_m.setBOption("print timing",true);
+  frame_m.setBOption("print desired timing",true);
+  frame_m.setBOption("print frame err",true);
+  measurers.addNode(&frame_m);
+
+  // The Gradient Machine Trainer
+  EMTrainer decoder(&dhmm);
+
+  //=================== Let's go... ===============================
+
+  decoder.decode(&measurers);
+
+  delete allocator;
+  return(0);
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/speech_hmm_tode_decode.cc work/main.d/Torch-3/examples/speech/speech_hmm_tode_decode.cc
--- tmp/Torch-3/examples/speech/speech_hmm_tode_decode.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/speech_hmm_tode_decode.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,246 @@
+const char *help = "\
+  GMM (c) Samy Bengio & Co 2001\n\
+  \n\
+  This program is used to do decode simple speech recognition \n";
+
+#include "LexiconInfo.h"
+#include "EMTrainer.h"
+#include "HMM.h"
+#include "CmdLine.h"
+#include "Random.h"
+#include "DiskHTKDataSet.h"
+#include "HTKDataSet.h"
+#include "PhoneModels.h"
+#include "LanguageModel.h"
+#include "LinearLexicon.h"
+#include "BeamSearchDecoder.h"
+#include "DiagonalGMM.h"
+#include "string_utils.h"
+#include "EditDistanceMeasurer.h"
+#include "WordSegMeasurer.h"
+#include "FileListCmdOption.h"
+
+using namespace Torch;
+
+#include "speech_include.cc"
+
+int main(int argc, char **argv)
+{
+  char* saved_model;
+  char* phoneme_name;
+  char* lex_name;
+
+  char* silence_phone;
+  char* sp_phone;
+  char* silence_word;
+  char* start_word;
+  char* end_word;
+  real log_word_entrance_penalty;
+  bool no_self_transitions;
+
+  int max_load;
+
+  char *dir_name;
+  bool htk_model;
+  bool disk;
+  bool print_timing;
+  char* lm_name;
+
+  Allocator *allocator = new Allocator;
+	
+	FileListCmdOption input_file_list("file name", "the list of inputs files or one data file");
+	input_file_list.isArgument(true);
+  
+	FileListCmdOption target_file_list("file name", "the list of target files or one target file");
+	target_file_list.isArgument(true);
+  
+	//=============================================================== 
+  //=================== The command-line ==========================
+  //=============================================================== 
+
+  // Construct the command line
+  CmdLine cmd;
+
+  // Put the help line at the beginning
+  cmd.info(help);
+
+  // Train mode
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("saved_model", &saved_model, "the saved model");
+  cmd.addSCmdArg("phoneme_name", &phoneme_name, "the list of phonemes file");
+  cmd.addSCmdArg("lex_name", &lex_name, "the lexicon file");
+	cmd.addCmdOption(&input_file_list);
+	cmd.addCmdOption(&target_file_list);
+
+  cmd.addText("\nModel Options:");
+  cmd.addSCmdOption("-lm", &lm_name,"", "optional language model");
+  cmd.addSCmdOption("-silence_phone", &silence_phone,"h#", "name of silence phone");
+  cmd.addSCmdOption("-sp_phone", &sp_phone,"", "name of short pause phoneme");
+  cmd.addSCmdOption("-silence_word", &silence_word,"sil", "name of silence word");
+  cmd.addSCmdOption("-start_word", &start_word,"<s>", "name of start word");
+  cmd.addSCmdOption("-end_word", &end_word,"</s>", "name of end word");
+  cmd.addRCmdOption("-log_word_entrance_penalty", &log_word_entrance_penalty, -15., "log of the word entrance penalty");
+  cmd.addBCmdOption("-no_self_transitions", &no_self_transitions, false, "do not admit grammar self transitions");
+
+  cmd.addText("\nMisc Options:");
+
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addBCmdOption("-htk_model", &htk_model, false,"model file is in HTK format");
+  cmd.addBCmdOption("-disk", &disk, false, "keep data on disk");
+  cmd.addBCmdOption("-print_timing", &print_timing, false, "print timing decoding information");
+
+  // Read the command line
+  cmd.read(argc, argv);
+  cmd.setWorkingDirectory(dir_name);
+
+  DiskXFile::setBigEndianMode();
+
+  //==================================================================== 
+  //=================== Testing Mode  =================================
+  //==================================================================== 
+
+  Random::seed();
+
+  // read lexicon
+  if (strlen(sp_phone) == 0)                                                        sp_phone = NULL;
+  if (strlen(silence_phone) == 0)
+    silence_phone = NULL;
+  LexiconInfo lexi(phoneme_name,silence_phone,sp_phone,lex_name,start_word,end_word);
+  int silence_index = lexi.vocabulary->getIndex(silence_word);
+
+  //==================================================================== 
+  //=================== Create the DataSet ... =========================
+  //==================================================================== 
+
+  // some basic tests on the files
+  if (input_file_list.n_files != target_file_list.n_files) {
+    error("the input and target files should have the same number of files (%d != %d)\n",input_file_list.n_files,target_file_list.n_files);
+  }
+  for (int i=0;i<input_file_list.n_files;i++) {
+    char* si = strRemoveSuffix(input_file_list.file_names[i]);
+    char* st = strRemoveSuffix(target_file_list.file_names[i]);
+    if (strcmp(strBaseName(si),strBaseName(st)))
+      warning("input file (%s) do not correspond to target file (%s)",input_file_list.file_names[i],target_file_list.file_names[i]);
+    free(si);
+    free(st);
+  }
+
+  DataSet* data;
+  int n_per_frame;
+  if (disk) {
+    data = (DataSet*)new(allocator) DiskHTKDataSet(input_file_list.file_names,target_file_list.file_names,input_file_list.n_files, true, max_load, &lexi); 
+    n_per_frame = ((DiskHTKDataSet*)data)->n_per_frame;
+  } else {
+    data = (DataSet*)new(allocator) HTKDataSet(input_file_list.file_names,target_file_list.file_names, input_file_list.n_files,true, max_load, &lexi);
+    n_per_frame = ((HTKDataSet*)data)->n_per_frame;
+  }
+
+  //=================== Create the HMM... =========================
+
+  SpeechHMM* shmm = NULL;
+  if (htk_model)
+    shmm = newSpeechHMMFromHTK(saved_model,&lexi,NULL,0,allocator);
+  else
+    shmm = newSpeechHMMFromTorch(saved_model,&lexi,NULL,0,allocator,&cmd);
+
+  PhoneModels pm(shmm);
+  LinearLexicon lex(shmm,&pm);
+  LanguageModel *lm = NULL;
+  if ((strcmp(lm_name,"")))
+    lm = new LanguageModel(2,lexi.vocabulary,lm_name,1.0);
+
+  BeamSearchDecoder decoder(&lex,lm,log_word_entrance_penalty,LOG_ZERO,LOG_ZERO,false);
+
+  shmm->setDataSet(data);
+  shmm->eMIterInitialize();
+  EditDistance edit_d;
+  EditDistanceMeasurer edit_m(&edit_d,data,cmd.getXFile("decoder_edit"));
+  WordSegMeasurer word_m(NULL,data,cmd.getXFile("decoder_word"));
+
+  for (int i=0;i<data->n_examples;i++) {
+    data->setExample(i);
+    int num_result_words;
+    int* result_words;
+    int* result_words_times;
+
+    // remove some words from target sequence
+    int n_targets = data->targets->n_frames;
+    int* targets = (int*)allocator->alloc(sizeof(int)*n_targets);
+    int k=0;
+    for (int j=0;j<data->targets->n_frames;j++) {
+      int word = (int)data->targets->frames[j][0];
+      if (word != lexi.vocabulary->sent_start_index &&
+          word != silence_index &&
+        word != lexi.vocabulary->sent_end_index) {
+        targets[k++] = word;
+      }
+    }
+    n_targets = k;
+
+    edit_d.reset();
+    decoder.decode(data->inputs->frames,data->inputs->n_frames,&num_result_words,&result_words,&result_words_times);
+
+    // remove some words from obtained sequence
+    k=0;
+    for (int j=0;j<num_result_words;j++) {
+      int ti = result_words_times[j];
+      int word = result_words[j];
+      if (word != lexi.vocabulary->sent_start_index &&
+        word != silence_index &&
+        word != lexi.vocabulary->sent_end_index) {
+        result_words_times[k] = ti;
+        result_words[k++] = word;
+      }
+    }
+    num_result_words = k;
+
+    edit_d.distance(result_words,num_result_words,targets,n_targets);
+    edit_m.measureExample();
+    word_m.file->printf("obtained: ");
+    for (int j=0;j<num_result_words;j++)
+      word_m.file->printf("%s ",lexi.vocabulary->getWord(result_words[j]));
+    word_m.file->printf("\n");
+
+    if (word_m.print_targets) {
+      word_m.file->printf("desired: ");
+      for (int j=0;j<n_targets;j++)
+        word_m.file->printf("%s ",lexi.vocabulary->getWord(targets[j]));
+      word_m.file->printf("\n");
+    }
+    if (print_timing) {
+      int last = 0;
+      for (int j=0;j<num_result_words-1;j++) {
+        word_m.file->printf("%d %d %s\n",last*n_per_frame,result_words_times[j+1]*n_per_frame,lexi.vocabulary->getWord(result_words[j]));
+        last = result_words_times[j+1];
+      }
+      word_m.file->printf("%d %d %s\n",last*n_per_frame,data->inputs->n_frames*n_per_frame,lexi.vocabulary->getWord(result_words[num_result_words-1]));
+    }
+    word_m.file->flush();
+
+/*
+    printf("obtained: ");
+    for (int j=0;j<num_result_words;j++) {
+      printf("%s ",lexi.vocabulary->getWord(result_words[j]));
+    }
+    printf("\n");
+    printf("desired: ");
+    for (int j=0;j<data->targets->n_frames;j++) {
+      printf("%s ",lexi.vocabulary->getWord((int)data->targets->frames[j][0]));
+    }
+    printf("\n");
+*/
+    free(result_words);
+    free(result_words_times);
+    allocator->free(targets);
+  }
+  edit_m.measureIteration();
+  word_m.measureIteration();
+  edit_m.measureEnd();
+  word_m.measureEnd();
+
+  if (lm)
+    delete lm;
+  delete allocator;
+  return(0);
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/speech_hmm_train.cc work/main.d/Torch-3/examples/speech/speech_hmm_train.cc
--- tmp/Torch-3/examples/speech/speech_hmm_train.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/speech_hmm_train.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,199 @@
+const char *help = "\
+speech_hmm_train (c) Samy Bengio & Co 2001\n\
+\n\
+This program is used to do speech recognition \n";
+
+#include "LexiconInfo.h"
+#include "EMTrainer.h"
+#include "HMM.h"
+#include "DiagonalGMM.h"
+#include "MatDataSet.h"
+#include "CmdLine.h"
+#include "NLLMeasurer.h"
+#include "Random.h"
+#include "DiskHTKDataSet.h"
+#include "HTKDataSet.h"
+#include "SpeechHMM.h"
+#include "FileListCmdOption.h"
+#include "string_utils.h"
+
+using namespace Torch;
+
+#include "speech_include.cc"
+
+int main(int argc, char **argv)
+{
+  char* phoneme_name;
+  char* lex_name;
+
+
+  char* silence_name;
+  char* silence_phone;
+  char* sp_name;
+  char* sp_phone;
+
+  real accuracy;
+  real threshold;
+  int max_iter;
+  real prior;
+
+  int max_load;
+  int the_seed;
+
+  char *dir_name;
+  char *model_file;
+  char *init_model;
+  bool add_sil_to_targets;
+  bool htk_model;
+  bool viterbi;
+  bool train_separate;
+  bool disk;
+
+  Allocator *allocator = new Allocator;
+
+	FileListCmdOption input_file_list("file name", "the list of inputs files or one data file");
+	input_file_list.isArgument(true);
+  
+	FileListCmdOption target_file_list("file name", "the list of target files or one target file");
+	target_file_list.isArgument(true);
+
+  //=============================================================== 
+  //=================== The command-line ==========================
+  //=============================================================== 
+
+  // Construct the command line
+  CmdLine cmd;
+
+  // Put the help line at the beginning
+  cmd.info(help);
+
+  // Train mode
+  cmd.addText("\nArguments:");
+  cmd.addSCmdArg("phoneme_name", &phoneme_name, "the list of phonemes file");
+  cmd.addSCmdArg("lex_name", &lex_name, "the lexicon file");
+	cmd.addCmdOption(&input_file_list);
+	cmd.addCmdOption(&target_file_list);
+  cmd.addSCmdArg("init model file", &init_model, "the initialized model file");
+
+  cmd.addText("\nModel Options:");
+  cmd.addSCmdOption("-silence_word", &silence_name,"sil", "name of silence word");
+  cmd.addSCmdOption("-silence_phone", &silence_phone,"h#", "name of silence phone");
+  cmd.addSCmdOption("-sp_word", &sp_name,"", "name of short pause word");
+  cmd.addSCmdOption("-sp_phone", &sp_phone,"", "name of short pause phoneme");
+  cmd.addBCmdOption("-add_sil_to_targets", &add_sil_to_targets, false, "add silence at begining of targets");
+
+  cmd.addText("\nLearning Options:");
+  cmd.addBCmdOption("-train_separate", &train_separate, false, "first train separate models");
+  cmd.addBCmdOption("-viterbi", &viterbi, false, "viterbi training (instead of EM)");
+  cmd.addRCmdOption("-threshold", &threshold, 0.001, "variance threshold");
+  cmd.addRCmdOption("-prior", &prior, 0.001, "prior on the weights");
+  cmd.addICmdOption("-iter", &max_iter, 25, "max number of iterations of HMM");
+  cmd.addRCmdOption("-e", &accuracy, 0.00001, "end accuracy");
+
+  cmd.addText("\nMisc Options:");
+  cmd.addICmdOption("-seed", &the_seed, -1, "the random seed");
+  cmd.addICmdOption("-load", &max_load, -1, "max number of examples to load for train");
+  cmd.addSCmdOption("-dir", &dir_name, ".", "directory to save measures");
+  cmd.addSCmdOption("-save", &model_file, "", "the model file");
+  cmd.addBCmdOption("-htk_model", &htk_model, false, "load and save in HTK model format");
+  cmd.addBCmdOption("-disk", &disk, false, "keep data on disk");
+
+  // Read the command line
+  cmd.read(argc, argv);
+  cmd.setWorkingDirectory(dir_name);
+
+  DiskXFile::setBigEndianMode();
+
+  //==================================================================== 
+  //=================== Training Mode  =================================
+  //==================================================================== 
+
+  if(the_seed == -1)
+    Random::seed();
+  else
+    Random::manualSeed((long)the_seed);
+
+  // read lexicon
+  if (strlen(sp_phone) == 0)
+    sp_phone = NULL;
+  if (strlen(silence_phone) == 0)
+    silence_phone = NULL;
+  LexiconInfo lex(phoneme_name,silence_phone,sp_phone,lex_name,add_sil_to_targets ? silence_name : NULL,NULL);
+
+  //==================================================================== 
+  //=================== Create the DataSet ... =========================
+  //==================================================================== 
+
+  // some basic tests on the files
+  if (input_file_list.n_files != target_file_list.n_files) {
+    error("the input and target files should have the same number of files (%d != %d)\n",input_file_list.n_files,target_file_list.n_files);
+  }
+  for (int i=0;i<input_file_list.n_files;i++) {
+    char* si = strRemoveSuffix(input_file_list.file_names[i]);
+    char* st = strRemoveSuffix(target_file_list.file_names[i]);
+    if (strcmp(strBaseName(si),strBaseName(st)))
+      warning("input file (%s) do not correspond to target file (%s)",input_file_list.file_names[i],target_file_list.file_names[i]);
+    free(si);
+    free(st);
+  }
+
+
+  DataSet* data;
+  if (disk)
+    data = (DataSet*)new(allocator) DiskHTKDataSet(input_file_list.file_names,target_file_list.file_names, input_file_list.n_files, true, max_load, &lex);
+  else
+    data = (DataSet*)new(allocator) HTKDataSet(input_file_list.file_names,target_file_list.file_names, input_file_list.n_files, true, max_load, &lex);
+
+  //=================== Create the HMM... =========================
+
+  real* thresh = (real*)allocator->alloc(data->n_inputs*sizeof(real));
+  initializeThreshold(data,thresh,threshold);  
+
+  SpeechHMM* shmm = NULL;
+  if (htk_model)
+    shmm = newSpeechHMMFromHTK(cmd.getPath(init_model),&lex,thresh,prior,allocator);
+  else
+    shmm = newSpeechHMMFromTorch(cmd.getPath(init_model),&lex,thresh,prior,allocator,&cmd);
+  
+  //=================== Measurers and Trainer  ===============================
+
+  // Measurers on the training dataset
+  MeasurerList measurers;
+  char* n_nll = strConcat(2,"hmm_train_val_",viterbi ? "viterbi" : "em");
+  allocator->retain(n_nll);
+  NLLMeasurer nll_meas(shmm->log_probabilities, data, cmd.getXFile(n_nll));
+  measurers.addNode(&nll_meas);
+
+  // The Gradient Machine Trainer
+  EMTrainer trainer(shmm);
+  trainer.setIOption("max iter", max_iter);
+  trainer.setROption("end accuracy", accuracy);
+  if (viterbi) 
+    trainer.setBOption("viterbi", true);
+
+  //=================== Let's go... ===============================
+
+  trainer.train(data, &measurers);
+
+  if(strcmp(model_file, "")) {
+    if (htk_model) {
+      save_htk_model(cmd.getPath(model_file),shmm,lex.phone_info->phone_names);
+    } else {
+      DiskXFile model_(cmd.getPath(model_file), "w");
+      cmd.saveXFile(&model_);
+      int n_models = shmm->n_models;
+      int n_gaussians = ((DiagonalGMM*)((HMM*)shmm->models[n_models-2])->states[1])->n_gaussians;
+      int* states = (int*)allocator->alloc(sizeof(int)*n_models);
+      for (int i=0;i<n_models;i++)
+        states[i] = shmm->models[i]->n_states;
+      model_.taggedWrite(&n_gaussians, sizeof(int), 1, "n_gaussians");
+      model_.taggedWrite(&n_models, sizeof(int), 1, "n_phonemes");
+      model_.taggedWrite(states,sizeof(int), n_models, "n_states");
+      model_.taggedWrite(&data->n_inputs, sizeof(int), 1, "n_inputs");
+      shmm->saveXFile(&model_);
+    }
+  }
+
+  delete allocator;
+  return(0);
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/speech_include.cc work/main.d/Torch-3/examples/speech/speech_include.cc
--- tmp/Torch-3/examples/speech/speech_include.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/speech_include.cc	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,409 @@
+
+void get_line(FILE* f, char* line, int n)
+{
+  char* r = fgets(line,n,f);
+  if (r != NULL && (int)strlen(r) == n-1)
+    error("the string is too long!");
+}
+
+void initializeThreshold(DataSet* data,real* thresh, real threshold)
+{
+  MeanVarNorm norm(data);
+  real* ptr = norm.inputs_stdv;
+  real* p_var = thresh;
+  for(int i=0;i<data->n_inputs;i++)
+    *p_var++ = *ptr * *ptr++ * threshold;
+}
+
+void read_phonemes(const char* filename, char*** phonemes_, int *n_phonemes, Allocator* allocator)
+{
+  DiskXFile f(filename, "r");
+
+  *n_phonemes = 0;
+  char bidon[10000];
+  do {
+    f.gets(bidon,10000);
+    *n_phonemes += 1;
+  } while (!f.eof());
+  *n_phonemes -= 1;
+  f.rewind();
+  
+  char** phonemes = (char**)allocator->alloc(sizeof(char*)* *n_phonemes);
+  char word[100];
+  for (int i=0;i< *n_phonemes;i++) {
+    f.scanf("%s",word);
+    phonemes[i] = (char*)allocator->alloc(sizeof(char)*(strlen(word)+1));
+    strcpy(phonemes[i],word);
+  }
+  message("%d phonemes detected", *n_phonemes);
+  *phonemes_ = phonemes;
+}
+
+int* read_states(const char* filename, int n_phonemes, int n_states, int pause_index, Allocator* allocator)
+{
+  int* states = (int*)allocator->alloc(sizeof(int)*n_phonemes);
+  if (strcmp(filename,"")==0) {
+    for (int i=0;i<n_phonemes;i++)
+      states[i] = n_states;
+    if (pause_index>=0)
+      states[pause_index] = 3;
+  } else {
+    DiskXFile f(filename, "r");
+
+    for (int i=0;i< n_phonemes;i++) {
+      f.scanf("%d",&states[i]);
+    }
+  }
+  return states;
+}
+
+// this function saves in HTK format a given SpeechHMM
+void save_htk_model(char* filename, SpeechHMM* shmm, char**phonemes)
+{
+  FILE* f=fopen(filename,"w");
+  if (!f)
+    error("file %s cannot be opened",filename);
+  fprintf(f,"~o\n");
+  fprintf(f,"<STREAMINFO> 1 %d\n",shmm->n_inputs);
+  fprintf(f,"<VECSIZE> %d<NULLD><MFCC_D_A_O>\n",shmm->n_inputs);
+  for (int i=0;i<shmm->n_models;i++) {
+    HMM* hmm = shmm->models[i];
+    fprintf(f,"~h \"%s\"\n",phonemes[i]);
+    fprintf(f,"<BEGINHMM>\n");
+    fprintf(f,"<NUMSTATES> %d\n",hmm->n_states);
+    for (int j=1;j<hmm->n_states-1;j++) {
+      DiagonalGMM* gmm = (DiagonalGMM*)hmm->states[j];
+      fprintf(f,"<STATE> %d\n",j+1);
+      fprintf(f,"<NUMMIXES> %d\n",gmm->n_gaussians);
+      for (int k=0;k<gmm->n_gaussians;k++) {
+        fprintf(f,"<MIXTURE> %d %12.10e\n",k+1,exp(gmm->log_weights[k]));
+        fprintf(f,"<MEAN> %d\n",gmm->n_inputs);
+        for (int l=0;l<gmm->n_inputs;l++) {
+          fprintf(f,"%12.10e ",gmm->means[k][l]);
+        }
+        fprintf(f,"\n");
+        fprintf(f,"<VARIANCE> %d\n",gmm->n_inputs);
+        for (int l=0;l<gmm->n_inputs;l++) {
+          fprintf(f,"%12.10e ",gmm->var[k][l]);
+        }
+        fprintf(f,"\n");
+      }
+    }
+    fprintf(f,"<TRANSP> %d\n",hmm->n_states);
+    for (int j=0;j<hmm->n_states;j++) {
+      for (int k=0;k<hmm->n_states;k++) {
+        fprintf(f,"%12.10e ",hmm->log_transitions[k][j] != LOG_ZERO ? exp(hmm->log_transitions[k][j]) : 0);
+      }
+      fprintf(f,"\n");
+    }
+    fprintf(f,"<ENDHMM>\n");
+  }
+  fclose(f);
+}
+
+// load a SpeechHMM that was saved in the HTK format
+// assumes that it uses DiagonalGMMs
+void load_htk_model(char* filename, SpeechHMM* shmm)
+{
+  char line[10000];
+  char* values[10000];
+  int n;
+  FILE* f=fopen(filename,"r");
+  if (!f)
+    error("file %s cannot be opened",filename);
+  // initialization
+  for (int i=0;i<shmm->n_models;i++) {
+    HMM* hmm = shmm->models[i];
+    for (int j=1;j<hmm->n_states-1;j++) {
+      DiagonalGMM* gmm = (DiagonalGMM*)hmm->states[j];
+      for (int k=0;k<gmm->n_gaussians;k++) {
+        gmm->log_weights[k] = LOG_ZERO;
+        for (int l=0;l<gmm->n_inputs;l++) {
+          gmm->means[k][l] = 0;
+          gmm->var[k][l] = 1;
+        }
+      }
+    }
+    for (int j=0;j<hmm->n_states;j++) {
+      for (int k=0;k<hmm->n_states;k++) {
+        hmm->log_transitions[k][j] = LOG_ZERO;
+      }
+    }
+  }
+  // reading the model
+  int model = -1;
+  int state = 0;
+  int mixture = 0;
+  real w;
+  HMM* hmm = NULL;
+  DiagonalGMM* gmm = NULL;
+  get_line(f,line,10000);
+  while (!feof(f)) {
+    if (strstr(line,"~h")) {
+      model++;
+      hmm = shmm->models[model];
+    } else if (strstr(line,"<STATE>")) {
+      sscanf(line,"%*s %d",&state);
+      gmm = (DiagonalGMM*)hmm->states[state-1];
+    } else if (strstr(line,"<MIXTURE>")) {
+#ifdef USE_DOUBLE
+      sscanf(line,"%*s %d %lf",&mixture,&w);
+#else
+      sscanf(line,"%*s %d %f",&mixture,&w);
+#endif
+      gmm->log_weights[mixture-1] = log(w);
+    } else if (strstr(line,"<MEAN>")) {
+      get_line(f,line,10000);
+      values[0] = strtok(line," ");
+      for (n=1;(values[n]=strtok(NULL," "));n++);
+      for (int l=0;l<gmm->n_inputs;l++) {
+        gmm->means[mixture-1][l] = (real)atof(values[l]);;
+      }
+    } else if (strstr(line,"<VARIANCE>")) {
+      get_line(f,line,10000);
+      values[0] = strtok(line," ");
+      for (n=1;(values[n]=strtok(NULL," "));n++);
+      for (int l=0;l<gmm->n_inputs;l++) {
+        gmm->var[mixture-1][l] = (real)atof(values[l]);;
+      }
+    } else if (strstr(line,"<TRANSP>")) {
+      for (int j=0;j<hmm->n_states;j++) {
+        get_line(f,line,10000);
+        values[0] = strtok(line," ");
+        for (n=1;(values[n]=strtok(NULL," "));n++);
+        for (int k=0;k<hmm->n_states;k++) {
+          w = atof(values[k]);
+          hmm->log_transitions[k][j] = w == 0 ? LOG_ZERO : log(w);
+        }
+      }
+    } 
+    get_line(f,line,10000);
+  }   
+  fclose(f);
+}   
+
+void setTransitions(real** transitions, int phoneme_n_states, int current_phoneme, int sp_phoneme, int silence_phoneme, bool full_connect)
+{
+  for (int j=0;j<phoneme_n_states;j++) {
+    for (int k=0;k<phoneme_n_states;k++)
+      transitions[j][k] = 0;
+  }
+  if (full_connect) {
+    for (int i=1;i<phoneme_n_states-1;i++) {
+       transitions[i][0] = 1./(phoneme_n_states-2);
+       for (int j=1;j<phoneme_n_states;j++) {
+          transitions[j][i] = 1./(phoneme_n_states-1);
+       }
+    }
+  } else {
+    transitions[1][0] = 1;
+    for (int j=1;j<phoneme_n_states-1;j++) {
+      transitions[j][j] = 0.5;
+      transitions[j+1][j] = 0.5;
+    }
+  }
+
+  // the short pause is special
+  if (current_phoneme == sp_phoneme) {
+    for (int j=0;j<phoneme_n_states;j++) {
+      for (int k=0;k<phoneme_n_states;k++)
+        transitions[j][k] = 0;
+    }
+    transitions[1][0] = 0.5;
+    transitions[2][0] = 0.5;
+  }
+
+  // the silence model is special
+  if (current_phoneme == silence_phoneme && !full_connect) {
+    for (int j=1;j<phoneme_n_states-2;j++) {
+      transitions[j+2][j] = 1./3.;
+      transitions[j+1][j] = 1./3.;
+      transitions[j][j] = 1./3.;
+    }
+  }
+}
+
+SpeechHMM* newSpeechHMM(int* states, int n_gaussians, int n_models, int n_inputs, LexiconInfo* lex, real* thresh, real prior, Allocator* allocator)
+{
+  DiagonalGMM*** gmms = (DiagonalGMM ***)allocator->alloc(sizeof(DiagonalGMM**)*n_models);
+  HMM** hmm = (HMM**)allocator->alloc(sizeof(HMM*)*n_models);
+  real*** transitions = (real***)allocator->alloc(n_models*sizeof(real**));
+  for (int i=0;i<n_models;i++) {
+    gmms[i] = (DiagonalGMM**)allocator->alloc(sizeof(DiagonalGMM*)*states[i]);
+    for (int j=1;j<states[i]-1;j++) {
+      DiagonalGMM* gmm = new(allocator)DiagonalGMM(n_inputs,n_gaussians);
+
+      // set the training options
+      if (thresh)
+        gmm->setVarThreshold(thresh);
+      if (prior>0)
+        gmm->setROption("prior weights",prior);
+      gmms[i][j] = gmm;
+    }
+
+    gmms[i][0] = NULL;
+    gmms[i][states[i]-1] = NULL;
+
+    // the transition table probability: left-right topology
+    transitions[i] = (real**)allocator->alloc(states[i]*sizeof(real*));
+    for (int j=0;j<states[i];j++) {
+      transitions[i][j] = (real*)allocator->alloc(states[i]*sizeof(real));
+    }
+    setTransitions(transitions[i], states[i], i, lex->phone_info->pause_index, 
+      lex->phone_info->sil_index,false);
+
+    hmm[i] = new (allocator)HMM(states[i],(Distribution**)gmms[i],transitions[i]);
+    hmm[i]->setROption("prior transitions",prior);
+    hmm[i]->setBOption("initialize", false);
+  }
+
+  SpeechHMM* shmm = new(allocator) SpeechHMM(n_models,hmm,lex);
+  shmm->setBOption("initialize", false);
+  return shmm;
+}
+
+SpeechHMM* newSpeechHMMFromTorch(char* file, LexiconInfo* lex, real* thresh, real prior, Allocator* allocator, CmdLine* cmd)
+{
+  int n_gaussians;
+  int n_phonemes;
+  int n_inputs;
+  DiskXFile f(file,"r");
+  cmd->loadXFile(&f);
+  f.taggedRead(&n_gaussians, sizeof(int), 1, "n_gaussians");
+  f.taggedRead(&n_phonemes, sizeof(int), 1, "n_phonemes");
+  int* states = (int*)allocator->alloc(sizeof(int)*n_phonemes);
+  f.taggedRead(states, sizeof(int), n_phonemes, "n_states");
+  f.taggedRead(&n_inputs, sizeof(int), 1, "n_inputs");
+  SpeechHMM* shmm = newSpeechHMM(states, n_gaussians, n_phonemes, n_inputs, 
+    lex, thresh, prior, allocator);
+  shmm->loadXFile(&f);
+  return shmm;
+}
+
+SpeechHMM* newSpeechHMMFromHTK(char* file, LexiconInfo* lex, real* thresh, real prior, Allocator* allocator)
+{
+  DiskXFile* f = new(allocator) DiskXFile(file,"r");
+  int n_gaussians = 0;
+  int n_phonemes = 0;
+  int n_inputs = 0;
+  int* states = NULL;
+  char line[10000];
+  char* values[10000];
+  f->gets(line,10000);
+  while (!f->eof()) {
+    if (strstr(line,"~h")) {
+      n_phonemes++;
+      states = (int*)allocator->realloc(states,sizeof(int)*n_phonemes);
+    } else if (strstr(line,"<NUMSTATES>")) {
+      values[0] = strtok(line," ");
+      values[1] = strtok(NULL," ");
+      states[n_phonemes-1] = atoi(values[1]);
+    } else if (strstr(line,"<NUMMIXES>")) {
+      values[0] = strtok(line," ");
+      values[1] = strtok(NULL," ");
+      n_gaussians = atoi(values[1]);
+    } else if (strstr(line,"<MEAN>")) {
+      values[0] = strtok(line," ");
+      values[1] = strtok(NULL," ");
+      n_inputs = atoi(values[1]);
+    }
+    f->gets(line,10000);
+  }
+  allocator->free(f);
+  SpeechHMM* shmm = newSpeechHMM(states, n_gaussians, n_phonemes, n_inputs, 
+    lex, thresh, prior, allocator);
+  load_htk_model(file, shmm);
+  return shmm;
+}
+
+HMM* extend_HMM_to_min_duration(HMM* hmm,int min_duration, Allocator* allocator)
+{
+  // how many states should I add
+  int n_states_to_add = min_duration - (hmm->n_states - 2);
+
+  if (n_states_to_add <= 0) {
+    warning("no added state");
+    return hmm;
+  }
+  
+  // the solution can not work if there are already shared states
+  if (hmm->n_shared_states > 0)
+    error("cannot add states since n_shared_states = %d",hmm->n_shared_states);
+
+  // let's duplicate the last real state
+  // we first need to create shared states
+  int n_shared_states = hmm->n_states - 2;
+  Distribution** shared_states = (Distribution**)allocator->alloc(sizeof(Distribution*)*n_shared_states);
+  for (int i=0;i<n_shared_states;i++)
+    shared_states[i] = hmm->states[i+1];
+
+  // then redo the states themselves
+  int new_n_states = hmm->n_states + n_states_to_add;
+  Distribution** states = (Distribution**)allocator->alloc(sizeof(Distribution*)*new_n_states);
+  states[0] = NULL;
+  states[new_n_states-1] = NULL;
+  for (int i=1;i<hmm->n_states-1;i++)
+    states[i] = shared_states[i-1];
+  for (int i=0;i<n_states_to_add;i++)
+    states[i+hmm->n_states-1] = shared_states[n_shared_states-1];
+
+  // then the transitions
+  real** transitions = (real**)allocator->alloc(sizeof(real*)*new_n_states);
+  for (int i=0;i<new_n_states;i++) {
+    transitions[i] = (real*)allocator->alloc(sizeof(real)*new_n_states);
+    for (int j=0;j<new_n_states;j++) {
+      transitions[i][j] = 0;
+    }
+  }
+  // copy old transitions
+  for (int i=0;i<hmm->n_states;i++) {
+    for (int j=0;j<hmm->n_states;j++) {
+      if (hmm->log_transitions[i][j] != LOG_ZERO) {
+        transitions[i][j] = exp(hmm->log_transitions[i][j]);
+      }
+    }
+  }
+  // add new transitions based on the old last state transitions
+  // (assume left-right transitions!)
+  int last_s = hmm->n_states-2;
+  for (int i=0;i<n_states_to_add;i++) {
+    int s = i+hmm->n_states-1;
+    transitions[s][s] = exp(hmm->log_transitions[last_s][last_s]);
+    transitions[s+1][s] = exp(hmm->log_transitions[last_s+1][last_s]);
+  }
+
+  HMM* n_hmm = new(allocator) HMM(new_n_states,states,transitions,n_shared_states,shared_states);
+  n_hmm->initialize = hmm->initialize;
+  n_hmm->linear_segmentation = hmm->linear_segmentation;
+  n_hmm->prior_transitions = hmm->prior_transitions;
+  for (int i=0;i<n_hmm->n_states;i++) {
+    real *p = n_hmm->transitions[i];
+    real *lp = n_hmm->log_transitions[i];
+    for (int j=0;j<n_hmm->n_states;j++,lp++,p++) {
+      if (*p > 0)
+        *lp = log(*p);
+      else
+        *lp = LOG_ZERO;
+    }
+  }
+  return n_hmm;
+}
+
+SpeechHMM* extend_SpeechHMM_to_min_duration(SpeechHMM* shmm,int min_duration, Allocator* allocator, int silence_model)
+{
+  LexiconInfo* lex = shmm->lexicon;
+  EMTrainer** mtrainer = shmm->model_trainer;
+  int n_models = shmm->n_models;
+  HMM** models = (HMM**)allocator->alloc(sizeof(HMM*)*n_models);
+  for (int i=0;i<n_models;i++) {
+    if (i == silence_model)
+      models[i] = shmm->models[i];
+    else
+      models[i] = extend_HMM_to_min_duration(shmm->models[i],min_duration,allocator);
+  }
+  SpeechHMM* new_shmm = new(allocator) SpeechHMM(n_models,models,lex,mtrainer);
+  new_shmm->prior_transitions = shmm->prior_transitions;
+  new_shmm->phoneme_targets = shmm->phoneme_targets;
+  return new_shmm;
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/train_align_tri work/main.d/Torch-3/examples/speech/train_align_tri
--- tmp/Torch-3/examples/speech/train_align_tri	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/train_align_tri	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,4 @@
+data/aligned_tri_targets/NU-1002.streetaddr.lab
+data/aligned_tri_targets/NU-1002.zipcode.lab
+data/aligned_tri_targets/NU-1007.streetaddr.lab
+data/aligned_tri_targets/NU-1007.zipcode.lab
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/train_files work/main.d/Torch-3/examples/speech/train_files
--- tmp/Torch-3/examples/speech/train_files	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/train_files	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,4 @@
+data/inputs/NU-1002.streetaddr.mfcSC
+data/inputs/NU-1002.zipcode.mfcSC
+data/inputs/NU-1007.streetaddr.mfcSC
+data/inputs/NU-1007.zipcode.mfcSC
diff --speed-large-files --minimal -Nru tmp/Torch-3/examples/speech/train_word work/main.d/Torch-3/examples/speech/train_word
--- tmp/Torch-3/examples/speech/train_word	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/examples/speech/train_word	2004-08-11 12:34:39.000000000 -0400
@@ -0,0 +1,4 @@
+data/targets/NU-1002.streetaddr.lab
+data/targets/NU-1002.zipcode.lab
+data/targets/NU-1007.streetaddr.lab
+data/targets/NU-1007.zipcode.lab
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/ClassNLLCriterion.cc work/main.d/Torch-3/gradients/ClassNLLCriterion.cc
--- tmp/Torch-3/gradients/ClassNLLCriterion.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/ClassNLLCriterion.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,59 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "ClassNLLCriterion.h"
+
+namespace Torch {
+
+ClassNLLCriterion::ClassNLLCriterion(ClassFormat *class_format_) : Criterion(class_format_->n_classes)
+{
+  class_format = class_format_;
+}
+
+void ClassNLLCriterion::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  int the_class = class_format->getClass(data->targets->frames[t]);
+  f_outputs[0] = -f_inputs[the_class];
+}
+
+void ClassNLLCriterion::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  if(partial_backprop)
+    return;
+
+  int the_class = class_format->getClass(data->targets->frames[t]);
+  for(int i = 0; i < n_inputs; i++)
+    beta_[i] = 0;
+  beta_[the_class] = -1;
+}
+
+ClassNLLCriterion::~ClassNLLCriterion()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/ClassNLLCriterion.h work/main.d/Torch-3/gradients/ClassNLLCriterion.h
--- tmp/Torch-3/gradients/ClassNLLCriterion.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/ClassNLLCriterion.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,71 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLASS_NLL_CRITERION_INC
+#define CLASS_NLL_CRITERION_INC
+
+#include "Criterion.h"
+#include "ClassFormat.h"
+
+namespace Torch {
+
+/** This criterion can be used to train *in classification* a #GradientMachine#
+    object using the #StochasticGradient# trainer. It then maximizes the log 
+    likelihood of the data.
+
+    If we write $o_i$ for the output $i$ of the #GradientMachine#, it supposes that
+    \begin{itemize}
+      \item the outputs $o_i$ are log-probabilities.
+      \item $exp(o_i)$ is the probability for the class $i$
+      \item the predicted class follows a multinomial distribution with parameters
+            $(exp(o_1), exp(o_2), exp(o_3)...)$
+    \end{itemize}
+
+    The number of target frames in #DataSet# must
+    correspond to the number of input frames given
+    to this criterion.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class ClassNLLCriterion : public Criterion
+{
+  public:
+    ClassFormat *class_format;
+
+    /// The ClassFormat is needed just to know how the targets are encoded in the dataset.
+    ClassNLLCriterion(ClassFormat *class_format);
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+    virtual ~ClassNLLCriterion();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/ConnectedMachine.cc work/main.d/Torch-3/gradients/ConnectedMachine.cc
--- tmp/Torch-3/gradients/ConnectedMachine.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/ConnectedMachine.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,466 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "ConnectedMachine.h"
+
+// Entering Level 2 code zone.
+// Wizard with more than 100000XP allowed only.
+// You shoud go away.
+// You're still here ?!
+// You've been warned.
+
+namespace Torch {
+
+ConnectedMachine::ConnectedMachine() : GradientMachine(0, 0)
+{
+  n_layers = 0;
+  n_machines_on_layer = NULL;
+  machines = NULL;
+
+  current_layer = -1;
+  current_machine = -1;
+
+  // NOTE: start_alpha hack_a_donf mode. Comme je le rempli moi-meme,
+  // je fous pas frame_size ici.
+  start_alpha = new(allocator) Sequence;
+  current_alpha_offset = 0;
+
+  addLayer();
+}
+
+void ConnectedMachine::build()
+{
+  // Check links
+  checkInternalLinks();
+
+  // Outputs... direct connection ?
+  if(n_machines_on_layer[n_layers-1] > 1)
+    outputs = new(allocator) Sequence(0, n_outputs);
+  else
+    outputs = machines[n_layers-1][0]->machine->outputs;
+
+  // Beta...
+  if(n_machines_on_layer[0] > 1)
+    beta = new(allocator) Sequence(0, n_inputs);
+  else
+    beta = machines[0][0]->machine->beta;
+
+  // Params...
+  for(int l = 0; l < n_layers; l++)
+  {
+    for(int m = 0; m < n_machines_on_layer[l]; m++)
+    {
+      ConnectedNode *node = machines[l][m];
+
+      if(l > 0)
+      {
+        if(node->n_input_links == 1)
+          node->inputs = node->input_links[0];
+        else
+          node->inputs = new(allocator) Sequence(0, node->machine->n_inputs);
+      }
+
+      node->alpha = new(allocator) Sequence(0, node->machine->n_outputs);
+      params->add(node->machine->params);
+      der_params->add(node->machine->der_params);
+    }
+  }
+}
+
+void ConnectedMachine::addFCL(GradientMachine *machine)
+{
+  if(n_machines_on_layer[current_layer])
+    addLayer();
+  
+  addMachine(machine);
+  
+  if(n_layers > 1)
+  {
+    for(int i = 0; i < n_machines_on_layer[current_layer-1]; i++)
+      connectOn(machines[current_layer-1][i]->machine);
+  }
+}
+
+void ConnectedMachine::addLayer()
+{
+  n_outputs = 0;
+
+  if(n_layers > 0)
+  {
+    if(n_machines_on_layer[n_layers-1] == 0)
+      error("ConnectedMachine: one layer without any machine !?!");
+  }
+
+  machines = (ConnectedNode ***)allocator->realloc(machines, (n_layers+1)*sizeof(ConnectedNode **));
+  n_machines_on_layer = (int *)allocator->realloc(n_machines_on_layer, sizeof(int)*(n_layers+1));
+  machines[n_layers] = NULL;
+  n_machines_on_layer[n_layers] = 0;
+  
+  current_layer = n_layers;
+  current_machine = -1;
+
+  n_layers++;
+}
+
+void ConnectedMachine::addMachine(GradientMachine *machine)
+{
+  machines[current_layer] = (ConnectedNode **)allocator->realloc(machines[current_layer],
+                                                    (n_machines_on_layer[current_layer] + 1)*sizeof(ConnectedNode *));
+  machines[current_layer][n_machines_on_layer[current_layer]] = (ConnectedNode *)allocator->alloc(sizeof(ConnectedNode));
+
+  // Initialisations diverses
+  ConnectedNode *node = machines[current_layer][n_machines_on_layer[current_layer]];
+  node->machine = machine;
+  node->input_links = NULL;
+  node->n_input_links = 0;
+  node->alpha_links = NULL;
+  node->n_alpha_links = 0;
+  node->alpha_links_offset = NULL;
+  node->n_inputs_check = 0;
+  node->inputs = NULL;
+  node->alpha = NULL;
+
+  //---
+
+  current_machine = n_machines_on_layer[current_layer];
+  n_machines_on_layer[current_layer]++;
+
+  if(current_layer == 0)
+  {
+    if(n_machines_on_layer[0] > 1)
+    {
+      if(machine->n_inputs != n_inputs)
+        error("ConnectedMachine: trying to connect machine of different input size at the first layer");
+    }
+    else
+      n_inputs = machine->n_inputs;
+  }
+
+  n_outputs += machine->n_outputs;
+  current_alpha_offset = 0;
+}
+
+void ConnectedMachine::connectOn(GradientMachine *machine)
+{
+  if(current_machine < 0)
+    error("ConnectedMachine: no machine to connect");
+
+  bool flag = true;
+  int l, m = -666;
+  for(l = 0; (l < current_layer) && flag; l++)
+  {
+    for(m = 0; m < n_machines_on_layer[l]; m++)
+    {
+      if(machines[l][m]->machine == machine)
+      {
+        flag = false;
+        break;
+      }
+    }
+  }
+
+  l--;
+
+  if(flag)
+    error("ConnectedMachine: cannot connect your machine");
+
+  ConnectedNode *node = machines[current_layer][current_machine];
+  node->input_links = (Sequence **)allocator->realloc(node->input_links, sizeof(Sequence *)*(node->n_input_links+1));
+  node->input_links[node->n_input_links] = machine->outputs;
+  node->n_inputs_check += machines[l][m]->machine->n_outputs;
+  node->n_input_links++;
+
+  node = machines[l][m];
+  node->alpha_links = (Sequence **)allocator->realloc(node->alpha_links, sizeof(Sequence *)*(node->n_alpha_links+1));
+  node->alpha_links[node->n_alpha_links] = machines[current_layer][current_machine]->machine->beta;
+  node->alpha_links_offset = (int *)allocator->realloc(node->alpha_links_offset, sizeof(int)*(node->n_alpha_links+1));
+  node->alpha_links_offset[node->n_alpha_links] = current_alpha_offset;
+  node->n_alpha_links++;
+
+  current_alpha_offset += machine->n_outputs;
+
+//  printf("[%d %d on %d %d] machine %d outputs. = machine mere: %d outputs. machine fils: %d inputs\n", l, m, current_layer, current_machine, machine->n_outputs, machines[l][m]->n_outputs, machines[current_layer][current_machine]->n_inputs);
+}
+
+void ConnectedMachine::checkInternalLinks()
+{
+  for(int l = 1; l < n_layers; l++)
+  {
+    for(int m = 0; m < n_machines_on_layer[l]; m++)
+    {
+      if(machines[l][m]->machine->n_inputs != machines[l][m]->n_inputs_check)
+        error("ConnectedMachine: incorrect number of inputs for machine [%d %d] (%d instead of %d)", l, m, machines[l][m]->machine->n_inputs, machines[l][m]->n_inputs_check);
+    }
+  }
+}
+
+void ConnectedMachine::forward(Sequence *inputs)
+{
+  for(int m = 0; m < n_machines_on_layer[0]; m++)
+    machines[0][m]->machine->forward(inputs);
+
+  for(int l = 1; l < n_layers; l++)
+  {
+    for(int m = 0; m < n_machines_on_layer[l]; m++)
+    {
+      ConnectedNode *node = machines[l][m];
+
+      // NOTE: check for direct input connection
+      // NOTE: node->inputs doit etre alors sur node->input_links[0] (sinon sequence vide)
+      if(node->n_input_links == 1)
+        node->machine->forward(node->inputs);
+      else
+      {
+        int n_frames_ = node->input_links[0]->n_frames;
+        node->inputs->resize(n_frames_);
+
+        int offset_ = 0;
+        for(int i = 0; i < node->n_input_links; i++)
+        {
+          int n_inputs_ = node->input_links[i]->frame_size;
+          for(int j = 0; j < n_frames_; j++)
+          {
+            real *dest_ = node->inputs->frames[j] + offset_;
+            real *src_ = node->input_links[i]->frames[j];
+
+            for(int k = 0; k < n_inputs_; k++)
+              dest_[k] = src_[k];
+          }
+          offset_ += n_inputs_;
+        }
+        node->machine->forward(node->inputs);
+      }
+    }
+  }
+
+  // NOTE: if not direct output connection, updates output.
+  if(n_machines_on_layer[n_layers-1] > 1)
+  {
+    int n_frames_ = machines[n_layers-1][0]->machine->outputs->n_frames;
+    outputs->resize(n_frames_);
+
+    int offset_ = 0;
+    for(int i = 0; i < n_machines_on_layer[n_layers-1]; i++)
+    {
+      int n_outputs_ = machines[n_layers-1][i]->machine->n_outputs;
+      for(int j = 0; j < n_frames_; j++)
+      {
+        real *dest_ = outputs->frames[j] + offset_;
+        real *src_ = machines[n_layers-1][i]->machine->outputs->frames[j];
+        
+        for(int k = 0; k < n_outputs_; k++)
+          dest_[k] = src_[k];
+      }
+      offset_ += n_outputs_;
+    }
+  }
+}
+
+void ConnectedMachine::backward(Sequence *inputs, Sequence *alpha)
+{
+  Sequence *alpha_ = NULL;
+  if(n_machines_on_layer[n_layers-1] > 1)
+  {
+    start_alpha->resize(alpha->n_frames, false);
+    start_alpha->frame_size = machines[n_layers-1][0]->machine->n_outputs;
+    for(int i = 0; i < alpha->n_frames; i++)
+      start_alpha->frames[i] = alpha->frames[i];
+    alpha_ = start_alpha;
+  }
+  else
+    alpha_ = alpha;
+
+  if(n_layers > 1)
+  {
+    for(int m = 0; m < n_machines_on_layer[n_layers-1]; m++)
+    {
+      ConnectedNode *node = machines[n_layers-1][m];
+
+      // NOTE: on ne tripote donc pas, en aucun cas, le alpha donne par l'utilisateur...
+      // NOTE: dans le truc qui suit c'est bien un +=...
+      if(m > 0)
+      {
+        int offset_ = machines[n_layers-1][m-1]->machine->n_outputs;
+        alpha_->frame_size = node->machine->n_outputs;
+        for(int i = 0; i < alpha_->n_frames; i++)
+          alpha_->frames[i] += offset_;
+      }
+
+      node->machine->backward(node->inputs, alpha_);
+    }
+  }
+  else
+  {
+    for(int m = 0; m < n_machines_on_layer[0]; m++)
+    {
+      ConnectedNode *node = machines[0][m];
+
+      if(m > 0)
+      {
+        // NOTE: on ne tripote donc pas, en aucun cas, le alpha donne par l'utilisateur...
+        // NOTE: dans le truc qui suit c'est bien un +=...
+        int offset_ = machines[0][m-1]->machine->n_outputs;
+        alpha_->frame_size = node->machine->n_outputs;
+        for(int i = 0; i < alpha_->n_frames; i++)
+          alpha_->frames[i] += offset_;
+      }
+
+      node->machine->backward(inputs, alpha_);
+    }
+  }
+
+  // NOTE: on pourrait encore optimiser une copie, mais 'sti...
+  for(int l = n_layers-2; l >= 0; l--)
+  {
+    for(int m = 0; m < n_machines_on_layer[l]; m++)
+    {
+      ConnectedNode *node = machines[l][m];
+
+      // NOTE: n_frames: fournie par alpha_link. Attention offset_alpha.
+      // NOTE: taille de alpha fournie par machine->n_outputs;
+      // a) Fout la taille de alpha comme il faut et initialise a 0
+      int n_frames_ = node->alpha_links[0]->n_frames;
+      int size_ = node->machine->n_outputs;
+      node->alpha->resize(n_frames_);
+      Sequence *alpha_ = node->alpha;
+
+      for(int i = 0; i < n_frames_; i++)
+      {
+        real *z = alpha_->frames[i];
+        for(int j = 0; j < size_; j++)
+          z[j] = 0;
+      }
+      
+      // b) Fait la putain de somme des CI_MO_NAK d'alphas...
+      for(int i = 0; i < node->n_alpha_links; i++)
+      {
+        for(int j = 0; j < n_frames_; j++)
+        {
+          real *src_ = node->alpha_links[i]->frames[j] + node->alpha_links_offset[i];
+          real *dest_ = alpha_->frames[j];
+          for(int k = 0; k < size_; k++)
+            dest_[k] += src_[k];
+        }
+      }
+
+      // c) backward le boxon
+      if(l == 0)
+        machines[0][m]->machine->backward(inputs, alpha_);
+      else
+        machines[l][m]->machine->backward(node->inputs, alpha_);
+    }
+  }
+
+
+  if( (n_machines_on_layer[0] > 1) && (!partial_backprop) )
+  {
+    // a) Fout la taille de beta comme il faut et initialise a 0
+    int n_frames_ = machines[0][0]->machine->beta->n_frames;
+    beta->resize(n_frames_);
+
+    for(int i = 0; i < n_frames_; i++)
+    {
+      real *dest_ = beta->frames[i];
+      for(int j = 0; j < n_inputs; j++)
+        dest_[j] = 0;
+    }
+    
+    // b) Fait la putain de somme des putains de beta
+    for(int i = 0; i < n_machines_on_layer[0]; i++)
+    {
+      for(int j = 0; j < n_frames_; j++)
+      {
+        real *dest_ = beta->frames[j];
+        real *src_ = machines[0][i]->machine->beta->frames[j];
+        
+        for(int k = 0; k < n_inputs; k++)
+          dest_[k] += src_[k];
+      }
+    }
+  }
+}
+
+void ConnectedMachine::reset()
+{
+  for(int i = 0; i < n_layers; i++)
+  {
+    for(int m = 0; m < n_machines_on_layer[i]; m++)
+      machines[i][m]->machine->reset();
+  }
+}
+
+void ConnectedMachine::iterInitialize()
+{
+  for(int i = 0; i < n_layers; i++)
+  {
+    for(int m = 0; m < n_machines_on_layer[i]; m++)
+      machines[i][m]->machine->iterInitialize();
+  }  
+}
+
+void ConnectedMachine::loadXFile(XFile *file)
+{
+  for(int i = 0; i < n_layers; i++)
+  {
+    for(int m = 0; m < n_machines_on_layer[i]; m++)
+      machines[i][m]->machine->loadXFile(file);
+  }
+}
+
+void ConnectedMachine::saveXFile(XFile *file)
+{
+  for(int i = 0; i < n_layers; i++)
+  {
+    for(int m = 0; m < n_machines_on_layer[i]; m++)
+      machines[i][m]->machine->saveXFile(file);
+  }
+}
+
+void ConnectedMachine::setPartialBackprop(bool flag)
+{
+  partial_backprop = flag;
+  for(int i = 0; i < n_machines_on_layer[0]; i++)
+    machines[0][i]->machine->setPartialBackprop(flag);
+}
+
+void ConnectedMachine::setDataSet(DataSet *dataset_)
+{
+  for(int i = 0; i < n_layers; i++)
+  {
+    for(int m = 0; m < n_machines_on_layer[i]; m++)
+      machines[i][m]->machine->setDataSet(dataset_);
+  }
+}
+
+ConnectedMachine::~ConnectedMachine()
+{
+}
+
+}
+
+// End of special zone.
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/ConnectedMachine.h work/main.d/Torch-3/gradients/ConnectedMachine.h
--- tmp/Torch-3/gradients/ConnectedMachine.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/ConnectedMachine.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,119 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CONNECTED_MACHINE_INC
+#define CONNECTED_MACHINE_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+struct ConnectedNode
+{
+    GradientMachine *machine;
+    Sequence **input_links;
+    Sequence **alpha_links;
+    int *alpha_links_offset;
+    int n_input_links;
+    int n_alpha_links;
+    int n_inputs_check;
+
+    Sequence *inputs;
+    Sequence *alpha;
+};
+
+/** Easy connections between several #GradientMachine#.
+    GradientMachine has "layers" on which you can
+    add some #GradientMachine#.
+
+    The inputs of the machine on the first layer will
+    be the inputs of the #ConnectedMachine#.
+
+    The outputs of the #ConnectedMachine# are the union
+    (in the order of adding) of all machines on the
+    last layer.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class ConnectedMachine : public GradientMachine
+{
+  private:
+    Sequence *start_alpha;
+    int current_alpha_offset;
+    int current_layer;
+    int current_machine;
+    void checkInternalLinks();
+
+  public:
+    ConnectedNode ***machines;
+    int *n_machines_on_layer;
+    int n_layers;
+
+    //-----
+
+    ///
+    ConnectedMachine();
+
+    /** Add a Full Connected Layer. The #machine# is fully connected
+        to the previous layer. If necessary, a layer is added before
+        adding the machine.
+    */
+    void addFCL(GradientMachine *machine);
+    
+    /// Add a #machine# on the current layer
+    void addMachine(GradientMachine *machine);
+
+    /** Connect the last added machine on #machine#.
+        Note that #machine# \emph{must} be in a previous layer.
+    */
+    void connectOn(GradientMachine *machine);
+
+    /// Add a layer (you don't have to call that for the first layer)
+    void addLayer();
+
+    /** Contruct the machine... you need to call that after adding and
+        connecting all the machines. */
+    void build();
+
+    //-----
+
+    virtual void reset();
+    virtual void iterInitialize();
+    virtual void forward(Sequence *inputs);
+    virtual void backward(Sequence *inputs, Sequence *alpha);
+    virtual void loadXFile(XFile *file);
+    virtual void saveXFile(XFile *file);
+    virtual void setPartialBackprop(bool flag=true);
+    virtual void setDataSet(DataSet *dataset_);
+
+    virtual ~ConnectedMachine();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Criterion.cc work/main.d/Torch-3/gradients/Criterion.cc
--- tmp/Torch-3/gradients/Criterion.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Criterion.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,48 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Criterion.h"
+
+namespace Torch {
+
+Criterion::Criterion(int n_inputs_, int n_params_) : GradientMachine(n_inputs_, 1, n_params_)
+{
+}
+
+void Criterion::setDataSet(DataSet *data_)
+{
+  data = data_;
+}
+
+Criterion::~Criterion()
+{
+
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Criterion.h work/main.d/Torch-3/gradients/Criterion.h
--- tmp/Torch-3/gradients/Criterion.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Criterion.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,77 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CRITERION_INC
+#define CRITERION_INC
+
+#include "GradientMachine.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+/** #Criterion# class for #StochasticGradient#.
+    A #Criterion# computes an error with its inputs
+    and a dataset #data#.
+
+    It knows how to backpropagate this error.
+
+    A #Criterion# shouldn't be connected to the inputs of
+    another #GradientMachine#.
+    ne doit pas se connecter sur l'entree d'une
+
+    By default, the number of outputs for a #Criterion#
+    is fixed to one. It \emph{must} contain the error:
+    This one is used by the #StochasticGradient# for the
+    stopping criterion.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Criterion : public GradientMachine
+{
+  public:
+
+    /// #DataSet# used to compute the error.
+    DataSet *data;
+
+    ///
+    Criterion(int n_inputs_, int n_params_=0);
+
+    /** Set #data# to #data_#. The criterion
+        should be able to react to this function.
+    */
+    virtual void setDataSet(DataSet *data_);
+
+    //-----
+
+    virtual ~Criterion();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Exp.cc work/main.d/Torch-3/gradients/Exp.cc
--- tmp/Torch-3/gradients/Exp.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Exp.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,56 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Exp.h"
+
+namespace Torch {
+
+Exp::Exp(int n_units) : GradientMachine(n_units, n_units)
+{
+}
+
+void Exp::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  for(int i = 0; i < n_inputs; i++)
+    f_outputs[i] = exp(f_inputs[i]);
+}
+
+void Exp::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  if(partial_backprop)
+    return;
+
+  for(int i = 0; i < n_inputs; i++)
+    beta_[i] = alpha_[i] * f_outputs[i];
+}
+
+Exp::~Exp()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Exp.h work/main.d/Torch-3/gradients/Exp.h
--- tmp/Torch-3/gradients/Exp.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Exp.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,62 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef EXP_INC
+#define EXP_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Exponentiel layer for #GradientMachine#.
+
+    The number of inputs/outputs is the number
+    of units for this machine.
+    Formally speaking, $ouputs[i] = exp(inputs[i])$.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Exp : public GradientMachine
+{
+  public:
+
+    /// Create a layer of size #n_units#
+    Exp(int n_units);
+
+    //-----
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~Exp();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/GradientMachine.cc work/main.d/Torch-3/gradients/GradientMachine.cc
--- tmp/Torch-3/gradients/GradientMachine.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/GradientMachine.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,107 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+GradientMachine::GradientMachine(int n_inputs_, int n_outputs_, int n_params_)
+{
+  n_inputs = n_inputs_;
+  n_outputs = n_outputs_;
+  if(n_outputs > 0)
+    outputs = new(allocator) Sequence(0, n_outputs);
+  else
+    outputs = NULL;
+  if(n_inputs > 0)
+    beta = new(allocator) Sequence(0, n_inputs);
+  else
+    beta = NULL;
+  params = new(allocator) Parameters(n_params_);
+  der_params = new(allocator) Parameters(n_params_);
+  partial_backprop = false;
+}
+
+void GradientMachine::setPartialBackprop(bool flag)
+{
+  partial_backprop = flag;
+}
+
+void GradientMachine::iterInitialize()
+{
+}
+
+void GradientMachine::forward(Sequence *inputs)
+{
+  outputs->resize(inputs->n_frames);
+
+  for(int i = 0; i < inputs->n_frames; i++)
+    frameForward(i, inputs->frames[i], outputs->frames[i]);
+}
+
+void GradientMachine::backward(Sequence *inputs, Sequence *alpha)
+{
+  beta->resize(inputs->n_frames);
+
+  if(alpha)
+  {
+    for(int i = 0; i < inputs->n_frames; i++)
+      frameBackward(i, inputs->frames[i], beta->frames[i], outputs->frames[i], alpha->frames[i]);
+  }
+  else
+  {
+    for(int i = 0; i < inputs->n_frames; i++)
+      frameBackward(i, inputs->frames[i], beta->frames[i], outputs->frames[i], NULL);
+  }
+}
+
+void GradientMachine::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+}
+
+void GradientMachine::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+}
+
+void GradientMachine::loadXFile(XFile *file)
+{
+  if(params)
+    params->loadXFile(file);
+}
+
+void GradientMachine::saveXFile(XFile *file)
+{
+  if(params)
+    params->saveXFile(file);
+}
+
+GradientMachine::~GradientMachine()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/GradientMachine.h work/main.d/Torch-3/gradients/GradientMachine.h
--- tmp/Torch-3/gradients/GradientMachine.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/GradientMachine.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,140 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef GRADIENT_MACHINE_INC
+#define GRADIENT_MACHINE_INC
+
+#include "Machine.h"
+#include "Parameters.h"
+
+namespace Torch {
+
+/** Gradient machine: machine which can
+    be trained with a gradient descent.
+
+    Gradient machines take in inputs sequences which have always the same
+    frame size, given by #n_inputs#, and outputs sequences which have always
+    the same frame size too, given by #n_outputs#.
+
+    @see StochasticGradient
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class GradientMachine : public Machine
+{
+  public:
+    /* Internal flag to know if we do the backprop with respect to
+       the inputs */
+    bool partial_backprop;
+
+    /// Frame size of inputs sequences.
+    int n_inputs;
+
+    /// Frame size of outputs sequences.
+    int n_outputs;
+
+    /** Contains all parameters which will be
+        updated with the gradient descent.
+        Almost all machines will have only one
+        node in params.
+    */
+    Parameters *params;
+
+    /** Contains the derivatives for all parameters.
+        Warning: #params# and #der_params#
+        must have the same structure.
+    */
+    Parameters *der_params;
+
+    /// Contains the derivative with respect to the inputs.
+    Sequence *beta;
+
+    //-----
+
+    /** Initialize a gradient machine with #n_inputs_# for the input frame size,
+        #n_outputs_# for the output frame size and #n_params_# parameters.
+        If #n_inputs_# is 0, no #beta# sequence will be allocated.
+        If #n_outputs_# is 0, no #outputs# sequence will be allocated.
+    */
+    GradientMachine(int n_inputs_, int n_outputs_, int n_params_=0);
+
+    /** This function is called before each
+        training iteration.
+        By default, do nothing.
+    */
+    virtual void iterInitialize();
+
+    /** Given a sequence, update #outputs#.
+        By default, it uses #frameForward()#, to update each output frame
+        given each input frame. It supposes by default the number of input
+        and output frames is the same.
+    */
+    virtual void forward(Sequence *inputs);
+
+    /** Given a sequence, update the derivative with respect to the input (#beta#)
+        and #der_params#. If #partial_backprop# is false, don't update #beta#.
+        By default, it uses #frameBackward()#, to update each beta frame
+        given each input and alpha frame. It supposes by default the number of input
+        and output frames is the same.
+    */
+    virtual void backward(Sequence *inputs, Sequence *alpha);
+
+    /// Set the partial backprop flag...
+    virtual void setPartialBackprop(bool flag=true);
+
+    /** Given a frame #f_inputs#, updates #f_outputs#. Used to easily create new classes.
+        It is called by the default #forward()#, and it does nothing by default.
+        If your machine needs to do special things on sequence (if input sequence do not
+        have the same size as the output sequence), don't overload this function, but
+        overload #forward()#. #t# is the current frame to be forwarded.
+    */
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+
+    /** Given the #f_inputs# and the derivatives #alpha_# with
+        respect to the outputs, updates the derivative with respect to the inputs (#beta_#)
+        and #der_params#.
+        It is called by the default #backward()#, and it does nothing by default.
+        If your machine needs to do special things on sequence (if input sequence do not
+        have the same size as the output sequence), don't overload this function, but
+        overload #backward()#. #t# is the current frame to be back-propagated.
+    */
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    /// By default, load the #params# field.
+    virtual void loadXFile(XFile *file);
+
+    /// By default, save the #params# field.
+    virtual void saveXFile(XFile *file);
+
+    //-----
+
+    virtual ~GradientMachine();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/InputsSelect.cc work/main.d/Torch-3/gradients/InputsSelect.cc
--- tmp/Torch-3/gradients/InputsSelect.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/InputsSelect.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,67 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "InputsSelect.h"
+
+namespace Torch {
+
+InputsSelect::InputsSelect(int n_inputs_, int offset_, int n_selected_) : GradientMachine(n_inputs_, n_selected_)
+{
+  offset = offset_;
+}
+
+void InputsSelect::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  real *src_ = f_inputs+offset;
+
+  for(int i = 0; i < n_outputs; i++)
+    f_outputs[i] = src_[i];
+}
+
+void InputsSelect::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  if(partial_backprop)
+    return;
+
+  for(int i = 0; i < offset; i++)
+    beta_[i] = 0;
+
+  real *ptr_beta = beta_+offset;
+  for(int i = 0; i < n_outputs; i++)
+    ptr_beta[i] = alpha_[i];
+
+  for(int i = offset+n_outputs; i < n_inputs; i++)
+    beta_[i]  = 0;
+}
+
+InputsSelect::~InputsSelect()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/InputsSelect.h work/main.d/Torch-3/gradients/InputsSelect.h
--- tmp/Torch-3/gradients/InputsSelect.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/InputsSelect.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,64 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef INPUTS_SELECT_INC
+#define INPUTS_SELECT_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Machine which select a block of adjacent
+    inputs, and put them in the outputs.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class InputsSelect : public GradientMachine
+{
+  public:
+    int offset;
+
+    //-----
+
+    /** Select #n_selected_# inputs from #offset_#.
+        (The input #offset_# will be included).
+    */
+    InputsSelect(int n_inputs_, int offset_, int n_selected_);
+
+    //-----
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~InputsSelect();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/LICENSE work/main.d/Torch-3/gradients/LICENSE
--- tmp/Torch-3/gradients/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/LICENSE	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,28 @@
+
+Copyright (c) 2003--2004 Ronan Collobert
+Copyright (c) 2003--2004 Samy Bengio
+Copyright (c) 2003--2004 Johnny Mariéthoz
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Linear.cc work/main.d/Torch-3/gradients/Linear.cc
--- tmp/Torch-3/gradients/Linear.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Linear.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,121 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Linear.h"
+#include "Random.h"
+
+namespace Torch {
+
+Linear::Linear(int n_inputs_, int n_outputs_) : GradientMachine(n_inputs_, n_outputs_, (n_inputs_+1)*n_outputs_)
+{
+  addROption("weight decay", &weight_decay, 0, "weight decay");
+  weights = params->data[0];
+  bias = params->data[0]+n_inputs*n_outputs;
+  der_weights = der_params->data[0];
+  der_bias = der_params->data[0]+n_inputs*n_outputs;
+  reset_();
+}
+
+void Linear::reset()
+{
+  reset_();
+}
+
+void Linear::reset_()
+{
+  // Note: just to be compatible with "Torch II Dev"
+  real *weights_ = weights;
+  real bound = 1./sqrt((real)n_inputs);
+
+  for(int i = 0; i < n_outputs; i++)
+  {
+    for(int j = 0; j < n_inputs; j++)
+      weights_[j] = Random::boundedUniform(-bound, bound);
+    weights_ += n_inputs;
+    bias[i] = Random::boundedUniform(-bound, bound);
+  }
+}
+
+void Linear::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  real *weights_ = weights;
+  for(int i = 0; i < n_outputs; i++)
+  {
+    real out = bias[i];
+
+    for(int j = 0; j < n_inputs; j++)
+      out += weights_[j] * f_inputs[j];
+    weights_ += n_inputs;
+
+    f_outputs[i] = out;
+  }
+}
+
+void Linear::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  if(!partial_backprop)
+  {
+    for(int i = 0; i < n_inputs; i++)
+      beta_[i] = 0;
+    
+    real *weights_ = weights;
+    for(int i = 0; i < n_outputs; i++)
+    {
+      real z = alpha_[i];
+      for(int j = 0; j < n_inputs; j++)
+        beta_[j] += z * weights_[j];
+      weights_ += n_inputs;
+    }
+  }
+
+  real *der_weights_ = der_weights;
+  for(int i = 0; i < n_outputs; i++)
+  {
+    real z = alpha_[i];
+    for(int j = 0; j < n_inputs; j++)
+      der_weights_[j] += z * f_inputs[j];
+    der_weights_ += n_inputs;
+
+    der_bias[i] += z;
+  }
+
+  if(weight_decay != 0)
+  {
+    real *src_ = params->data[0];
+    real *dest_ = der_params->data[0];
+    // Note: pas de weight decay sur les biais.
+    for(int i = 0; i < n_inputs*n_outputs; i++)
+      dest_[i] += weight_decay * src_[i];
+  }
+}
+
+Linear::~Linear()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Linear.h work/main.d/Torch-3/gradients/Linear.h
--- tmp/Torch-3/gradients/Linear.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Linear.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,80 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LINEAR_INC
+#define LINEAR_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Linear layer for #GradientMachine#.
+    Formally speaking, $ouputs[i] = \sum_j w_{ij} inputs[i] + b_i$.\\
+    $w_{ij}$ and $b_j$ are in #params#, with the following structure:\\
+    $w_00... w_0n, b_0, w_10... w_1n, b_1, ...$\\
+
+    If you want, you can add a weight decay which looks like
+    $\sum_i,j w_{ij}^2 + sum_i b_i^2$.
+
+    Options:
+    \begin{tabular}{lcll}
+      "weight decay"  &  real  &  the weight decay & [0]
+    \end{tabular}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Linear : public GradientMachine
+{
+  public:
+    real weight_decay;
+    real *weights;
+    real *bias;
+    real *der_weights;
+    real *der_bias;
+    void reset_();
+
+    //-----
+
+    ///
+    Linear(int n_inputs_, int n_outputs_);
+
+    //-----
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    /// Computes new random values for weights.
+    virtual void reset();
+
+    virtual ~Linear();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/LogMixer.cc work/main.d/Torch-3/gradients/LogMixer.cc
--- tmp/Torch-3/gradients/LogMixer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/LogMixer.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,83 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "LogMixer.h"
+#include "log_add.h"
+
+namespace Torch {
+
+LogMixer::LogMixer(int n_experts_, int n_outputs_per_expert) : GradientMachine(n_experts_*(n_outputs_per_expert+1), n_outputs_per_expert)
+{
+  n_experts = n_experts_;
+}
+
+void LogMixer::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  for(int i = 0; i < n_outputs; i++)
+    f_outputs[i] = LOG_ZERO;
+
+  real *log_weight_ = f_inputs;
+  real *log_src_ = f_inputs+n_experts;
+  for(int i = 0; i < n_experts; i++)
+  {
+    real z = log_weight_[i];
+    for(int j = 0; j < n_outputs; j++)
+      f_outputs[j] = logAdd(f_outputs[j], z + *log_src_++);
+  }
+}
+
+void LogMixer::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  if(partial_backprop)
+    return;
+
+  real *beta__ = beta_+n_experts;
+  real *log_weight_ = f_inputs;
+  real *log_src_ = f_inputs+n_experts;
+  for(int i = 0; i < n_experts; i++)
+  {
+    real z = log_weight_[i];
+    for(int j = 0; j < n_outputs; j++)
+      *beta__++ = alpha_[j] * exp(z + *log_src_++ - f_outputs[j]);
+  }
+    
+  beta__ = beta_+n_experts;
+  for(int i = 0; i < n_experts; i++)
+  {
+    real sum = 0;
+    for(int j = 0; j < n_outputs; j++)
+      sum += *beta__++;
+    beta_[i] = sum;
+  }
+}
+
+LogMixer::~LogMixer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/LogMixer.h work/main.d/Torch-3/gradients/LogMixer.h
--- tmp/Torch-3/gradients/LogMixer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/LogMixer.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,72 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LOG_MIXER_INC
+#define LOG_MIXER_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** LogMixer useful for experts mixtures.
+    Formally speaking, it computes:
+    $outputs[i] = log(\sum_j exp(log_{a_j}) + log(LogInputs_j[i]))$
+    
+    where
+    \begin{itemize}
+      \item ${log_{a_1},...,log_{a_n}}$ are the first #n_experts# inputs
+      of the machine.
+      
+      \item $LogInputs_j$ are the outputs of the j-th expert.
+      Therefore, the inputs given to the machine have the following structure:
+      ${log_a, LogOutputsExpert_1, LogOutputsExpert_2, ...}$.
+    \end{itemize}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class LogMixer : public GradientMachine
+{
+  public:
+    int n_experts;
+
+    //-----
+
+    ///
+    LogMixer(int n_inputs_, int n_outputs_per_expert);
+
+    //-----
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~LogMixer();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/LogSigmoid.cc work/main.d/Torch-3/gradients/LogSigmoid.cc
--- tmp/Torch-3/gradients/LogSigmoid.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/LogSigmoid.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,64 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "LogSigmoid.h"
+
+namespace Torch {
+
+LogSigmoid::LogSigmoid(int n_units) : GradientMachine(n_units, n_units)
+{
+  buff = (real *)allocator->alloc(sizeof(real)*n_units);
+}
+
+void LogSigmoid::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  for(int i = 0; i < n_inputs; i++)
+  {
+    real z = exp(-f_inputs[i]);
+    buff[i] = z;
+    f_outputs[i] = -log(1. + z);
+  }
+}
+
+void LogSigmoid::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  if(partial_backprop)
+    return;
+
+  for(int i = 0; i < n_outputs; i++)
+  {
+    real z = buff[i];
+    beta_[i] = alpha_[i] * z / (1. + z);
+  }
+}
+
+LogSigmoid::~LogSigmoid()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/LogSigmoid.h work/main.d/Torch-3/gradients/LogSigmoid.h
--- tmp/Torch-3/gradients/LogSigmoid.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/LogSigmoid.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,63 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LOG_SIGMOID_INC
+#define LOG_SIGMOID_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Log-Sigmoid layer for #GradientMachine#.
+    The number of inputs/outputs is the number
+    of units of this machine.
+    Formally speaking, $ouputs[i] = log(1/(1+exp(-inputs[i])))$
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class LogSigmoid : public GradientMachine
+{
+  public:
+    real *buff;
+
+    //-----
+    
+    /// Create a layer with #n_units# units.
+    LogSigmoid(int n_units);
+
+    //-----
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~LogSigmoid();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/LogSoftMax.cc work/main.d/Torch-3/gradients/LogSoftMax.cc
--- tmp/Torch-3/gradients/LogSoftMax.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/LogSoftMax.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,69 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "LogSoftMax.h"
+#include "log_add.h"
+
+namespace Torch {
+
+LogSoftMax::LogSoftMax(int n_units) : GradientMachine(n_units, n_units)
+{
+}
+
+void LogSoftMax::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  real sum = LOG_ZERO;
+  for(int i = 0; i < n_inputs; i++)
+  {
+    real z = f_inputs[i];
+    f_outputs[i] = z;
+    sum = logAdd(sum, z);
+  }
+
+  for(int i = 0; i < n_outputs; i++)
+    f_outputs[i] -= sum;
+}
+
+void LogSoftMax::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  if(partial_backprop)
+    return;
+
+  real sum = 0;
+  for(int i = 0; i < n_outputs; i++)
+    sum += alpha_[i];
+
+  for(int i = 0; i < n_outputs; i++)
+    beta_[i] = alpha_[i] - exp(f_outputs[i]) * sum;
+}
+
+LogSoftMax::~LogSoftMax()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/LogSoftMax.h work/main.d/Torch-3/gradients/LogSoftMax.h
--- tmp/Torch-3/gradients/LogSoftMax.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/LogSoftMax.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,66 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef LOG_SOFT_MAX_INC
+#define LOG_SOFT_MAX_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Log-SoftMax layer for #GradientMachine#.
+
+    The number of inputs/outputs is the number
+    of units in the machine.
+
+    Formally speaking, $ouputs[i] = log(1/a * exp(inputs[i]))$
+    where $a = \sum_j exp(inputs[j])$.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class LogSoftMax : public GradientMachine
+{
+  public:
+
+    //-----
+
+    /// Create a layer with #n_units# units.
+    LogSoftMax(int n_units);
+
+    //-----
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~LogSoftMax();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Makefile work/main.d/Torch-3/gradients/Makefile
--- tmp/Torch-3/gradients/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Makefile	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,42 @@
+# get user and architecture specific options
+OS := $(shell uname -s)
+TORCHDIR := $(shell cd ..; pwd)
+include ../Makefile_options_$(OS)
+
+CC_FILES := $(wildcard *.cc)
+OBJS := $(foreach f,$(CC_FILES),$(OBJS_DIR)/$(patsubst %.cc,%.o,$(f)))
+
+all:	$(LIBTORCH)
+
+$(LIBTORCH): $(OBJS)
+	@echo "Archiving..."
+	@$(AR) $(LIBTORCH) $(OBJS)
+
+$(OBJS_DIR)/%.o: %.cc
+	@echo $<
+	@$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $@ -c $<
+
+distclean:
+	@\rm -f .deps_*
+
+clean:
+	@echo "Remove objects file and dependencies..."
+	@\rm -Rf $(OBJS) $(LIBTORCH)
+	@\rm -f .deps_$(VERSION_KEY)
+
+depend:
+	@echo "Tracking dependencies..."
+	@\rm -f .deps_$(VERSION_KEY)
+	@for file in *.cc ; do printf "$(OBJS_DIR)/" >> .deps_$(VERSION_KEY); $(DEP) $(CFLAGS_$(MODE)) $(INCS) $$file >> .deps_$(VERSION_KEY); done
+
+.deps_$(VERSION_KEY):
+	@echo ">>> Please do a 'make depend' <<<"
+	exit 10
+
+ifneq ($(MAKECMDGOALS),distclean)
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),depend)
+include .deps_$(VERSION_KEY)
+endif
+endif
+endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Mixer.cc work/main.d/Torch-3/gradients/Mixer.cc
--- tmp/Torch-3/gradients/Mixer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Mixer.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,84 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Mixer.h"
+
+namespace Torch {
+
+Mixer::Mixer(int n_experts_, int n_outputs_per_expert) : GradientMachine(n_experts_*(n_outputs_per_expert+1), n_outputs_per_expert)
+{
+  n_experts = n_experts_;
+}
+
+void Mixer::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  for(int i = 0; i < n_outputs; i++)
+    f_outputs[i] = 0;
+  
+  real *weight_ = f_inputs;
+  real *src_ = f_inputs+n_experts;
+  for(int i = 0; i < n_experts; i++)
+  {
+    real z = weight_[i];
+    for(int j = 0; j < n_outputs; j++)
+      f_outputs[j] += z * src_[j];
+    src_ += n_outputs;
+  }
+}
+
+void Mixer::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  if(partial_backprop)
+    return;
+
+  real *src_ = f_inputs+n_experts;
+  for(int i = 0; i < n_experts; i++)
+  {
+    real z = 0;
+    for(int j = 0; j < n_outputs; j++)
+      z += alpha_[j] * src_[j];
+    beta_[i] = z;
+    src_ += n_outputs;
+  }
+
+  real *beta__ = beta_+n_experts;
+  src_ = f_inputs;
+  for(int i = 0; i < n_experts; i++)
+  {
+    real z = src_[i];
+    for(int j = 0; j < n_outputs; j++)
+      beta__[j] = alpha_[j] * z;
+    beta__ += n_outputs;
+  }
+}
+
+Mixer::~Mixer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Mixer.h work/main.d/Torch-3/gradients/Mixer.h
--- tmp/Torch-3/gradients/Mixer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Mixer.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,76 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MIXER_INC
+#define MIXER_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Mixer useful for experts mixtures.
+    Formally speaking, it computes:
+    $outputs[i] = \sum_j a_j * inputs_j[i]$
+
+    where
+    \begin{itemize}
+      \item ${a_1,...,a_n}$ are in the table
+      of the first node of the #inputs# list,
+      when you call #forward()#.
+      
+      \item $inputs_j$ are the inputs of the j-th expert.
+      Therefore, the #inputs# list has the structure
+      ${a, inputs_1, inputs_2, ...}$.
+      Only $a$ must be alone in one node.
+    \end{itemize}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Mixer : public GradientMachine
+{
+  public:
+    /// Number of experts.
+    int n_experts;
+
+    //-----
+
+    ///
+    Mixer(int n_inputs_, int n_outputs_per_expert);
+
+    //-----
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~Mixer();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/MLP.cc work/main.d/Torch-3/gradients/MLP.cc
--- tmp/Torch-3/gradients/MLP.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/MLP.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,122 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "MLP.h"
+#include "Linear.h"
+#include "Tanh.h"
+#include "Sigmoid.h"
+#include "SoftMax.h"
+#include "LogSoftMax.h"
+#include "Exp.h"
+#include "SoftPlus.h"
+
+namespace Torch {
+
+MLP::MLP(int n_layers_, int n_inputs_, ...)
+{
+  n_layers = n_layers_;
+  layers = (GradientMachine **)allocator->alloc(sizeof(GradientMachine *)*n_layers);
+  is_linear = (bool *)allocator->alloc(sizeof(bool)*n_layers);
+  for(int i = 0; i < n_layers; i++)
+    is_linear[i] = false;
+
+  va_list args;
+  va_start(args, n_inputs_);  
+  for(int i = 0; i < n_layers; i++)
+  {
+    char *layer_type = va_arg(args, char *);
+    int n_outputs_ = va_arg(args, int);
+    bool is_valid = false;
+
+    if(!strcmp(layer_type, "linear"))
+    {
+      layers[i] = new(allocator) Linear(n_inputs_, n_outputs_);
+      is_linear[i] = true;
+      is_valid = true;
+    }
+
+    if(!strcmp(layer_type, "tanh"))
+    {
+      layers[i] = new(allocator) Tanh(n_outputs_);
+      is_valid = true;
+    }
+
+    if(!strcmp(layer_type, "sigmoid"))
+    {
+      layers[i] = new(allocator) Sigmoid(n_outputs_);
+      is_valid = true;
+    }
+
+    if(!strcmp(layer_type, "softmax"))
+    {
+      layers[i] = new(allocator) SoftMax(n_outputs_);
+      is_valid = true;
+    }
+
+    if(!strcmp(layer_type, "log-softmax"))
+    {
+      layers[i] = new(allocator) LogSoftMax(n_outputs_);
+      is_valid = true;
+    }
+
+    if(!strcmp(layer_type, "exp"))
+    {
+      layers[i] = new(allocator) Exp(n_outputs_);
+      is_valid = true;
+    }
+
+    if(!strcmp(layer_type, "softplus"))
+    {
+      layers[i] = new(allocator) SoftPlus(n_outputs_);
+      is_valid = true;
+    }
+
+    if(!is_valid)
+      error("MLP: unknow layer type <%s>", layer_type);
+    
+    this->addFCL(layers[i]);
+    n_inputs_ = n_outputs_;
+  }
+  build();
+  va_end(args);
+}
+
+void MLP::setWeightDecay(real weight_decay)
+{
+  for(int i = 0; i < n_layers; i++)
+  {
+    if(is_linear[i])
+      layers[i]->setROption("weight decay", weight_decay);
+  }
+}
+
+MLP::~MLP()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/MLP.h work/main.d/Torch-3/gradients/MLP.h
--- tmp/Torch-3/gradients/MLP.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/MLP.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,66 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MLP_INC
+#define MLP_INC
+
+#include "ConnectedMachine.h"
+
+namespace Torch {
+
+/** A Multi-Layer Perceptron.
+
+   @author Ronan Collobert (collober@idiap.ch)
+*/
+class MLP : public ConnectedMachine
+{
+  public:
+    GradientMachine **layers;
+    int n_layers;
+    bool *is_linear;
+
+    /** Create a MLP with #n_layers# layers and #n_inputs_# inputs.
+        The definitions of the layer come then: it's a string
+        followed by an integer for the number of outputs of the layer.
+        Valid strings are "linear", "tanh", "sigmoid", "softmax", "log-softmax",
+        "exp" and "softplus".
+
+        Example: to create an MLP with one linear layer and one softmax layer,
+        MLP(2, n_inputs, "linear", n_outputs, "softmax", n_outputs);
+    */
+    MLP(int n_layers, int n_inputs_, ...);
+
+    /// Set the weight decay in all Linear layers.
+    void setWeightDecay(real weight_decay);
+
+    virtual ~MLP();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/MSECriterion.cc work/main.d/Torch-3/gradients/MSECriterion.cc
--- tmp/Torch-3/gradients/MSECriterion.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/MSECriterion.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,76 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "MSECriterion.h"
+
+namespace Torch {
+
+MSECriterion::MSECriterion(int n_inputs_) : Criterion(n_inputs_)
+{
+  addBOption("average frame size", &average_frame_size, true, "divided by the frame size");
+}
+
+void MSECriterion::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  real *desired = data->targets->frames[t];
+  real err = 0;
+
+  for(int i = 0; i < n_inputs; i++)
+  {
+      real z = desired[i] - f_inputs[i];
+      err += z*z;
+  }
+
+  if(average_frame_size)
+    err /= n_inputs;
+
+  f_outputs[0] = err;
+}
+
+void MSECriterion::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  real *desired = data->targets->frames[t];
+
+  if(average_frame_size)
+  {
+    real norm_ = 2./n_inputs;
+    for(int i = 0; i < n_inputs; i++)
+      beta_[i] = norm_*(f_inputs[i] - desired[i]);
+  }
+  else
+  {
+    for(int i = 0; i < n_inputs; i++)
+      beta_[i] = 2.*(f_inputs[i] - desired[i]);
+  }
+}
+
+MSECriterion::~MSECriterion()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/MSECriterion.h work/main.d/Torch-3/gradients/MSECriterion.h
--- tmp/Torch-3/gradients/MSECriterion.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/MSECriterion.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,71 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MSE_CRITERION_INC
+#define MSE_CRITERION_INC
+
+#include "Criterion.h"
+
+namespace Torch {
+
+/** Mean Squared Error criterion.
+    Compute the MSE between its inputs and,
+    the targets of its associated #DataSet#.
+
+    The number of target frames in #DataSet# must
+    correspond to the number of input frames given
+    to this criterion.
+
+    Options:
+    \begin{tabular}{lcll}
+      "average frame size"  &  bool  &  divided by the frame size & [true]
+    \end{tabular}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class MSECriterion : public Criterion
+{
+  public:
+    bool average_frame_size;
+
+    //-----
+
+    /// #n_inputs_# is the input frame size.
+    MSECriterion(int n_inputs_);
+
+    //-----
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~MSECriterion();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/MultiCriterion.cc work/main.d/Torch-3/gradients/MultiCriterion.cc
--- tmp/Torch-3/gradients/MultiCriterion.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/MultiCriterion.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,116 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "MultiCriterion.h"
+
+namespace Torch {
+
+MultiCriterion::MultiCriterion(Criterion** criterions_,int n_criterions_, real* weights_) : Criterion(criterions_[0]->n_inputs)
+{
+  n_criterions = n_criterions_;
+  criterions = criterions_;
+  weights = weights_;
+  for(int i = 0; i < n_criterions; i++)
+  {
+    if(n_inputs != criterions[i]->n_inputs)
+      error("MultiCriterion: given criterions don't have the same number of inputs");
+  }
+
+  if(!weights)
+  {
+    weights = (real *)allocator->alloc(sizeof(real)*n_criterions);
+    for(int i = 0; i < n_criterions; i++)
+      weights[i] = 1.;
+  }
+}
+
+void MultiCriterion::setDataSet(DataSet *data_)
+{
+  data = data_;
+  for (int i=0;i<n_criterions;i++)
+    criterions[i]->setDataSet(data_);
+}
+
+void MultiCriterion::iterInitialize()
+{
+  for (int i=0;i<n_criterions;i++)
+    criterions[i]->iterInitialize();
+}
+
+void MultiCriterion::reset()
+{
+  for (int i=0;i<n_criterions;i++)
+    criterions[i]->reset();
+}
+
+void MultiCriterion::forward(Sequence *inputs)
+{
+  for(int i = 0; i < n_criterions; i++)
+    criterions[i]->forward(inputs);
+
+  int n_frames_ = criterions[0]->outputs->n_frames;
+  outputs->resize(n_frames_);
+
+  for(int i = 0; i < n_frames_; i++)
+  {
+    real sum = 0;
+    for(int j = 0; j < n_criterions; j++)
+      sum += criterions[j]->outputs->frames[i][0] * weights[j];
+    outputs->frames[i][0] = sum;
+  }
+}
+
+void MultiCriterion::backward(Sequence *inputs, Sequence *alpha)
+{
+  int n_frames_ = inputs->n_frames;
+  beta->resize(n_frames_);
+
+  for(int i = 0; i < n_criterions; i++)
+    criterions[i]->backward(inputs, alpha);
+
+  for(int i = 0; i < n_frames_; i++)
+  {
+    real *beta_ = beta->frames[i];
+    for(int j = 0; j < n_inputs; j++)
+      beta_[j] = 0;
+
+    for(int j = 0; j < n_criterions; j++)
+    {
+      real *src_ = criterions[j]->beta->frames[i];
+      real w_ = weights[j];
+      for(int k = 0; k < n_inputs; k++)
+        beta_[k] += src_[k] * w_;
+    }
+  }
+}
+
+MultiCriterion::~MultiCriterion()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/MultiCriterion.h work/main.d/Torch-3/gradients/MultiCriterion.h
--- tmp/Torch-3/gradients/MultiCriterion.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/MultiCriterion.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,74 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MULTI_CRITERION_INC
+#define MULTI_CRITERION_INC
+
+#include "Criterion.h"
+
+namespace Torch {
+
+/** MultiCriterion can be used to handle multiple criterions.
+
+    The #MultiCriterion# is a #Criterion# which is the weighted
+    sum of given criterions. (By default, the weights are equal to #1#).
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class MultiCriterion : public Criterion
+{
+  public:
+
+    /// the number of criterions
+    int n_criterions;
+
+    /// the criterions
+    Criterion** criterions;
+
+    /// the relative weight of each criterion
+    real* weights;
+
+    //-----
+
+    ///
+    MultiCriterion(Criterion** criterions_, int n_criterions_, real* weights_ = NULL);
+
+    //-----
+
+    virtual void forward(Sequence *inputs);
+    virtual void backward(Sequence *inputs, Sequence *alpha);
+    virtual void setDataSet(DataSet *data_);
+    virtual void iterInitialize();
+    virtual void reset();
+
+    virtual ~MultiCriterion();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/SaturationMeasurer.cc work/main.d/Torch-3/gradients/SaturationMeasurer.cc
--- tmp/Torch-3/gradients/SaturationMeasurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/SaturationMeasurer.cc	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,99 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "SaturationMeasurer.h"
+
+namespace Torch {
+
+SaturationMeasurer::SaturationMeasurer(GradientMachine *machine_, DataSet *data_, XFile *file_) : Measurer(data_, file_)
+{
+  machine = machine_;
+  reset_();
+}
+
+void SaturationMeasurer::measureExample()
+{
+  Sequence *outputs_ = machine->outputs;
+  real sum = 0;
+  for(int i = 0; i < outputs_->n_frames; i++)
+  {
+    real *frame_ = outputs_->frames[i];
+    for(int j = 0; j < outputs_->frame_size; j++)
+      sum += fabs(frame_[j]);
+    n_sum_out += outputs_->frame_size;
+  }
+  outputs_sum += sum;
+  
+  Parameters *der_params_ = machine->der_params;
+  sum = 0;
+  for(int i = 0; i < der_params_->n_data; i++)
+  {
+    real *data_ = der_params_->data[i];
+    for(int j = 0; j < der_params_->size[i]; j++)
+      sum += fabs(data_[j]);
+    n_sum_der += der_params_->size[i];
+  }
+  derivatives_sum += sum;
+}
+
+void SaturationMeasurer::measureIteration()
+{
+  if(n_sum_out != 0)
+    outputs_sum /= n_sum_out;
+  if(n_sum_der != 0)
+    derivatives_sum /= n_sum_der;
+
+  if(binary_mode)
+  {
+    file->write(&outputs_sum, sizeof(real), 1);
+    file->write(&derivatives_sum, sizeof(real), 1);
+  }
+  else
+    file->printf("%g %g\n", outputs_sum, derivatives_sum);
+  file->flush();
+  reset_();
+}
+
+void SaturationMeasurer::reset()
+{
+  reset_();
+}
+
+void SaturationMeasurer::reset_()
+{
+  derivatives_sum = 0;
+  outputs_sum = 0;
+  n_sum_out = 0;
+  n_sum_der = 0;
+}
+
+SaturationMeasurer::~SaturationMeasurer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/SaturationMeasurer.h work/main.d/Torch-3/gradients/SaturationMeasurer.h
--- tmp/Torch-3/gradients/SaturationMeasurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/SaturationMeasurer.h	2004-08-11 12:34:40.000000000 -0400
@@ -0,0 +1,74 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SATURATION_MEASURER_INC
+#define SATURATION_MEASURER_INC
+
+#include "Measurer.h"
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Measure the saturation of a #GradientMachine#.
+
+    Save in #file# (on two columns)
+    \begin{itemize}
+      \item the absolute mean of the outputs of the machine.
+      \item the absolute mean of the derivative of the parameters of the machine.
+    \end{itemize}
+
+   @author Ronan Collobert (collober@idiap.ch)
+*/
+class SaturationMeasurer : public Measurer
+{
+  public:
+    real derivatives_sum;
+    real outputs_sum;
+    real n_sum_out;
+    real n_sum_der;
+
+    GradientMachine *machine;
+
+    //-----
+
+    ///
+    SaturationMeasurer(GradientMachine *machine_, DataSet *data_, XFile *file_);
+
+    //-----
+
+    virtual void reset();
+    void reset_();
+    virtual void measureExample();
+    virtual void measureIteration();
+
+    virtual ~SaturationMeasurer();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Sigmoid.cc work/main.d/Torch-3/gradients/Sigmoid.cc
--- tmp/Torch-3/gradients/Sigmoid.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Sigmoid.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,60 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Sigmoid.h"
+
+namespace Torch {
+
+Sigmoid::Sigmoid(int n_units) : GradientMachine(n_units, n_units)
+{
+}
+
+void Sigmoid::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  for(int i = 0; i < n_inputs; i++)
+    f_outputs[i] = 1./(1.+ exp(-f_inputs[i]));
+}
+
+void Sigmoid::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  if(partial_backprop)
+    return;
+
+  for(int i = 0; i < n_outputs; i++)
+  {
+    real z = f_outputs[i];
+    beta_[i] = alpha_[i] * (1. - z) * z;
+  }
+}
+
+Sigmoid::~Sigmoid()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Sigmoid.h work/main.d/Torch-3/gradients/Sigmoid.h
--- tmp/Torch-3/gradients/Sigmoid.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Sigmoid.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,64 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SIGMOID_INC
+#define SIGMOID_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Sigmoid layer for #GradientMachine#.
+
+    The number of inputs/outputs is the number
+    of units in the machine.
+
+    Formally speaking, $ouputs[i] = 1/(1+ exp(-inputs[i]))$
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Sigmoid : public GradientMachine
+{
+  public:
+
+    //-----
+
+    /// Create a layer with #n_units# units.
+    Sigmoid(int n_units);
+
+    //-----
+    
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~Sigmoid();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/SoftMax.cc work/main.d/Torch-3/gradients/SoftMax.cc
--- tmp/Torch-3/gradients/SoftMax.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/SoftMax.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,80 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "SoftMax.h"
+
+namespace Torch {
+
+SoftMax::SoftMax(int n_units) : GradientMachine(n_units, n_units)
+{
+  addROption("shift", &shift, 0, "shift to avoid overflow");
+  addBOption("compute shift", &calc_shift, false, "compute shift to avoid overflow");
+}
+
+void SoftMax::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  if(calc_shift)
+  {
+    shift = f_inputs[0];
+    for(int i = 1; i < n_inputs; i++)
+    {
+      if(f_inputs[i] > shift)
+          shift = f_inputs[i];
+    }
+  }
+
+  real sum = 0;
+  for(int i = 0; i < n_outputs; i++)
+  {
+    real z = exp(f_inputs[i] - shift);
+    f_outputs[i] = z;
+    sum += z;
+  }
+
+  for(int i = 0; i < n_outputs; i++)
+    f_outputs[i] /= sum;
+}
+
+void SoftMax::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  if(partial_backprop)
+    return;
+
+  real sum = 0;
+  for(int i = 0; i < n_outputs; i++)
+    sum += alpha_[i] * f_outputs[i];
+
+  for(int i = 0; i < n_outputs; i++)
+    beta_[i] = f_outputs[i] * (alpha_[i] - sum);
+}
+
+SoftMax::~SoftMax()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/SoftMax.h work/main.d/Torch-3/gradients/SoftMax.h
--- tmp/Torch-3/gradients/SoftMax.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/SoftMax.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,76 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SOFT_MAX_INC
+#define SOFT_MAX_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** SoftMax layer for #GradientMachine#.
+
+    The number of inputs/outputs is the number
+    of units in the machine.
+
+    Formally speaking, $ouputs[i] = 1/a * exp(inputs[i]-shift)$
+    where $a = \sum_j exp(inputs[j]-shift)$.
+
+    Options:
+    \begin{tabular}{lcll}
+      "shift"           & real &   shift to avoid overflow         & [0]\\
+      "compute shift"   & bool &   compute shift to avoid overflow & [false]
+    \end{tabular}
+
+    (you can have the "shift" you want, if you want, or
+    you can automatically compute the shift)
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class SoftMax : public GradientMachine
+{
+  public:
+    real shift;
+    bool calc_shift;
+
+    //-----
+
+    /// Create a layer with #n_units# units.
+    SoftMax(int n_units);
+
+    //-----
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~SoftMax();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/SoftPlus.cc work/main.d/Torch-3/gradients/SoftPlus.cc
--- tmp/Torch-3/gradients/SoftPlus.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/SoftPlus.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,59 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "SoftPlus.h"
+
+namespace Torch {
+
+SoftPlus::SoftPlus(int n_units) : GradientMachine(n_units, n_units)
+{
+}
+
+void SoftPlus::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  for(int i = 0; i < n_inputs; i++)
+    f_outputs[i] = log1p(exp(f_inputs[i]));
+}
+
+void SoftPlus::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  if(partial_backprop)
+    return;
+
+  for(int i = 0; i < n_outputs; i++)
+  {
+		real z = exp(f_outputs[i]);
+    beta_[i] = alpha_[i] * (z-1)/z;
+  }
+}
+
+SoftPlus::~SoftPlus()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/SoftPlus.h work/main.d/Torch-3/gradients/SoftPlus.h
--- tmp/Torch-3/gradients/SoftPlus.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/SoftPlus.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,62 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SOFT_PLUS_INC
+#define SOFT_PLUS_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** SoftPlus layer for #GradientMachine#.
+    
+    Can be used to constrain the output of a machine to be always positive.
+    The number of inputs/outputs is the number of units in the machine.
+
+    Formally speaking, $ouputs[i] = log(1+exp(inputs[i]))$
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class SoftPlus : public GradientMachine
+{
+  public:
+
+    /// Create a layer with #n_units# units.
+    SoftPlus(int n_units);
+
+    //-----
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+    
+    virtual ~SoftPlus();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/StochasticGradient.cc work/main.d/Torch-3/gradients/StochasticGradient.cc
--- tmp/Torch-3/gradients/StochasticGradient.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/StochasticGradient.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,180 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "StochasticGradient.h"
+#include "Random.h"
+
+namespace Torch {
+
+StochasticGradient::StochasticGradient(GradientMachine *machine_, Criterion *criterion_) : Trainer(machine_)
+{
+  // Boaf
+  criterion = criterion_;
+
+  addROption("end accuracy", &end_accuracy, 0.0001, "end accuracy");
+  addROption("learning rate", &learning_rate, 0.01, "learning rate");
+  addROption("learning rate decay", &learning_rate_decay, 0, "learning rate decay");
+  addIOption("max iter", &max_iter, -1, "maximum number of iterations");
+  addBOption("shuffle", &do_shuffle, true, "shuffle the dataset");
+}
+
+void StochasticGradient::train(DataSet *data, MeasurerList *measurers)
+{
+  int iter = 0;
+  real err = 0;
+  real prev_err = INF;
+  real current_learning_rate = learning_rate;
+  int n_train = data->n_examples;
+  int *shuffle = (int *)Allocator::sysAlloc(n_train*sizeof(int));
+  
+  DataSet **datas;
+  Measurer ***meas;
+  int *n_meas;
+  int n_datas;
+
+  message("StochasticGradient: training");
+
+  machine->setDataSet(data);
+  criterion->setDataSet(data);
+
+  if(measurers)
+  {
+    for(int i = 0; i < measurers->n_nodes; i++)
+      measurers->nodes[i]->reset();
+  }
+  criterion->reset();
+
+  Allocator *allocator_ = extractMeasurers(measurers, data, &datas, &meas, &n_meas, &n_datas);
+
+  if(do_shuffle)
+    Random::getShuffledIndices(shuffle, n_train);
+  else
+  {
+    for(int i = 0; i < n_train; i++)
+      shuffle[i] = i;
+  }
+
+  while(1)
+  {
+    ((GradientMachine *)machine)->iterInitialize();
+    criterion->iterInitialize();
+    err = 0;
+    for(int t = 0; t < n_train; t++)
+    {
+      Parameters *der_params = ((GradientMachine *)machine)->der_params;
+      if(der_params)
+      {
+        for(int i = 0; i < der_params->n_data; i++)
+          memset(der_params->data[i], 0, sizeof(real)*der_params->size[i]);
+      }
+      data->setExample(shuffle[t]);
+      machine->forward(data->inputs);
+      criterion->forward(machine->outputs);
+      criterion->backward(machine->outputs, NULL);
+      ((GradientMachine *)machine)->backward(data->inputs, criterion->beta);
+      
+      for(int i = 0; i < n_meas[0]; i++)
+        meas[0][i]->measureExample();
+      
+      Parameters *params = ((GradientMachine *)machine)->params;
+      if(params)
+      {
+        for(int i = 0; i < params->n_data; i++)
+        {
+          real *ptr_params = params->data[i];
+          real *ptr_der_params = der_params->data[i];
+          
+          for(int j = 0; j < params->size[i]; j++)
+            ptr_params[j] -= current_learning_rate * ptr_der_params[j];
+        }
+      }
+      // Note que peut-etre faudrait foutre
+      // un "accumul_erreur" dans la classe Criterion
+      // des fois que ca soit pas une somme...
+      // Mais bon, a priori ca vient d'une integrale,
+      // donc me gonflez pas.
+      // PREVENIR ICI L'UTILISATEUR DE L'UTILITE
+      // DE L'OUTPUT DANS UN CRITERION
+      err += criterion->outputs->frames[0][0];
+    }
+
+    for(int i = 0; i < n_meas[0]; i++)
+      meas[0][i]->measureIteration();
+
+    // le data 0 est le train dans tous les cas...
+    for(int julie = 1; julie < n_datas; julie++)
+    {
+      DataSet *dataset = datas[julie];
+
+      for(int t = 0; t < dataset->n_examples; t++)
+      {
+        dataset->setExample(t);
+        machine->forward(dataset->inputs);
+
+        for(int i = 0; i < n_meas[julie]; i++)
+          meas[julie][i]->measureExample();
+      }
+
+      for(int i = 0; i < n_meas[julie]; i++)
+        meas[julie][i]->measureIteration();
+    }
+
+    print(".");
+    err /= (real)(n_train);
+    if(fabs(prev_err - err) < end_accuracy)
+    {
+      print("\n");
+      break;
+    }
+    prev_err = err;
+
+    iter++;      
+    current_learning_rate = learning_rate/(1.+((real)(iter))*learning_rate_decay);
+    if( (iter >= max_iter) && (max_iter > 0) )
+    {
+      print("\n");
+      warning("StochasticGradient: you have reached the maximum number of iterations");
+      break;
+    }
+  }
+  free(shuffle);
+
+  for(int julie = 0; julie < n_datas; julie++)
+  {
+    for(int i = 0; i < n_meas[julie]; i++)
+      meas[julie][i]->measureEnd();
+  }
+
+  delete allocator_;
+}
+
+StochasticGradient::~StochasticGradient()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/StochasticGradient.h work/main.d/Torch-3/gradients/StochasticGradient.h
--- tmp/Torch-3/gradients/StochasticGradient.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/StochasticGradient.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,79 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef STOCHASTIC_GRADIENT_INC
+#define STOCHASTIC_GRADIENT_INC
+
+#include "Trainer.h"
+#include "GradientMachine.h"
+#include "DataSet.h"
+#include "Criterion.h"
+
+namespace Torch {
+
+/** Trainer for GradientMachine.
+    Given a machine and a criterion, train the machine using
+    a stochastic gradient descent.
+
+    Options:
+    \begin{tabular}{lcll}
+      "end accuracy"         & real  &  end accuracy                   & [0.0001]\\
+      "learning rate"        & real  &  learning rate                  & [0.01]\\
+      "learning rate decay"  & real  &  learning rate decay            & [0]\\
+      "max iter"             & int   &  maximum number of iterations   & [-1]\\
+      "shuffle"              & bool  &  shuffle the dataset            & [true]
+    \end{tabular}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class StochasticGradient : public Trainer
+{
+  public:
+    Criterion *criterion;
+    real learning_rate;
+    real learning_rate_decay;
+    real end_accuracy;
+    int max_iter;
+    bool do_shuffle;
+
+    //-----
+
+    /** Take the #machine_# to train, the train #data_#, the #criterion_#
+        to use, and the #optimizer_# to use.
+    */
+    StochasticGradient(GradientMachine *machine_, Criterion *criterion_);
+
+    //-----
+
+    virtual void train(DataSet *data, MeasurerList *measurers);
+    virtual ~StochasticGradient();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/SumMachine.cc work/main.d/Torch-3/gradients/SumMachine.cc
--- tmp/Torch-3/gradients/SumMachine.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/SumMachine.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,66 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "SumMachine.h"
+
+namespace Torch {
+
+
+SumMachine::SumMachine(int n_units, int n_machines_) : GradientMachine(n_units * n_machines_, n_units)
+{
+  n_machines = n_machines_;
+}
+
+void SumMachine::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  for(int i = 0; i < n_outputs; i++)
+    f_outputs[i] = 0;
+
+  for(int i = 0; i < n_machines; i++)
+  {
+    for(int j = 0; j < n_outputs; j++)
+      f_outputs[j] += f_inputs[j];
+    f_inputs += n_outputs;
+  }
+}
+
+void SumMachine::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  for(int i = 0; i < n_machines; i++)
+  {
+    for(int j = 0; j < n_outputs; j++)
+      beta_[j] = alpha_[j]; 
+    beta_ += n_outputs;
+  }
+}
+
+SumMachine::~SumMachine()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/SumMachine.h work/main.d/Torch-3/gradients/SumMachine.h
--- tmp/Torch-3/gradients/SumMachine.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/SumMachine.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,60 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SUM_MACHINE_INC
+#define SUM_MACHINE_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** This machine simply adds up its input vectors. Formally speaking,
+    $outputs[i] = \sum_j inputs_j[i]$ where $i$ spans the size of the
+    vectors and $j$ spans the number of input vectors.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class SumMachine : public GradientMachine
+{
+  public:
+
+    /// The number of input vectors
+    int n_machines;
+
+    /// 
+    SumMachine(int n_units, int n_machines_);
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~SumMachine();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Tanh.cc work/main.d/Torch-3/gradients/Tanh.cc
--- tmp/Torch-3/gradients/Tanh.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Tanh.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,59 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Tanh.h"
+
+namespace Torch {
+
+Tanh::Tanh(int n_units) : GradientMachine(n_units, n_units)
+{
+}
+
+void Tanh::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  for(int i = 0; i < n_inputs; i++)
+    f_outputs[i] = tanh(f_inputs[i]);
+}
+
+void Tanh::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{  
+  if(partial_backprop)
+    return;
+
+  for(int i = 0; i < n_outputs; i++)
+  {
+    real z = f_outputs[i];
+    beta_[i] = alpha_[i] * (1. - z*z);
+  }
+}
+
+Tanh::~Tanh()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/Tanh.h work/main.d/Torch-3/gradients/Tanh.h
--- tmp/Torch-3/gradients/Tanh.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/Tanh.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,61 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef TANH_INC
+#define TANH_INC
+
+#include "GradientMachine.h"
+
+namespace Torch {
+
+/** Tanh layer for #GradientMachine#.
+
+    The number of inputs/outputs is the number
+    of units for this machine.
+    Formally speaking, $ouputs[i] = tanh(inputs[i])$.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Tanh : public GradientMachine
+{
+  public:
+
+    /// Create a layer with #n_units# units.
+    Tanh(int n_units);
+
+    //-----
+
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~Tanh();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/WeightedMSECriterion.cc work/main.d/Torch-3/gradients/WeightedMSECriterion.cc
--- tmp/Torch-3/gradients/WeightedMSECriterion.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/WeightedMSECriterion.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,86 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "WeightedMSECriterion.h"
+
+namespace Torch {
+
+WeightedMSECriterion::WeightedMSECriterion(DataSet *data_) : Criterion(data_->n_targets)
+{
+  addBOption("average frame size", &average_frame_size, true, "divided by the frame size");
+  data = data_;
+  weights = (real *)allocator->alloc(sizeof(real)*data->n_real_examples);
+  for(int i = 0; i < data->n_real_examples; i++)
+    weights[i] = 1;
+}
+
+WeightedMSECriterion::WeightedMSECriterion(DataSet *data_, real *weights_) : Criterion(data_->n_targets)
+{
+  data = data_;
+  weights = weights_;
+}
+
+void WeightedMSECriterion::setDataSet(DataSet *data_)
+{
+  if(data_->n_real_examples != data->n_real_examples)
+    error("WeightedMSECriterion: trying to use a wrong DataSet");
+  data = data_;
+}
+
+void WeightedMSECriterion::frameForward(int t, real *f_inputs, real *f_outputs)
+{
+  real *desired = data->targets->frames[t];
+  real err = 0;
+  
+  for(int i = 0; i < n_inputs; i++)
+  {
+      real z = desired[i] - f_inputs[i];
+      err += z*z;
+  }
+
+  f_outputs[0] = err*weights[data->real_current_example_index];
+
+  if(average_frame_size)
+    f_outputs[0] /= n_inputs;
+}
+
+void WeightedMSECriterion::frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_)
+{
+  real z = 2.*weights[data->real_current_example_index];
+  if(average_frame_size)
+    z /= n_inputs;
+  real *desired = data->targets->frames[t];
+  for(int i = 0; i < n_inputs; i++)
+    beta_[i] = z*(f_inputs[i] - desired[i]);
+}
+
+WeightedMSECriterion::~WeightedMSECriterion()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/gradients/WeightedMSECriterion.h work/main.d/Torch-3/gradients/WeightedMSECriterion.h
--- tmp/Torch-3/gradients/WeightedMSECriterion.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/gradients/WeightedMSECriterion.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,84 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef WEIGHTED_MSE_CRITERION_INC
+#define WEIGHTED_MSE_CRITERION_INC
+
+#include "Criterion.h"
+
+namespace Torch {
+
+/** Similar to #MSECriterion#, but you
+    can put a weight on each example.
+
+    Options:
+    \begin{tabular}{lcll}
+      "average frame size"  &  bool  &  divided by the frame size & [true]
+    \end{tabular}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class WeightedMSECriterion : public Criterion
+{
+  public:
+    bool average_frame_size;
+
+    /** Pointer on the weights.
+        You can modify the weights when you want.
+        
+        The length of #weights# \emph{is} the
+        #n_real_examples# of #data#.
+    */
+    real *weights;
+
+    //-----
+
+    /** With this constructor, the weights are allocated
+        and initializated to 1.
+    */
+    WeightedMSECriterion(DataSet *data_);
+
+    /** With this constructor, you provide the #weights#.
+
+       The length of #weights# \emph{must be} the
+       #n_real_examples# of #data#.       
+    */
+    WeightedMSECriterion(DataSet *data_, real *weights_);
+
+    //-----
+
+    virtual void setDataSet(DataSet *data_);
+    virtual void frameForward(int t, real *f_inputs, real *f_outputs);
+    virtual void frameBackward(int t, real *f_inputs, real *beta_, real *f_outputs, real *alpha_);
+
+    virtual ~WeightedMSECriterion();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/Kernel.cc work/main.d/Torch-3/kernels/Kernel.cc
--- tmp/Torch-3/kernels/Kernel.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/Kernel.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,148 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Kernel.h"
+
+namespace Torch {
+
+Kernel::Kernel()
+{
+}
+
+Kernel::~Kernel()
+{
+}
+
+//=====
+
+DotKernel::DotKernel(real s_)
+{
+  s = s_;
+}
+
+real DotKernel::eval(Sequence *x, Sequence *y)
+{
+  real *x_ = x->frames[0];
+  real *y_ = y->frames[0];
+
+  real sum = 0;
+  for(int i = 0; i < x->frame_size; i++)
+    sum += x_[i]*y_[i];
+
+  return s*sum;
+}
+
+DotKernel::~DotKernel()
+{
+}
+
+//=====
+
+PolynomialKernel::PolynomialKernel(int degree, real s_, real r_)
+{
+  d = degree;
+  s = s_;
+  r = r_;
+}
+
+real PolynomialKernel::eval(Sequence *x, Sequence *y)
+{
+  real *x_ = x->frames[0];
+  real *y_ = y->frames[0];
+
+  real sum = 0;
+  for(int i = 0; i < x->frame_size; i++)
+    sum += x_[i]*y_[i];
+
+  sum = s*sum+r;
+
+  // la fonction pow rame a donf
+  real julie = sum;
+  for(int t = 1; t < d; t++)
+    julie *= sum;
+    
+  return(julie);
+}
+
+PolynomialKernel::~PolynomialKernel()
+{
+}
+
+//=====
+
+GaussianKernel::GaussianKernel(real g_)
+{
+  g = g_;
+}
+
+real GaussianKernel::eval(Sequence *x, Sequence *y)
+{
+  real *x_ = x->frames[0];
+  real *y_ = y->frames[0];
+
+  real sum = 0.;
+  for(int i = 0; i < x->frame_size; i++)
+  {
+    real z = x_[i]-y_[i];
+    sum -= z*z;
+  }
+
+  return exp(g*sum);
+}
+
+GaussianKernel::~GaussianKernel()
+{
+}
+
+//=====
+
+SigmoidKernel::SigmoidKernel(real s_, real r_)
+{
+  s = s_;
+  r = r_;
+}
+
+real SigmoidKernel::eval(Sequence *x, Sequence *y)
+{
+  real *x_ = x->frames[0];
+  real *y_ = y->frames[0];
+
+  real sum = 0;
+  for(int i = 0; i < x->frame_size; i++)
+    sum += x_[i]*y_[i];
+
+  return(tanh(s*sum+r));
+}
+
+SigmoidKernel::~SigmoidKernel()
+{
+}
+
+//=====
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/Kernel.h work/main.d/Torch-3/kernels/Kernel.h
--- tmp/Torch-3/kernels/Kernel.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/Kernel.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,128 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef KERNEL_INC
+#define KERNEL_INC
+
+#include "Object.h"
+#include "Sequence.h"
+
+namespace Torch {
+
+/** General Kernel class.
+    Kernels are applied on two sequences with the method #eval()#.
+    Actually, usual kernels (given here) don't use sequences,
+    but the first frame of each sequences...
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Kernel : public Object
+{
+  public:
+
+    ///
+    Kernel();
+
+    /// Compute kernel between the example #x# and #y#.
+    virtual real eval(Sequence *x, Sequence *y) = 0;
+
+    //-----
+
+    virtual ~Kernel();
+};
+
+/** DotProduct Kernel.
+    k(x,y) = s*(x.y).
+
+    @author Ronan Collobert (collober@idiap.ch)
+ */
+class DotKernel : public Kernel
+{
+  public:
+    real s;
+
+    ///
+    DotKernel(real s_=1.);
+
+    virtual real eval(Sequence *x, Sequence *y);
+    virtual ~DotKernel();
+};
+
+
+/** Polynomial Kernel $k(x,y) = (s*x.y+r)^d$.
+    
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class PolynomialKernel : public Kernel
+{
+  public:
+    int d;
+    real s, r;
+
+    ///
+    PolynomialKernel(int degree, real s_=1., real r_=1.);
+
+    virtual real eval(Sequence *x, Sequence *y);
+    virtual ~PolynomialKernel();
+};
+
+/** Gaussian Kernel $k(x,y) = exp(-g * ||x-y||^2)$
+    
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class GaussianKernel : public Kernel
+{
+  public:
+    real g;
+
+    ///
+    GaussianKernel(real g_);
+
+    virtual real eval(Sequence *x, Sequence *y);
+    virtual ~GaussianKernel();
+};
+
+/** Sigmoid Kernel $k(x,y) = tanh(s*x.y+r)$
+    
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class SigmoidKernel : public Kernel
+{
+  public:
+    real s, r;
+
+    ///
+    SigmoidKernel(real s_, real r_);
+
+    virtual real eval(Sequence *x, Sequence *y);
+    virtual ~SigmoidKernel();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/LICENSE work/main.d/Torch-3/kernels/LICENSE
--- tmp/Torch-3/kernels/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/LICENSE	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,28 @@
+
+Copyright (c) 2003--2004 Ronan Collobert
+Copyright (c) 2003--2004 Samy Bengio
+Copyright (c) 2003--2004 Johnny Mariéthoz
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/Makefile work/main.d/Torch-3/kernels/Makefile
--- tmp/Torch-3/kernels/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/Makefile	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,42 @@
+# get user and architecture specific options
+OS := $(shell uname -s)
+TORCHDIR := $(shell cd ..; pwd)
+include ../Makefile_options_$(OS)
+
+CC_FILES := $(wildcard *.cc)
+OBJS := $(foreach f,$(CC_FILES),$(OBJS_DIR)/$(patsubst %.cc,%.o,$(f)))
+
+all:	$(LIBTORCH)
+
+$(LIBTORCH): $(OBJS)
+	@echo "Archiving..."
+	@$(AR) $(LIBTORCH) $(OBJS)
+
+$(OBJS_DIR)/%.o: %.cc
+	@echo $<
+	@$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $@ -c $<
+
+distclean:
+	@\rm -f .deps_*
+
+clean:
+	@echo "Remove objects file and dependencies..."
+	@\rm -Rf $(OBJS) $(LIBTORCH)
+	@\rm -f .deps_$(VERSION_KEY)
+
+depend:
+	@echo "Tracking dependencies..."
+	@\rm -f .deps_$(VERSION_KEY)
+	@for file in *.cc ; do printf "$(OBJS_DIR)/" >> .deps_$(VERSION_KEY); $(DEP) $(CFLAGS_$(MODE)) $(INCS) $$file >> .deps_$(VERSION_KEY); done
+
+.deps_$(VERSION_KEY):
+	@echo ">>> Please do a 'make depend' <<<"
+	exit 10
+
+ifneq ($(MAKECMDGOALS),distclean)
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),depend)
+include .deps_$(VERSION_KEY)
+endif
+endif
+endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/QCCache.cc work/main.d/Torch-3/kernels/QCCache.cc
--- tmp/Torch-3/kernels/QCCache.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/QCCache.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,41 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "QCCache.h"
+
+namespace Torch {
+
+QCCache::QCCache()
+{
+}
+
+QCCache::~QCCache()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/QCCache.h work/main.d/Torch-3/kernels/QCCache.h
--- tmp/Torch-3/kernels/QCCache.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/QCCache.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,81 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef QC_CACHE_INC
+#define QC_CACHE_INC
+
+#include "Object.h"
+
+namespace Torch {
+
+/** "Cache" used by the Quadratic Constrained Trainer (#QCTrainer#).
+    This class provides the Q (symetric) matrix of the
+    quadratic problem.
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @see QCTrainer
+*/
+class QCCache : public Object
+{
+  public:
+
+    //-----
+
+    ///
+    QCCache();
+
+    /// Returns the adress of the row/column #index# for the Q matrix.
+    virtual real *adressCache(int index) = 0;
+
+    /// Allocate the cache.
+    virtual void allocate() = 0;
+
+    /// Erase the cache (but don't destroy it).
+    virtual void clear() = 0;
+
+    /// Destroy the cache.
+    virtual void destroy() = 0;
+
+    /** Set the active variables to be those contained in #active_var#.
+        The number of active variable is given by #n_active_var_#.
+
+        (It's usefull for some problems)
+        
+        @see QCMachine
+        @see QCTrainer
+    */
+    virtual void setActiveVariables(int *active_var_, int n_active_var_) = 0;
+
+    //-----
+
+    virtual ~QCCache();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/QCMachine.cc work/main.d/Torch-3/kernels/QCMachine.cc
--- tmp/Torch-3/kernels/QCMachine.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/QCMachine.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,65 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "QCMachine.h"
+
+namespace Torch {
+
+QCMachine::QCMachine()
+{
+  Cup = NULL;
+  Cdown = NULL;
+  n_alpha = 0;
+  alpha = NULL;
+  grad = NULL;
+  y = NULL;
+  cache = NULL;
+
+#ifdef USE_DOUBLE
+  addROption("eps bounds", &bound_eps, 1E-12, "bounds accuracy");
+#else
+  addROption("eps bounds", &bound_eps, 1E-4, "bounds accuracy");
+#endif
+}
+
+void QCMachine::reInit(int n_alpha_)
+{
+  n_alpha = n_alpha_;
+
+  Cup = (real *)allocator->realloc(Cup, sizeof(real)*n_alpha);
+  Cdown = (real *)allocator->realloc(Cdown, sizeof(real)*n_alpha);
+  alpha = (real *)allocator->realloc(alpha, sizeof(real)*n_alpha);
+  grad = (real *)allocator->realloc(grad, sizeof(real)*n_alpha);
+  y = (real *)allocator->realloc(y, sizeof(real)*n_alpha);
+}
+
+QCMachine::~QCMachine()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/QCMachine.h work/main.d/Torch-3/kernels/QCMachine.h
--- tmp/Torch-3/kernels/QCMachine.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/QCMachine.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,115 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef QC_MACHINE_INC
+#define QC_MACHINE_INC
+
+#include "Machine.h"
+#include "QCCache.h"
+
+namespace Torch {
+
+/** "Quadratic Constrained Machine".
+    It's a machine with #alpha# parameters which
+    are the minimum of a constrained quadratic problem.
+
+    The problem:
+
+    minimize $QP(alpha) = alpha' * Q * alpha + beta'*alpha$
+    
+    with the following constraints:
+         \begin{itemize}
+           \item $\sum_j alpha_j y_j = 1$
+           \item $Cdown_j <= alpha_j <= Cup_j$
+         \end{itemize}
+
+    where $y$, $Cdown$, $Cup$ are given by the user
+    and \emph{must be} $y_j = +- 1$.
+
+    The number of #alpha# variable is determined here by #l#.
+    (Therefore, it determines the size of de Cup, Cdown et y...)
+
+    Note: if $alpha_j$ is closed to $Cup_j$ [ou $Cdown_j$] with
+          the accuracy "eps bounds", $alpha_j$ is considered
+          to be equal to $Cup_j$ [ou $Cdown_j$].
+
+    Options:
+    \begin{tabular}{lcll}
+      "eps bounds"  &  real  &  bound accuracy: & [1E-4 in float, 1E-12 in double]
+    \end{tabular}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class QCMachine : public Machine
+{
+  public:
+
+    ///
+    real *Cup;
+
+    ///
+    real *Cdown;
+
+    ///
+    real bound_eps;
+
+    ///
+    int n_alpha;
+
+    ///
+    real *alpha;
+
+    ///
+    real *grad;
+
+    ///
+    real *y;
+
+    ///
+    QCCache *cache;
+
+    //-----
+
+    ///
+    QCMachine();
+
+    /** Function called by #QCTrainer# after the optimization.
+        @see QCTrainer
+    */
+    virtual void checkSupportVectors() = 0;
+    void reInit(int n_alpha_);
+
+    //-----
+
+    virtual ~QCMachine();    
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/QCTrainer.cc work/main.d/Torch-3/kernels/QCTrainer.cc
--- tmp/Torch-3/kernels/QCTrainer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/QCTrainer.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,398 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "QCTrainer.h"
+
+namespace Torch {
+
+QCTrainer::QCTrainer(QCMachine *qcmachine_) : Trainer(qcmachine_)
+{
+  qcmachine = qcmachine_;
+
+  active_var = NULL;
+  active_var_new = NULL;
+  not_at_bound_at_iter = NULL;
+  status_alpha = NULL;
+
+  //------
+
+#ifdef USE_DOUBLE
+  addROption("eps shrink", &eps_shrink, 1E-9, "shrinking accuracy");
+#else
+  addROption("eps shrink", &eps_shrink, 1E-4, "shrinking accuracy");
+#endif
+
+  addBOption("unshrink", &unshrink_mode, false, "unshrink or not unshrink");
+  addIOption("max unshrink", &n_max_unshrink, 1, "maximal number of unshrinking");
+  addIOption("iter shrink", &n_iter_min_to_shrink, 100, "minimal number of iterations to shrink");
+  addROption("end accuracy", &end_eps, 0.01, "end accuracy");
+  addIOption("iter message", &n_iter_message, 1000, "number of iterations between messages");
+}
+
+void QCTrainer::prepareToLaunch()
+{
+  n_alpha = qcmachine->n_alpha;
+  grad = qcmachine->grad;
+  Cup = qcmachine->Cup;
+  Cdown = qcmachine->Cdown;
+  alpha = qcmachine->alpha;
+  y = qcmachine->y;
+  bound_eps = qcmachine->bound_eps;
+  cache = qcmachine->cache;
+
+  cache->allocate();
+  deja_shrink = false;
+  n_active_var = n_alpha;
+  active_var = (int *)allocator->alloc(sizeof(int)*n_alpha);
+  active_var_new = (int *)allocator->alloc(sizeof(int)*n_alpha);
+  not_at_bound_at_iter = (int *)allocator->alloc(sizeof(int)*n_alpha);
+  status_alpha = (char *)allocator->alloc(sizeof(char)*n_alpha);
+
+  for(int i = 0; i < n_alpha; i++)
+  {
+    active_var[i] = i;
+    updateStatus(i);
+//    status_alpha[i] = 1;
+    not_at_bound_at_iter[i] = 0;
+  }
+}
+
+void QCTrainer::atomiseAll()
+{
+  cache->destroy();
+  allocator->free(active_var);
+  allocator->free(active_var_new);
+  allocator->free(not_at_bound_at_iter);
+  allocator->free(status_alpha);
+
+  active_var = NULL;
+  active_var_new = NULL;
+  not_at_bound_at_iter = NULL;
+  status_alpha = NULL;
+}
+
+bool QCTrainer::selectVariables(int *i, int *j)
+{
+  real gmax_i = -INF;
+  real gmin_j =  INF;
+  int i_ = -1;
+  int j_ = -1;
+
+  for(int it = 0; it < n_active_var; it++)   
+  {
+    int t = active_var[it];
+
+    if(y[t] > 0)
+    {
+      if(isNotDown(t))
+      {
+        if(grad[t] > gmax_i)
+        {
+          gmax_i = grad[t];
+          i_ = t;
+        }
+      }
+
+      if(isNotUp(t))
+      {
+        if(grad[t] < gmin_j)
+        {
+          gmin_j = grad[t];
+          j_ = t;
+        }
+      }            
+    }
+    else
+    {
+      if(isNotUp(t))
+      {
+        if(-grad[t] > gmax_i)
+        {
+          gmax_i = -grad[t];
+          i_ = t;
+        }
+      }
+      
+      if(isNotDown(t))
+      {
+        if(-grad[t] < gmin_j)
+        {
+          gmin_j = -grad[t];
+          j_ = t;
+        }
+      }            
+    }
+  }
+
+  current_error =  gmax_i - gmin_j;
+
+  if(current_error < end_eps)
+    return(true);
+  
+  if( (i_ == -1) || (j_ == -1) )
+    return(true);
+
+  *i = i_;
+  *j = j_;
+
+  return(false);
+}
+
+// Renvoie le nb de var susceptibles d'etre shrinkee
+int QCTrainer::checkShrinking(real bmin, real bmax)
+{
+  real bb = (bmin+bmax)/2.;
+
+  n_active_var_new = 0;
+  for(int it = 0; it < n_active_var; it++)
+  {
+    int t = active_var[it];
+    bool garde = true;
+
+    if(isNotDown(t) && isNotUp(t))
+      not_at_bound_at_iter[t] = iter;
+    else
+    {
+      if(isNotUp(t)) // Donc elle est en bas.
+      {
+        if(grad[t] + y[t]*bb < eps_shrink)
+          not_at_bound_at_iter[t] = iter;
+        else
+        {
+          if( (iter - not_at_bound_at_iter[t]) > n_iter_min_to_shrink)
+            garde = false;
+        }
+      }
+      else
+      {
+        if(grad[t] + y[t]*bb > -eps_shrink)
+          not_at_bound_at_iter[t] = iter;
+        else
+        {
+          if( (iter - not_at_bound_at_iter[t]) > n_iter_min_to_shrink)
+            garde = false;
+        }
+      }      
+    }
+
+    if(garde)
+      active_var_new[n_active_var_new++] = t;
+  }
+
+  return(n_active_var-n_active_var_new);
+}
+
+void QCTrainer::shrink()
+{
+  n_active_var = n_active_var_new;
+  int *ptr_sav = active_var;
+  active_var = active_var_new;
+  active_var_new = ptr_sav;
+  deja_shrink = true;
+
+  if(!unshrink_mode)
+    cache->setActiveVariables(active_var, n_active_var);
+}
+
+void QCTrainer::unShrink()
+{
+  for(int i = 0; i < n_alpha; i++)
+    active_var[i] = i;
+
+  n_active_var = n_alpha;
+  deja_shrink = false;
+
+  if(++n_unshrink == n_max_unshrink)
+  {
+    unshrink_mode = false;
+    n_iter_min_to_shrink = 666666666;
+    warning("QCTrainer: shrinking and unshrinking desactived...");
+  }
+}
+
+void QCTrainer::train(DataSet *data, MeasurerList *measurers)
+{
+  qcmachine->setDataSet(data);
+  prepareToLaunch();
+
+  int xi, xj;
+  int n_to_shrink = 0;
+  n_unshrink = 0;
+
+  message("QCTrainer: training...");
+
+  iter = 0;
+  while(1)
+  {
+    if(selectVariables(&xi, &xj))
+    {
+      if(unshrink_mode)
+      {
+        message("QCTrainer: unshrink...");
+        unShrink();
+        if(selectVariables(&xi, &xj))
+        {
+          message("QCTrainer: ...finished");
+          break;
+        }
+        else
+          message("QCTrainer: ...restart");
+      }
+      else
+        break;
+    }
+
+    if(iter >= n_iter_min_to_shrink)
+      n_to_shrink = checkShrinking(-y[xi]*grad[xi], -y[xj]*grad[xj]);
+
+    k_xi = cache->adressCache(xi);
+    k_xj = cache->adressCache(xj);
+
+    old_alpha_xi = alpha[xi];
+    old_alpha_xj = alpha[xj];
+
+    analyticSolve(xi, xj);
+
+    real delta_alpha_xi = alpha[xi] - old_alpha_xi;
+    real delta_alpha_xj = alpha[xj] - old_alpha_xj;
+
+    if(deja_shrink && !unshrink_mode)
+    {
+      for(int t = 0; t < n_active_var; t++)
+      {
+        int it = active_var[t];
+        grad[it] += k_xi[it]*delta_alpha_xi + k_xj[it]*delta_alpha_xj;
+      }
+    }
+    else
+    {
+      for(int t = 0; t < n_alpha; t++)
+        grad[t] += k_xi[t]*delta_alpha_xi + k_xj[t]*delta_alpha_xj;
+    }
+
+    iter++;
+    if(! (iter % n_iter_message) )
+    {
+      // Pour ne pas effrayer le neophite.
+      if(current_error < 0)
+        current_error = 0;
+      print("  + Iteration %d\n", iter);
+      print("   --> Current error    = %g\n", current_error);
+      print("   --> Active variables = %d\n", n_active_var);
+    }
+
+    /////////////// Shhhhhrinnnk
+
+    if(!(iter % n_iter_min_to_shrink))
+    {
+      if( (n_to_shrink > n_active_var/10) && (n_active_var-n_to_shrink > 100) )
+        shrink();
+    }
+  }
+
+  // Pour ne pas effrayer le neophite.
+  if(current_error < 0)
+    current_error = 0;
+  print("  + Iteration %d\n", iter);
+  print("   --> Current error    = %g\n", current_error);
+  print("   --> Active variables = %d\n", n_active_var);
+
+  qcmachine->checkSupportVectors();
+  atomiseAll();
+}
+
+void QCTrainer::updateStatus(int i)
+{
+  if(alpha[i] < Cup[i] - bound_eps)
+    status_alpha[i] = 1;
+  else
+    status_alpha[i] = 0;
+
+  if(alpha[i] > Cdown[i] + bound_eps)
+    status_alpha[i] |= 2;
+}
+
+void QCTrainer::analyticSolve(int xi, int xj)
+{
+  real ww, H, L;
+
+  real s = y[xi]*y[xj];
+  if(s < 0)
+  {
+    ww = old_alpha_xi - old_alpha_xj;
+    L = ((Cdown[xj]+ww >   Cdown[xi]) ? Cdown[xj]+ww :  Cdown[xi]);
+    H = ((Cup[xj]+ww   >     Cup[xi]) ? Cup[xi]      : Cup[xj]+ww);
+  }
+  else
+  {
+    ww = old_alpha_xi + old_alpha_xj;
+    L = ((ww-Cup[xj]   >    Cdown[xi]) ? ww-Cup[xj] :     Cdown[xi]);
+    H = ((ww-Cdown[xj] >      Cup[xi]) ?    Cup[xi] :  ww-Cdown[xj]);
+  }
+
+  real eta = k_xi[xi] - 2.*s*k_xi[xj] + k_xj[xj];
+  if(eta > 0)
+  {
+    real alph = old_alpha_xi + (s*grad[xj] - grad[xi])/eta;
+	
+    if(alph > H)
+      alph = H;
+    else
+    {
+      if(alph < L)
+        alph = L;
+    }
+    
+    alpha[xi] = alph;
+    alpha[xj] -= s*(alpha[xi]-old_alpha_xi);
+  }
+  else
+  {
+    print(".");
+    real alph = grad[xi] - s*grad[xj];
+    if(alph > 0)
+    {
+      alpha[xi] = L;
+      alpha[xj] -= s*(alpha[xi]-old_alpha_xi);
+    }
+    else
+    {
+      alpha[xi] = H;
+      alpha[xj] -= s*(alpha[xi]-old_alpha_xi);
+    }
+  }
+
+  updateStatus(xi);
+  updateStatus(xj);
+}
+
+QCTrainer::~QCTrainer()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/QCTrainer.h work/main.d/Torch-3/kernels/QCTrainer.h
--- tmp/Torch-3/kernels/QCTrainer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/QCTrainer.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,144 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef QC_TRAINER_INC
+#define QC_TRAINER_INC
+
+#include "Trainer.h"
+#include "QCMachine.h"
+#include "QCCache.h"
+
+namespace Torch {
+
+
+/** Train a #QCMachine#.
+    With the conventions of QCMachine.h,
+    Q is given by the class QCCache (in #cache#)
+
+    Options:
+    \begin{tabular}{lcll}
+      "unshrink"      & bool  &  unshrink or not unshrink              & [false] \\
+      "max unshrink"  & int   &  maximal number of unshrinking         & [1] \\
+      "iter shrink"   & int   &  minimal number of iterations to shrink& [100] \\
+      "eps shrink"    & real  &  shrinking accuracy                    & [1E-4 (f)  1E-9 (d)] \\
+      "end accuracy"  & real  &  end accuracy                          & [0.01] \\
+      "iter message"  & int   &  number of iterations between messages & [1000]
+    \end{tabular}
+
+
+    Note: "iter shrink" must be carefully chosen.
+    Read http://www.ai.mit.edu/projects/jmlr/papers/volume1/collobert01a/collobert01a.ps.gz
+    for more details.
+
+    @author Ronan Collobert (collober@idiap.ch)
+    @see QCCache
+    @see QCMachine
+*/
+class QCTrainer : public Trainer
+{
+  public:
+    // ohhh boy, c'est la zone
+    QCMachine *qcmachine;
+    QCCache *cache;
+
+    int n_unshrink;
+    int n_max_unshrink;
+
+    real *k_xi;
+    real *k_xj;
+  
+    real old_alpha_xi;
+    real old_alpha_xj;
+    real current_error;
+
+    int *active_var_new;
+    int n_active_var_new;
+
+    int n_alpha;                  // le nb de alphas
+
+    bool deja_shrink;
+    bool unshrink_mode;
+
+    real *y;
+    real *alpha;
+    real *grad;
+
+    real eps_shrink;
+    real end_eps;
+    real bound_eps;
+
+    int n_active_var;
+    int *active_var;
+    int *not_at_bound_at_iter;
+    int iter;
+    int n_iter_min_to_shrink;
+    int n_iter_message;
+
+    char *status_alpha;
+    real *Cup;
+    real *Cdown;
+
+    //-----
+
+    ///
+    QCTrainer(QCMachine *qcmachine_);
+
+    /** Train it...
+        Before calling this function, #grad# in #qcmachine#
+        must contain the gradient of QP(alpha) with respect
+        to alpha = 0.
+
+        ( = $beta$, with the conventions of QCMachine.h)
+
+        Moreover #alpha# in #qcmachine# has to be zero.
+    */
+    void train(DataSet *data, MeasurerList *measurers);
+
+    //-----
+
+    void prepareToLaunch();
+    void atomiseAll();
+
+    bool bCompute();
+    bool selectVariables(int *i, int *j);
+    int checkShrinking(real bmin, real bmax);
+    void shrink();
+    void unShrink();
+
+    void analyticSolve(int xi, int xj);
+    void updateStatus(int i);  
+    inline bool isNotUp(int i)   {  return(status_alpha[i] != 2); };
+    inline bool isNotDown(int i) {  return(status_alpha[i] != 1); };
+
+    virtual ~QCTrainer();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/SVMCache.cc work/main.d/Torch-3/kernels/SVMCache.cc
--- tmp/Torch-3/kernels/SVMCache.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/SVMCache.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,250 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "SVMCache.h"
+
+namespace Torch {
+
+SVMCache::SVMCache(int n_alpha_, Kernel *kernel_, real cache_size_in_megs_)
+{
+  n_alpha = n_alpha_;
+  n_cache_entries = 0;
+
+  kernel = kernel_;
+  cache_size_in_megs = cache_size_in_megs_;
+
+  memory_cache = NULL;
+  cached = NULL;
+  list_index = NULL;
+
+  n_active_var = -1;
+  active_var = NULL;
+}
+
+void SVMCache::allocate()
+{
+  n_active_var = -1;
+  active_var = NULL;
+
+  // Allocs...
+  temp_allocator = new Allocator;
+  n_cache_entries = (int)(cache_size_in_megs*1048576./((real)sizeof(real)*n_alpha));
+  list_index = (SVMCacheList **)temp_allocator->alloc(sizeof(SVMCacheList *)*n_alpha);
+  cached = (SVMCacheList *)temp_allocator->alloc(sizeof(SVMCacheList)*n_cache_entries);
+
+  message("SVMCache: max columns in cache: %d", n_cache_entries);
+  if(n_cache_entries < 2)
+    error("SVMCache: please change the cache size : it's too small");
+
+  // Init
+  SVMCacheList *ptr = cached;
+  for(int i = 0; i < n_alpha; i++)
+    list_index[i] = NULL;
+
+  memory_cache = (real *)temp_allocator->alloc(sizeof(real)*n_cache_entries*n_alpha);
+  for(int i = 0; i < n_cache_entries; i++)
+  {
+    ptr->adr = memory_cache+i*n_alpha;
+    ptr->index = -1;
+    if(i != 0)
+      ptr->prev = (ptr-1);
+    else
+      ptr->prev = &cached[n_cache_entries-1];
+    if(i != n_cache_entries-1)
+      ptr->next = (ptr+1);
+    else
+      ptr->next = cached;
+
+    ptr++;
+  }
+}
+
+void SVMCache::destroy()
+{
+  delete temp_allocator;
+
+  list_index = NULL;
+  memory_cache = NULL;
+}
+
+void SVMCache::clear()
+{
+  SVMCacheList *ptr = cached;
+  for(int i = 0; i < n_cache_entries; i++)
+  {
+    ptr->index = -1;
+    ptr = ptr->next;
+  }
+
+  for(int i = 0; i < n_cache_entries; i++)
+    list_index[i] = NULL;
+}
+
+real *SVMCache::adressCache(int index)
+{
+  SVMCacheList *ptr;
+
+  // Rq: en regression faudrait faire gaffe a pas recalculer deux trucs...
+  // Mais pb: -1 +1 a inverser dans la matrice...
+  // Donc faich.
+
+  ptr = list_index[index];
+  if( (ptr != NULL) && (ptr != cached) )
+  {
+    ptr->prev->next = ptr->next;
+    ptr->next->prev = ptr->prev;
+
+    ptr->next = cached;
+    ptr->prev = cached->prev;
+    cached->prev->next = ptr;
+    cached->prev = ptr;
+    cached = ptr;
+  }
+  else
+  {
+    cached = cached->prev;
+    if(cached->index != -1)
+      list_index[cached->index] = NULL;
+    cached->index = index;
+    list_index[index] = cached;
+    getColumn(index, cached->adr);
+  }
+
+  return(cached->adr);
+}
+
+void SVMCache::setActiveVariables(int *active_var_, int n_active_var_)
+{
+  n_active_var = n_active_var_;
+  active_var = active_var_;
+}
+
+SVMCache::~SVMCache()
+{
+}
+
+SVMCacheClassification::SVMCacheClassification(DataSet *data_, Kernel *kernel_, real cache_size_in_megs_)
+  : SVMCache(data_->n_examples, kernel_, cache_size_in_megs_)
+{
+  data = data_;
+  y = (real *)allocator->alloc(sizeof(real)*data->n_examples);
+  for(int i = 0; i < data->n_examples; i++)
+  {
+    data->setExample(i);
+    y[i] = data->targets->frames[0][0];
+  }
+}
+
+void SVMCacheClassification::getColumn(int index, real *adr)
+{
+  data->setExample(index);
+  Sequence *inputs = data->inputs;
+  data->pushExample();
+
+  if(active_var)
+  {
+    if(y[index] > 0)
+    {
+      for(int it = 0; it < n_active_var; it++)
+      {
+        int t = active_var[it];
+        data->setExample(t);
+        adr[t] =  y[t]*kernel->eval(inputs, data->inputs);
+      }
+    }
+    else
+    {
+      for(int it = 0; it < n_active_var; it++)
+      {
+        int t = active_var[it];
+        data->setExample(t);
+        adr[t] = -y[t]*kernel->eval(inputs, data->inputs);
+      }
+    }
+  }
+  else
+  {
+    if(y[index] > 0)
+    {
+      for(int i = 0; i < n_alpha; i++)
+      {
+        data->setExample(i);
+        adr[i] =  y[i]*kernel->eval(inputs, data->inputs);
+      }
+    }
+    else
+    {
+      for(int i = 0; i < n_alpha; i++)
+      {
+        data->setExample(i);
+        adr[i] = -y[i]*kernel->eval(inputs, data->inputs);
+      }
+    }
+  }
+
+  data->popExample();
+}
+
+SVMCacheRegression::SVMCacheRegression(DataSet *data_, Kernel *kernel_, real cache_size_in_megs_)
+  : SVMCache(2*data_->n_examples, kernel_, cache_size_in_megs_)
+{
+  data = data_;
+  n_examples = data->n_examples;
+}
+
+void SVMCacheRegression::getColumn(int index, real *adr)
+{
+  data->setExample(index%n_examples);
+  Sequence *inputs = data->inputs;
+  data->pushExample();
+  
+  if(active_var)
+  {
+    for(int i = 0; i < n_active_var; i++)
+    {
+      int k = active_var[i]%n_examples;
+      data->setExample(k);
+      adr[k] = kernel->eval(inputs, data->inputs);
+    }
+  }
+  else
+  {
+    for(int i = 0; i < n_examples; i++)
+    {
+      data->setExample(i);
+      adr[i] = kernel->eval(inputs, data->inputs);
+    }
+  }
+
+  for(int i = 0; i < n_examples; i++)
+    adr[i+n_examples] = adr[i];
+
+  data->popExample();
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/SVMCache.h work/main.d/Torch-3/kernels/SVMCache.h
--- tmp/Torch-3/kernels/SVMCache.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/SVMCache.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,135 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SVM_CACHE_INC
+#define SVM_CACHE_INC
+
+#include "QCCache.h"
+#include "Kernel.h"
+#include "SVMClassification.h"
+#include "SVMRegression.h"
+
+namespace Torch {
+
+struct SVMCacheList
+{
+    real *adr;
+    int index;
+    SVMCacheList *prev;
+    SVMCacheList *next;
+};
+
+/** #QCCache# implementation for SVMs.
+    Compute the Q matrix.
+
+    @see SVM
+    @see QCMachine
+    @see QCTrainer
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class SVMCache : public QCCache
+{
+  public:
+    int n_alpha;
+    int n_cache_entries;
+    real cache_size_in_megs;
+    real *memory_cache;
+    
+    SVMCacheList *cached;
+    SVMCacheList **list_index;
+
+    Kernel *kernel;
+
+    int n_active_var;
+    int *active_var;
+
+    Allocator *temp_allocator;
+
+    //-----
+
+    ///
+    SVMCache(int n_alpha_, Kernel *kernel_, real cache_size_in_megs_);
+
+    //-----
+
+    void allocate();
+    virtual void clear();
+    virtual void destroy();
+    virtual void setActiveVariables(int *active_var_, int n_active_var_);
+
+    //-----
+
+    virtual real *adressCache(int index);  
+    virtual void getColumn(int index, real *adr) = 0;    
+    virtual ~SVMCache();
+};
+
+/** Cache for SVM classification.
+
+    @author Ronan Collobert (collober@idiap.ch)
+ */
+class SVMCacheClassification : public SVMCache
+{
+  public:
+    DataSet *data;
+    real *y;
+
+    //-----
+
+    ///
+    SVMCacheClassification(DataSet *data_, Kernel *kernel_, real cache_size_in_megs_);
+
+    //-----
+
+    virtual void getColumn(int index, real *adr);
+};
+
+/** Cache for SVM regression.
+
+    @author Ronan Collobert (collober@idiap.ch)
+ */
+class SVMCacheRegression : public SVMCache
+{
+  public:
+    DataSet *data;
+    int n_examples;
+
+    //-----
+
+    ///
+    SVMCacheRegression(DataSet *data_, Kernel *kernel_, real cache_size_in_megs_);
+
+    //-----
+
+    virtual void getColumn(int index, real *adr);
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/SVM.cc work/main.d/Torch-3/kernels/SVM.cc
--- tmp/Torch-3/kernels/SVM.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/SVM.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,127 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "SVM.h"
+#include "XFile.h"
+
+namespace Torch {
+
+SVM::SVM(Kernel *kernel_, IOSequenceArray *io_sequence_array_)
+{
+  data = NULL;
+  kernel = kernel_;
+
+  support_vectors = NULL;
+  n_support_vectors = 0;
+  n_support_vectors_bound = 0;
+  sv_alpha = NULL;
+  sv_sequences = NULL;
+  sv_allocator = new Allocator;
+
+  outputs = new(allocator) Sequence(1, 1);
+
+  if(io_sequence_array_)
+    io_sequence_array = io_sequence_array_;
+  else
+    io_sequence_array = new(allocator) IOSequenceArray;
+}
+
+void SVM::forward(Sequence *inputs)
+{
+  real sum = 0;
+  for(int t = 0; t < n_support_vectors; t++)
+    sum += sv_alpha[t]*kernel->eval(sv_sequences[t], inputs);
+
+  sum += b;
+
+  outputs->frames[0][0] = sum;
+}
+
+bool SVM::bCompute()
+{
+  real sum = 0;
+  int n_ = 0;
+  for(int it = 0; it < n_support_vectors; it++)
+  {
+    int t = support_vectors[it];
+    if( (alpha[t] > Cdown[t]+bound_eps) && (alpha[t] < Cup[t]-bound_eps) )
+    {
+      sum += y[t]*grad[t];
+      n_++;
+    }
+  }
+  
+  if(n_)
+  {
+    b = -sum/(real)n_;
+    return(true);
+  }
+  else
+    return(false);
+}
+
+void SVM::loadXFile(XFile *file)
+{
+  file->taggedRead(&b, sizeof(real), 1, "b");
+  file->taggedRead(&n_support_vectors, sizeof(int), 1, "NSV");
+  file->taggedRead(&n_support_vectors_bound, sizeof(int), 1, "NSVB");
+
+  sv_allocator->freeAll();
+  if(n_support_vectors > 0)
+  {
+    sv_alpha = (real *)sv_allocator->alloc(sizeof(real)*n_support_vectors);
+    file->taggedRead(sv_alpha, sizeof(real), n_support_vectors, "SVALPHA");
+    
+    sv_sequences = (Sequence **)sv_allocator->alloc(sizeof(Sequence *)*n_support_vectors);
+    io_sequence_array->read(file, sv_sequences, n_support_vectors, sv_allocator);
+  }
+  else
+  {
+    sv_alpha = NULL;
+    sv_sequences = NULL;
+  }
+}
+
+void SVM::saveXFile(XFile *file)
+{
+  file->taggedWrite(&b, sizeof(real), 1, "b");
+  file->taggedWrite(&n_support_vectors, sizeof(int), 1, "NSV");
+  file->taggedWrite(&n_support_vectors_bound, sizeof(int), 1, "NSVB");
+  if(n_support_vectors > 0)
+  {
+    file->taggedWrite(sv_alpha, sizeof(real), n_support_vectors, "SVALPHA");
+    io_sequence_array->write(file, sv_sequences, n_support_vectors);
+  }
+}
+
+SVM::~SVM()
+{
+  delete sv_allocator;
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/SVMClassification.cc work/main.d/Torch-3/kernels/SVMClassification.cc
--- tmp/Torch-3/kernels/SVMClassification.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/SVMClassification.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,147 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "SVMClassification.h"
+#include "SVMCache.h"
+
+namespace Torch {
+
+SVMClassification::SVMClassification(Kernel *kernel_, real *C_, IOSequenceArray *io_sequence_array_) : SVM(kernel_, io_sequence_array_)
+{
+  Cuser = C_;
+  addROption("C", &C_cst, 100, "trade off margin/classification error");
+  addROption("cache size", &cache_size_in_megs, 50., "cache size (in Mo)");
+
+  sequences_buffer = NULL;
+  frames_buffer = NULL;
+}
+
+void SVMClassification::setDataSet(DataSet *dataset_)
+{
+  data = dataset_;
+  QCMachine::reInit(data->n_examples);
+
+  for(int i = 0; i < n_alpha; i++)
+    Cdown[i] = 0;
+
+  if(Cuser)
+  {
+    for(int i = 0; i < n_alpha; i++)
+      Cup[i] = Cuser[data->selected_examples[i]];
+  }
+  else
+  {
+    for(int i = 0; i < n_alpha; i++)
+      Cup[i] = C_cst;
+  }
+
+  for(int i = 0; i < n_alpha; i++)
+    alpha[i] = 0;
+
+  b = 0;
+
+  data->pushExample();
+  for(int i = 0; i < n_alpha; i++)
+  {
+    data->setExample(i);
+    y[i] = data->targets->frames[0][0];
+    grad[i] = -1;
+  }
+  data->popExample();
+
+  if(cache)
+    allocator->free(cache);
+
+  cache = new(allocator) SVMCacheClassification(data, kernel, cache_size_in_megs);
+
+  n_support_vectors = 0;
+  n_support_vectors_bound = 0;
+}
+
+void SVMClassification::checkSupportVectors()
+{
+  // Get the number of support vectors, and the size need to duplicate them...
+  n_support_vectors = 0;
+  n_support_vectors_bound = 0;
+  int frame_buffer_size = 0;
+  for(int i = 0; i < n_alpha; i++)
+  {
+    if(alpha[i] > bound_eps)
+    {
+      if(alpha[i] > Cup[i] - bound_eps)
+        n_support_vectors_bound++;
+      
+      n_support_vectors++;
+
+      data->setExample(i);
+      frame_buffer_size += data->inputs->getFramesSpace();
+    }
+  }
+
+  // Allocate all the stuff
+  sv_allocator->freeAll();
+  support_vectors = (int *)sv_allocator->alloc(sizeof(int)*n_support_vectors);
+  sv_alpha = (real *)sv_allocator->alloc(sizeof(real)*n_support_vectors);
+  sv_sequences = (Sequence **)sv_allocator->alloc(sizeof(Sequence *)*n_support_vectors);
+
+  data->setExample(0);
+  int sequence_size = data->inputs->getSequenceSpace();
+  sequences_buffer = (char *)sv_allocator->alloc(sequence_size*n_support_vectors);
+  frames_buffer = (char *)sv_allocator->alloc(frame_buffer_size);
+
+  // Duplicate support vectors, and save their index...
+  n_support_vectors = 0;
+  char *frames_buffer_ = frames_buffer;
+  char *sequences_buffer_ = sequences_buffer;
+  for(int i = 0; i < n_alpha; i++)
+  {
+    if(alpha[i] > bound_eps)
+    {
+      support_vectors[n_support_vectors  ] = i;
+      sv_alpha[n_support_vectors] = y[i]*alpha[i];
+      data->setExample(i);
+      sv_sequences[n_support_vectors] = data->inputs->clone(sv_allocator, sequences_buffer_, frames_buffer_);
+      frames_buffer_ += data->inputs->getFramesSpace();
+      sequences_buffer_ += sequence_size;
+      n_support_vectors++;
+    }
+  }
+
+  // Compute the "b" variable...
+  if(!bCompute())
+  {
+    warning("SVMClassification: b is not unique. It's probably wrong");
+    warning("SVMClassification: I think you are using silly parameters");
+  }
+}
+
+SVMClassification::~SVMClassification()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/SVMClassification.h work/main.d/Torch-3/kernels/SVMClassification.h
--- tmp/Torch-3/kernels/SVMClassification.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/SVMClassification.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,86 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SVM_CLASSIFICATION_INC
+#define SVM_CLASSIFICATION_INC
+
+#include "SVM.h"
+
+namespace Torch {
+
+
+/** SVM in classification.
+
+    Try to find the hyperplane $w.x+b = 0$
+    as
+    $(w,b)$ minimize $0.5*||w||^2 + \sum_j C_j |1- y_j*(w.x_j+b)|_+$
+
+    (where $|x|_+ = x$ if $x > 0$, else $0$)
+
+    (in fact, we use a #kernel# instead of a dot product)
+
+    The $C_j$ coefficients are given in #C_# when you
+    call the constructor. If this one is NULL, then
+    the value given by the "C" option is used for
+    all $C_j$.
+    (The size of #C_# \emph{must be} #data->n_real_examples#)
+
+    Options:
+    \begin{tabular}{lcll}
+      "C"          &  real &  trade off between the weight decay and the error & [100] \\
+      "cache size" & real  &  cache size (in Mo)                               & [50]
+    \end{tabular}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class SVMClassification : public SVM
+{
+  private:
+    char *sequences_buffer;
+    char *frames_buffer;
+
+  public:
+    real cache_size_in_megs;
+    real *Cuser;
+    real C_cst;
+
+    //-----
+
+    ///
+    SVMClassification(Kernel *kernel_, real *C_=NULL, IOSequenceArray *io_sequence_array_=NULL);
+
+    //-----
+
+    virtual void setDataSet(DataSet *dataset_);
+    virtual void checkSupportVectors();
+    virtual ~SVMClassification();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/SVM.h work/main.d/Torch-3/kernels/SVM.h
--- tmp/Torch-3/kernels/SVM.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/SVM.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,106 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SVM_INC
+#define SVM_INC
+
+#include "QCMachine.h"
+#include "Kernel.h"
+#include "DataSet.h"
+#include "IOSequenceArray.h"
+
+namespace Torch {
+
+/** Support Vector Machine.
+    
+    The Q matrix of #QCMachine# is in this case
+    $q_{ij} = k(x_i, x_j)$, where $k$ is a kernel
+    and $x_i$ is the i-th example of #data#/
+    
+    The goal is to looking for the #alpha# and #b#
+    which are the best in a SVM-sense.
+
+    The learning function is
+    $f(x) = \sum_j y_j alpha_j k(x_i, x) + b$
+    
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class SVM : public QCMachine
+{
+  public:
+    /// To allocate all stuff related to support vectors.
+    Allocator *sv_allocator;
+
+    /// Give the sequence-format.
+    IOSequenceArray *io_sequence_array;
+
+    /** The dataset associated to the SVM.
+    */
+    DataSet *data;
+
+    /// The kernel associated to the SVM.
+    Kernel *kernel;
+
+    ///
+    real b;
+
+    /// The support vectors
+    int *support_vectors;
+
+    /// sv_alpha[i] is the weight of the SV i.
+    real *sv_alpha;
+
+    /// SV sequences.
+    Sequence **sv_sequences;
+
+    /// The number of support vectors
+    int n_support_vectors;
+
+    /// The number of support vectors which are at the bound "C"
+    int n_support_vectors_bound;
+
+    //-----
+    
+    ///
+    SVM(Kernel *kernel_, IOSequenceArray *io_sequence_array_=NULL);
+
+    /// Computes the #b#.
+    bool bCompute();
+
+    //-----
+
+    virtual void forward(Sequence *inputs);
+    virtual void loadXFile(XFile *file);
+    virtual void saveXFile(XFile *file);
+
+    virtual ~SVM();    
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/SVMRegression.cc work/main.d/Torch-3/kernels/SVMRegression.cc
--- tmp/Torch-3/kernels/SVMRegression.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/SVMRegression.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,194 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "SVMRegression.h"
+#include "SVMCache.h"
+
+namespace Torch {
+
+SVMRegression::SVMRegression(Kernel *kernel_, real *C_, IOSequenceArray *io_sequence_array_) : SVM(kernel_, io_sequence_array_)
+{
+  Cuser = C_;
+  addROption("eps regression", &eps_regression, 0.7, "size of the error tube");
+  addROption("C", &C_cst, 100, "trade off margin/classification error");
+  addROption("cache size", &cache_size_in_megs, 50., "cache size (in Mo)");
+
+  sequences_buffer = NULL;
+  frames_buffer = NULL;
+}
+
+void SVMRegression::setDataSet(DataSet *dataset_)
+{
+  data = dataset_;
+  QCMachine::reInit(2*data->n_examples);
+
+  for(int i = 0; i < n_alpha; i++)
+    alpha[i] = 0;
+
+  b = 0;
+
+  int n_examples_ = data->n_examples;
+  if(Cuser)
+  {
+    for(int i = 0; i < n_examples_; i++)
+    {
+      Cup[i] = 0;
+      Cdown[i] = -Cuser[data->selected_examples[i]];
+    }
+
+    for(int i = n_examples_; i < n_alpha; i++)
+    {
+      Cup[i] = Cuser[data->selected_examples[i-n_examples_]+n_examples_];
+      Cdown[i] = 0;
+    }
+  }
+  else
+  {
+    for(int i = 0; i < n_examples_; i++)
+    {
+      Cup[i] = 0;
+      Cdown[i] = -C_cst;
+    }
+
+    for(int i = n_examples_; i < n_alpha; i++)
+    {
+      Cup[i] = C_cst;
+      Cdown[i] = 0;
+    }
+  }
+
+  data->pushExample();
+  for(int i = 0; i < n_examples_; i++)
+  {
+    data->setExample(i);
+    real z = data->targets->frames[0][0];
+    
+    grad[i] =  -z - eps_regression;
+    y[i] =  1;
+    
+    grad[i+n_examples_] = -z + eps_regression;
+    y[i+n_examples_] = 1;
+  }
+  data->popExample();
+
+  if(cache)
+    allocator->free(cache);
+  cache = new(allocator) SVMCacheRegression(data, kernel, cache_size_in_megs);
+
+  n_support_vectors = 0; 
+  n_support_vectors_bound = 0; 
+}
+
+void SVMRegression::checkSupportVectors()
+{
+  // Get the number of support vectors, and the size need to duplicate them...
+  n_support_vectors = 0;
+  n_support_vectors_bound = 0;
+  int frame_buffer_size = 0;
+  for(int i = 0; i < data->n_examples; i++)
+  {
+    if(alpha[i] < -bound_eps)
+    {
+      if(alpha[i] < Cdown[i] + bound_eps)
+        n_support_vectors_bound++;
+      
+      n_support_vectors++;
+
+      data->setExample(i);
+      frame_buffer_size += data->inputs->getFramesSpace();
+    }
+  }
+  for(int i = data->n_examples; i < 2*data->n_examples; i++)
+  {
+    if(alpha[i] > bound_eps)
+    {
+      if(alpha[i] > Cup[i] - bound_eps)
+        n_support_vectors_bound++;
+      
+      n_support_vectors++;
+
+      data->setExample(i-data->n_examples);
+      frame_buffer_size += data->inputs->getFramesSpace();
+    }
+  }
+
+  // Allocate all the stuff
+  sv_allocator->freeAll();
+  support_vectors = (int *)sv_allocator->alloc(sizeof(int)*n_support_vectors);
+  sv_alpha = (real *)sv_allocator->alloc(sizeof(real)*n_support_vectors);
+  sv_sequences = (Sequence **)sv_allocator->alloc(sizeof(Sequence *)*n_support_vectors);
+
+  data->setExample(0);
+  int sequence_size = data->inputs->getSequenceSpace();
+  sequences_buffer = (char *)sv_allocator->alloc(sequence_size*n_support_vectors);
+  frames_buffer = (char *)sv_allocator->alloc(frame_buffer_size);
+
+  // Duplicate support vectors, and save their index...
+  n_support_vectors = 0;
+  char *frames_buffer_ = frames_buffer;
+  char *sequences_buffer_ = sequences_buffer;
+  for(int i = 0; i < data->n_examples; i++)
+  {
+    if(alpha[i] < -bound_eps)
+    {
+      support_vectors[n_support_vectors  ] = i;
+      sv_alpha[n_support_vectors] = y[i]*alpha[i];
+      data->setExample(i);
+      sv_sequences[n_support_vectors] = data->inputs->clone(sv_allocator, sequences_buffer_, frames_buffer_);
+      frames_buffer_ += data->inputs->getFramesSpace();
+      sequences_buffer_ += sequence_size;
+      n_support_vectors++;
+    }
+  }
+  for(int i = data->n_examples; i < 2*data->n_examples; i++)
+  {
+    if(alpha[i] > bound_eps)
+    {
+      support_vectors[n_support_vectors  ] = i;
+      sv_alpha[n_support_vectors] = y[i]*alpha[i];
+      data->setExample(i-data->n_examples);
+      sv_sequences[n_support_vectors] = data->inputs->clone(sv_allocator, sequences_buffer_, frames_buffer_);
+      frames_buffer_ += data->inputs->getFramesSpace();
+      sequences_buffer_ += sequence_size;
+      n_support_vectors++;
+    }
+  }
+
+  // Compute the "b" variable...
+  if(!bCompute())
+  {
+    warning("SVMRegression: b is not unique. It's probably wrong");
+    warning("SVMRegression: I think you are using silly parameters");
+  }
+}
+
+SVMRegression::~SVMRegression()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/kernels/SVMRegression.h work/main.d/Torch-3/kernels/SVMRegression.h
--- tmp/Torch-3/kernels/SVMRegression.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/kernels/SVMRegression.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,93 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SVM_REGRESSION_INC
+#define SVM_REGRESSION_INC
+
+#include "SVM.h"
+
+namespace Torch {
+
+/** SVM in regression.
+
+    Try to find the hyperplane f(x) = w.x+b
+    as
+    $(w,b)$ minimize $0.5*||w||^2 + \sum_j C_j |w.x_j+b -y_j -eps|_+$
+                             $+ \sum_j C_(j+n) |y_j -w.x_j-b -eps|_+$
+    
+    (where $|x|_+ = x$ if $x > 0$, else $0$)
+    (and $n$ is the number of training examples)
+    (the size of $C$ is here 2*$n$)
+
+    ("eps" is #eps_regression# in the code)
+
+    (in fact, we use a kernel #kernel# instead of
+    a dot product)
+
+    The $C_j$ coefficients are given by #C_# when you
+    call the constructor. If this one is NULL, all
+    #C_j# will have the value given by the "C" option.
+    (The size of #C_# \emph{must be} #2*data->n_real_examples#)
+
+    Options:
+    \begin{tabular}{lcll}
+      "C"               &  real  & trade off between the weight decay and the error & [100] \\
+      "eps regression"  &  real  & size of the error tube                           & [0.7] \\
+      "cache size"      & real   &  cache size (in Mo)                              & [50]
+    \end{tabular}
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class SVMRegression : public SVM
+{
+  private:
+    char *sequences_buffer;
+    char *frames_buffer;
+
+  public:
+    real cache_size_in_megs;
+    real eps_regression;
+    real *Cuser;
+    real C_cst;
+
+    //-----
+
+    ///
+    SVMRegression(Kernel *kernel_, real *C_=NULL, IOSequenceArray *io_sequence_array_=NULL);
+
+    //-----
+
+    virtual void setDataSet(DataSet *dataset_);
+    virtual void checkSupportVectors();
+
+    virtual ~SVMRegression();    
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/LICENSE work/main.d/Torch-3/LICENSE
--- tmp/Torch-3/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/LICENSE	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,28 @@
+
+Copyright (c) 2003--2004 Ronan Collobert
+Copyright (c) 2003--2004 Samy Bengio
+Copyright (c) 2003--2004 Johnny Mariéthoz
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --speed-large-files --minimal -Nru tmp/Torch-3/Makefile work/main.d/Torch-3/Makefile
--- tmp/Torch-3/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/Makefile	2008-02-07 11:35:14.000000000 -0200
@@ -0,0 +1,36 @@
+OS := $(shell uname -s)
+TORCHDIR := $(shell pwd)
+include Makefile_options_$(OS)
+
+SUBDIRS := core
+SUBDIRS += $(PACKAGES)
+
+all: depend
+	@echo ">>> Try to compile Torch <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@) || exit 10 ; done
+	@echo ">> !!! Ok !!! <<<"
+
+clean:
+	@echo ">>> Atomise all <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@ ) || exit 10 ; done
+	@\rm -Rf $(LIBTORCHXX)
+	@\rm -Rf $(OBJS_DIR)
+	@\rm -Rf $(LIBS_DIR)
+	@echo ">> !!! Ok !!! <<<"
+
+distclean:
+	@echo ">>> Thermonuclearise all <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@ ) || exit 10 ; done
+	@\rm -Rf lib
+	@\rm -Rf objs
+	@echo ">> !!! Ok !!! <<<"
+
+depend:
+	@echo ">>> Dependencies <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@ ) || exit 10 ; done
+	@\mkdir -p $(OBJS_DIR)
+	@\mkdir -p $(LIBS_DIR)
+	@echo ">> !!! Ok !!! <<<"
+
+Makefile_options_$(OS):
+	@echo "**** PLEASE CHECK YOUR MAKEFILE_OPTIONS for >>" $(OS) "<< ****"
diff --speed-large-files --minimal -Nru tmp/Torch-3/Makefile~ work/main.d/Torch-3/Makefile~
--- tmp/Torch-3/Makefile~	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/Makefile~	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,36 @@
+OS := $(shell uname -s)
+TORCHDIR := $(shell pwd)
+include Makefile_options_$(OS)
+
+SUBDIRS := core
+SUBDIRS += $(PACKAGES)
+
+all:
+	@echo ">>> Try to compile Torch <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@) || exit 10 ; done
+	@echo ">> !!! Ok !!! <<<"
+
+clean:
+	@echo ">>> Atomise all <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@ ) || exit 10 ; done
+	@\rm -Rf $(LIBTORCHXX)
+	@\rm -Rf $(OBJS_DIR)
+	@\rm -Rf $(LIBS_DIR)
+	@echo ">> !!! Ok !!! <<<"
+
+distclean:
+	@echo ">>> Thermonuclearise all <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@ ) || exit 10 ; done
+	@\rm -Rf lib
+	@\rm -Rf objs
+	@echo ">> !!! Ok !!! <<<"
+
+depend:
+	@echo ">>> Dependencies <<<"
+	@for subdir in ${SUBDIRS} ; do ( cd $$subdir ; ${MAKE} $@ ) || exit 10 ; done
+	@\mkdir -p $(OBJS_DIR)
+	@\mkdir -p $(LIBS_DIR)
+	@echo ">> !!! Ok !!! <<<"
+
+Makefile_options_$(OS):
+	@echo "**** PLEASE CHECK YOUR MAKEFILE_OPTIONS for >>" $(OS) "<< ****"
diff --speed-large-files --minimal -Nru tmp/Torch-3/Makefile_options_Linux work/main.d/Torch-3/Makefile_options_Linux
--- tmp/Torch-3/Makefile_options_Linux	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/Makefile_options_Linux	2008-02-07 11:35:35.000000000 -0200
@@ -0,0 +1,64 @@
+#
+# What you have to check...
+#
+
+# Packages you want to use
+PACKAGES = 
+
+# Magik key if you have several makefile
+# for the same platform
+MAGIK_KEY = 
+
+# Compiler, linker and archiver
+#CC = g++
+#LD = g++
+AR := $(AR) -rus
+
+# Command for creating dependencies
+DEP = $(CC) -MM
+
+# Your librairies
+# (for example "-lm", but not needed on most systems...)
+MYLIBS = 
+
+# Your includes
+# (for example -I/usr/local/special)
+MYINCS = 
+
+# optimize mode
+DEBUG = OPT
+# debug mode
+#DEBUG = DBG
+
+# double version
+#FLOATING = DOUBLE
+# floating version
+FLOATING = FLOAT
+
+# Debug double mode
+CFLAGS_DBG_DOUBLE = -g -Wall -DUSE_DOUBLE -DDEBUG
+
+# Debug float mode
+CFLAGS_DBG_FLOAT = -g -Wall -DDEBUG
+
+# Optimized double mode
+CFLAGS_OPT_DOUBLE = -Wall -O2 -ffast-math -mcpu=i686 -march=i686 -malign-double -DUSE_DOUBLE
+
+# Optimized float mode
+CFLAGS_OPT_FLOAT = $(CFLAGS)
+
+#
+#
+# Variables that you may find useful inside your Makefile
+# Do not touch.
+#
+#
+
+MODE = $(DEBUG)_$(FLOATING)
+VERSION_KEY = $(MAGIK_KEY)$(OS)_$(MODE)
+LIBS_DIR = $(TORCHDIR)/lib/$(VERSION_KEY)
+OBJS_DIR = $(TORCHDIR)/objs/$(VERSION_KEY)
+LIBTORCH = $(LIBS_DIR)/libtorch.a
+LIBS = -L$(TORCHDIR)/lib/$(VERSION_KEY) -ltorch $(MYLIBS)
+INCS := -I$(TORCHDIR)/core $(MYINCS)
+INCS += $(foreach f,$(PACKAGES),-I$(TORCHDIR)/$(f))
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/LICENSE work/main.d/Torch-3/matrix/LICENSE
--- tmp/Torch-3/matrix/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/LICENSE	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,28 @@
+
+Copyright (c) 2003--2004 Ronan Collobert
+Copyright (c) 2003--2004 Samy Bengio
+Copyright (c) 2003--2004 Johnny Mariéthoz
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/Makefile work/main.d/Torch-3/matrix/Makefile
--- tmp/Torch-3/matrix/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/Makefile	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,42 @@
+# get user and architecture specific options
+OS := $(shell uname -s)
+TORCHDIR := $(shell cd ..; pwd)
+include ../Makefile_options_$(OS)
+
+CC_FILES := $(wildcard *.cc)
+OBJS := $(foreach f,$(CC_FILES),$(OBJS_DIR)/$(patsubst %.cc,%.o,$(f)))
+
+all:	$(LIBTORCH)
+
+$(LIBTORCH): $(OBJS)
+	@echo "Archiving..."
+	@$(AR) $(LIBTORCH) $(OBJS)
+
+$(OBJS_DIR)/%.o: %.cc
+	@echo $<
+	@$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $@ -c $<
+
+distclean:
+	@\rm -f .deps_*
+
+clean:
+	@echo "Remove objects file and dependencies..."
+	@\rm -Rf $(OBJS) $(LIBTORCH)
+	@\rm -f .deps_$(VERSION_KEY)
+
+depend:
+	@echo "Tracking dependencies..."
+	@\rm -f .deps_$(VERSION_KEY)
+	@for file in *.cc ; do printf "$(OBJS_DIR)/" >> .deps_$(VERSION_KEY); $(DEP) $(CFLAGS_$(MODE)) $(INCS) $$file >> .deps_$(VERSION_KEY); done
+
+.deps_$(VERSION_KEY):
+	@echo ">>> Please do a 'make depend' <<<"
+	exit 10
+
+ifneq ($(MAKECMDGOALS),distclean)
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),depend)
+include .deps_$(VERSION_KEY)
+endif
+endif
+endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/Mat.cc work/main.d/Torch-3/matrix/Mat.cc
--- tmp/Torch-3/matrix/Mat.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/Mat.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,190 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Mat.h"
+
+namespace Torch {
+
+Mat::Mat(real ** ptr_, int n_rows, int n_cols)
+{
+  ptr = ptr_;
+  m = n_rows;
+  n = n_cols;
+  base = NULL;
+}
+
+Mat::Mat(real * ptr_, int n_rows, int n_cols)
+{
+  m = n_rows;
+  n = n_cols;
+  base = NULL;
+  ptr = (real **)allocator->alloc(sizeof(real *) * m);
+  for (int i = 0; i < m; i++)
+    ptr[i] = ptr_ + i * n;
+}
+
+Mat::Mat(int n_rows, int n_cols)
+{
+  m = n_rows;
+  n = n_cols;
+  base = (real *)allocator->alloc(sizeof(real) * m * n);
+  ptr = (real **)allocator->alloc(sizeof(real *) * m);
+  for (int i = 0; i < m; i++)
+    ptr[i] = base + i * n;
+}
+
+void Mat::copy(Mat * mat)
+{
+  if (mat == this)
+    return;
+
+  for (int i = 0; i < m; i++)
+  {
+    real *ptr_r = mat->ptr[i];
+    real *ptr_w = ptr[i];
+    for (int j = 0; j < n; j++)
+      *ptr_w++ = *ptr_r++;
+  }
+}
+
+void Mat::zero()
+{
+  for (int i = 0; i < m; i++)
+  {
+    real *ptr_w = ptr[i];
+    for (int j = 0; j < n; j++)
+      *ptr_w++ = 0.;
+  }
+}
+
+real Mat::norm1()
+{
+  real max_val = 0.;
+  for (int j = 0; j < n; j++)
+  {
+    real sum = 0.0;
+    for (int i = 0; i < m; i++)
+      sum += fabs(ptr[i][j]);
+
+    if (max_val < sum)
+      max_val = sum;
+  }
+
+  return max_val;
+}
+
+real Mat::normFrobenius()
+{
+  real sum = 0.;
+  for (int i = 0; i < m; i++)
+  {
+    real *ptr_x = ptr[i];
+    for (int j = 0; j < n; j++)
+    {
+      real z = *ptr_x++;
+      sum += z * z;
+    }
+  }
+
+  return sqrt(sum);
+}
+
+real Mat::normInf()
+{
+  real max_val = 0.;
+  for (int i = 0; i < m; i++)
+  {
+    real sum = 0.0;
+    real *ptr_x = ptr[i];
+    for (int j = 0; j < n; j++)
+      sum += fabs(*ptr_x++);
+
+    if (max_val < sum)
+      max_val = sum;
+  }
+
+  return max_val;
+}
+
+Vec *Mat::getRow(int row, Vec * vec)
+{
+  if (!vec)
+    vec = new Vec(n);
+
+  real *ptr_w = vec->ptr;
+  real *ptr_r = ptr[row];
+  for (int i = 0; i < n; i++)
+    *ptr_w++ = *ptr_r++;
+
+  return (vec);
+}
+
+Vec *Mat::getCol(int col, Vec * vec)
+{
+  if (!vec)
+    vec = new Vec(m);
+
+  real *ptr_w = vec->ptr;
+  for (int i = 0; i < m; i++)
+    *ptr_w++ = ptr[i][col];
+
+  return (vec);
+}
+
+void Mat::setRow(int row, Vec * vec)
+{
+  real *ptr_w = ptr[row];
+  real *ptr_r = vec->ptr;
+  for (int i = 0; i < n; i++)
+    *ptr_w++ = *ptr_r++;
+}
+
+void Mat::setCol(int col, Vec * vec)
+{
+  real *ptr_r = vec->ptr;
+  for (int i = 0; i < m; i++)
+    ptr[i][col] = *ptr_r++;
+}
+
+Mat *Mat::subMat(int row1, int col1, int row2, int col2)
+{
+  real **ptr_ = (real **)Allocator::sysAlloc(sizeof(real *) * (row2 - row1 + 1));
+  for (int i = row1; i <= row2; i++)
+    ptr_[i - row1] = &ptr[i][col1];
+
+  Mat *mat = new Mat(ptr_, row2 - row1 + 1, col2 - col1 + 1);
+  mat->allocator->retain(ptr_);
+
+  return (mat);
+}
+
+Mat::~Mat()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/Mat.h work/main.d/Torch-3/matrix/Mat.h
--- tmp/Torch-3/matrix/Mat.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/Mat.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,114 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MAT_INC
+#define MAT_INC
+
+#include "Object.h"
+#include "Vec.h"
+
+namespace Torch {
+
+/** Matrix object.
+
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Mat : public Object
+{
+  public:    
+    /// Size of the matrix
+    int m, n;
+    
+    /// Data of the matrix
+    real **ptr;
+    
+    /** NULL if not allocated by Mat.
+        (when you're using the first constructor of Mat, or for
+        the matrix returned by subMat)
+    */
+    real *base;
+    
+    /** Create a matrix from values in #ptr_#.
+        (No memory copy).
+    */
+    Mat(real ** ptr_, int n_rows, int n_cols);
+
+    /** Create a matrix from values in #ptr_#.
+        (No memory copy).
+    */
+    Mat(real * ptr_, int n_rows, int n_cols);
+    
+    /// Create a new matrix
+    Mat(int n_rows, int n_cols);
+    
+    /// Copy the matrix #mat#
+    void copy(Mat * mat);
+    
+    /// Zero the matrix
+    void zero();
+    
+    /// Compute the norm1
+    real norm1();
+    
+    /// Compute the Frobenius norm
+    real normFrobenius();
+    
+    /// Compute the norm inf
+    real normInf();
+    
+    /** Return the row #row# of the matrix.
+        If #vec# is NULL, return a new vector.
+        Else copy the row in #vec#.
+    */
+    Vec *getRow(int row, Vec * vec = NULL);
+    
+    /** Return the column #col# of the matrix.
+        If #vec# is NULL, return a new vector.
+        Else copy the column in #vec#.
+    */
+    Vec *getCol(int col, Vec * vec = NULL);
+    
+    /// Set the row #row# to values in #vec#
+    void setRow(int row, Vec * vec);
+    
+    /// Set the column #col# to values in #vec#
+    void setCol(int row, Vec * vec);
+    
+    /** Return a sub-matrix.
+        Note that the memory is shared with the original
+        matrix, so *be carefull*.
+        You have to destroy the returned matrix.
+    */
+    Mat *subMat(int row1, int col1, int row2, int col2);
+
+   ~Mat();
+};
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/Mat_operations.cc work/main.d/Torch-3/matrix/Mat_operations.cc
--- tmp/Torch-3/matrix/Mat_operations.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/Mat_operations.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,283 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Mat_operations.h"
+#include "mx_low_level.h"
+
+namespace Torch {
+
+/* m_add -- matrix addition -- may be in-situ */
+void mxMatAddMat(Mat * mat1, Mat * mat2, Mat * out)
+{
+  int m, n;
+
+  m = mat1->m;
+  n = mat1->n;
+  for (int i = 0; i < m; i++)
+    mxAdd__(mat1->ptr[i], mat2->ptr[i], out->ptr[i], n);
+}
+
+/* m_sub -- matrix subtraction -- may be in-situ */
+void mxMatSubMat(Mat * mat1, Mat * mat2, Mat * out)
+{
+  int m, n;
+
+  m = mat1->m;
+  n = mat1->n;
+  for (int i = 0; i < m; i++)
+    mxSub__(mat1->ptr[i], mat2->ptr[i], out->ptr[i], n);
+}
+
+/* m_mlt -- matrix-matrix multiplication */
+void mxMatMulMat(Mat * mat1, Mat * mat2, Mat * out)
+{
+  int m, n, p;
+  real **mat1_v, **mat2_v;
+
+  m = mat1->m;
+  n = mat1->n;
+  p = mat2->n;
+  mat1_v = mat1->ptr;
+  mat2_v = mat2->ptr;
+
+  out->zero();
+  for (int i = 0; i < m; i++)
+  {
+    for (int k = 0; k < n; k++)
+    {
+      if (mat1_v[i][k] != 0.0)
+	mxRealMulAdd__(out->ptr[i], mat2_v[k], mat1_v[i][k], p);
+    }
+  }
+}
+
+/* mmtr_mlt -- matrix-matrix transposed multiplication
+	-- A.B^T is returned, and stored in OUT */
+void mxMatMulTrMat(Mat * mat1, Mat * mat2, Mat * out)
+{
+  int limit = mat1->n;
+  for (int i = 0; i < mat1->m; i++)
+  {
+    for (int j = 0; j < mat2->m; j++)
+      out->ptr[i][j] = mxIp__(mat1->ptr[i], mat2->ptr[j], limit);
+  }
+}
+
+/* mtrm_mlt -- matrix transposed-matrix multiplication
+	-- A^T.B is returned, result stored in OUT */
+void mxTrMatMulMat(Mat * mat1, Mat * mat2, Mat * out)
+{
+  int limit = mat2->n;
+  out->zero();
+  for (int k = 0; k < mat1->m; k++)
+    for (int i = 0; i < mat1->n; i++)
+    {
+      if (mat1->ptr[k][i] != 0.0)
+	mxRealMulAdd__(out->ptr[i], mat2->ptr[k], mat1->ptr[k][i], limit);
+    }
+}
+
+/* mv_mlt -- matrix-vector multiplication 
+		-- Note: b is treated as a column vector */
+void mxMatMulVec(Mat * mat, Vec * b, Vec * out)
+{
+  int m, n;
+  real **mat_v, *b_v;
+
+  m = mat->m;
+  n = mat->n;
+  mat_v = mat->ptr;
+  b_v = b->ptr;
+  for (int i = 0; i < m; i++)
+    out->ptr[i] = mxIp__(mat_v[i], b_v, n);
+}
+
+/* sm_mlt -- scalar-matrix multiply -- may be in-situ */
+void mxRealMulMat(real scalar, Mat * matrix, Mat * out)
+{
+  int m, n;
+
+  m = matrix->m;
+  n = matrix->n;
+  for (int i = 0; i < m; i++)
+    mxRealMul__(matrix->ptr[i], scalar, out->ptr[i], n);
+}
+
+/* vm_mlt -- vector-matrix multiplication 
+		-- Note: b is treated as a row vector */
+void mxVecMulMat(Vec * b, Mat * mat, Vec * out)
+{
+  int m, n;
+
+  m = mat->m;
+  n = mat->n;
+
+  out->zero();
+  for (int j = 0; j < m; j++)
+    if (b->ptr[j] != 0.0)
+      mxRealMulAdd__(out->ptr, mat->ptr[j], b->ptr[j], n);
+}
+
+/* m_transp -- transpose matrix */
+void mxTrMat(Mat * in, Mat * out)
+{
+  if (in != out)
+  {
+    for (int i = 0; i < in->m; i++)
+    {
+      for (int j = 0; j < in->n; j++)
+	out->ptr[j][i] = in->ptr[i][j];
+    }
+  }
+  else
+  {
+    for (int i = 1; i < in->m; i++)
+    {
+      for (int j = 0; j < i; j++)
+      {
+	real tmp = in->ptr[i][j];
+	in->ptr[i][j] = in->ptr[j][i];
+	in->ptr[j][i] = tmp;
+      }
+    }
+  }
+}
+
+/* swap_rows -- swaps rows i and j of matrix A upto column lim */
+// lo and hi -1 if you want to swap all
+void mxSwapRowsMat(Mat * mat, int i, int j, int lo, int hi)
+{
+  if (lo < 0)
+    lo = 0;
+
+  if (hi < 0)
+    hi = mat->n - 1;
+
+  real **mat_ptr = mat->ptr;
+  for (int k = lo; k <= hi; k++)
+  {
+    real tmp = mat_ptr[k][i];
+    mat_ptr[k][i] = mat_ptr[k][j];
+    mat_ptr[k][j] = tmp;
+  }
+}
+
+/* swap_cols -- swap columns i and j of matrix A upto row lim */
+// lo and hi -1 if you want to swap all
+void mxSwapColsMat(Mat * mat, int i, int j, int lo, int hi)
+{
+  if (lo < 0)
+    lo = 0;
+
+  if (hi < 0)
+    hi = mat->m - 1;
+
+  real **mat_ptr = mat->ptr;
+  for (int k = lo; k <= hi; k++)
+  {
+    real tmp = mat_ptr[i][k];
+    mat_ptr[i][k] = mat_ptr[j][k];
+    mat_ptr[j][k] = tmp;
+  }
+}
+
+/* ms_mltadd -- matrix-scalar multiply and add
+	-- may be in situ
+	-- returns out == A1 + s*A2 */
+void mxMatAddRealMulMat(Mat * mat1, Mat * mat2, real s, Mat * out)
+{
+  int m, n;
+
+  if (s == 0.0)
+  {
+    out->copy(mat1);
+    return;
+  }
+
+  if (s == 1.0)
+  {
+    mxMatAddMat(mat1, mat2, out);
+    return;
+  }
+
+  out->copy(mat1);
+  m = mat1->m;
+  n = mat1->n;
+  for (int i = 0; i < m; i++)
+    mxRealMulAdd__(out->ptr[i], mat2->ptr[i], s, n);
+}
+
+/* mv_mltadd -- matrix-vector multiply and add
+	-- may not be in situ
+	-- returns out == v1 + alpha*A*v2 */
+void
+mxVecAddRealMulMatMulVec(Vec * v1, real alpha, Mat * mat, Vec * v2,
+			 Vec * out)
+{
+  int m, n;
+  real *v2_ptr, *out_ptr;
+
+  out->copy(v1);
+  if (alpha == 0.0)
+    return;
+
+  v2_ptr = v2->ptr;
+  out_ptr = out->ptr;
+  m = mat->m;
+  n = mat->n;
+  for (int i = 0; i < m; i++)
+    out_ptr[i] += alpha * mxIp__(mat->ptr[i], v2_ptr, n);
+}
+
+/* vm_mltadd -- vector-matrix multiply and add
+	-- may not be in situ
+	-- returns out' == v1' + alpha * v2'*A */
+void
+mxVecAddRealMulVecMulMat(Vec * v1, real alpha, Vec * v2, Mat * mat,
+			 Vec * out)
+{
+  int m, n;
+  real *out_ptr;
+
+  out->copy(v1);
+
+  out_ptr = out->ptr;
+  m = mat->m;
+  n = mat->n;
+  for (int j = 0; j < m; j++)
+  {
+    real tmp = v2->ptr[j] * alpha;
+    if (tmp != 0.0)
+      mxRealMulAdd__(out_ptr, mat->ptr[j], tmp, n);
+  }
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/Mat_operations.h work/main.d/Torch-3/matrix/Mat_operations.h
--- tmp/Torch-3/matrix/Mat_operations.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/Mat_operations.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,96 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MAT_OPERATIONS_INC
+#define MAT_OPERATIONS_INC
+
+#include "Mat.h"
+#include "Vec.h"
+
+namespace Torch {
+
+/** Collection of matrix operation functions.
+    Based on the "Meschach Library", available at the
+    anonymous ftp site thrain.anu.edu.au in the directory
+    pub/meschach.
+
+    @author David E. Stewart (david.stewart@anu.edu.au)
+    @author Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+//@{
+/// Matrix addition -- may be in-situ
+void mxMatAddMat(Mat * mat1, Mat * mat2, Mat * out);
+/// Matrix subtraction -- may be in-situ
+void mxMatSubMat(Mat * mat1, Mat * mat2, Mat * out);
+/// Matrix-matrix multiplication
+void mxMatMulMat(Mat * mat1, Mat * mat2, Mat * out);
+/** Matrix-matrix transposed multiplication.
+    -- #A.B^T# is stored in out */
+void mxMatMulTrMat(Mat * mat1, Mat * mat2, Mat * out);
+/** Matrix transposed-matrix multiplication.
+    -- #A^T.B# is stored in out */
+void mxTrMatMulMat(Mat * mat1, Mat * mat2, Mat * out);
+/** Matrix-vector multiplication.
+    -- Note: #b# is treated as a column vector */
+void mxMatMulVec(Mat * mat, Vec * b, Vec * out);
+/// Scalar-matrix multiply -- may be in-situ
+void mxRealMulMat(real scalar, Mat * matrix, Mat * out);
+/** Vector-matrix multiplication. 
+    -- Note: #b# is treated as a row vector */
+void mxVecMulMat(Vec * b, Mat * mat, Vec * out);
+/// Transpose matrix
+void mxTrMat(Mat * in, Mat * out);
+/** Swaps rows i and j of matrix A upto column lim.
+    #lo# and #hi# to -1 if you want to swap all */
+void mxSwapRowsMat(Mat * mat, int i, int j, int lo, int hi);
+/** Swap columns i and j of matrix A upto row lim.
+    #lo# and #hi# to -1 if you want to swap all */
+void mxSwapColsMat(Mat * mat, int i, int j, int lo, int hi);
+/** Matrix-scalar multiply and add.
+    -- may be in situ.
+    -- returns out == A1 + s*A2 */
+void mxMatAddRealMulMat(Mat * mat1, Mat * mat2, real s, Mat * out);
+/** Matrix-vector multiply and add.
+    -- may not be in situ
+    -- returns out == v1 + alpha*A*v2 */
+void mxVecAddRealMulMatMulVec(Vec * v1, real alpha, Mat * mat, Vec * v2,
+			      Vec * out);
+/** Vector-matrix multiply and add
+    -- may not be in situ
+    -- returns out' == v1' + alpha * v2'*A */
+void mxVecAddRealMulVecMulMat(Vec * v1, real alpha, Vec * v2, Mat * mat,
+			      Vec * out);
+//@}
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/matrix.h work/main.d/Torch-3/matrix/matrix.h
--- tmp/Torch-3/matrix/matrix.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/matrix.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,55 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MATRIX_INC
+#define MATRIX_INC
+
+/* Includes when you're using the "matrix" package.
+
+   @author Ronan Collobert (collober@idiap.ch)
+*/
+
+#include "Mat.h"
+#include "Mat_operations.h"
+#include "Perm.h"
+#include "Perm_operations.h"
+#include "Vec.h"
+#include "mx_low_level.h"
+#include "mx_lu_factor.h"
+#include "mx_solve.h"
+#include "mx_householder.h"
+#include "mx_hessenberg.h"
+#include "mx_givens.h"
+#include "mx_sym_eig.h"
+
+namespace Torch {
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_givens.cc work/main.d/Torch-3/matrix/mx_givens.cc
--- tmp/Torch-3/matrix/mx_givens.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_givens.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,97 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "mx_givens.h"
+
+namespace Torch {
+
+/*
+		Files for matrix computations
+
+	Givens operations file. Contains routines for calculating and
+	applying givens rotations for/to vectors and also to matrices by
+	row and by column.
+*/
+
+/* givens -- returns c,s parameters for Givens rotation to
+		eliminate y in the vector [ x y ]' */
+void mx_givens(real x, real y, real * c, real * s)
+{
+  real norm = sqrt(x * x + y * y);
+  if (norm == 0.0)
+  {
+    *c = 1.0;
+    *s = 0.0;
+  }				/* identity */
+  else
+  {
+    *c = x / norm;
+    *s = y / norm;
+  }
+}
+
+/* rot_vec -- apply Givens rotation to x's i & k components */
+void mx_rot_vec(Vec * x, int i, int k, real c, real s, Vec * out)
+{
+  out->copy(x);
+
+  real temp = c * out->ptr[i] + s * out->ptr[k];
+  out->ptr[k] = -s * out->ptr[i] + c * out->ptr[k];
+  out->ptr[i] = temp;
+}
+
+/* rot_rows -- premultiply mat by givens rotation described by c,s */
+void mx_rot_rows(Mat * mat, int i, int k, real c, real s, Mat * out)
+{
+  out->copy(mat);
+
+  for (int j = 0; j < mat->n; j++)
+  {
+    real temp = c * out->ptr[i][j] + s * out->ptr[k][j];
+    out->ptr[k][j] = -s * out->ptr[i][j] + c * out->ptr[k][j];
+    out->ptr[i][j] = temp;
+  }
+}
+
+/* rot_cols -- postmultiply mat by givens rotation described by c,s */
+void mx_rot_cols(Mat * mat, int i, int k, real c, real s, Mat * out)
+{
+  out->copy(mat);
+
+  for (int j = 0; j < mat->m; j++)
+  {
+    real temp = c * out->ptr[j][i] + s * out->ptr[j][k];
+    out->ptr[j][k] = -s * out->ptr[j][i] + c * out->ptr[j][k];
+    out->ptr[j][i] = temp;
+  }
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_givens.h work/main.d/Torch-3/matrix/mx_givens.h
--- tmp/Torch-3/matrix/mx_givens.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_givens.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,76 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MX_GIVENS_INC
+#define MX_GIVENS_INC
+
+#include "Vec.h"
+#include "Mat.h"
+
+namespace Torch {
+
+/**
+   Givens matrix operations routines.
+   Routines for calculating and applying Givens rotations for/to
+   vectors and also to matrices by row and by column.
+   
+   Based on the "Meschach Library", available at the
+   anonymous ftp site thrain.anu.edu.au in the directory
+   pub/meschach.
+   
+   @author David E. Stewart (david.stewart@anu.edu.au)
+   @author Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+   @author Ronan Collobert (collober@idiap.ch)
+*/
+//@{
+
+/** Returns #c#, #s# parameters for Givens rotation
+    to eliminate #y# in the vector #[ x y ]'#.
+*/
+void mx_givens(real x, real y, real * c, real * s);
+
+/** Apply Givens rotation to #x#'s #i# and #k# components.
+ */
+void mx_rot_vec(Vec * x, int i, int k, real c, real s, Vec * out);
+
+/** Premultiply #mat# by givens rotation described by #c#,#s#.
+ */
+void mx_rot_rows(Mat * mat, int i, int k, real c, real s, Mat * out);
+
+/** Postmultiply #mat# by givens rotation described by #c#,#s#.
+ */
+void mx_rot_cols(Mat * mat, int i, int k, real c, real s, Mat * out);
+
+//@}
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_hessenberg.cc work/main.d/Torch-3/matrix/mx_hessenberg.cc
--- tmp/Torch-3/matrix/mx_hessenberg.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_hessenberg.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,107 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "mx_hessenberg.h"
+#include "mx_householder.h"
+
+namespace Torch {
+
+/*
+		File containing routines for determining Hessenberg
+	factorisations.
+*/
+
+/* Hfactor -- compute Hessenberg factorisation in compact form.
+	-- factorisation performed in situ
+	-- for details of the compact form see QRfactor.c and matrix2.doc */
+void mxHFactor(Mat * mat, Vec * diag, Vec * beta)
+{
+  int limit = mat->m - 1;
+
+  Vec *tmp = new Vec(mat->m);
+
+  for (int k = 0; k < limit; k++)
+  {
+    mat->getCol(k, tmp);
+    mxHhVec(tmp, k + 1, &beta->ptr[k], tmp, &mat->ptr[k + 1][k]);
+    diag->ptr[k] = tmp->ptr[k + 1];
+    mxHhTrCols(mat, k + 1, k + 1, tmp, beta->ptr[k]);
+    mxHhTrRows(mat, 0, k + 1, tmp, beta->ptr[k]);
+  }
+
+  delete tmp;
+}
+
+/* makeHQ -- construct the Hessenberg orthogonalising matrix Q;
+	-- i.e. Hess M = Q.M.Q'	*/
+void mxMakeHQ(Mat * h_mat, Vec * diag, Vec * beta, Mat * q_out)
+{
+  int limit = h_mat->m - 1;
+//    Qout = m_resize(Qout,H->m,H->m);
+
+  Vec *tmp1 = new Vec(h_mat->m);
+  Vec *tmp2 = new Vec(h_mat->m);
+
+  for (int i = 0; i < h_mat->m; i++)
+  {
+    tmp1->zero();
+    tmp1->ptr[i] = 1.0;
+
+    /* apply H/h transforms in reverse order */
+    for (int j = limit - 1; j >= 0; j--)
+    {
+      h_mat->getCol(j, tmp2);
+      tmp2->ptr[j + 1] = diag->ptr[j];
+      mxHhTrVec(tmp2, beta->ptr[j], j + 1, tmp1, tmp1);
+    }
+
+    /* insert into Qout */
+    q_out->setCol(i, tmp1);
+  }
+  delete tmp1;
+  delete tmp2;
+}
+
+/* makeH -- construct actual Hessenberg matrix */
+void mxMakeH(Mat * h_mat, Mat * h_out)
+{
+//    Hout = m_resize(Hout,H->m,H->m);
+  h_out->copy(h_mat);
+
+  int limit = h_mat->m;
+  for (int i = 1; i < limit; i++)
+  {
+    for (int j = 0; j < i - 1; j++)
+      h_out->ptr[i][j] = 0.0;
+  }
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_hessenberg.h work/main.d/Torch-3/matrix/mx_hessenberg.h
--- tmp/Torch-3/matrix/mx_hessenberg.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_hessenberg.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,72 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MX_HESSENBERG_INC
+#define MX_HESSENBERG_INC
+
+#include "Mat.h"
+#include "Vec.h"
+
+namespace Torch {
+
+/**
+   Routines for determining Hessenberg factorisations.
+   
+   Based on the "Meschach Library", available at the
+   anonymous ftp site thrain.anu.edu.au in the directory
+   pub/meschach.
+   
+   @author David E. Stewart (david.stewart@anu.edu.au)
+   @author Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+   @author Ronan Collobert (collober@idiap.ch)
+*/
+//@{
+
+/** Compute Hessenberg factorisation in compact form.
+   Factorisation performed in situ.
+*/
+void mxHFactor(Mat * mat, Vec * diag, Vec * beta);
+
+
+/** Construct the Hessenberg orthogonalising matrix Q.
+    i.e. Hess M = Q.M.Q'.
+*/
+void mxMakeHQ(Mat * h_mat, Vec * diag, Vec * beta, Mat * q_out);
+
+/** Construct actual Hessenberg matrix.
+ */
+void mxMakeH(Mat * h_mat, Mat * h_out);
+
+//@}
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_householder.cc work/main.d/Torch-3/matrix/mx_householder.cc
--- tmp/Torch-3/matrix/mx_householder.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_householder.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,124 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "mx_householder.h"
+#include "mx_low_level.h"
+
+namespace Torch {
+
+/*
+  Files for matrix computations
+  
+  Householder transformation file. Contains routines for calculating
+  householder transformations, applying them to vectors and matrices
+  by both row & column.
+*/
+
+
+/* hhvec -- calulates Householder vector to eliminate all entries after the
+	i0 entry of the vector vec. It is returned as out. May be in-situ */
+void mxHhVec(Vec * vec, int i0, real * beta, Vec * out, real * newval)
+{
+  out->copy(out, i0);
+  real norm = sqrt(out->iP(out, i0));
+  if (norm <= 0.0)
+  {
+    *beta = 0.0;
+    return;
+  }
+  *beta = 1.0 / (norm * (norm + fabs(out->ptr[i0])));
+  if (out->ptr[i0] > 0.0)
+    *newval = -norm;
+  else
+    *newval = norm;
+  out->ptr[i0] -= *newval;
+}
+
+/* hhtrvec -- apply Householder transformation to vector -- may be in-situ */
+/* hh = Householder vector */
+void mxHhTrVec(Vec * hh, real beta, int i0, Vec * in, Vec * out)
+{
+  real scale = beta * hh->iP(in, i0);
+  out->copy(in);
+  mxRealMulAdd__(&out->ptr[i0], &hh->ptr[i0], -scale, in->n - i0);
+}
+
+/* hhtrrows -- transform a matrix by a Householder vector by rows
+	starting at row i0 from column j0 -- in-situ */
+void mxHhTrRows(Mat * mat, int i0, int j0, Vec * hh, real beta)
+{
+  real ip, scale;
+
+  if (beta == 0.0)
+    return;
+
+  /* for each row ... */
+  for (int i = i0; i < mat->m; i++)
+  {				/* compute inner product */
+    ip = mxIp__(&mat->ptr[i][j0], &hh->ptr[j0], mat->n - j0);
+
+    scale = beta * ip;
+    if (scale == 0.0)
+      continue;
+
+    /* do operation */
+    mxRealMulAdd__(&mat->ptr[i][j0], &hh->ptr[j0], -scale, mat->n - j0);
+  }
+}
+
+
+/* hhtrcols -- transform a matrix by a Householder vector by columns
+	starting at row i0 from column j0 -- in-situ */
+void mxHhTrCols(Mat * mat, int i0, int j0, Vec * hh, real beta)
+{
+  if (beta == 0.0)
+    return;
+
+  Vec *w = new Vec(mat->n);
+  w->zero();
+
+  for (int i = i0; i < mat->m; i++)
+  {
+    if (hh->ptr[i] != 0.0)
+      mxRealMulAdd__(&w->ptr[j0], &mat->ptr[i][j0], hh->ptr[i],
+		     mat->n - j0);
+  }
+  for (int i = i0; i < mat->m; i++)
+  {
+    if (hh->ptr[i] != 0.0)
+      mxRealMulAdd__(&mat->ptr[i][j0], &w->ptr[j0], -beta * hh->ptr[i],
+		     mat->n - j0);
+  }
+
+  delete w;
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_householder.h work/main.d/Torch-3/matrix/mx_householder.h
--- tmp/Torch-3/matrix/mx_householder.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_householder.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,81 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MX_HOUSEHOLDER_INC
+#define MX_HOUSEHOLDER_INC
+
+#include "Mat.h"
+#include "Vec.h"
+
+namespace Torch {
+
+/**
+   Householder transformation routines.
+   Contains routines for calculating householder transformations,
+   applying them to vectors and matrices by both row and column.
+
+   Based on the "Meschach Library", available at the
+   anonymous ftp site thrain.anu.edu.au in the directory
+   pub/meschach.
+   
+   @author David E. Stewart (david.stewart@anu.edu.au)
+   @author Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+   @author Ronan Collobert (collober@idiap.ch)
+*/
+//@{
+
+/** Calulates Householder vector.
+    To eliminate all entries after the i0 entry of the vector vec.
+    It is returned as out. May be in-situ.
+*/
+void mxHhVec(Vec * vec, int i0, real * beta, Vec * out, real * newval);
+
+
+/** Apply Householder transformation to vector. 
+    May be in-situ. (#hh# is the Householder vector).
+*/
+void mxHhTrVec(Vec * hh, real beta, int i0, Vec * in, Vec * out);
+
+/** Transform a matrix by a Householder vector by rows.
+    Start at row i0 from column j0. In-situ.
+*/
+void mxHhTrRows(Mat * mat, int i0, int j0, Vec * hh, real beta);
+
+/* Transform a matrix by a Householder vector by columns.
+   Start at row i0 from column j0. In-situ.
+*/
+void mxHhTrCols(Mat * mat, int i0, int j0, Vec * hh, real beta);
+
+//@}
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_low_level.cc work/main.d/Torch-3/matrix/mx_low_level.cc
--- tmp/Torch-3/matrix/mx_low_level.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_low_level.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,123 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "mx_low_level.h"
+
+namespace Torch {
+
+/* __ip__ -- inner product */
+real mxIp__(real * dp1, real * dp2, int len)
+{
+#ifdef VUNROLL
+  int len4;
+  real sum1, sum2, sum3;
+#endif
+  real sum;
+
+  sum = 0.0;
+#ifdef VUNROLL
+  sum1 = sum2 = sum3 = 0.0;
+
+  len4 = (len >> 2);
+  len = len % 4;
+
+  for (int i = 0; i < len4; i++)
+  {
+    int z = i << 2;
+    sum  += dp1[z] * dp2[z];
+    sum1 += dp1[z + 1] * dp2[z + 1];
+    sum2 += dp1[z + 2] * dp2[z + 2];
+    sum3 += dp1[z + 3] * dp2[z + 3];
+  }
+  sum += sum1 + sum2 + sum3;
+  dp1 += (len4 << 2);
+  dp2 += (len4 << 2);
+#endif
+
+  for (int i = 0; i < len; i++)
+    sum += dp1[i] * dp2[i];
+
+  return sum;
+}
+
+/* __mltadd__ -- scalar multiply and add c.f. v_mltadd() */
+void mxRealMulAdd__(real * dp1, real * dp2, real s, int len)
+{
+#ifdef VUNROLL
+  int len4;
+
+  len4 = len / 4;
+  len = len % 4;
+  for (int i = 0; i < len4; i++)
+  {
+    dp1[4 * i] += s * dp2[4 * i];
+    dp1[4 * i + 1] += s * dp2[4 * i + 1];
+    dp1[4 * i + 2] += s * dp2[4 * i + 2];
+    dp1[4 * i + 3] += s * dp2[4 * i + 3];
+  }
+  dp1 += 4 * len4;
+  dp2 += 4 * len4;
+#endif
+
+  for (int i = 0; i < len; i++)
+    dp1[i] += s * dp2[i];
+}
+
+/* __smlt__ scalar multiply array c.f. sv_mlt() */
+void mxRealMul__(real * dp, real s, real * out, int len)
+{
+  for (int i = 0; i < len; i++)
+    out[i] = s * dp[i];
+}
+
+/* __add__ -- add arrays c.f. v_add() */
+void mxAdd__(real * dp1, real * dp2, real * out, int len)
+{
+  for (int i = 0; i < len; i++)
+    out[i] = dp1[i] + dp2[i];
+}
+
+/* __sub__ -- subtract arrays c.f. v_sub() */
+void mxSub__(real * dp1, real * dp2, real * out, int len)
+{
+  for (int i = 0; i < len; i++)
+    out[i] = dp1[i] - dp2[i];
+}
+
+/* __zero__ -- zeros an array of floating point numbers */
+void mxZero__(real * dp, int len)
+{
+  /* else, need to zero the array entry by entry */
+  for (int i = 0; i < len; i++)
+    dp[i] = 0.0;
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_low_level.h work/main.d/Torch-3/matrix/mx_low_level.h
--- tmp/Torch-3/matrix/mx_low_level.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_low_level.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,65 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MX_LOW_LEVEL_INC
+#define MX_LOW_LEVEL_INC
+
+#include "general.h"
+
+namespace Torch {
+#define VUNROLL
+
+/*  Collection of low level functions.
+    Based on the "Meschach Library", available at the
+    anonymous ftp site thrain.anu.edu.au in the directory
+    pub/meschach.
+
+    @author David E. Stewart (david.stewart@anu.edu.au)
+    @author Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+
+// Inner product
+real mxIp__(real * dp1, real * dp2, int len);
+// Scalar multiply and add c.f. v_mltadd()
+void mxRealMulAdd__(real * dp1, real * dp2, real s, int len);
+// Scalar multiply array c.f. sv_mlt()
+void mxRealMul__(real * dp, real s, real * out, int len);
+// Add arrays c.f. v_add()
+void mxAdd__(real * dp1, real * dp2, real * out, int len);
+// Subtract arrays c.f. v_sub()
+void mxSub__(real * dp1, real * dp2, real * out, int len);
+// Zeros an array of floating point numbers
+void mxZero__(real * dp, int len);
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_lu_factor.cc work/main.d/Torch-3/matrix/mx_lu_factor.cc
--- tmp/Torch-3/matrix/mx_lu_factor.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_lu_factor.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,287 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Perm_operations.h"
+#include "mx_lu_factor.h"
+#include "mx_low_level.h"
+#include "mx_solve.h"
+
+namespace Torch {
+
+/*
+ * Most matrix factorisation routines are in-situ unless otherwise specified 
+ */
+
+/*
+ * LUfactor -- gaussian elimination with scaled partial pivoting -- Note:
+ * returns LU matrix which is A 
+ */
+void mxLUFactor(Mat * mat, Perm * pivot)
+{
+  int m, n;
+  int i_max;
+  real **mat_v, *mat_piv, *mat_row;
+  real max1, temp, tiny;
+
+  Vec *scale = new Vec(mat->m);
+
+  m = mat->m;
+  n = mat->n;
+  mat_v = mat->ptr;
+
+  tiny = 10.0 / INF;
+
+  /*
+   * initialise pivot with identity permutation 
+   */
+  for (int i = 0; i < m; i++)
+    pivot->ptr[i] = i;
+
+  /*
+   * set scale parameters 
+   */
+  for (int i = 0; i < m; i++)
+  {
+    max1 = 0.0;
+    for (int j = 0; j < n; j++)
+    {
+      temp = fabs(mat_v[i][j]);
+      if (max1 < temp)
+	max1 = temp;
+    }
+    scale->ptr[i] = max1;
+  }
+
+  /*
+   * main loop 
+   */
+  int k_max = (m < n ? m : n) - 1;
+  for (int k = 0; k < k_max; k++)
+  {
+    /*
+     * find best pivot row 
+     */
+    max1 = 0.0;
+    i_max = -1;
+    for (int i = k; i < m; i++)
+    {
+      if (fabs(scale->ptr[i]) >= tiny * fabs(mat_v[i][k]))
+      {
+	temp = fabs(mat_v[i][k]) / scale->ptr[i];
+	if (temp > max1)
+	{
+	  max1 = temp;
+	  i_max = i;
+	}
+      }
+    }
+
+    /*
+     * if no pivot then ignore column k... 
+     */
+    if (i_max == -1)
+    {
+      /*
+       * set pivot entry mat[k][k] exactly to zero, rather than just
+       * "small" 
+       */
+      mat_v[k][k] = 0.0;
+      continue;
+    }
+
+    /*
+     * do we pivot ? 
+     */
+    if (i_max != k)
+    {				/*
+				   * yes we do... 
+				 */
+      mxTrPerm(pivot, i_max, k);
+      for (int j = 0; j < n; j++)
+      {
+	temp = mat_v[i_max][j];
+	mat_v[i_max][j] = mat_v[k][j];
+	mat_v[k][j] = temp;
+      }
+    }
+
+    /*
+     * row operations 
+     */
+    for (int i = k + 1; i < m; i++)
+    {				/*
+				   * for each row do... 
+ *//*
+ * Note: divide by zero should never happen 
+ */
+      temp = mat_v[i][k] = mat_v[i][k] / mat_v[k][k];
+      mat_piv = &(mat_v[k][k + 1]);
+      mat_row = &(mat_v[i][k + 1]);
+      if (k + 1 < n)
+	mxRealMulAdd__(mat_row, mat_piv, -temp, n - (k + 1));
+    }
+  }
+
+  delete scale;
+}
+
+
+/*
+ * LUsolve -- given an LU factorisation in A, solve Ax=b 
+ */
+void mxLUSolve(Mat * mat, Perm * pivot, Vec * b, Vec * x)
+{
+  // x := P.b 
+  mxPermVec(pivot, b, x);
+  // implicit diagonal = 1 
+  mxLSolve(mat, x, x, 1.0);
+  // explicit diagonal
+  mxUSolve(mat, x, x, 0.0);
+}
+
+/*
+ * LUTsolve -- given an LU factorisation in A, solve A^T.x=b 
+ */
+void mxLUTSolve(Mat * mat, Perm * pivot, Vec * b, Vec * x)
+{
+  x->copy(b);
+  // explicit diagonal
+  mxUTSolve(mat, x, x, 0.0);
+  // implicit diagonal = 1
+  mxLTSolve(mat, x, x, 1.0);
+  // x := P^T.tmp
+  mxPermInvVec(pivot, x, x);
+}
+
+/*
+ * m_inverse -- returns inverse of A, provided A is not too rank deficient -- 
+ * uses LU factorisation 
+ */
+void mxInverse(Mat * mat, Mat * out)
+{
+  // That's me...
+  Mat *mat_cp = new Mat(mat->m, mat->n);
+  Vec *tmp = new Vec(mat->m);
+  Vec *tmp2 = new Vec(mat->m);
+  Perm *pivot = new Perm(mat->m);
+
+  mat_cp->copy(mat);
+  mxLUFactor(mat_cp, pivot);
+
+  for (int i = 0; i < mat->n; i++)
+  {
+    tmp->zero();
+    tmp->ptr[i] = 1.0;
+    mxLUSolve(mat_cp, pivot, tmp, tmp2);
+    out->setCol(i, tmp2);
+  }
+
+  delete mat_cp;
+  delete tmp;
+  delete tmp2;
+  delete pivot;
+}
+
+/*
+ * LUcondest -- returns an estimate of the condition number of LU given the
+ * LU factorisation in compact form 
+ */
+real mxLUCondest(Mat * mat, Perm * pivot)
+{
+  real cond_est, L_norm, U_norm, sum, tiny;
+  int n = mat->n;
+  Vec *y = new Vec(n);
+  Vec *z = new Vec(n);
+
+  tiny = 10.0 / INF;
+
+  for (int i = 0; i < n; i++)
+  {
+    sum = 0.0;
+    for (int j = 0; j < i; j++)
+      sum -= mat->ptr[j][i] * y->ptr[j];
+    sum -= (sum < 0.0) ? 1.0 : -1.0;
+    if (fabs(mat->ptr[i][i]) <= tiny * fabs(sum))
+    {
+      delete y;
+      delete z;
+      return INF;
+    }
+    y->ptr[i] = sum / mat->ptr[i][i];
+  }
+
+  mxLTSolve(mat, y, y, 1.0);
+  mxLUSolve(mat, pivot, y, z);
+
+  /*
+   * now estimate norm of A (even though it is not directly available) 
+   */
+  /*
+   * actually computes ||L||_inf.||U||_inf 
+   */
+  U_norm = 0.0;
+  for (int i = 0; i < n; i++)
+  {
+    sum = 0.0;
+    for (int j = i; j < n; j++)
+      sum += fabs(mat->ptr[i][j]);
+    if (sum > U_norm)
+      U_norm = sum;
+  }
+  L_norm = 0.0;
+  for (int i = 0; i < n; i++)
+  {
+    sum = 1.0;
+    for (int j = 0; j < i; j++)
+      sum += fabs(mat->ptr[i][j]);
+    if (sum > L_norm)
+      L_norm = sum;
+  }
+
+  cond_est = U_norm * L_norm * z->normInf() / y->normInf();
+
+  delete y;
+  delete z;
+
+  return cond_est;
+}
+
+/*
+   Given #A# and #b#, solve #A.x=b# */
+void mxSolve(Mat *mat, Vec *b, Vec *x)
+{
+  Perm *pivot = new Perm(mat->m);
+  mxLUFactor(mat, pivot);
+  mxLUSolve(mat, pivot, b, x);
+  delete pivot;
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_lu_factor.h work/main.d/Torch-3/matrix/mx_lu_factor.h
--- tmp/Torch-3/matrix/mx_lu_factor.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_lu_factor.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,80 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MX_LU_FACTOR_INC
+#define MX_LU_FACTOR_INC
+
+#include "Mat.h"
+#include "Vec.h"
+#include "Perm.h"
+
+namespace Torch {
+
+/** Collection of matrix factorisation operation functions.
+    Based on the "Meschach Library", available at the
+    anonymous ftp site thrain.anu.edu.au in the directory
+    pub/meschach.
+
+    Most matrix factorisation routines are in-situ
+    unless otherwise specified.
+
+    @author David E. Stewart (david.stewart@anu.edu.au)
+    @author Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+//@{
+
+/** Gaussian elimination with scaled partial pivoting.
+    -- Note: returns LU matrix which is #A#. */
+void mxLUFactor(Mat * mat, Perm * pivot);
+
+/**
+   Given an LU factorisation in #A#, solve #Ax=b# */
+void mxLUSolve(Mat * mat, Perm * pivot, Vec * b, Vec * x);
+
+/**
+   Given an LU factorisation in #A#, solve #A^T.x=b# */
+void mxLUTSolve(Mat * mat, Perm * pivot, Vec * b, Vec * x);
+
+/**
+   Returns inverse of #A#, provided #A# is not too rank deficient.
+   Uses LU factorisation. */
+void mxInverse(Mat * mat, Mat * out);
+
+/**
+   Given #A# and #b#, solve #A.x=b# */
+void mxSolve(Mat *mat, Vec *b, Vec *x);
+
+//@}
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_solve.cc work/main.d/Torch-3/matrix/mx_solve.cc
--- tmp/Torch-3/matrix/mx_solve.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_solve.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,247 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "mx_solve.h"
+#include "mx_low_level.h"
+
+namespace Torch {
+
+/* Most matrix factorisation routines are in-situ unless otherwise specified */
+
+/* Usolve -- back substitution with optional over-riding diagonal
+		-- can be in-situ but doesn't need to be */
+void mxUSolve(Mat * matrix, Vec * b, Vec * out, real diag)
+{
+  int dim;
+  int i, i_lim;
+  real **mat_ptr, *mat_row, *b_ptr, *out_ptr, *out_col, sum, tiny;
+
+  dim = min(matrix->m, matrix->n);
+  mat_ptr = matrix->ptr;
+  b_ptr = b->ptr;
+  out_ptr = out->ptr;
+
+  tiny = 10.0 / INF;
+
+  for (i = dim - 1; i >= 0; i--)
+    if (b_ptr[i] != 0.0)
+      break;
+    else
+      out_ptr[i] = 0.0;
+  i_lim = i;
+
+  for (; i >= 0; i--)
+  {
+    sum = b_ptr[i];
+    mat_row = &mat_ptr[i][i + 1];
+    out_col = &out_ptr[i + 1];
+    sum -= mxIp__(mat_row, out_col, i_lim - i);
+    if (diag == 0.0)
+    {
+      if (fabs(mat_ptr[i][i]) <= tiny * fabs(sum))
+	error("USolve: sorry, singular problem.");
+      else
+	out_ptr[i] = sum / mat_ptr[i][i];
+    }
+    else
+      out_ptr[i] = sum / diag;
+  }
+}
+
+/* Lsolve -- forward elimination with (optional) default diagonal value */
+void mxLSolve(Mat * matrix, Vec * b, Vec * out, real diag)
+{
+  int dim, i, i_lim;
+  real **mat_ptr, *mat_row, *b_ptr, *out_ptr, *out_col, sum, tiny;
+
+  dim = min(matrix->m, matrix->n);
+  mat_ptr = matrix->ptr;
+  b_ptr = b->ptr;
+  out_ptr = out->ptr;
+
+  for (i = 0; i < dim; i++)
+    if (b_ptr[i] != 0.0)
+      break;
+    else
+      out_ptr[i] = 0.0;
+  i_lim = i;
+
+  tiny = 10.0 / INF;
+
+  for (; i < dim; i++)
+  {
+    sum = b_ptr[i];
+    mat_row = &mat_ptr[i][i_lim];
+    out_col = &out_ptr[i_lim];
+    sum -= mxIp__(mat_row, out_col, i - i_lim);
+    if (diag == 0.0)
+    {
+      if (fabs(mat_ptr[i][i]) <= tiny * fabs(sum))
+	error("LSolve: sorry, singular problem.");
+      else
+	out_ptr[i] = sum / mat_ptr[i][i];
+    }
+    else
+      out_ptr[i] = sum / diag;
+  }
+}
+
+
+/* UTsolve -- forward elimination with (optional) default diagonal value
+		using UPPER triangular part of matrix */
+void mxUTSolve(Mat * mat, Vec * b, Vec * out, real diag)
+{
+  int dim, i, i_lim;
+  real **mat_ptr, *b_ptr, *out_ptr, tmp, invdiag, tiny;
+
+  dim = min(mat->m, mat->n);
+  mat_ptr = mat->ptr;
+  b_ptr = b->ptr;
+  out_ptr = out->ptr;
+
+  tiny = 10.0 / INF;
+
+  for (i = 0; i < dim; i++)
+  {
+    if (b_ptr[i] != 0.0)
+      break;
+    else
+      out_ptr[i] = 0.0;
+  }
+  i_lim = i;
+  if (b != out)
+  {
+    mxZero__(out_ptr, out->n);
+    real *ptr_r = &b_ptr[i_lim];
+    real *ptr_w = &out_ptr[i_lim];
+    for (int j = 0; j < dim - i_lim; j++)
+      *ptr_w++ = *ptr_r++;
+  }
+
+  if (diag == 0.0)
+  {
+    for (; i < dim; i++)
+    {
+      tmp = mat_ptr[i][i];
+      if (fabs(tmp) <= tiny * fabs(out_ptr[i]))
+	error("UTSolve: sorry, singular problem.");
+      out_ptr[i] /= tmp;
+      mxRealMulAdd__(&out_ptr[i + 1], &mat_ptr[i][i + 1], -out_ptr[i],
+		     dim - i - 1);
+    }
+  }
+  else
+  {
+    invdiag = 1.0 / diag;
+    for (; i < dim; i++)
+    {
+      out_ptr[i] *= invdiag;
+      mxRealMulAdd__(&out_ptr[i + 1], &mat_ptr[i][i + 1], -out_ptr[i],
+		     dim - i - 1);
+    }
+  }
+}
+
+/* Dsolve -- solves Dx=b where D is the diagonal of A -- may be in-situ */
+void mxDSolve(Mat * mat, Vec * b, Vec * x)
+{
+  int dim, i;
+  real tiny;
+
+  dim = min(mat->m, mat->n);
+
+  tiny = 10.0 / INF;
+
+  dim = b->n;
+  for (i = 0; i < dim; i++)
+  {
+    if (fabs(mat->ptr[i][i]) <= tiny * fabs(b->ptr[i]))
+      error("DSolve: sorry, singular problem.");
+    else
+      x->ptr[i] = b->ptr[i] / mat->ptr[i][i];
+  }
+}
+
+/* LTsolve -- back substitution with optional over-riding diagonal
+		using the LOWER triangular part of matrix
+		-- can be in-situ but doesn't need to be */
+void mxLTSolve(Mat * mat, Vec * b, Vec * out, real diag)
+{
+  int dim;
+  int i, i_lim;
+  real **mat_ptr, *b_ptr, *out_ptr, tmp, invdiag, tiny;
+
+  dim = min(mat->m, mat->n);
+  mat_ptr = mat->ptr;
+  b_ptr = b->ptr;
+  out_ptr = out->ptr;
+
+  tiny = 10.0 / INF;
+
+  for (i = dim - 1; i >= 0; i--)
+  {
+    if (b_ptr[i] != 0.0)
+      break;
+  }
+  i_lim = i;
+
+  if (b != out)
+  {
+    mxZero__(out_ptr, out->n);
+    real *ptr_r = b_ptr;
+    real *ptr_w = out_ptr;
+    for (int j = 0; j < i_lim + 1; j++)
+      *ptr_w++ = *ptr_r++;
+  }
+
+  if (diag == 0.0)
+  {
+    for (; i >= 0; i--)
+    {
+      tmp = mat_ptr[i][i];
+      if (fabs(tmp) <= tiny * fabs(out_ptr[i]))
+	error("LTSolve: sorry, singular problem.");
+      out_ptr[i] /= tmp;
+      mxRealMulAdd__(out_ptr, mat_ptr[i], -out_ptr[i], i);
+    }
+  }
+  else
+  {
+    invdiag = 1.0 / diag;
+    for (; i >= 0; i--)
+    {
+      out_ptr[i] *= invdiag;
+      mxRealMulAdd__(out_ptr, mat_ptr[i], -out_ptr[i], i);
+    }
+  }
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_solve.h work/main.d/Torch-3/matrix/mx_solve.h
--- tmp/Torch-3/matrix/mx_solve.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_solve.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,72 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MX_SOLVE_INC
+#define MX_SOLVE_INC
+
+#include "Mat.h"
+#include "Vec.h"
+
+namespace Torch {
+
+/*  Collection of factorisations functions.
+    Based on the "Meschach Library", available at the
+    anonymous ftp site thrain.anu.edu.au in the directory
+    pub/meschach.
+
+    @author David E. Stewart (david.stewart@anu.edu.au)
+    @author Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+
+/* Back substitution with optional over-riding diagonal.
+    Can be in-situ but doesn't need to be. */
+void mxUSolve(Mat * matrix, Vec * b, Vec * out, real diag);
+
+// Forward elimination with (optional) default diagonal value.
+void mxLSolve(Mat * matrix, Vec * b, Vec * out, real diag);
+
+/* Forward elimination with (optional) default diagonal value.
+    Use UPPER triangular part of matrix. */
+void mxUTSolve(Mat * mat, Vec * b, Vec * out, real diag);
+
+/* Solves Dx=b where D is the diagonal of A.
+    May be in-situ. */
+void mxDSolve(Mat * mat, Vec * b, Vec * x);
+
+/* Back substitution with optional over-riding diagonal.
+   Use the LOWER triangular part of matrix.
+   Can be in-situ but doesn't need to be. */
+void mxLTSolve(Mat * mat, Vec * b, Vec * out, real diag);
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_sym_eig.cc work/main.d/Torch-3/matrix/mx_sym_eig.cc
--- tmp/Torch-3/matrix/mx_sym_eig.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_sym_eig.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,206 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+/*
+	File containing routines for symmetric eigenvalue problems
+*/
+
+#include "mx_sym_eig.h"
+
+namespace Torch {
+
+
+#define	SQRT2	1.4142135623730949
+#define	sgn(x)	( (x) >= 0 ? 1 : -1 )
+
+/* trieig -- finds eigenvalues of symmetric tridiagonal matrices
+	-- matrix represented by a pair of vectors a (diag entries)
+		and b (sub- & super-diag entries)
+	-- eigenvalues in a on return */
+void mxTriEig(Vec * a, Vec * b, Mat * mat_q)
+{
+  int i_min, i_max;
+  real b_sqr, bk, ak1, bk1, ak2, bk2, z;
+  real c, c2, cs, s, s2, d, mu;
+
+  int n = a->n;
+  real *a_ptr = a->ptr;
+  real *b_ptr = b->ptr;
+
+  i_min = 0;
+  while (i_min < n)		/* outer while loop */
+  {
+    /* find i_max to suit;
+       submatrix i_min..i_max should be irreducible */
+    i_max = n - 1;
+    for (int i = i_min; i < n - 1; i++)
+    {
+      if (b_ptr[i] == 0.0)
+      {
+	i_max = i;
+	break;
+      }
+    }
+
+    if (i_max <= i_min)
+    {
+      i_min = i_max + 1;
+      continue;			/* outer while loop */
+    }
+
+    /* repeatedly perform QR method until matrix splits */
+    bool split = false;
+    while (!split)		/* inner while loop */
+    {
+      /* find Wilkinson shift */
+      d = (a_ptr[i_max - 1] - a_ptr[i_max]) / 2;
+      b_sqr = b_ptr[i_max - 1] * b_ptr[i_max - 1];
+      mu = a_ptr[i_max] - b_sqr / (d + sgn(d) * sqrt(d * d + b_sqr));
+
+      /* initial Givens' rotation */
+      mx_givens(a_ptr[i_min] - mu, b_ptr[i_min], &c, &s);
+      s = -s;
+      if (fabs(c) < SQRT2)
+      {
+	c2 = c * c;
+	s2 = 1 - c2;
+      }
+      else
+      {
+	s2 = s * s;
+	c2 = 1 - s2;
+      }
+      cs = c * s;
+      ak1 =
+	  c2 * a_ptr[i_min] + s2 * a_ptr[i_min + 1] -
+	  2 * cs * b_ptr[i_min];
+      bk1 =
+	  cs * (a_ptr[i_min] - a_ptr[i_min + 1]) + (c2 -
+						    s2) * b_ptr[i_min];
+      ak2 =
+	  s2 * a_ptr[i_min] + c2 * a_ptr[i_min + 1] +
+	  2 * cs * b_ptr[i_min];
+      bk2 = (i_min < i_max - 1) ? c * b_ptr[i_min + 1] : 0.0;
+      z = (i_min < i_max - 1) ? -s * b_ptr[i_min + 1] : 0.0;
+      a_ptr[i_min] = ak1;
+      a_ptr[i_min + 1] = ak2;
+      b_ptr[i_min] = bk1;
+      if (i_min < i_max - 1)
+	b_ptr[i_min + 1] = bk2;
+      if (mat_q)
+	mx_rot_cols(mat_q, i_min, i_min + 1, c, -s, mat_q);
+
+      for (int i = i_min + 1; i < i_max; i++)
+      {
+	/* get Givens' rotation for sub-block -- k == i-1 */
+	mx_givens(b_ptr[i - 1], z, &c, &s);
+	s = -s;
+
+	/* perform Givens' rotation on sub-block */
+	if (fabs(c) < SQRT2)
+	{
+	  c2 = c * c;
+	  s2 = 1 - c2;
+	}
+	else
+	{
+	  s2 = s * s;
+	  c2 = 1 - s2;
+	}
+	cs = c * s;
+	bk = c * b_ptr[i - 1] - s * z;
+	ak1 = c2 * a_ptr[i] + s2 * a_ptr[i + 1] - 2 * cs * b_ptr[i];
+	bk1 = cs * (a_ptr[i] - a_ptr[i + 1]) + (c2 - s2) * b_ptr[i];
+	ak2 = s2 * a_ptr[i] + c2 * a_ptr[i + 1] + 2 * cs * b_ptr[i];
+	bk2 = (i + 1 < i_max) ? c * b_ptr[i + 1] : 0.0;
+	z = (i + 1 < i_max) ? -s * b_ptr[i + 1] : 0.0;
+	a_ptr[i] = ak1;
+	a_ptr[i + 1] = ak2;
+	b_ptr[i] = bk1;
+	if (i < i_max - 1)
+	  b_ptr[i + 1] = bk2;
+	if (i > i_min)
+	  b_ptr[i - 1] = bk;
+	if (mat_q)
+	  mx_rot_cols(mat_q, i, i + 1, c, -s, mat_q);
+      }
+
+      /* test to see if matrix should be split */
+      for (int i = i_min; i < i_max; i++)
+      {
+	if (fabs(b_ptr[i]) <
+	    REAL_EPSILON * (fabs(a_ptr[i]) + fabs(a_ptr[i + 1])))
+	{
+	  b_ptr[i] = 0.0;
+	  split = true;
+	}
+      }
+    }
+  }
+}
+
+/* symmeig -- computes eigenvalues of a dense symmetric matrix
+	-- mat_a **must** be symmetric on entry
+	-- eigenvalues stored in out
+	-- mat_q contains orthogonal matrix of eigenvectors
+	-- returns vector of eigenvalues
+  -- je pense: if mat_q is NULL, eigenvectors won't be computed
+*/
+void mxSymEig(Mat * mat_a, Mat * mat_q, Vec * out)
+{
+  Mat *tmp = new Mat(mat_a->m, mat_a->n);
+  tmp->copy(mat_a);
+
+  Vec *b = new Vec(mat_a->m - 1);
+  Vec *diag = new Vec(mat_a->m);
+  Vec *beta = new Vec(mat_a->m);
+
+  mxHFactor(tmp, diag, beta);
+  if (mat_q)
+    mxMakeHQ(tmp, diag, beta, mat_q);
+
+  int i;
+  for (i = 0; i < mat_a->m - 1; i++)
+  {
+    out->ptr[i] = tmp->ptr[i][i];
+    b->ptr[i] = tmp->ptr[i][i + 1];
+  }
+  out->ptr[i] = tmp->ptr[i][i];
+
+  mxTriEig(out, b, mat_q);
+
+  delete beta;
+  delete diag;
+  delete b;
+  delete tmp;
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/mx_sym_eig.h work/main.d/Torch-3/matrix/mx_sym_eig.h
--- tmp/Torch-3/matrix/mx_sym_eig.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/mx_sym_eig.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,74 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef MX_SYM_EIG_INC
+#define MX_SYM_EIG_INC
+
+#include "Vec.h"
+#include "Mat.h"
+#include "mx_givens.h"
+#include "mx_hessenberg.h"
+
+namespace Torch {
+
+/**
+	Routines for symmetric eigenvalue problems.
+
+  Based on the "Meschach Library", available at the
+  anonymous ftp site thrain.anu.edu.au in the directory
+  pub/meschach.
+  
+  @author David E. Stewart (david.stewart@anu.edu.au)
+  @author Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+  @author Ronan Collobert (collober@idiap.ch)
+*/
+//@{
+
+/** Finds eigenvalues of symmetric tridiagonal matrices.
+    The matrix is represented by a pair of vectors #a# (diag entries)
+		and #b# (sub-diag and super-diag entries).
+    Eigenvalues in #a# on return, and eigenvectors in #mat_q#, if this one
+    is not #NULL#.
+*/
+void mxTriEig(Vec * a, Vec * b, Mat * mat_q);
+
+/** Computes eigenvalues of a dense symmetric matrix.
+	  #mat_a# \emph{must} be symmetric on entry.
+    Eigenvalues stored in #out#.
+    #mat_q# contains orthogonal matrix of eigenvectors if not #NULL#.
+*/
+void mxSymEig(Mat * mat_a, Mat * mat_q, Vec * out);
+
+//@}
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/Perm.cc work/main.d/Torch-3/matrix/Perm.cc
--- tmp/Torch-3/matrix/Perm.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/Perm.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,52 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Perm.h"
+
+namespace Torch {
+
+Perm::Perm(int n_dim)
+{
+  n = n_dim;
+  ptr = (int *)allocator->alloc(sizeof(int) * n);
+}
+
+void Perm::copy(Perm * perm)
+{
+  int *ptr_r = perm->ptr;
+  int *ptr_w = ptr;
+
+  for (int i = 0; i < n; i++)
+    *ptr_w++ = *ptr_r++;
+}
+
+Perm::~Perm()
+{
+}
+
+}
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/Perm.h work/main.d/Torch-3/matrix/Perm.h
--- tmp/Torch-3/matrix/Perm.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/Perm.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,62 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef PERM_INC
+#define PERM_INC
+
+#include "Object.h"
+#include "Perm.h"
+
+namespace Torch {
+
+/** Permutation object.
+    
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Perm : public Object
+{ 
+  public:
+    /// Size of the permutation
+    int n;
+    
+    /// Data of the permutation
+    int *ptr;
+    
+    /// Create a new permutation
+    Perm(int n_dim);
+    
+    /// Copy the permutation #perm#
+    void copy(Perm * perm);
+    
+   ~Perm();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/Perm_operations.cc work/main.d/Torch-3/matrix/Perm_operations.cc
--- tmp/Torch-3/matrix/Perm_operations.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/Perm_operations.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,280 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Perm_operations.h"
+
+namespace Torch {
+
+/**********************************************************************
+Note: A permutation is often interpreted as a matrix
+		(i.e. a permutation matrix).
+	A permutation px represents a permutation matrix P where
+		P[i][j] == 1 if and only if px->ptr[i] == j
+**********************************************************************/
+
+
+/* px_inv -- invert permutation -- in situ
+	-- taken from ACM Collected Algorithms #250 */
+void mxPermInv(Perm * px, Perm * out)
+{
+  int i, j, k, *p;
+
+  out->copy(px);
+
+  p = out->ptr;
+  for (int n = out->n - 1; n >= 0; n--)
+  {
+    i = p[n];
+    if (i < 0)
+      p[n] = -1 - i;
+    else
+    {
+      if (i != n)
+      {
+	k = n;
+	while (1)
+	{
+	  j = p[i];
+	  p[i] = -1 - k;
+	  if (j == n)
+	  {
+	    p[n] = i;
+	    break;
+	  }
+	  k = i;
+	  i = j;
+	}
+      }
+    }
+  }
+}
+
+/* px_mlt -- permutation multiplication (composition) */
+// not in-situ
+void mxPermMulPerm(Perm * px1, Perm * px2, Perm * out)
+{
+  int size = px1->n;
+  for (int i = 0; i < size; i++)
+    out->ptr[i] = px1->ptr[px2->ptr[i]];
+}
+
+/* px_vec -- permute vector */
+// can be in-situ
+void mxPermVec(Perm * px, Vec * vec, Vec * out)
+{
+  int old_i, i, size, start;
+  real tmp;
+
+  size = px->n;
+  if (size == 0)
+  {
+    out->copy(vec);
+    return;
+  }
+
+  if (out != vec)
+  {
+    for (i = 0; i < size; i++)
+      out->ptr[i] = vec->ptr[px->ptr[i]];
+  }
+  else
+  {				/* in situ algorithm */
+    start = 0;
+    while (start < size)
+    {
+      old_i = start;
+      i = px->ptr[old_i];
+      if (i >= size)
+      {
+	start++;
+	continue;
+      }
+      tmp = vec->ptr[start];
+      while (1)
+      {
+	vec->ptr[old_i] = vec->ptr[i];
+	px->ptr[old_i] = i + size;
+	old_i = i;
+	i = px->ptr[old_i];
+	if (i >= size)
+	  break;
+	if (i == start)
+	{
+	  vec->ptr[old_i] = tmp;
+	  px->ptr[old_i] = i + size;
+	  break;
+	}
+      }
+      start++;
+    }
+
+    for (i = 0; i < size; i++)
+      px->ptr[i] = px->ptr[i] - size;
+  }
+}
+
+/* pxinv_vec -- apply the inverse of px to x, returning the result in out */
+// can be in-situ, but "oh booooy!"...
+void mxPermInvVec(Perm * px, Vec * x, Vec * out)
+{
+  int size = px->n;
+  if (size == 0)
+  {
+    out->copy(x);
+    return;
+  }
+  if (out != x)
+  {
+    for (int i = 0; i < size; i++)
+      out->ptr[px->ptr[i]] = x->ptr[i];
+  }
+  else
+  {				/* in situ algorithm --- cheat's way out */
+    mxPermInv(px, px);
+    mxPermVec(px, x, out);
+    mxPermInv(px, px);
+  }
+}
+
+
+
+/* px_transp -- transpose elements of permutation
+		-- Really multiplying a permutation by a transposition */
+/* i1, i2 <---> elements to transpose */
+void mxTrPerm(Perm * px, int i1, int i2)
+{
+  int temp;
+
+  if (i1 < px->n && i2 < px->n)
+  {
+    temp = px->ptr[i1];
+    px->ptr[i1] = px->ptr[i2];
+    px->ptr[i2] = temp;
+  }
+}
+
+/* myqsort -- a cheap implementation of Quicksort on integers
+		-- returns number of swaps */
+static int mxQsort(int *a, int num)
+{
+  int i, j, tmp, v;
+  int numswaps;
+
+  numswaps = 0;
+  if (num <= 1)
+    return 0;
+
+  i = 0;
+  j = num;
+  v = a[0];
+  for (;;)
+  {
+    while (a[++i] < v);
+    while (a[--j] > v);
+    if (i >= j)
+      break;
+
+    tmp = a[i];
+    a[i] = a[j];
+    a[j] = tmp;
+    numswaps++;
+  }
+
+  tmp = a[0];
+  a[0] = a[j];
+  a[j] = tmp;
+  if (j != 0)
+    numswaps++;
+
+  numswaps += mxQsort(&a[0], j);
+  numswaps += mxQsort(&a[j + 1], num - (j + 1));
+
+  return numswaps;
+}
+
+
+/* px_sign -- compute the ``sign'' of a permutation = +/-1 where
+		px is the product of an even/odd # transpositions */
+int mxPermSign(Perm * px)
+{
+  int numtransp;
+  Perm *px2 = new Perm(px->n);
+
+  px2->copy(px);
+  numtransp = mxQsort(px2->ptr, px2->n);
+
+  delete px2;
+
+  return (numtransp % 2) ? -1 : 1;
+}
+
+
+/* px_cols -- permute columns of matrix A; out = A.px'
+	-- May NOT be in situ */
+void mxPermColsMat(Perm * px, Mat * mat, Mat * out)
+{
+  int m, n, px_j;
+  real **mat_ptr, **out_ptr;
+
+  m = mat->m;
+  n = mat->n;
+  mat_ptr = mat->ptr;
+  out_ptr = out->ptr;
+
+  for (int j = 0; j < n; j++)
+  {
+    px_j = px->ptr[j];
+    for (int i = 0; i < m; i++)
+      out_ptr[i][px_j] = mat_ptr[i][j];
+  }
+}
+
+/* px_rows -- permute rows of matrix A; out = px.A
+	-- May NOT be in situ */
+void mxPermRowsMat(Perm * px, Mat * mat, Mat * out)
+{
+  int m, n, px_i;
+  real **mat_ptr, **out_ptr;
+
+  m = mat->m;
+  n = mat->n;
+  mat_ptr = mat->ptr;
+  out_ptr = out->ptr;
+
+  for (int i = 0; i < m; i++)
+  {
+    px_i = px->ptr[i];
+    for (int j = 0; j < n; j++)
+      out_ptr[i][j] = mat_ptr[px_i][j];
+  }
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/Perm_operations.h work/main.d/Torch-3/matrix/Perm_operations.h
--- tmp/Torch-3/matrix/Perm_operations.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/Perm_operations.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,80 @@
+// Copyright (C) 2003--2004 Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+//                and David E. Stewart (david.stewart@anu.edu.au)
+//                and Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef PERM_OPERATIONS_INC
+#define PERM_OPERATIONS_INC
+
+#include "Perm.h"
+#include "Mat.h"
+#include "Vec.h"
+
+namespace Torch {
+
+/** Collection of permutations operation functions.
+    Based on the "Meschach Library", available at the
+    anonymous ftp site thrain.anu.edu.au in the directory
+    pub/meschach.
+
+    @author David E. Stewart (david.stewart@anu.edu.au)
+    @author Zbigniew Leyk (zbigniew.leyk@anu.edu.au)
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+//@{
+/** Invert permutation -- in situ.
+    Taken from ACM Collected Algorithms 250. */
+void mxPermInv(Perm * px, Perm * out);
+
+/** Permutation multiplication (composition) -- not in-situ */
+void mxPermMulPerm(Perm * px1, Perm * px2, Perm * out);
+
+/** Permute vector -- can be in-situ */
+void mxPermVec(Perm * px, Vec * vec, Vec * out);
+
+/** Apply the inverse of px to x, returning the result in out.
+    Can be in-situ, but "oh booooy!"... */
+void mxPermInvVec(Perm * px, Vec * x, Vec * out);
+
+/** Transpose elements of permutation.
+    Really multiplying a permutation by a transposition.
+    i1 and i2 are the elements to transpose. */
+void mxTrPerm(Perm * px, int i1, int i2);
+
+/** Permute columns of matrix A; out = A.px'. -- May NOT be in situ */
+void mxPermColsMat(Perm * px, Mat * mat, Mat * out);
+
+/** Permute rows of matrix A; out = px.A. -- May NOT be in situ */
+void mxPermRowsMat(Perm * px, Mat * mat, Mat * out);
+
+//@}
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/README work/main.d/Torch-3/matrix/README
--- tmp/Torch-3/matrix/README	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/README	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,26 @@
+This package is an adaptation of a part of the Meschach Library.
+Here is the copyright of the authors:
+
+/**************************************************************************
+**
+** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.
+**
+**			     Meschach Library
+** 
+** This Meschach Library is provided "as is" without any express 
+** or implied warranty of any kind with respect to this software. 
+** In particular the authors shall not be liable for any direct, 
+** indirect, special, incidental or consequential damages arising 
+** in any way from use of the software.
+** 
+** Everyone is granted permission to copy, modify and redistribute this
+** Meschach Library, provided:
+**  1.  All copies contain this copyright notice.
+**  2.  All modified copies shall carry a notice stating who
+**      made the last modification and the date of such modification.
+**  3.  No charge is made for this software or works derived from it.  
+**      This clause shall not be construed as constraining other software
+**      distributed on the same medium as this software, nor is a
+**      distribution fee considered a charge.
+**
+***************************************************************************/
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/Vec.cc work/main.d/Torch-3/matrix/Vec.cc
--- tmp/Torch-3/matrix/Vec.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/Vec.cc	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,141 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "Vec.h"
+#include "mx_low_level.h"
+
+namespace Torch {
+
+Vec::Vec(real * ptr_, int n_dim)
+{
+  ptr = ptr_;
+  n = n_dim;
+}
+
+Vec::Vec(int n_dim)
+{
+  n = n_dim;
+  ptr = (real *)allocator->alloc(sizeof(real) * n);
+}
+
+void Vec::copy(Vec * vec, int start_i)
+{
+  if (vec == this)
+    return;
+
+  real *ptr_r = vec->ptr + start_i;
+  real *ptr_w = ptr + start_i;
+  for (int i = 0; i < n - start_i; i++)
+    *ptr_w++ = *ptr_r++;
+}
+
+void Vec::zero()
+{
+  real *ptr_w = ptr;
+  for (int i = 0; i < n; i++)
+    *ptr_w++ = 0.;
+}
+
+real Vec::norm1(Vec * weights)
+{
+  real sum = 0.0;
+  real *ptr_x = ptr;
+  if (weights)
+  {
+    real *ptr_w = weights->ptr;
+    for (int i = 0; i < n; i++)
+      sum += *ptr_w++ * fabs(*ptr_x++);
+  }
+  else
+  {
+    for (int i = 0; i < n; i++)
+      sum += fabs(*ptr_x++);
+  }
+
+  return sum;
+}
+
+real Vec::norm2(Vec * weights)
+{
+  real sum = 0.0;
+  real *ptr_x = ptr;
+  if (weights)
+  {
+    real *ptr_w = weights->ptr;
+    for (int i = 0; i < n; i++)
+    {
+      real z = *ptr_x++;
+      sum += *ptr_w++ * z * z;
+    }
+  }
+  else
+  {
+    for (int i = 0; i < n; i++)
+    {
+      real z = *ptr_x++;
+      sum += z * z;
+    }
+  }
+
+  return sqrt(sum);
+}
+
+real Vec::normInf()
+{
+  real *ptr_x = ptr;
+  real max_val = fabs(*ptr_x++);
+
+  for (int i = 1; i < n; i++)
+  {
+    real z = fabs(*ptr_x);
+    if (max_val < z)
+      max_val = z;
+    ptr_x++;
+  }
+
+  return max_val;
+}
+
+real Vec::iP(Vec * vec, int start_i)
+{
+  return (mxIp__(ptr + start_i, vec->ptr + start_i, n - start_i));
+}
+
+Vec *Vec::subVec(int dim1, int dim2)
+{
+  Vec *vec = new Vec(ptr + dim1, dim2 - dim1 + 1);
+
+  return (vec);
+}
+
+Vec::~Vec()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/matrix/Vec.h work/main.d/Torch-3/matrix/Vec.h
--- tmp/Torch-3/matrix/Vec.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/matrix/Vec.h	2004-08-11 12:34:41.000000000 -0400
@@ -0,0 +1,88 @@
+// Copyright (C) 2003--2004 Ronan Collobert (collober@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef VEC_INC
+#define VEC_INC
+
+#include "Object.h"
+#include "Vec.h"
+
+namespace Torch {
+
+/** Vector object.
+    
+    @author Ronan Collobert (collober@idiap.ch)
+*/
+class Vec : public Object
+{
+  public:
+    /// Size of the vector
+    int n;
+
+    /// Data of the vector
+    real *ptr;
+
+    /** Create a vector from values in #ptr_#.
+        (No memory copy).
+    */
+    Vec(real * ptr_, int n_dim);
+
+    /// Create a new vector
+    Vec(int n_dim);
+
+    /// Copy the vector #vec# starting from index #start_i#
+    void copy(Vec * vec, int start_i = 0);
+
+    /// Zero the matrix
+    void zero();
+
+    /// Compute the norm1
+    real norm1(Vec * weights = NULL);
+
+    /// Compute the norm2
+    real norm2(Vec * weights = NULL);
+
+    /// Compute the norm inf
+    real normInf();
+
+    /// Inner product of two vectors from #start_i# downwards
+    real iP(Vec * vec, int start_i = 0);
+
+    /** Return a sub-vector.
+        Note that the memory is shared with the original
+        vector, so *be carefull*.
+    */
+    Vec *subVec(int dim1, int dim2);
+
+    ~Vec();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/nonparametrics/KNN.cc work/main.d/Torch-3/nonparametrics/KNN.cc
--- tmp/Torch-3/nonparametrics/KNN.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/nonparametrics/KNN.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,164 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "KNN.h"
+
+namespace Torch {
+
+KNN::KNN(int n_outputs_,int K_)
+{
+  // works only for sequences of 1 frame (static data!)
+  data = NULL;
+  distances = NULL;
+  indices = NULL;
+  setK(K_);
+  n_outputs = n_outputs_;
+  outputs = new(allocator) Sequence(1,n_outputs);
+  n_real_examples = 0;
+  real_examples = NULL;
+}
+
+void KNN::setDataSet(DataSet *dataset_)
+{
+  data = dataset_;
+  n_real_examples = data->n_examples;
+  real_examples = (int*)allocator->realloc(real_examples,n_real_examples*sizeof(int));
+  for (int i=0;i<data->n_examples;i++) {
+    real_examples[i] = data->selected_examples[i];
+  }
+}
+
+void KNN::setK(int K_)
+{
+  K = K_;
+  distances = (real *)allocator->realloc(distances,K*sizeof(real));
+  indices = (int *)allocator->realloc(indices,K*sizeof(int));
+}
+
+real KNN::distance(real* v1, real* v2, int n)
+{
+  real dist = 0.;
+  for(int j=0;j<n;j++) {
+    real diff = *v1++ - *v2++;
+     dist += diff*diff;
+  }
+  return dist;
+}
+
+void KNN::forward(Sequence* inputs)
+{
+  // keep current example in order to restore at the end
+  data->pushExample();
+
+  // verify that n_examples > K
+  int old_K = K;
+  if (n_real_examples < K)
+    K = n_real_examples;
+
+  // initialization of distances to big values;
+  for (int i=0;i<K;i++) {
+    distances[i] = INF;
+    indices[i] = -1;
+  }
+
+  // compute the K nearest neighbords
+
+  // for each vector in data
+  int* i_ptr = real_examples;
+  for (int i=0;i<n_real_examples;i++) {
+    data->setRealExample(*i_ptr++);
+    // calculate euclidean distance between example and current vector
+    real dist = distance(inputs->frames[0],data->inputs->frames[0],data->n_inputs);
+
+/*
+    real dist = 0;
+    Sequence* cur = data->inputs;
+    real *x = inputs->frames[0];
+    real *datax = cur->frames[0];
+    for(int j=0;j<data->n_inputs;j++) {
+      real diff = *x++ - *datax++;
+       dist += diff*diff;
+    }
+*/
+    // eventually add current vector to K nearest neighbors
+    if (dist < distances[K-1]) {
+      // find insertion point
+      real* bptr = distances;
+      real* eptr = distances + K - 1;
+      real* mptr = bptr + (eptr - bptr) / 2;
+      do {
+        if (dist < *mptr)
+          eptr = mptr;
+        else
+          bptr = mptr + 1;
+        mptr = bptr + (eptr - bptr) / 2;
+      } while (mptr < eptr);
+      // insert the point by shifting all subsequent distances
+      eptr = distances + K - 1;
+      bptr = eptr - 1;
+
+      int* eptr_idx = indices + K - 1;
+      int* bptr_idx = eptr_idx - 1;
+
+      while (eptr > mptr) {
+        *eptr-- = *bptr--;      /*   distances   */
+        *eptr_idx-- = *bptr_idx--;      /*   indices   */
+      }
+      *mptr = dist;
+      indices[mptr - distances] = data->real_current_example_index;
+    }
+  }
+
+  // give an answer as the mean of the answers of the KNNs
+  // initialize outputs to null
+  real* out = outputs->frames[0];
+  for (int j=0;j<n_outputs;j++)
+    *out++ = 0;
+  for (int i=0;i<K;i++) {
+    out = outputs->frames[0];
+    data->setRealExample(indices[i]);
+    real *targ = data->targets->frames[0];
+    for (int j=0;j<n_outputs;j++)
+      *out++ += *targ++;
+  }
+  out = outputs->frames[0];
+  for (int j=0;j<n_outputs;j++)
+    *out++ /= (real)K;
+
+  // in case K was modified
+  K = old_K;
+  // restore current_example
+  data->popExample();
+}
+
+KNN::~KNN()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/nonparametrics/KNN.h work/main.d/Torch-3/nonparametrics/KNN.h
--- tmp/Torch-3/nonparametrics/KNN.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/nonparametrics/KNN.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,81 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef KNN_INC
+#define KNN_INC
+
+#include "Machine.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+/** This machine implements the K-nearest-neighbors (KNN) algorithm.
+    Given a dataset (in the constructor), the #forward# method returns
+    for a given input the average of the outputs of the K nearest examples
+    (in the input space, using the Euclidean distance). As a side effect,
+    the machine also keep the table of distances of the K-nearest-neighbors.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class KNN : public Machine
+{
+  public:
+
+    /// The number of nearest neighbors. Controls the capacity of the machine
+    int K;
+    /// For each nearest neighbor, keeps its distance to the current input
+    real* distances;
+    /// For each nearest neighbor, keeps its index in the dataset
+    int* indices;
+    /// The dataset that contains the potential neaghbors
+    DataSet* data;
+
+    /// the size of the output vector
+    int n_outputs;
+
+    /// the indices of the training examples
+    int *real_examples;
+    int n_real_examples;
+
+    ///
+    KNN(int n_outputs_,int K_);
+
+    virtual void forward(Sequence *inputs);
+    virtual void setDataSet(DataSet *dataset_);
+    virtual real distance(real* v1, real* v2, int n);
+
+    /// change the value of K
+    virtual void setK(int K_);
+
+    virtual ~KNN();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/nonparametrics/LICENSE work/main.d/Torch-3/nonparametrics/LICENSE
--- tmp/Torch-3/nonparametrics/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/nonparametrics/LICENSE	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,28 @@
+
+Copyright (c) 2003--2004 Ronan Collobert
+Copyright (c) 2003--2004 Samy Bengio
+Copyright (c) 2003--2004 Johnny Mariéthoz
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --speed-large-files --minimal -Nru tmp/Torch-3/nonparametrics/Makefile work/main.d/Torch-3/nonparametrics/Makefile
--- tmp/Torch-3/nonparametrics/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/nonparametrics/Makefile	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,42 @@
+# get user and architecture specific options
+OS := $(shell uname -s)
+TORCHDIR := $(shell cd ..; pwd)
+include ../Makefile_options_$(OS)
+
+CC_FILES := $(wildcard *.cc)
+OBJS := $(foreach f,$(CC_FILES),$(OBJS_DIR)/$(patsubst %.cc,%.o,$(f)))
+
+all:	$(LIBTORCH)
+
+$(LIBTORCH): $(OBJS)
+	@echo "Archiving..."
+	@$(AR) $(LIBTORCH) $(OBJS)
+
+$(OBJS_DIR)/%.o: %.cc
+	@echo $<
+	@$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $@ -c $<
+
+distclean:
+	@\rm -f .deps_*
+
+clean:
+	@echo "Remove objects file and dependencies..."
+	@\rm -Rf $(OBJS) $(LIBTORCH)
+	@\rm -f .deps_$(VERSION_KEY)
+
+depend:
+	@echo "Tracking dependencies..."
+	@\rm -f .deps_$(VERSION_KEY)
+	@for file in *.cc ; do printf "$(OBJS_DIR)/" >> .deps_$(VERSION_KEY); $(DEP) $(CFLAGS_$(MODE)) $(INCS) $$file >> .deps_$(VERSION_KEY); done
+
+.deps_$(VERSION_KEY):
+	@echo ">>> Please do a 'make depend' <<<"
+	exit 10
+
+ifneq ($(MAKECMDGOALS),distclean)
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),depend)
+include .deps_$(VERSION_KEY)
+endif
+endif
+endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/nonparametrics/NPTrainer.cc work/main.d/Torch-3/nonparametrics/NPTrainer.cc
--- tmp/Torch-3/nonparametrics/NPTrainer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/nonparametrics/NPTrainer.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,48 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "NPTrainer.h"
+
+namespace Torch {
+
+NPTrainer::NPTrainer(Machine *machine_) : Trainer(machine_)
+{
+}
+
+void NPTrainer::train(DataSet* data, MeasurerList *measurers)
+{
+  // almost nothing to do since it is non parametric!
+  machine->setDataSet(data);
+}
+
+NPTrainer::~NPTrainer()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/nonparametrics/NPTrainer.h work/main.d/Torch-3/nonparametrics/NPTrainer.h
--- tmp/Torch-3/nonparametrics/NPTrainer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/nonparametrics/NPTrainer.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,58 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef NPTRAINER_INC
+#define NPTRAINER_INC
+
+#include "Trainer.h"
+
+namespace Torch {
+
+/** Trainer for Non Parametric Machines. This trainer does nothing during
+    training! But it can be used to test Non Parametric models such as
+    KNN or ParzenDistributions or even select a correct hyper-parameter
+    using cross-validation.
+
+    @author Samy Bengio (bengio@idiap.ch)
+ */
+class NPTrainer : public Trainer
+{
+  public:
+
+    NPTrainer(Machine *machine_);
+
+    //-----
+
+    virtual void train(DataSet*, MeasurerList *measurers);
+    virtual ~NPTrainer();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/nonparametrics/ParzenMachine.cc work/main.d/Torch-3/nonparametrics/ParzenMachine.cc
--- tmp/Torch-3/nonparametrics/ParzenMachine.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/nonparametrics/ParzenMachine.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,100 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "ParzenMachine.h"
+
+namespace Torch {
+
+ParzenMachine::ParzenMachine(int n_inputs_,int n_outputs_,real var_)
+{
+  data = NULL;
+  setVar(var_);
+  n_outputs = n_outputs_;
+  n_inputs = n_inputs_;
+  outputs = new(allocator) Sequence(1,n_outputs);
+  n_real_examples = 0;
+  real_examples = NULL;
+}
+
+void ParzenMachine::setVar(real var_)
+{
+  var = var_;
+}
+
+void ParzenMachine::setDataSet(DataSet *dataset_)
+{
+  data = dataset_;
+  n_real_examples = data->n_examples;
+  real_examples = (int*)allocator->realloc(real_examples,n_real_examples*sizeof(int));
+  for (int i=0;i<data->n_examples;i++) {
+    real_examples[i] = data->selected_examples[i];
+  }
+}
+
+void ParzenMachine::forward(Sequence* inputs)
+{
+  // keep current example in order to restore at the end
+  data->pushExample();
+
+  real* out = outputs->frames[0];
+  denominator = 0.;
+  for (int j=0;j<n_outputs;j++)
+    *out++ = 0;
+  int *i_ptr = real_examples;
+  for (int i=0;i<n_real_examples;i++) {
+    data->setRealExample(*i_ptr++);
+    real* in = inputs->frames[0];
+    real* in_i = data->inputs->frames[0];
+    real dist = 0;
+    for (int j=0;j<n_inputs;j++) {
+      real z = *in++ - *in_i++;
+      dist += z*z;
+    }
+    real e = exp(-dist / (2.*var));
+    denominator += e;
+    out = outputs->frames[0];
+    real* targ_i = data->targets->frames[0];
+    for (int j=0;j<n_outputs;j++) {
+      *out++ += *targ_i++ * e;
+    }
+  }
+
+  out = outputs->frames[0];
+  for (int j=0;j<n_outputs;j++)
+    *out++ /= denominator;
+
+  // restore current_example
+  data->popExample();
+}
+
+ParzenMachine::~ParzenMachine()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/nonparametrics/ParzenMachine.h work/main.d/Torch-3/nonparametrics/ParzenMachine.h
--- tmp/Torch-3/nonparametrics/ParzenMachine.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/nonparametrics/ParzenMachine.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,86 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef PARZEN_MACHINE_INC
+#define PARZEN_MACHINE_INC
+
+#include "Machine.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+/** This machine implements the Parzen Window estimator.
+    Given a dataset (in the constructor), the #forward# method returns
+    for a given input the average of the outputs of the training set
+    weighted by a Gaussian kernel distance:
+
+    $ y(x) = \frac{\sum_i t_i \exp(- \frac{||x - x_i||^2}{2 var})}{\sum_i \exp(- \frac{||x - x_i||^2}{2 var})}$
+
+    The only parameter #var# is given in the constructor.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class ParzenMachine : public Machine
+{
+  public:
+
+    /// the variance used
+    real var;
+
+    /// The dataset that contains the training set
+    DataSet* data;
+
+    /// the indices of the training examples
+    int *real_examples;
+    int n_real_examples;
+
+    /// keep the denominator
+    real denominator;
+
+    /// the size of the output vector
+    int n_outputs;
+
+    /// the size of the input vector
+    int n_inputs;
+
+    ///
+    ParzenMachine(int n_inputs_,int n_outputs_,real var_);
+
+    virtual void forward(Sequence *inputs);
+    virtual void setDataSet(DataSet* dataset_);
+
+    /// change the value of var
+    virtual void setVar(real var_);
+
+    virtual ~ParzenMachine();
+};
+
+
+}
+
+#endif
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Allocator.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Allocator.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Bagging.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Bagging.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/BoostingMeasurer.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/BoostingMeasurer.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Boosting.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Boosting.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/ClassFormatDataSet.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/ClassFormatDataSet.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/ClassFormat.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/ClassFormat.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/ClassMeasurer.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/ClassMeasurer.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/ClassNLLMeasurer.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/ClassNLLMeasurer.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/CmdLine.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/CmdLine.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/CmdOption.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/CmdOption.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/DataSet.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/DataSet.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/DiskDataSet.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/DiskDataSet.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/DiskMatDataSet.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/DiskMatDataSet.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/DiskXFile.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/DiskXFile.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/FileListCmdOption.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/FileListCmdOption.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/FrameSelectorDataSet.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/FrameSelectorDataSet.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/general.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/general.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/IOAscii.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/IOAscii.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/IOBin.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/IOBin.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/IOBufferize.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/IOBufferize.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/IOMulti.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/IOMulti.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/IOSequenceArray.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/IOSequenceArray.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/IOSequence.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/IOSequence.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/IOSub.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/IOSub.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/KFold.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/KFold.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/log_add.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/log_add.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Machine.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Machine.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/MatDataSet.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/MatDataSet.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/MeanVarNorm.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/MeanVarNorm.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Measurer.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Measurer.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/MemoryDataSet.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/MemoryDataSet.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/MemoryXFile.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/MemoryXFile.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/MSEMeasurer.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/MSEMeasurer.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/MultiClassFormat.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/MultiClassFormat.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/NullXFile.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/NullXFile.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Object.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Object.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/OneHotClassFormat.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/OneHotClassFormat.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/OutputMeasurer.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/OutputMeasurer.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Parameters.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Parameters.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/PipeXFile.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/PipeXFile.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/PreProcessing.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/PreProcessing.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Random.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Random.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Sequence.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Sequence.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Stack.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Stack.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/string_utils.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/string_utils.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/TimeMeasurer.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/TimeMeasurer.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Timer.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Timer.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/Trainer.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/Trainer.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/TwoClassFormat.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/TwoClassFormat.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/WeightedSumMachine.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/WeightedSumMachine.o differ
Binary files tmp/Torch-3/objs/Linux_OPT_FLOAT/XFile.o and work/main.d/Torch-3/objs/Linux_OPT_FLOAT/XFile.o differ
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/EditDistance.cc work/main.d/Torch-3/speech/EditDistance.cc
--- tmp/Torch-3/speech/EditDistance.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/EditDistance.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,312 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "EditDistance.h"
+#include "XFile.h"
+
+namespace Torch {
+
+EditDistance::EditDistance(bool is_confusion_)
+{
+  obtained = NULL;
+  desired = NULL;
+  obt_size = 0;
+  des_size = 0;
+  insert_cost = 1;
+  delete_cost = 1;
+  subst_cost = 1;
+  is_confusion = is_confusion_;
+  confusion = NULL;
+  conf_ins = NULL;
+  conf_del = NULL;
+  n_confusion = 0;
+  reset();
+}
+
+void EditDistance::setCosts(int i_cost, int d_cost, int s_cost)
+{
+  insert_cost = i_cost;
+  delete_cost = d_cost;
+  subst_cost = s_cost;
+}
+
+void EditDistance::reset()
+{
+  accuracy = 0;
+  n_insert=0;
+  n_delete=0;
+  n_subst=0;
+  n_seq=0;
+  if (confusion) {
+    for (int i=0;i<n_confusion;i++) {
+      for (int j=0;j<n_confusion;j++)
+        confusion[i][j] = 0;
+      conf_ins[i] = 0;
+      conf_del[i] = 0;
+    }
+  }
+}
+
+void EditDistance::distance(int* obtained_, int obt_size_, int* desired_, int des_size_)
+{
+  obtained = obtained_;
+  obt_size = obt_size_;
+  desired = desired_;
+  des_size = des_size_;
+
+  if (is_confusion) {
+    // count the max number of symbols in desired/obtained
+    int the_max = -1;
+    for (int i=0;i<obt_size;i++)
+      if (the_max < obtained[i])
+        the_max = obtained[i];
+    for (int i=0;i<des_size;i++)
+      if (the_max < desired[i])
+        the_max = desired[i];
+    the_max++;
+    // prepare the confusion matrix itself
+    if (n_confusion<the_max) {
+      confusion = (int**)allocator->realloc(confusion,the_max*sizeof(int*));
+      conf_ins = (int*)allocator->realloc(conf_ins,the_max*sizeof(int));
+      conf_del = (int*)allocator->realloc(conf_del,the_max*sizeof(int));
+      for (int i=0;i<n_confusion;i++) {
+        confusion[i] = (int*)allocator->realloc(confusion[i],the_max*sizeof(int));
+      }
+      for (int i=n_confusion;i<the_max;i++) {
+        confusion[i] = (int*)allocator->alloc(the_max*sizeof(int));
+      }
+      for (int i=0;i<the_max;i++) {
+        for (int j=0;j<the_max;j++) 
+          confusion[i][j] = 0;
+        conf_ins[i] = 0;
+        conf_del[i] = 0;
+      }
+      n_confusion = the_max;
+    }
+  }
+
+  n_insert = 0;
+  n_delete = 0;
+  n_subst = 0;
+  int subst;
+  Allocator allocator_;
+  int **d = (int**)allocator_.alloc((des_size+1)*sizeof(int*));
+  int **d_ins = (int**)allocator_.alloc((des_size+1)*sizeof(int*));
+  int **d_del = (int**)allocator_.alloc((des_size+1)*sizeof(int*));
+  int **d_sub = (int**)allocator_.alloc((des_size+1)*sizeof(int*));
+  for (int i=0;i<des_size+1;i++) {
+    d[i] = (int*)allocator_.alloc((obt_size+1)*sizeof(int));
+    d_ins[i] = (int*)allocator_.alloc((obt_size+1)*sizeof(int));
+    d_del[i] = (int*)allocator_.alloc((obt_size+1)*sizeof(int));
+    d_sub[i] = (int*)allocator_.alloc((obt_size+1)*sizeof(int));
+    for (int j=0;j<obt_size+1;j++) {
+      d[i][j] = 0;
+      d_ins[i][j] = 0;
+      d_del[i][j] = 0;
+      d_sub[i][j] = 0;
+    }
+  }
+  int** previous = NULL;
+  if (is_confusion) {
+    // in this table, 1 = subst, 2 = del, 3 = ins
+    previous = (int**)allocator_.alloc((des_size+1)*sizeof(int*));
+    for (int i=0;i<des_size+1;i++) {
+      previous[i] = (int*)allocator_.alloc((obt_size+1)*sizeof(int));
+      for (int j=0;j<obt_size+1;j++)
+        previous[i][j] = 0;
+    }
+  }
+  for (int i=0;i<des_size;i++) {
+    d[i+1][0] = d[i][0] + delete_cost;
+    d_del[i+1][0] = d[i+1][0];
+    if (is_confusion)
+      previous[i+1][0] = 2;
+  }
+  for (int i=0;i<obt_size;i++) {
+    d[0][i+1] = d[0][i] + insert_cost;
+    d_ins[0][i+1] = d[0][i+1];
+    if (is_confusion)
+      previous[0][i+1] = 3;
+  }
+  for (int i=0;i<des_size;i++) {
+    for (int j=0;j<obt_size;j++) {
+      if (desired[i] == obtained[j]) {
+        subst = 0;
+      } else {
+        subst = subst_cost;
+      }
+      int s_cost = d[i][j]+subst;
+      int d_cost = d[i][j+1]+delete_cost;
+      int i_cost = d[i+1][j]+insert_cost;
+      if (s_cost <= d_cost && s_cost <= i_cost) {
+        d[i+1][j+1] = s_cost;
+        d_sub[i+1][j+1] = d_sub[i][j]+subst;
+        d_del[i+1][j+1] = d_del[i][j];
+        d_ins[i+1][j+1] = d_ins[i][j];
+        if (is_confusion)
+          previous[i+1][j+1] = 1;
+      } else if (d_cost <= i_cost && d_cost <= s_cost) {
+        d[i+1][j+1] = d_cost;
+        d_del[i+1][j+1] = d_del[i][j+1]+delete_cost;
+        d_sub[i+1][j+1] = d_sub[i][j+1];
+        d_ins[i+1][j+1] = d_ins[i][j+1];
+        if (is_confusion)
+          previous[i+1][j+1] = 2;
+      } else {
+        d[i+1][j+1] = i_cost;
+        d_ins[i+1][j+1] = d_ins[i+1][j]+insert_cost;
+        d_del[i+1][j+1] = d_del[i+1][j];
+        d_sub[i+1][j+1] = d_sub[i+1][j];
+        if (is_confusion)
+          previous[i+1][j+1] = 3;
+      }
+    }
+  }
+  n_subst = d_sub[des_size][obt_size] / subst_cost;
+  n_delete = d_del[des_size][obt_size] / delete_cost;
+  n_insert = d_ins[des_size][obt_size] / insert_cost;
+  n_seq = des_size;
+  //dist = d[des_size][obt_size];
+  accuracy = (n_seq - n_delete - n_subst - n_insert) * 100. / (real)n_seq;
+
+  if (is_confusion) {
+    int i=des_size;
+    int j=obt_size;
+    while (!(i == 0 && j == 0)) {
+//printf("i = %d j = %d\n",i,j);
+      // what kind of mistake did we do?
+      if (previous[i][j] == 1) {
+        // substitution
+        int s_des = desired[i-1];
+        int s_obt = obtained[j-1];
+        confusion[s_obt][s_des] ++;
+//printf("subst %d %d at (%d,%d)\n",s_des,s_obt,i-1,j-1);
+        i--;
+        j--;
+      } else if (previous[i][j] == 2) {
+        // deletion
+        int s_des = desired[i-1];
+        conf_del[s_des] ++;
+//printf("del %d at (%d,%d)\n",s_des,i-1,j-1);
+        i--;
+      } else if (previous[i][j] == 3) {
+        // insertion
+        int s_obt = obtained[j-1];
+        conf_ins[s_obt] ++;
+//printf("ins %d at (%d,%d)\n",s_obt,i-1,j-1);
+        j--;
+      }
+    }
+  }
+}
+
+void EditDistance::add(EditDistance* d)
+{
+  n_insert += d->n_insert;
+  n_delete += d->n_delete;
+  n_subst += d->n_subst;
+  n_seq += d->n_seq;
+  accuracy = (n_seq - n_delete - n_subst - n_insert) * 100. / (real)n_seq;
+  if (is_confusion) {
+    // should enlarge the matrix if too small
+    if (n_confusion < d->n_confusion) {
+      confusion = (int**)allocator->realloc(confusion,d->n_confusion*sizeof(int*));
+      conf_ins = (int*)allocator->realloc(conf_ins,d->n_confusion*sizeof(int));
+      conf_del = (int*)allocator->realloc(conf_del,d->n_confusion*sizeof(int));
+      for (int i=0;i<n_confusion;i++) {
+        confusion[i] = (int*)allocator->realloc(confusion[i],d->n_confusion*sizeof(int));
+        for (int j=n_confusion;j<d->n_confusion;j++)
+          confusion[i][j] = 0;
+      }
+      for (int i=n_confusion;i<d->n_confusion;i++) {
+        confusion[i] = (int*)allocator->alloc(d->n_confusion*sizeof(int));
+        for (int j=0;j<d->n_confusion;j++)
+          confusion[i][j] = 0;
+        conf_ins[i] = 0;
+        conf_del[i] = 0;
+      }
+      n_confusion = d->n_confusion;
+    }
+    // then add both results
+    for (int i=0;i<d->n_confusion;i++) {
+      for (int j=0;j<d->n_confusion;j++) {
+        confusion[i][j] += d->confusion[i][j];
+      }
+      conf_ins[i] += d->conf_ins[i];
+      conf_del[i] += d->conf_del[i];
+    }
+  }
+}
+
+void EditDistance::print(XFile *f)
+{
+  if (is_confusion) {
+    for (int i=0;i<n_confusion;i++) {
+      int tot=0;
+      for (int j=0;j<n_confusion;j++) {
+        f->printf("%d  ",confusion[i][j]);
+        tot += confusion[i][j];
+      }
+      f->printf(" total %d\n",tot);
+    }
+    f->printf("total\n");
+    for (int j=0;j<n_confusion;j++) {
+      int tot=0;
+      for (int i=0;i<n_confusion;i++) {
+        tot += confusion[i][j];
+      }
+      f->printf("%d  ",tot);
+    }
+    f->printf("\ndel\n");
+    for (int i=0;i<n_confusion;i++)
+      f->printf("%d  ",conf_del[i]);
+    f->printf("\nins\n");
+    for (int i=0;i<n_confusion;i++)
+      f->printf("%d  ",conf_ins[i]);
+    f->printf("\n");
+  }
+
+  f->printf("total %d insert %d delete %d subst %d N %d\n",
+    n_insert+n_delete+n_subst,n_insert,n_delete,n_subst,n_seq);
+
+  f->flush();
+}
+
+void EditDistance::printRatio(XFile *f)
+{
+  f->printf("accuracy %5.2f insert %5.2f delete %5.2f subst %5.2f N %d\n",  
+    accuracy,n_insert*100./n_seq,n_delete*100./n_seq,n_subst*100./n_seq,n_seq);
+  f->flush();
+}
+
+EditDistance::~EditDistance() 
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/EditDistance.h work/main.d/Torch-3/speech/EditDistance.h
--- tmp/Torch-3/speech/EditDistance.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/EditDistance.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,111 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef EDIT_DISTANCE_INC
+#define EDIT_DISTANCE_INC
+
+#include "general.h"
+#include "Object.h"
+
+namespace Torch {
+
+/** This class can be used to compute the "edit distance" between
+    two sequences. It computes the number of insertions, deletions and
+    substitutions. The overall distance is the sum of these numbers
+    weighted by their cost (which are intergers equal to 1 by default).
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class EditDistance : public Object
+{
+  public:
+    /// the total edit distance between two sequences
+    real accuracy;
+    /// the number of insertions (weighted by their cost)
+    int n_insert;
+    /// the number of deletions (weighted by their cost)
+    int n_delete;
+    /// the number of substitutions (weighted by their cost)
+    int n_subst;
+    /// the number of sequences measured (used to normalize #dist# by #n_seq#)
+    int n_seq;
+    /// the cost of one insertion
+    int insert_cost;
+    /// the cost of one deletion
+    int delete_cost;
+    /// the cost of one substitution
+    int subst_cost;
+
+    /// the obtained sequence
+    int* obtained;
+    /// the size of the obtained sequence
+    int obt_size;
+
+    /// the desired sequence
+    int* desired;
+    /// the size of the desired sequence
+    int des_size;
+
+    /// the confusion matrix itself
+    int** confusion;
+    /// the number of symbols
+    int n_confusion;
+    /// insertions and deletions
+    int* conf_ins;
+    int* conf_del;
+    /// do we want a confusion matrix?
+    bool is_confusion;
+
+    ///
+    EditDistance(bool is_confusion_=false);
+
+    /// sets the different costs
+    virtual void setCosts(int i_cost, int d_cost, int s_cost);
+
+    /// computes the edit distance between #obtained# and #desired#.
+    virtual void distance(int* obtained, int obt_size, int* desired, int des_size);
+
+    /// accumulates the distances of the current object and the given object
+    virtual void add(EditDistance* d);
+
+    /// prints the edit distance and optionally the sequences
+    virtual void print(XFile *f);
+
+    /** prints the edit distance ratio (divided by the number of sequnces) 
+        and optionally the obtained and desired sequences
+    */
+    virtual void printRatio(XFile *f);
+
+    virtual void reset();
+    ~EditDistance();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/EditDistanceMeasurer.cc work/main.d/Torch-3/speech/EditDistanceMeasurer.cc
--- tmp/Torch-3/speech/EditDistanceMeasurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/EditDistanceMeasurer.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,64 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "EditDistanceMeasurer.h"
+
+namespace Torch {
+
+EditDistanceMeasurer::EditDistanceMeasurer(EditDistance *edit_, DataSet *data_, XFile *file_,bool is_confusion_) : Measurer(data_, file_)
+{
+  edit = edit_;
+  sum = new(allocator) EditDistance(is_confusion_);
+  addBOption("print example", &print_ex, false, "print example");
+}
+
+void EditDistanceMeasurer::measureExample()
+{
+  if (print_ex)
+    edit->print(file);
+  sum->add(edit);
+}
+
+void EditDistanceMeasurer::measureIteration()
+{
+  sum->print(file);
+  sum->printRatio(file);
+}
+
+void EditDistanceMeasurer::reset()
+{
+  sum->reset();
+}
+
+EditDistanceMeasurer::~EditDistanceMeasurer()
+{
+}
+
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/EditDistanceMeasurer.h work/main.d/Torch-3/speech/EditDistanceMeasurer.h
--- tmp/Torch-3/speech/EditDistanceMeasurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/EditDistanceMeasurer.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,68 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef EDIT_DISTANCE_MEASURER_INC
+#define EDIT_DISTANCE_MEASURER_INC
+
+#include "Measurer.h"
+#include "EditDistance.h"
+#include "DataSet.h"
+
+namespace Torch {
+
+/** This class can be used to measure and print an #EditDistance# object.
+    It is used for instance in speech recognition experiments.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class EditDistanceMeasurer : public Measurer
+{
+  public:
+    /// the #EditDistance# to measure
+    EditDistance *edit;
+
+    /// an accumulator of #EditDistance# objects, to compute statistics
+    EditDistance *sum;
+
+    /// do we print the edit distance for each example?
+    bool print_ex;
+
+    ///
+    EditDistanceMeasurer(EditDistance *edit_, DataSet *data_, XFile *file_,bool is_confusion_=false);
+
+    virtual void reset();
+    virtual void measureExample();
+    virtual void measureIteration();
+
+    virtual ~EditDistanceMeasurer();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/FrameSeg.cc work/main.d/Torch-3/speech/FrameSeg.cc
--- tmp/Torch-3/speech/FrameSeg.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/FrameSeg.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,44 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "FrameSeg.h"
+
+namespace Torch {
+
+FrameSeg::FrameSeg(LexiconInfo* lexicon_) 
+{
+  lexicon = lexicon_;
+}
+
+FrameSeg::~FrameSeg()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/FrameSeg.h work/main.d/Torch-3/speech/FrameSeg.h
--- tmp/Torch-3/speech/FrameSeg.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/FrameSeg.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,69 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef FRAME_SEG_INC
+#define FRAME_SEG_INC
+
+#include "LexiconInfo.h"
+#include "Sequence.h"
+
+namespace Torch {
+
+/** This class keeps track of all information to compute errors at the
+    frame level
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class FrameSeg : public Object
+{
+  public:
+
+    /// the corresponding lexicon
+    LexiconInfo* lexicon;
+    
+    /// the target sequence
+    Sequence* target;
+
+    /// the obtained sequence
+    Sequence* obtained;
+
+    /// the translation between words, states, model_states
+    int* states_to_model_states;
+    int* states_to_model;
+    int* states_to_word;
+
+    ///
+    FrameSeg(LexiconInfo* lexicon_);
+
+    virtual ~FrameSeg();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/FrameSegMeasurer.cc work/main.d/Torch-3/speech/FrameSegMeasurer.cc
--- tmp/Torch-3/speech/FrameSegMeasurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/FrameSegMeasurer.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,191 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "FrameSegMeasurer.h"
+
+namespace Torch {
+
+FrameSegMeasurer::FrameSegMeasurer(FrameSeg* frameseg_, DataSet *data_, XFile *file_,char** file_list_,int n_file_list_) : Measurer(data_, file_)
+{
+  frameseg = frameseg_;
+	file_list = file_list_;
+	n_file_list = n_file_list_;
+  addBOption("print timing", &print_timing, false, "print timing");
+  addBOption("print phoneme timing", &print_phoneme_timing, false, "print phoneme timing");
+  addBOption("print desired timing", &print_desired_timing, false, "print timing for desired");
+  addBOption("print with words", &print_with_words, false, "if timing, print with words");
+  addBOption("print frame err", &print_frame_err, false, "print frame err");
+  addBOption("print soft frame err", &print_soft_frame_err, false, "print soft frame err");
+  addIOption("soft frame err length", &n_soft_frames, 1, "n soft frames");
+  addIOption("n per frame", &n_per_frame, 1, "n per frame");
+}
+
+void FrameSegMeasurer::measureExample()
+{
+	XFile* xfile = file;
+	bool empty = true;
+	if(n_file_list)
+		xfile = new(allocator)DiskXFile(file_list[data->real_current_example_index],"w");
+
+  if (print_desired_timing && frameseg->target->frame_size>1) {
+    int begin = 0;
+    for (int j=0;j<frameseg->target->n_frames;j++) {
+      int end = (int)frameseg->target->frames[j][1]*n_per_frame;
+      xfile->printf("%d %d %s\n",begin,end,frameseg->lexicon->vocabulary->words[(int)frameseg->target->frames[j][0]]);
+      begin = end;
+    }
+	if(!n_file_list)
+    xfile->printf("--------\n");
+  }
+  if (print_timing) {
+    int start_frame = 0;
+    for (int i=0;i<frameseg->obtained->n_frames-1;i++) {
+      int current = (int)frameseg->obtained->frames[i][0];
+      int next = (int)frameseg->obtained->frames[i+1][0];
+      if (current != next && next >=0) {
+				empty = false;
+        if (print_with_words && next>=0) {
+          xfile->printf("%d %d %s-%s-%d\n",start_frame*n_per_frame,(i+1)*n_per_frame,frameseg->lexicon->vocabulary->words[frameseg->states_to_word[next]],frameseg->lexicon->phone_info->phone_names[frameseg->states_to_model[next]],frameseg->states_to_model_states[next]);
+        } else if (!print_with_words && current>=0) {
+          xfile->printf("%d %d %s-%d\n",start_frame*n_per_frame,(i+1)*n_per_frame,frameseg->lexicon->phone_info->phone_names[frameseg->states_to_model[next]],frameseg->states_to_model_states[next]);
+        }
+        start_frame = i+1;
+      }
+    }
+	if(!n_file_list)
+    xfile->printf("========\n");
+  }
+  if (print_phoneme_timing) {
+    int start_frame = 0;
+    for (int i=1;i<frameseg->obtained->n_frames-1;i++) {
+      int current = (int)frameseg->obtained->frames[i][0];
+      int next = (int)frameseg->obtained->frames[i+1][0];
+      int ph_current = current >=0 ? frameseg->states_to_model[current] : -1;
+      int ph_next = next >=0 ? frameseg->states_to_model[next] : -1;
+      if (ph_current != ph_next) {
+				empty = false;
+        if (print_with_words && ph_next>=0) {
+          xfile->printf("%d %d %s-%s\n",start_frame*n_per_frame,(i+1)*n_per_frame,frameseg->lexicon->vocabulary->words[frameseg->states_to_word[current]],frameseg->lexicon->phone_info->phone_names[ph_current]);
+        } else if (!print_with_words && ph_current>=0) {
+          xfile->printf("%d %d %s\n",start_frame*n_per_frame,(i+1)*n_per_frame,frameseg->lexicon->phone_info->phone_names[ph_current]);
+        }
+        start_frame = i+1;
+      }
+    }
+	if(!n_file_list)
+    xfile->printf("========\n");
+  }
+	if(empty && n_file_list)
+		warning("File: %s can be empty",file_list[data->real_current_example_index]);
+  if (print_frame_err && frameseg->target->frame_size>1) {
+    for (int i=0;i<frameseg->obtained->n_frames;i++) {
+      int current = (int)frameseg->obtained->frames[i][0];
+      int obtained_word = current >=0 ? frameseg->states_to_word[current] : -1;
+      // compute desired word
+      int desired_word = -1;
+      int previous = 0;
+      for (int j=0;j<frameseg->target->n_frames;j++) {
+        if (i >= previous && i < frameseg->target->frames[j][1]) {
+          desired_word = (int)frameseg->target->frames[j][0];
+          break;
+        }
+        previous = (int)frameseg->target->frames[j][1];
+      }
+      if (obtained_word != desired_word) {
+        n_incorrect ++;
+      } else {
+        n_correct ++;
+      }
+      n_frames++;
+    }
+  }
+  if (print_soft_frame_err && frameseg->target->frame_size>1) {
+    for (int i=0;i<frameseg->obtained->n_frames;i++) {
+      int current = (int)frameseg->obtained->frames[i][0];
+      int obtained_word = current >= 0 ? frameseg->states_to_word[current] : -1;
+      // compute desired word
+      int desired_word = -1;
+      for (int l=0;l<n_soft_frames;l++) {
+        int previous = 0;
+        for (int j=0;j<frameseg->target->n_frames;j++) {
+          if (i+l >= previous && i+l < frameseg->target->frames[j][1]) {
+            desired_word = (int)frameseg->target->frames[j][0];
+            break;
+          }
+          previous = (int)frameseg->target->frames[j][1];
+        }
+        if (obtained_word == desired_word)
+          break;
+        previous = 0;
+        for (int j=0;j<frameseg->target->n_frames;j++) {
+          if (i-l >= previous && i-l < frameseg->target->frames[j][1]) {
+            desired_word = (int)frameseg->target->frames[j][0];
+            break;
+          }
+          previous = (int)frameseg->target->frames[j][1];
+        }
+        if (obtained_word == desired_word)
+          break;
+      }
+      if (obtained_word != desired_word) {
+        n_incorrect_soft ++;
+      } else {
+        n_correct_soft ++;
+      }
+      n_frames_soft++;
+    }
+  }
+  xfile->flush();
+	if(n_file_list)
+		allocator->free(xfile);	
+}
+
+void FrameSegMeasurer::measureIteration()
+{
+  if (print_frame_err) {
+    file->printf("n_correct %d (%5.2f%%) n_incorrect %d (%5.2f%%) n %d\n",n_correct,100.*n_correct/n_frames,n_incorrect,100.*n_incorrect/n_frames,n_frames);
+  }
+  if (print_soft_frame_err) {
+    file->printf("n_soft_correct %d (%5.2f%%) n_soft_incorrect %d (%5.2f%%) n %d len %d\n",n_correct_soft,100.*n_correct_soft/n_frames_soft,n_incorrect_soft,100.*n_incorrect_soft/n_frames_soft,n_frames_soft,n_soft_frames);
+  }
+  file->flush();
+}
+
+void FrameSegMeasurer::reset()
+{
+  n_correct = n_incorrect = n_frames = 0;
+  n_correct_soft = n_incorrect_soft = n_frames_soft = 0;
+}
+
+FrameSegMeasurer::~FrameSegMeasurer()
+{
+}
+
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/FrameSegMeasurer.h work/main.d/Torch-3/speech/FrameSegMeasurer.h
--- tmp/Torch-3/speech/FrameSegMeasurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/FrameSegMeasurer.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,83 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef FRAME_SEG_MEASURER_INC
+#define FRAME_SEG_MEASURER_INC
+
+#include "Measurer.h"
+#include "FrameSeg.h"
+#include "EditDistance.h"
+
+namespace Torch {
+
+/** This class can be used to save the frame segmentation of a 
+    #SimpleDecoderSpeechHMM#
+    in a file. Optionally, it also prints the corresponding target segmentation.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class FrameSegMeasurer : public Measurer
+{
+  public:
+    /// the pointer to the corresponding frameseg object
+    FrameSeg *frameseg;
+
+    bool print_desired_timing;
+    bool print_with_words;
+    bool print_timing;
+    bool print_phoneme_timing;
+    bool print_frame_err;
+    bool print_soft_frame_err;
+    int n_soft_frames;
+    /// when timing is required, what is the number of tics per frames
+    int n_per_frame;
+
+    /// some stats
+    int n_correct;
+    int n_incorrect;
+    int n_frames;
+    int n_correct_soft;
+    int n_incorrect_soft;
+    int n_frames_soft;
+
+		char** file_list;
+		int n_file_list;
+
+    ///
+    FrameSegMeasurer(FrameSeg* frameseg_, DataSet *data_, XFile *file_,char** file_list_=NULL,int n_file_list_ = 0);
+    virtual void reset();
+    virtual void measureExample();
+    virtual void measureIteration();
+
+    virtual ~FrameSegMeasurer();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/Grammar.cc work/main.d/Torch-3/speech/Grammar.cc
--- tmp/Torch-3/speech/Grammar.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/Grammar.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,56 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "Grammar.h"
+
+namespace Torch {
+
+Grammar::Grammar(int n_words_)
+{
+  n_words = n_words_;
+  words = (int*)allocator->alloc(sizeof(int)*n_words);
+  start = (int*)allocator->alloc(sizeof(int)*n_words);
+  transitions = (bool**)allocator->alloc(sizeof(bool*)*n_words);
+  for (int i=0;i<n_words;i++) {
+    words[i] = -1;
+    start[i] = -1;
+    transitions[i] = (bool*)allocator->alloc(sizeof(bool)*n_words);
+    for (int j=0;j<n_words;j++) {
+      transitions[i][j] = false;
+    }
+  }
+}
+
+Grammar::~Grammar()
+{
+}
+
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/Grammar.h work/main.d/Torch-3/speech/Grammar.h
--- tmp/Torch-3/speech/Grammar.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/Grammar.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,71 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef GRAMMAR_INC
+#define GRAMMAR_INC
+
+#include "Object.h"
+
+namespace Torch {
+
+/** This class contains the grammar of accepted sentences for a
+    speech recognition experiment such as the one using SimpleDecoderSpeechHMM
+    A grammar is a transition table where each node is a word.
+    The user is responsible to set the transition table as he wishes.
+    (by default, there are no transition!)
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class Grammar : public Object
+{
+  public:
+    /** the number of words in the grammar (different than the number
+        of words in the lexicon, because the same word can appear twice
+        in the grammar)
+    */
+    int n_words;
+    /// the index of the words (in the lexicon object)
+    int* words;
+    /** this vector is used in SimpleDecoderSpeechHMM to keep the state 
+        index in the decoding state matrix, corresponding to the given word
+    */
+    int* start;
+    /** the transition matrix. each true transition (i,j) means the
+        word whose index is i can be followed by the word whose index is j
+    */
+    bool** transitions;
+
+    ///
+    Grammar(int n_words_);
+    virtual ~Grammar();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/LICENSE work/main.d/Torch-3/speech/LICENSE
--- tmp/Torch-3/speech/LICENSE	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/LICENSE	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,28 @@
+
+Copyright (c) 2003--2004 Ronan Collobert
+Copyright (c) 2003--2004 Samy Bengio
+Copyright (c) 2003--2004 Johnny Mariéthoz
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/Makefile work/main.d/Torch-3/speech/Makefile
--- tmp/Torch-3/speech/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/Makefile	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,42 @@
+# get user and architecture specific options
+OS := $(shell uname -s)
+TORCHDIR := $(shell cd ..; pwd)
+include ../Makefile_options_$(OS)
+
+CC_FILES := $(wildcard *.cc)
+OBJS := $(foreach f,$(CC_FILES),$(OBJS_DIR)/$(patsubst %.cc,%.o,$(f)))
+
+all:	$(LIBTORCH)
+
+$(LIBTORCH): $(OBJS)
+	@echo "Archiving..."
+	@$(AR) $(LIBTORCH) $(OBJS)
+
+$(OBJS_DIR)/%.o: %.cc
+	@echo $<
+	@$(CC) $(CFLAGS_$(MODE)) $(INCS) -o $@ -c $<
+
+distclean:
+	@\rm -f .deps_*
+
+clean:
+	@echo "Remove objects file and dependencies..."
+	@\rm -Rf $(OBJS) $(LIBTORCH)
+	@\rm -f .deps_$(VERSION_KEY)
+
+depend:
+	@echo "Tracking dependencies..."
+	@\rm -f .deps_$(VERSION_KEY)
+	@for file in *.cc ; do printf "$(OBJS_DIR)/" >> .deps_$(VERSION_KEY); $(DEP) $(CFLAGS_$(MODE)) $(INCS) $$file >> .deps_$(VERSION_KEY); done
+
+.deps_$(VERSION_KEY):
+	@echo ">>> Please do a 'make depend' <<<"
+	exit 10
+
+ifneq ($(MAKECMDGOALS),distclean)
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),depend)
+include .deps_$(VERSION_KEY)
+endif
+endif
+endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/SimpleDecoderSpeechHMM.cc work/main.d/Torch-3/speech/SimpleDecoderSpeechHMM.cc
--- tmp/Torch-3/speech/SimpleDecoderSpeechHMM.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/SimpleDecoderSpeechHMM.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,352 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "SimpleDecoderSpeechHMM.h"
+#include "log_add.h"
+
+namespace Torch {
+
+SimpleDecoderSpeechHMM::SimpleDecoderSpeechHMM(SpeechHMM* model_,Grammar* grammar_) : SpeechHMM(model_->n_models,model_->models,model_->lexicon,NULL)
+{
+  model = model_;
+  grammar = grammar_;
+
+  addROption("log word entrance penalty", &log_word_entrance_penalty, LOG_ONE, "log word entrance penalty");
+  addBOption("forced alignment", &forced_alignment, false, "forced alignment");
+
+  wordseg = new(allocator)WordSeg(lexicon);
+  frameseg = new(allocator)FrameSeg(lexicon);
+
+  n_previous_states = NULL;
+  previous_states = NULL;
+  n_states = nStatesInGrammar();
+  setMaxNStates(n_states);
+}
+
+void SimpleDecoderSpeechHMM::setMaxNStates(int max_n_states_)
+{
+  if (max_n_states_ <= max_n_states)
+    return;
+  // we have to resize the previous_states matrix
+  if (previous_states) {
+    for (int i=0;i<max_n_states;i++) {
+      allocator->free(previous_states[i]);
+    }
+  }
+  n_previous_states = (int*)allocator->realloc(n_previous_states,sizeof(int)*max_n_states_);
+  previous_states = (int**)allocator->realloc(previous_states,sizeof(int*)*max_n_states_);
+  for (int i=0;i<max_n_states_;i++) {
+    previous_states[i] = (int*)allocator->alloc(sizeof(int)*max_n_states_);
+  }
+  SpeechHMM::setMaxNStates(max_n_states_);
+}
+
+
+int SimpleDecoderSpeechHMM::nStatesInGrammar()
+{
+  int grammar_n_states=2;
+  for (int i=1;i<grammar->n_words-1;i++) {
+    int word = grammar->words[i];
+    grammar_n_states += nStatesInWord(word);
+  }
+  return grammar_n_states;
+}
+
+void SimpleDecoderSpeechHMM::prepareTestModel(Sequence* ex)
+{
+  // create the new transition matrix, based on the models and the target sentence
+  // first realloc if necessary
+  int n_frames = ex->n_frames;
+  log_probabilities_s->resize(n_frames);
+  log_alpha->resize(n_frames);
+  log_beta->resize(n_frames);
+  arg_viterbi->resize(n_frames);
+  viterbi_sequence->resize(n_frames);
+
+  // then put all transitions to 0
+  for (int i=0;i<n_states;i++) {
+    for (int j=0;j<n_states;j++) {
+      log_transitions[i][j] = LOG_ZERO;
+      word_transitions[i][j] = false;
+    }
+  }
+
+  // then create the new transition matrix
+  states_to_word[0] = -1;
+  states_to_model_states[0] = -1;
+  states_to_model[0] = -1;
+  states[0] = NULL;
+  states[n_states-1] = NULL;
+  // the transitions from the initial state
+  // first count the total probability, and normalize it
+  real total_prob = 0;
+  for (int i=1;i<grammar->n_words-1;i++) {
+    if (grammar->transitions[i][0]) {
+      int m = grammar->words[i];
+      int lex_ind = lexicon->vocab_to_lex_map[m].pronuns[0];
+      LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+      int p = lex_ent->phones[0];
+      for (int k=1;k<models[p]->n_states;k++)
+        total_prob += exp(models[p]->log_transitions[k][0]);
+    }
+  }
+  // then update the probabilities
+  int j=1;
+  real log_total_prob = log(total_prob);
+  for (int i=1;i<grammar->n_words-1;i++) {
+    if (grammar->transitions[i][0]) {
+      int m = grammar->words[i];
+      int lex_ind = lexicon->vocab_to_lex_map[m].pronuns[0];
+      LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+      int p = lex_ent->phones[0];
+      for (int k=1;k<models[p]->n_states;k++)
+        log_transitions[j+k-1][0] = models[p]->log_transitions[k][0] - 
+          log_total_prob;
+      j += nStatesInWord(m);
+    }
+  }
+
+  //then, for each word in the grammar, add it
+  int current_state = 1;
+  for (int i=1;i<grammar->n_words-1;i++) {
+    grammar->start[i] = current_state;
+    current_state = addWordToModel(grammar->words[i],current_state);
+  }
+  // then add the transitions between words
+  for (int i=1;i<grammar->n_words-1;i++) {
+    int word = grammar->words[i];
+    int lex_ind = lexicon->vocab_to_lex_map[word].pronuns[0];
+    LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+    // count the transitions starting from word
+    real log_n_transitions = 0;
+    for (int j=1;j<grammar->n_words;j++) {
+      log_n_transitions += (grammar->transitions[j][i]);
+    }
+    log_n_transitions = log_n_transitions>0 ? log(log_n_transitions) : LOG_ONE;
+    for (int j=1;j<grammar->n_words;j++) {
+      if (grammar->transitions[j][i]) {
+        int next_word = grammar->words[j];
+        if (next_word != -1) {
+          // add transitions between words
+          addConnectionsBetweenWordsToModel(word,next_word,grammar->start[i],
+            grammar->start[j],log_n_transitions);
+        } else {
+          // add last transitions
+          int current_model = lex_ent->phones[lex_ent->n_phones-1];
+          int n_states_in_model = models[current_model]->n_states;
+          int n_states_in_word = nStatesInWord(word);
+          int last_state = n_states-1;
+          for (int k=1;k<n_states_in_model-1;k++)
+            log_transitions[last_state][grammar->start[i]+n_states_in_word-n_states_in_model+2+k-1] = models[current_model]->log_transitions[n_states_in_model-1][k];
+        }
+      }
+    }
+  }
+/*
+  printTransitions(false,true);
+  for (int i=0;i<n_states;i++) {
+    printf("state %d corresponds to state %d in model %d in word %d\n",i,states_to_model_states[i],states_to_model[i],states_to_word[i]);
+  }
+*/
+}
+
+void SimpleDecoderSpeechHMM::setDataSet(DataSet* data_)
+{
+  data = data_;
+}
+
+void SimpleDecoderSpeechHMM::logProbabilities(Sequence *inputs)
+{
+  for (int f=0;f<inputs->n_frames;f++) {
+    for (int i=0;i<n_models;i++) {
+      if (models[i]->n_shared_states == 0) {
+        for (int j=1;j<models[i]->n_states-1;j++) {
+          models[i]->states[j]->frameLogProbability(f, inputs->frames[f]);
+        }
+      } else {
+        for (int j=0;j<models[i]->n_shared_states;j++) {
+          models[i]->shared_states[j]->frameLogProbability(f, inputs->frames[f]);
+        }
+      }
+    }
+    for (int i=1;i<n_states-1;i++) {
+      log_probabilities_s->frames[f][i] = states[i]->log_probabilities->frames[f][0];
+    }
+  }
+}
+
+void SimpleDecoderSpeechHMM::setPreviousStates()
+{
+  for (int i=0;i<n_states;i++) {
+    n_previous_states[i] = 0;
+    for (int j=0;j<n_states;j++) {
+      if (log_transitions[i][j] != LOG_ZERO)
+        n_previous_states[i]++;
+    }
+    int k=0;
+    for (int j=0;j<n_states;j++) {
+      if (log_transitions[i][j] != LOG_ZERO)
+        previous_states[i][k++] = j;
+    }
+  }
+}
+
+void SimpleDecoderSpeechHMM::logViterbi(Sequence* inputs)
+{
+  // first, initialize everything to LOG_ZERO
+  for (int f=0;f<inputs->n_frames;f++) {
+    for (int i=0;i<n_states;i++) {
+      log_alpha->frames[f][i] = LOG_ZERO;
+    }
+  }
+  // case for first frame
+  for (int i=1;i<n_states-1;i++) {
+    if (log_transitions[i][0] == LOG_ZERO)
+      continue;
+    log_alpha->frames[0][i] = log_probabilities_s->frames[0][i] +
+      log_transitions[i][0];
+    arg_viterbi->frames[0][i] = 0.0;
+  }
+  // other cases
+  for (int f=1;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      for (int k=0;k<n_previous_states[i];k++) {
+        int j = previous_states[i][k];
+        real v = log_transitions[i][j] + log_probabilities_s->frames[f][i] +
+          log_alpha->frames[f-1][j];
+        if (word_transitions[i][j]) {
+          v += log_word_entrance_penalty;
+        }
+        if (log_alpha->frames[f][i] < v) {
+          log_alpha->frames[f][i] = v;
+          arg_viterbi->frames[f][i] = (real)j;
+        }
+      }
+    }
+  }
+  // last case
+  log_probability = LOG_ZERO;
+  int f = inputs->n_frames-1;
+  int i = n_states-1;
+  for (int j=1;j<n_states-1;j++) {
+    if (log_transitions[i][j] == LOG_ZERO)
+      continue;
+    real v = log_alpha->frames[f][j]+log_transitions[i][j];
+    if (log_probability < v) {
+      log_probability = v;
+      last_arg_viterbi = j;
+    }
+  }
+  if (log_probability > LOG_ZERO) {
+    // now recall the state sequence
+    viterbi_sequence->frames[inputs->n_frames-1][0] = (real)last_arg_viterbi;
+    for (int f=inputs->n_frames-2;f>=0;f--) {
+      viterbi_sequence->frames[f][0] = (real)(arg_viterbi->frames[f+1][(int)(viterbi_sequence->frames[f+1][0])]);
+    }
+  } else {
+    warning("sequence impossible to decode: probably too short for grammar");
+    for (int f=0;f<inputs->n_frames;f++)
+      viterbi_sequence->frames[f][0] = -1;
+    log_probability = 0;
+  }
+}
+
+void SimpleDecoderSpeechHMM::decode(Sequence* ex)
+{
+  for (int i=0;i<n_models;i++)
+    models[i]->eMSequenceInitialize(ex);
+  if (forced_alignment) {
+    prepareTrainModel(ex);
+    log_probabilities_s->resize(ex->n_frames);
+    log_alpha->resize(ex->n_frames);
+    log_beta->resize(ex->n_frames);
+    arg_viterbi->resize(ex->n_frames);
+    viterbi_sequence->resize(ex->n_frames);
+  } else
+    prepareTestModel(ex);
+  setPreviousStates();
+  logProbabilities(ex);
+  logViterbi(ex);
+
+	// keep in memory the word sequence
+  wordseg->resize(ex->n_frames);
+
+  // convert the state sequence to a word sequence
+  wordseg->word_sequence_size = 0;
+  int previous_state = -1;
+  for (int i=0;i<ex->n_frames;i++) {
+    int state = (int)viterbi_sequence->frames[i][0];
+    int word = state>=0 ? states_to_word[state] : lexicon->vocabulary->sil_index;
+    // do not keep silences and register each time we exit a model
+    if (word != lexicon->vocabulary->sent_start_index &&
+        word != lexicon->vocabulary->sent_end_index &&
+        word != lexicon->vocabulary->sil_index) {
+      if ((previous_state == -1) ||
+          (previous_state>=0 && word_transitions[state][previous_state])) {
+        //wordseg->word_sequence_time[wordseg->word_sequence_size] = i>0 ? i-1 : i;
+        wordseg->word_sequence_time[wordseg->word_sequence_size] = i;
+        wordseg->word_sequence[wordseg->word_sequence_size++] = word;
+      }
+    }
+    previous_state = state;
+  }
+
+  // keep in memory the target word sequence
+  if (data->targets) {
+    setTargets(data->targets);
+    int t_f = targets->n_frames;
+    wordseg->resizeTargets(t_f);
+
+    int j=0;
+    for (int i=0;i<t_f;i++) {
+      int word = (int)targets->frames[i][0];
+      if (word != lexicon->vocabulary->sent_start_index &&
+          word != lexicon->vocabulary->sent_end_index &&
+          word != lexicon->vocabulary->sil_index) {
+        wordseg->target_word_sequence[j++] = word;
+      }
+    }
+    wordseg->target_word_sequence_size = j;
+    
+    frameseg->states_to_model = states_to_model;
+    frameseg->states_to_model_states = states_to_model_states;
+    frameseg->states_to_word = states_to_word;
+    frameseg->target = targets;
+    frameseg->obtained = viterbi_sequence;
+  }
+
+  //outputs->frames[0][0] = edit_distance->accuracy;
+}
+
+SimpleDecoderSpeechHMM::~SimpleDecoderSpeechHMM()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/SimpleDecoderSpeechHMM.h work/main.d/Torch-3/speech/SimpleDecoderSpeechHMM.h
--- tmp/Torch-3/speech/SimpleDecoderSpeechHMM.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/SimpleDecoderSpeechHMM.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,115 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SIMPLE_DECODER_SPEECH_HMM_INC
+#define SIMPLE_DECODER_SPEECH_HMM_INC
+
+#include "SpeechHMM.h"
+#include "Grammar.h"
+#include "WordSeg.h"
+#include "FrameSeg.h"
+
+namespace Torch {
+
+/** This class implements a special case of Hidden Markov Models that
+    can be used to do connected word speech recognition for small
+    vocabulary, using embedded training.
+
+    It contains a #SpeechHMM# and a grammar (which states
+    the legal sentences of the langage).
+
+    The decoding is done by creating the whole transition matrix
+    and hence is not adapted to large vocabulary problems.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class SimpleDecoderSpeechHMM : public SpeechHMM
+{
+  public:
+
+    /// The trained SpeechHMM model to decode
+    SpeechHMM* model;
+
+    /// the acceptable grammar
+    Grammar* grammar;
+
+    /// the object containing target and obtained word sequences
+    WordSeg* wordseg;
+    FrameSeg* frameseg;
+
+    /// log word entrance penalty: during viterbi, penalizes large sentences
+    real log_word_entrance_penalty;
+    /// should we perform forced alignment or real decoding?
+    bool forced_alignment;
+
+    /// for each state, how many previous states
+    int* n_previous_states;
+    /// for each state, the list of previous states
+    int** previous_states;
+
+
+    /** In order to create a SimpleDecoderSpeechHMM, we need to give a vector of #n_models_#
+        #HMM#s as well as their corresponding name, a lexicon and a grammar,
+        an optional log_word_entrance_penalty and an optional trainer that can be
+        used to initialize each model independently.
+    */
+    SimpleDecoderSpeechHMM(SpeechHMM* model, Grammar* grammar_);
+
+    /// this method sets the test data set to be used
+    virtual void setDataSet(DataSet* data_);
+
+    /** this method redefine the normal logViterbi class with 
+        constraint on word entrance */
+    virtual void logViterbi(Sequence* inputs);
+
+    /// this method returns the sentence associated to the input
+    virtual void decode(Sequence* input);
+
+    /// this method computes more efficiently the emission probabilities
+    virtual void logProbabilities(Sequence *inputs);
+
+    /// prepare structure previous_states and n_previous_states
+    virtual void setPreviousStates();
+
+    /** this method prepare the transition graph associated with a
+        given test sentence
+    */
+    virtual void prepareTestModel(Sequence* input);
+
+    /// this methods returns the number of states in the grammar
+    virtual int nStatesInGrammar();
+
+    virtual void setMaxNStates(int max_n_states_);
+
+    virtual ~SimpleDecoderSpeechHMM();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/SpeechHMM.cc work/main.d/Torch-3/speech/SpeechHMM.cc
--- tmp/Torch-3/speech/SpeechHMM.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/SpeechHMM.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,779 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "SpeechHMM.h"
+#include "log_add.h"
+
+namespace Torch {
+
+SpeechHMM::SpeechHMM(int n_models_, HMM **models_, LexiconInfo* lex_, EMTrainer** model_trainer_) : HMM(0,(Distribution**)models_,NULL)
+{
+  n_models = n_models_;
+  data = NULL;
+  models = models_;
+  max_n_states = 1;
+  initial_models_trainer_measurers = NULL;
+  addROption("prior transitions", &prior_transitions , 1e-3, "minimum weights for each gaussians");
+  addBOption("targets are phonemes", &phoneme_targets, false, "for initialization, targets are often phonemes instead of words");
+  model_trainer = model_trainer_;
+  lexicon = lex_;
+
+  add_to_targets = 0;
+  targets = new(allocator) Sequence(1,1);
+
+  for (int i=0;i<n_models;i++) {
+    params->add(models[i]->params);
+    der_params->add(models[i]->der_params);
+  }
+  // find the longest sequence in the dataset
+  // in terms of frames and number of states of the graph
+  log_probabilities_s = new (allocator)Sequence(1,max_n_states);
+  log_alpha = new (allocator)Sequence(1,max_n_states);
+  log_beta = new (allocator)Sequence(1,max_n_states);
+  arg_viterbi = new (allocator)Sequence(1,max_n_states);
+  viterbi_sequence = new (allocator)Sequence(1,1);
+  states = (Distribution**)allocator->alloc(sizeof(Distribution*)*max_n_states);
+  states_to_model_states = (int*)allocator->alloc(sizeof(int)*max_n_states);
+  states_to_model = (int*)allocator->alloc(sizeof(int)*max_n_states);
+  states_to_word = (int*)allocator->alloc(sizeof(int)*max_n_states);
+  log_transitions = (real**)allocator->alloc(sizeof(real*)*max_n_states);
+  word_transitions = (bool**)allocator->alloc(sizeof(bool*)*max_n_states);
+  for (int i=0;i<max_n_states;i++) {
+    log_transitions[i] = (real*)allocator->alloc(sizeof(real)*max_n_states);;
+    word_transitions[i] = (bool*)allocator->alloc(sizeof(bool)*max_n_states);;
+    for (int j=0;j<max_n_states;j++) {
+      log_transitions[i][j] = LOG_ZERO;
+      word_transitions[i][j] = false;
+    }
+  }
+}
+
+
+void SpeechHMM::setMaxNStates(int max_n_states_)
+{
+  if(max_n_states_ <= max_n_states)
+    return;
+  for (int i=0;i<max_n_states;i++) {
+    allocator->free(log_transitions[i]);
+    allocator->free(word_transitions[i]);
+  }
+  max_n_states = max_n_states_;
+
+  allocator->free(log_probabilities_s);
+  allocator->free(log_alpha);
+  allocator->free(log_beta);
+  allocator->free(arg_viterbi);
+
+  log_probabilities_s = new (allocator)Sequence(1,max_n_states);
+  log_alpha = new (allocator)Sequence(1,max_n_states);
+  log_beta = new (allocator)Sequence(1,max_n_states);
+  arg_viterbi = new (allocator)Sequence(1,max_n_states);
+
+  states = (Distribution**)allocator->realloc(states,sizeof(Distribution*)*max_n_states);
+  states_to_model_states = (int*)allocator->realloc(states_to_model_states, sizeof(int)*max_n_states);
+  states_to_model = (int*)allocator->realloc(states_to_model, sizeof(int)*max_n_states);
+  states_to_word = (int*)allocator->realloc(states_to_word, sizeof(int)*max_n_states);
+  log_transitions = (real**)allocator->realloc(log_transitions, sizeof(real*)*max_n_states);
+  word_transitions = (bool**)allocator->realloc(word_transitions, sizeof(bool*)*max_n_states);
+
+  for (int i=0;i<max_n_states;i++) {
+    log_transitions[i] = (real*)allocator->alloc(sizeof(real)*max_n_states);;
+    word_transitions[i] = (bool*)allocator->alloc(sizeof(bool)*max_n_states);;
+    for (int j=0;j<max_n_states;j++) {
+      log_transitions[i][j] = LOG_ZERO;
+      word_transitions[i][j] = false;
+    }
+  }
+}
+
+void SpeechHMM::loadXFile(XFile *file)
+{
+  for (int i=0;i<n_models;i++)
+    models[i]->loadXFile(file);
+}
+
+void SpeechHMM::saveXFile(XFile *file)
+{
+  for (int i=0;i<n_models;i++)
+    models[i]->saveXFile(file);
+}
+
+void SpeechHMM::setTargets(Sequence* t)
+{
+  if (!phoneme_targets && add_to_targets > 0) {
+    if (targets->frame_size != t->frame_size) {
+      allocator->free(targets);
+      targets = new(allocator) Sequence(t->n_frames+add_to_targets,t->frame_size);
+    } else
+      targets->resize(t->n_frames+add_to_targets);
+    int j=0;
+    if (lexicon->vocabulary->sil_index >= 0) {
+      if (t->frame_size > 1)
+        targets->frames[j][1] = 1; // silence lasts 1 frame
+      targets->frames[j++][0] = lexicon->vocabulary->sil_index;
+    }
+    for (int i=0;i<t->n_frames;i++,j++) {
+      for (int k=0;k<t->frame_size;k++) {
+        targets->frames[j][k] = t->frames[i][k];
+      }
+    }
+    if (lexicon->vocabulary->sent_end_index >= 0) {
+      if (t->frame_size > 1) {
+        targets->frames[j][1] = t->frames[t->n_frames-1][1];
+        targets->frames[j-1][1] = t->frames[t->n_frames-1][1]-1;
+      }
+      targets->frames[j++][0] = lexicon->vocabulary->sent_end_index;
+    }
+  } else
+    targets = t;
+}
+
+void SpeechHMM::splitDataSet(DataSet* data_, ExampleFrameSelectorDataSet** split_data_)
+{
+  // just print some informations
+  data_->setExample(0);
+  message("SpeechHMM: Targets are given as %s",phoneme_targets ? "phonemes" : "words");
+  message("SpeechHMM: Targets are given %s alignments",data_->targets->frame_size > 1 ? "with" : "without");
+
+  for (int i=0; i<data_->n_examples; i++) {
+    data_->setExample(i);
+    setTargets(data_->targets);
+    Sequence* inputs = data_->inputs;
+    int n_frames = inputs->n_frames;
+
+    if(targets->frame_size > 1) {
+      // we have the alignment
+      for (int j=0;j<targets->n_frames;j++) {
+        int unit = (int)targets->frames[j][0];
+        real begin_unit = j == 0 ? 0. : targets->frames[j-1][1];
+        real end_unit = targets->frames[j][1];
+        if (phoneme_targets) {
+          // the alignment is given in terms of phonemes
+          int bu = (int)begin_unit;
+          int eu = (int)end_unit;
+          if (eu > n_frames) {
+            warning("The target alignment has been truncated from %d to %d",eu,n_frames-1);
+            eu = n_frames;
+          }
+          int length = eu - bu;
+          split_data_[unit]->addExample(i, bu, length, j,  1);
+        } else {
+          // the alignment is given in terms of words
+          real n_frames_in_word = end_unit - begin_unit;
+          // will work for the first pronunciation only!
+          int n_states_in_word = 0;
+          int lex_ind = lexicon->vocab_to_lex_map[unit].pronuns[0];
+          LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+          for (int k=0;k<lex_ent->n_phones;k++) {
+            int phoneme = lex_ent->phones[k];
+            n_states_in_word += models[phoneme]->n_states-2;    
+          }
+          real n_frames_per_state = n_frames_in_word/n_states_in_word;
+          // finaly bordel a noeud the index!!!
+          real begin_phoneme = begin_unit;
+          real end_phoneme;
+          for (int k=0;k<lex_ent->n_phones;k++) {
+            int phoneme = lex_ent->phones[k];
+            end_phoneme = begin_phoneme + n_frames_per_state * 
+              (models[phoneme]->n_states-2);
+            int bu = (int)begin_phoneme;
+            int eu = (int)end_phoneme;
+            if (eu >= n_frames) {
+              warning("SpeechHMM::splitData: The target alignment has been truncated from %d to %d",eu,n_frames-1);
+              eu = n_frames - 1;
+            }
+            int length = eu - bu;
+            split_data_[phoneme]->addExample(i, bu, length, j,  1);
+            begin_phoneme = end_phoneme;
+          }
+        }
+      }
+    } else {
+      //linear alignment!
+      if (phoneme_targets) {
+        // targets are phonemes
+        //find the total number of states in the example
+        int tot_n_states = 0;
+        for( int j=0;j<targets->n_frames;j++) {
+          int phoneme = (int)targets->frames[j][0];
+          tot_n_states += models[phoneme]->n_states-2;
+        }
+        //then assign frames for each phoneme model
+        real n_frames_per_state = (real)n_frames/tot_n_states;
+        real begin_phoneme = 0.;
+        for( int j=0;j<targets->n_frames;j++) {
+          int phoneme = (int)targets->frames[j][0];
+          real end_phoneme = begin_phoneme + n_frames_per_state *
+              (models[phoneme]->n_states-2);
+          int ib = (int)begin_phoneme;
+          int ie = (int)end_phoneme;
+          if (ie >= n_frames) {
+            ie = n_frames - 1;
+          }
+          int length = ie - ib;
+          if (length < 1) {
+            warning("a segmentation produced a sequence of frames (%d) less than then number of states (%d) of the model",n_frames,tot_n_states);
+          } else
+            split_data_[phoneme]->addExample(i, ib, length, j,  1);
+          begin_phoneme = end_phoneme;
+        }
+      } else {
+        // targets are given in terms of words
+        //this will work with the first pronounciation of each word only!!!
+        //find the total number of states in the example
+        int tot_n_states = 0;
+        for( int j=0;j<targets->n_frames;j++) {
+          int word = (int)targets->frames[j][0];
+          int lex_ind = lexicon->vocab_to_lex_map[word].pronuns[0];
+          LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+          for (int k=0;k<lex_ent->n_phones;k++) {
+            int phoneme = lex_ent->phones[k];
+            tot_n_states += models[phoneme]->n_states-2;
+          }
+        }
+        //then assign frames for each phoneme model
+        real n_frames_per_state = (real)n_frames/tot_n_states;
+        real begin_phoneme = 0.;
+        for(int j=0;j<targets->n_frames;j++) {
+          int word = (int)targets->frames[j][0];
+          int lex_ind = lexicon->vocab_to_lex_map[word].pronuns[0];
+          LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+          for (int k=0;k<lex_ent->n_phones;k++) {
+            int phoneme = lex_ent->phones[k];
+            real end_phoneme = begin_phoneme + n_frames_per_state *
+              (models[phoneme]->n_states-2);
+            int ib = (int)begin_phoneme;
+            int ie = (int)end_phoneme;
+            if (ie >= n_frames) {
+              ie = n_frames - 1;
+            }
+            int length = ie - ib;
+            if (length < 1) {
+              warning("a segmentation produced a sequence of frames (%d) less than then number of states (%d) of the model",n_frames,tot_n_states);
+            } else
+              split_data_[phoneme]->addExample(i, ib, length, j,  1);
+            begin_phoneme = end_phoneme;
+          }
+        }
+      }
+    }
+  }
+}
+
+void SpeechHMM::setDataSet(DataSet* data_)
+{
+  // if alignment information is given in the dataset, use it.
+  // otherwise, do a linear alignment along the states
+
+  data = data_;
+
+  add_to_targets = 0;
+  if (!phoneme_targets) {
+    if (lexicon->vocabulary->sil_index >= 0)
+      add_to_targets++;
+    if (lexicon->vocabulary->sent_end_index >= 0)
+      add_to_targets++;
+  }
+
+  if (initialize) {
+    // initialize model
+    ExampleFrameSelectorDataSet** sub_dataset = (ExampleFrameSelectorDataSet**)allocator->alloc(sizeof(ExampleFrameSelectorDataSet*)*n_models);
+    for (int m=0;m<n_models;m++) {
+      sub_dataset[m] = new(allocator) ExampleFrameSelectorDataSet(data_);
+    }
+    splitDataSet(data_, sub_dataset);
+
+    for (int m=0;m<n_models;m++) {
+      // the transitions and emission parameters will be set in each model
+      if (sub_dataset[m]->n_examples==0) {
+          message("KMeans initialization of model %d with all data",m);
+          models[m]->setDataSet(data_);
+      } else if (model_trainer) {
+          message("HMM initialization of model %d with own aligned data",m);
+          model_trainer[m]->train(sub_dataset[m], initial_models_trainer_measurers);
+      } else {
+          message("KMeans initialization of model %d with own aligned data",m);
+          models[m]->setDataSet(sub_dataset[m]);
+      }
+    }
+  } else {
+    // we still need to set the dataset of each model
+    for (int m=0;m<n_models;m++) {
+      models[m]->setDataSet(data_);
+    }
+  }
+}
+
+void SpeechHMM::addConnectionsBetweenWordsToModel(int word,int next_word, int current_state,int next_current_state, real log_n_next)
+{
+  int n_states_word_pronun = 0;
+  int n_pronuns = lexicon->vocab_to_lex_map[word].n_pronuns;
+  for (int l=0;l<n_pronuns;l++) {
+    int lex_ind = lexicon->vocab_to_lex_map[word].pronuns[l];
+    LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+    int current_model = lex_ent->phones[lex_ent->n_phones-1];
+    int n_states_model = models[current_model]->n_states;
+    int n_states_next_word_pronun = 0;
+    int n_pronuns_next = lexicon->vocab_to_lex_map[next_word].n_pronuns;
+    int n_states_current_word_pronun = nStatesInWordPronunciation(word,l);
+    n_states_word_pronun += n_states_current_word_pronun;
+    for (int m=0;m<n_pronuns_next;m++) {
+      int next_lex_ind = lexicon->vocab_to_lex_map[next_word].pronuns[m];
+      LexiconInfoEntry *next_lex_ent = &lexicon->entries[next_lex_ind];
+      int next_model = next_lex_ent->phones[0];
+      int n_states_next_model = models[next_model]->n_states;
+      for (int j=1;j<n_states_model;j++) {
+        if (models[current_model]->log_transitions[n_states_model-1][j] != LOG_ZERO) {
+          for (int k=1;k<n_states_next_model-1;k++) {
+            if (models[next_model]->log_transitions[k][0] != LOG_ZERO) {
+              log_transitions[next_current_state+n_states_next_word_pronun+k-1][current_state+n_states_word_pronun-n_states_model+1+j] = 
+                models[current_model]->log_transitions[n_states_model-1][j] +
+                models[next_model]->log_transitions[k][0] - log_n_next;
+              word_transitions[next_current_state+n_states_next_word_pronun+k-1][current_state+n_states_word_pronun-n_states_model+1+j] = true;
+            }
+          }
+        }
+      }
+      n_states_next_word_pronun += nStatesInWordPronunciation(next_word,m);
+    }
+  }
+}
+
+int SpeechHMM::addWordToModel(int word, int current_state)
+{
+  int n_pronuns = lexicon->vocab_to_lex_map[word].n_pronuns;
+  for (int i=0;i<n_pronuns;i++) {
+    int lex_ind = lexicon->vocab_to_lex_map[word].pronuns[i];
+    LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+    // for each phoneme
+    for (int l=0;l<lex_ent->n_phones;l++) {
+      int current_model = lex_ent->phones[l];
+      // for each emitting state of the current model
+      int n_states_model = models[current_model]->n_states;
+      for (int j=1;j<n_states_model-1;j++,current_state++) {
+//printf("In word %d Loading model %d state %d into state %d\n",word, current_model, j, current_state);
+        states[current_state] = models[current_model]->states[j];
+        states_to_model_states[current_state] = j;
+        states_to_model[current_state] = current_model;
+        states_to_word[current_state] = word;
+        // for each transition from current_state
+        for (int k=1;k<n_states_model-1;k++) {
+          log_transitions[current_state+k-j][current_state] = 
+            models[current_model]->log_transitions[k][j];
+        }
+      }
+      // add transitions between phonemes
+      if (l<lex_ent->n_phones-1) {
+        int next_model = lex_ent->phones[l+1];
+        int n_states_next_model = models[next_model]->n_states;
+        for (int j=1;j<n_states_model;j++) {
+           if (models[current_model]->log_transitions[n_states_model-1][j] != LOG_ZERO) {
+           for (int k=1;k<n_states_next_model-1;k++) {
+              if (models[next_model]->log_transitions[k][0] != LOG_ZERO)
+                log_transitions[current_state+k-1][current_state-n_states_model+1+j] = 
+                  models[current_model]->log_transitions[n_states_model-1][j] +
+                  models[next_model]->log_transitions[k][0];
+            }
+          }
+        }
+      }
+    }
+  }
+  return current_state;
+}
+
+void SpeechHMM::prepareTrainModel(Sequence* inputs)
+{
+  // create the new transition matrix, based on the models and the target sentence
+  setTargets(data->targets);
+  n_states = 2;
+  for (int j=0;j<targets->n_frames;j++) {
+    int word = (int)targets->frames[j][0];
+    int n_pronuns = lexicon->vocab_to_lex_map[word].n_pronuns;
+    for (int l=0;l<n_pronuns;l++) {
+      int lex_ind = lexicon->vocab_to_lex_map[word].pronuns[l];
+      LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+      // for each phoneme
+      for (int k=0;k<lex_ent->n_phones;k++) {
+        int current_model = lex_ent->phones[k];
+        n_states += models[current_model]->n_states-2;
+      }
+    }
+  }
+  // first realloc if necessary and test for minimum sequence length
+  if (inputs->n_frames < n_states-2)
+    warning("your sentence has %d frames where your HMM model has %d emitting states", inputs->n_frames,n_states-2);
+  setMaxNStates(n_states);
+
+  // then put all transitions to 0
+  for (int i=0;i<n_states;i++) {
+    for (int j=0;j<n_states;j++) {
+      log_transitions[i][j] = LOG_ZERO;
+      word_transitions[i][j] = false;
+    }
+  }
+
+  // the transitions from the initial state
+  int word = (int)targets->frames[0][0];
+  int lex_ind = lexicon->vocab_to_lex_map[word].pronuns[0];
+  LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+  int current_model = lex_ent->phones[0];
+  states_to_model_states[0] = 0;
+  states_to_model[0] = current_model;
+  states_to_word[0] = word;
+  states[0] = NULL;
+  states[n_states-1] = NULL;
+  int n_states_in_word = 0;
+  int n_pronuns = lexicon->vocab_to_lex_map[word].n_pronuns;
+  real norm = log((real)n_pronuns);
+  for (int i=0;i<n_pronuns;i++) {
+    lex_ind = lexicon->vocab_to_lex_map[word].pronuns[i];
+    lex_ent = &lexicon->entries[lex_ind];
+    int current_model = lex_ent->phones[0];
+    for (int j=1;j<models[current_model]->n_states;j++)
+      log_transitions[n_states_in_word+j][0] = models[current_model]->log_transitions[j][0] - norm;
+    n_states_in_word += nStatesInWordPronunciation(word,i);
+  }
+  int current_state = 1;
+  for (int i=0;i<targets->n_frames;i++) {
+    word = (int)targets->frames[i][0];
+    n_pronuns = lexicon->vocab_to_lex_map[word].n_pronuns;
+    int next_current_state = addWordToModel(word, current_state);
+    if (i<targets->n_frames-1) {
+      int next_word = (int)targets->frames[i+1][0];
+      // add transitions between words
+      int n_pronuns_next = lexicon->vocab_to_lex_map[next_word].n_pronuns;
+      norm = log((real)n_pronuns*n_pronuns_next);
+      addConnectionsBetweenWordsToModel(word,next_word,current_state,
+        next_current_state,norm);
+    } else {
+      // add last transitions
+      n_states_in_word = 0;
+      for (int k=0;k<n_pronuns;k++) {
+        n_states_in_word += nStatesInWordPronunciation(word,k);
+        int lex_ind = lexicon->vocab_to_lex_map[word].pronuns[k];
+        LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+        int current_model = lex_ent->phones[lex_ent->n_phones-1];
+        int n_states_in_model = models[current_model]->n_states;
+        for (int j=1;j<n_states_in_model-1;j++)
+          log_transitions[next_current_state][current_state+n_states_in_word-n_states_in_model+1+j] = models[current_model]->log_transitions[n_states_in_model-1][j];
+      }
+    }
+    current_state = next_current_state;
+  }
+}
+
+int SpeechHMM::nStatesInWordPronunciation(int word, int pronun)
+{
+  int word_n_states=0;
+  int lex_ind = lexicon->vocab_to_lex_map[word].pronuns[pronun];
+  LexiconInfoEntry *lex_ent = &lexicon->entries[lex_ind];
+  for (int j=0;j<lex_ent->n_phones;j++) {
+    word_n_states += models[lex_ent->phones[j]]->n_states - 2;
+  }
+  return word_n_states;
+}
+
+int SpeechHMM::nStatesInWord(int word)
+{
+  int word_n_states=0;
+  int n_pronuns = lexicon->vocab_to_lex_map[word].n_pronuns;
+  for (int i=0;i<n_pronuns;i++) {
+    word_n_states += nStatesInWordPronunciation(word,i);
+  }
+  return word_n_states;
+}
+
+
+void SpeechHMM::eMSequenceInitialize(Sequence* inputs)
+{
+  prepareTrainModel(inputs);
+  log_probabilities_s->resize(inputs->n_frames);
+  log_alpha->resize(inputs->n_frames);
+  log_beta->resize(inputs->n_frames);
+  arg_viterbi->resize(inputs->n_frames);
+  viterbi_sequence->resize(inputs->n_frames);
+
+  // propagate to each model
+  for (int i=0;i<n_models;i++)
+    models[i]->eMSequenceInitialize(inputs);
+
+}
+
+void SpeechHMM::sequenceInitialize(Sequence* inputs)
+{
+  prepareTrainModel(inputs);
+  log_probabilities_s->resize(inputs->n_frames);
+  log_alpha->resize(inputs->n_frames);
+  log_beta->resize(inputs->n_frames);
+  arg_viterbi->resize(inputs->n_frames);
+  viterbi_sequence->resize(inputs->n_frames);
+
+  // propagate to each model
+  for (int i=0;i<n_models;i++)
+    models[i]->sequenceInitialize(inputs);
+
+}
+
+void SpeechHMM::eMIterInitialize()
+{
+  for (int i=0;i<n_models;i++)
+    models[i]->eMIterInitialize();
+}
+
+void SpeechHMM::iterInitialize()
+{
+  for (int i=0;i<n_models;i++)
+    models[i]->iterInitialize();
+}
+
+void SpeechHMM::eMAccPosteriors(Sequence *inputs, real log_posterior)
+{
+  // compute the beta by backward recursion
+  logBeta(inputs);
+
+  // accumulate the emission and transition posteriors
+  for (int f=0;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      if (log_alpha->frames[f][i] != LOG_ZERO && 
+          log_beta->frames[f][i] != LOG_ZERO) {
+        real log_posterior_i_f = log_posterior + log_alpha->frames[f][i] +
+          log_beta->frames[f][i] - log_probability;
+        states[i]->frameEMAccPosteriors(f,inputs->frames[f],log_posterior_i_f);
+      }
+    }
+  }
+  for (int f=1;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      real log_emit_i = states[i]->log_probabilities->frames[f][0];
+      int model_to = states_to_model[i];
+      int state_to = states_to_model_states[i];
+      for (int j=1;j<n_states;j++) {
+        if (log_transitions[i][j] == LOG_ZERO || log_alpha->frames[f-1][j] == LOG_ZERO || log_beta->frames[f][i] == LOG_ZERO || log_emit_i == LOG_ZERO)
+          continue;
+        // find the real transition
+        int model_from = states_to_model[j];
+        int state_from = states_to_model_states[j];
+        if (model_from == model_to) {
+          models[model_from]->transitions_acc[state_to][state_from] += 
+            exp(log_posterior + log_alpha->frames[f-1][j] + 
+            log_transitions[i][j] + 
+            log_emit_i + log_beta->frames[f][i] - log_probability);
+        } else {
+          int last_state_from = models[model_from]->n_states-1;
+          models[model_from]->transitions_acc[last_state_from][state_from] +=
+            exp(log_posterior + log_alpha->frames[f-1][j] + 
+            models[model_from]->log_transitions[last_state_from][state_from] +
+            log_emit_i + log_beta->frames[f][i] - log_probability);
+          models[model_to]->transitions_acc[state_to][0] += 
+            exp(log_posterior + log_alpha->frames[f-1][j] + 
+            models[model_to]->log_transitions[state_to][0] +
+            log_emit_i + log_beta->frames[f][i] - log_probability);
+        }
+      }
+    }
+  }
+  // particular case of transitions from initial state
+  for (int j=1;j<n_states-1;j++) {
+    if (log_transitions[j][0] == LOG_ZERO || log_beta->frames[0][j] == LOG_ZERO)
+      continue;
+    int model_to = states_to_model[j];
+    int state_to = states_to_model_states[j];
+    real log_emit_j = states[j]->log_probabilities->frames[0][0];
+    models[model_to]->transitions_acc[state_to][0] +=
+      exp(log_posterior + log_beta->frames[0][j] + log_emit_j +
+      models[model_to]->log_transitions[state_to][0] -
+      log_probability);
+  }
+  // particular case of transitions to last state
+  int f = inputs->n_frames-1;
+  int i = n_states-1;
+  for (int j=1;j<n_states-1;j++) {
+    if (log_transitions[i][j] == LOG_ZERO || log_alpha->frames[f][j] == LOG_ZERO)
+      continue;
+    int model_from = states_to_model[j];
+    int state_from = states_to_model_states[j];
+    int last_state_from = models[model_from]->n_states-1;
+    models[model_from]->transitions_acc[last_state_from][state_from] +=
+      exp(log_posterior + log_alpha->frames[f][j] + 
+      models[model_from]->log_transitions[last_state_from][state_from] -
+      log_probability);
+  }
+}
+
+void SpeechHMM::viterbiAccPosteriors(Sequence *inputs, real log_posterior)
+{
+  // accumulate the emission and transition posteriors
+  real p = exp(log_posterior);
+  for (int f=0;f<inputs->n_frames;f++) {
+    int i = (int)viterbi_sequence->frames[f][0];
+    if (i>=0) {
+      int model_to = states_to_model[i];
+      int state_to = states_to_model_states[i];
+      states[i]->frameEMAccPosteriors(f, inputs->frames[f], log_posterior);
+      int j = (int)arg_viterbi->frames[f][i];
+      // find the real transition
+      if (j>=0) {
+        int model_from = states_to_model[j];
+        int state_from = states_to_model_states[j];
+        if (model_from == model_to) {
+          models[model_from]->transitions_acc[state_to][state_from] += p;
+        } else {
+          int last_state_from = models[model_from]->n_states-1;
+          models[model_from]->transitions_acc[last_state_from][state_from] += p;
+          models[model_to]->transitions_acc[state_to][0] += p;
+        }
+      }
+    }
+  }
+}
+
+void SpeechHMM::eMUpdate()
+{
+  // for each model
+  for (int i=0;i<n_models;i++) {
+    models[i]->eMUpdate();
+  }
+}
+
+void SpeechHMM::backward(Sequence *inputs, Sequence *alpha)
+{
+  // compute the beta by backward recursion
+  logBeta(inputs);
+
+  // accumulate the emission and transition posteriors
+  for (int f=0;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      if (log_alpha->frames[f][i] != LOG_ZERO && 
+        log_beta->frames[f][i] != LOG_ZERO) {
+        real posterior_i_f = *alpha->frames[0] * exp(log_alpha->frames[f][i] + 
+          log_beta->frames[f][i] - log_probability);
+        states[i]->frameBackward(f,inputs->frames[f],NULL,NULL,&posterior_i_f);
+      }
+    }
+  }
+  for (int f=1;f<inputs->n_frames;f++) {
+    for (int i=1;i<n_states-1;i++) {
+      real log_emit_i = states[i]->log_probabilities->frames[f][0];
+      int model_to = states_to_model[i];
+      int state_to = states_to_model_states[i];
+      for (int j=1;j<n_states;j++) {
+        if (log_transitions[i][j] == LOG_ZERO || 
+          log_alpha->frames[f-1][j] == LOG_ZERO ||
+          log_beta->frames[f][i] == LOG_ZERO)
+          continue;
+        int model_from = states_to_model[j];
+        int state_from = states_to_model_states[j];
+        if (model_from == model_to) {
+          real posterior_i_j_f = *alpha->frames[0] * exp(log_alpha->frames[f-1][j] +
+            log_transitions[i][j] + log_emit_i + log_beta->frames[f][i] - 
+            log_probability);
+          models[model_from]->dlog_transitions[state_to][state_from] +=
+            posterior_i_j_f;
+          for (int k=1;k<n_states;k++) {
+            if (log_transitions[k][j] == LOG_ZERO)
+              continue;
+            models[model_from]->dlog_transitions[state_to][state_from] -=
+              posterior_i_j_f * exp(log_transitions[k][j]);
+          }
+        } else {
+          int last_state_from = models[model_from]->n_states-1;
+          real posterior_i_j_f_from = *alpha->frames[0] * exp(log_alpha->frames[f-1][j] +
+            models[model_from]->log_transitions[last_state_from][state_from] + 
+            log_emit_i + log_beta->frames[f][i] - log_probability);
+          real posterior_i_j_f_to = *alpha->frames[0] * exp(log_alpha->frames[f-1][j] +
+            models[model_to]->log_transitions[state_to][0] + 
+            log_emit_i + log_beta->frames[f][i] - log_probability);
+          models[model_from]->dlog_transitions[last_state_from][state_from] +=
+            posterior_i_j_f_from;
+          for (int k=1;k<n_states;k++) {
+            if (log_transitions[k][j] == LOG_ZERO)
+              continue;
+            models[model_from]->dlog_transitions[last_state_from][state_from] -=
+              posterior_i_j_f_from * exp(models[model_from]->log_transitions[last_state_from][state_from]);
+            models[model_to]->dlog_transitions[state_to][0] -=
+              posterior_i_j_f_to * exp(models[model_to]->log_transitions[state_to][0]);
+          }
+        }
+      }
+    }
+  }
+  // particular case of transitions from initial state
+  for (int j=1;j<n_states-1;j++) {
+    if (log_transitions[j][0] == LOG_ZERO)
+      continue;
+    int model_to = states_to_model[j];
+    int state_to = states_to_model_states[j];
+    real log_emit_j = models[model_to]->states[state_to]->log_probabilities->frames[0][0];
+    real posterior_i_j_f = *alpha->frames[0] * exp(log_beta->frames[0][j] +
+      log_emit_j + models[model_to]->log_transitions[state_to][0] - 
+      log_probability);
+    models[model_to]->dlog_transitions[state_to][0] += posterior_i_j_f;
+    for (int k=1;k<n_states-1;k++) {
+      if (log_transitions[k][0] == LOG_ZERO)
+        continue;
+      int k_model_to = states_to_model[k];
+      int k_state_to = states_to_model_states[k];
+      models[k_model_to]->dlog_transitions[k_state_to][0] -=
+        posterior_i_j_f * exp(models[k_model_to]->log_transitions[k_state_to][0]);
+    }
+  }
+  // particular case of transitions to last state
+  int f = inputs->n_frames-1;
+  int i = n_states-1;
+  for (int j=1;j<n_states-1;j++) {
+    if (log_transitions[i][j] == LOG_ZERO ||
+      log_alpha->frames[f][j] == LOG_ZERO)
+      continue;
+    int model_from = states_to_model[j];
+    int state_from = states_to_model_states[j];
+    int last_state_from = models[model_from]->n_states-1;
+    real posterior_i_j_f = *alpha->frames[0] * exp(log_alpha->frames[f][j] +
+      models[model_from]->log_transitions[last_state_from][state_from] -
+      log_probability);
+    models[model_from]->dlog_transitions[last_state_from][state_from] +=
+      posterior_i_j_f;
+    for (int k=1;k<n_states-1;k++) {
+      if (log_transitions[k][j] == LOG_ZERO)
+        continue;
+      int k_model_from = states_to_model[k];
+      int k_state_from = states_to_model_states[k];
+      int k_last_state_from = models[k_model_from]->n_states-1;
+      models[k_model_from]->dlog_transitions[k_last_state_from][k_state_from] -=
+        posterior_i_j_f * exp(models[k_model_from]->log_transitions[k_last_state_from][k_state_from]);
+    }
+  }
+}
+
+SpeechHMM::~SpeechHMM()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/SpeechHMM.h work/main.d/Torch-3/speech/SpeechHMM.h
--- tmp/Torch-3/speech/SpeechHMM.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/SpeechHMM.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,149 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SPEECH_HMM_INC
+#define SPEECH_HMM_INC
+
+#include "HMM.h"
+#include "LexiconInfo.h"
+#include "EditDistance.h"
+#include "log_add.h"
+#include "EMTrainer.h"
+#include "ExampleFrameSelectorDataSet.h"
+
+namespace Torch {
+
+/** This class implements a special case of Hidden Markov Models that
+    can be used to do connected word speech recognition for small
+    vocabulary, using embedded training.
+
+    It contains a set of phoneme models (represented by HMMs), a lexicon
+    of words (which are sequences of phonemes) 
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class SpeechHMM : public HMM
+{
+  public:
+    /// the number of basic phoneme models 
+    int n_models;
+    /// the basic phoneme models
+    HMM** models;
+
+    /// a dataset for initialization
+		DataSet* data;
+		
+    /** if an initial alignment is given and an emtrainer for each model
+        then it is used to train the models after kmeans during reset
+    */
+    EMTrainer** model_trainer;
+
+		/// as well as a measurer of this trainer
+    MeasurerList* initial_models_trainer_measurers;
+
+    /// the acceptable lexicon
+    LexiconInfo* lexicon;
+
+    /// the current target sequence, with start and end words/phonemes
+    Sequence* targets;
+    /// number of words to add
+    int add_to_targets;
+
+    /// true if the given transition is a transition between words
+    bool **word_transitions;
+
+    /// the maximum number of states in the graph (used for allocation)
+    int max_n_states;
+    
+    /// the relation between model states and SpeechHMM states
+    int* states_to_model_states;
+
+    /// the relation between models and SpeechHMM states
+    int* states_to_model;
+
+    /// the relation between words and SpeechHMM states
+    int* states_to_word;
+  
+    /// are targets expressed in words or phonemes?
+    bool phoneme_targets;
+
+    /** In order to create a SpeechHMM, we need to give a vector of #n_models_#
+        #HMM#s as well as their corresponding name, a lexicon,
+        an optional log_word_entrance_penalty and an optional trainer that can be
+        used to initialize each model independently.
+    */
+    SpeechHMM(int n_models_, HMM **models_, LexiconInfo* lex_, EMTrainer** model_trainer_ = NULL);
+
+    virtual void setDataSet(DataSet* data_);
+		void splitDataSet(DataSet* data_, ExampleFrameSelectorDataSet** split_data_);
+    virtual void loadXFile(XFile *file);
+    virtual void saveXFile(XFile *file);
+
+    virtual void iterInitialize();
+    virtual void eMIterInitialize();
+    virtual void eMSequenceInitialize(Sequence* inputs);
+    virtual void sequenceInitialize(Sequence* inputs);
+    virtual void eMAccPosteriors(Sequence *inputs, real log_posterior);
+    virtual void viterbiAccPosteriors(Sequence *inputs, real log_posterior);
+    virtual void eMUpdate();
+
+
+    /** this method prepare the transition graph associated with a
+        given training sentence
+    */
+    virtual void prepareTrainModel(Sequence* input);
+
+    /** this method is used by #prepareTrainModel# 
+        to prepare the model. It adds a given word to the current graph.
+    */
+    virtual int addWordToModel(int word, int current_state);
+
+    virtual	void setMaxNStates(int max_n_states_);
+
+    /** this method is used by #prepareTrainModel#
+        to prepare the model. It adds the connections between words.
+    */
+    virtual void addConnectionsBetweenWordsToModel(int word,int next_word, int current_state,int next_current_state, real log_n_next);
+
+    /// this methods returns the number of states in a given word
+    virtual int nStatesInWord(int word);
+
+    /// this methods returns the number of states in a given word pronunciation
+    virtual int nStatesInWordPronunciation(int word, int pronun);
+
+    virtual void backward(Sequence *inputs, Sequence *alpha);
+
+    virtual void setTargets(Sequence* t);
+
+    virtual ~SpeechHMM();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/WordSeg.cc work/main.d/Torch-3/speech/WordSeg.cc
--- tmp/Torch-3/speech/WordSeg.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/WordSeg.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,73 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "WordSeg.h"
+
+namespace Torch {
+
+WordSeg::WordSeg(LexiconInfo* lexicon_) 
+{
+  lexicon = lexicon_;
+
+  target_word_sequence = NULL;
+  target_word_sequence_size = 0;
+  target_word_sequence_max_size = 0;
+
+  word_sequence = NULL;
+  word_sequence_time = NULL;
+  word_sequence_size = 0;
+  word_sequence_max_size = 0;
+
+}
+
+void WordSeg::resize(int new_size)
+{
+  if (word_sequence_max_size < new_size) {
+    word_sequence_max_size = new_size;
+    word_sequence = (int*)allocator->realloc(word_sequence,word_sequence_max_size*sizeof(int));
+    word_sequence_time = (int*)allocator->realloc(word_sequence_time,word_sequence_max_size*sizeof(int));
+  }
+}
+
+void WordSeg::resizeTargets(int new_size) 
+{
+  if (new_size > target_word_sequence_max_size) {
+    target_word_sequence_max_size = new_size;
+    target_word_sequence =
+      (int*)allocator->realloc(target_word_sequence,new_size*sizeof(int));
+  }
+
+}
+
+WordSeg::~WordSeg()
+{
+}
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/WordSeg.h work/main.d/Torch-3/speech/WordSeg.h
--- tmp/Torch-3/speech/WordSeg.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/WordSeg.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,75 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef WORD_SEG_INC
+#define WORD_SEG_INC
+
+#include "LexiconInfo.h"
+
+namespace Torch {
+
+/** This class keeps track of all information to compute word errors
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class WordSeg : public Object
+{
+  public:
+
+    /// the corresponding lexicon
+    LexiconInfo* lexicon;
+    
+    /// the target word sequence
+    int* target_word_sequence;
+    /// the length of the target word sequence
+    int target_word_sequence_size;
+    /// the length of the longest target word sequence
+    int target_word_sequence_max_size;
+
+    /// the word sequence
+    int* word_sequence;
+    /// the length of the word sequence
+    int word_sequence_size;
+    /// the length of the longest word sequence
+    int word_sequence_max_size;
+    /// the starting time of each word of the word sequence
+    int* word_sequence_time;
+
+    ///
+    WordSeg(LexiconInfo* lexicon_);
+
+    virtual void resize(int new_size);
+    virtual void resizeTargets(int new_size);
+
+    virtual ~WordSeg();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/WordSegMeasurer.cc work/main.d/Torch-3/speech/WordSegMeasurer.cc
--- tmp/Torch-3/speech/WordSegMeasurer.cc	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/WordSegMeasurer.cc	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,130 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "WordSegMeasurer.h"
+#include "DiskXFile.h"
+
+namespace Torch {
+
+WordSegMeasurer::WordSegMeasurer(WordSeg* wordseg_, DataSet *data_, XFile *file_,EditDistance* edit_distance_,char** file_list_,int n_file_list_) : Measurer(data_, file_)
+{
+  wordseg = wordseg_;
+  edit_distance = edit_distance_;
+  if (edit_distance) {
+    sum_edit_distance = new(allocator)EditDistance(edit_distance->is_confusion);
+    sum_edit_distance->reset();
+  } else {
+    sum_edit_distance = NULL;
+  }
+	file_list = file_list_;
+	n_file_list = n_file_list_;
+  addBOption("print targets", &print_targets, true, "print targets");
+  addBOption("print obtained", &print_obtained, true, "print obtained");
+  addBOption("print timing", &print_timing, false, "print timing");
+  addBOption("print desired timing", &print_desired_timing, false, "print desired timing");
+  addIOption("n per frame", &n_per_frame, 1, "n per frame");
+}
+
+void WordSegMeasurer::measureExample()
+{
+	XFile* xfile = file;
+	if(n_file_list)
+		xfile = new(allocator)DiskXFile(file_list[data->real_current_example_index],"w");
+
+  if (print_obtained) {
+    xfile->printf("obtained: ");
+    for (int j=0;j<wordseg->word_sequence_size;j++) {
+      xfile->printf("%s ",wordseg->lexicon->vocabulary->words[wordseg->word_sequence[j]]);
+    }
+    xfile->printf("\n");
+  }
+  if (print_timing && wordseg->word_sequence_size>0) {
+    for (int j=0;j<wordseg->word_sequence_size-1;j++) {
+      xfile->printf("%d %d %s\n",wordseg->word_sequence_time[j]*n_per_frame,wordseg->word_sequence_time[j+1]*n_per_frame,wordseg->lexicon->vocabulary->words[wordseg->word_sequence[j]]);
+    }
+    xfile->printf("%d %d %s\n",wordseg->word_sequence_time[wordseg->word_sequence_size-1]*n_per_frame,data->inputs->n_frames*n_per_frame,wordseg->lexicon->vocabulary->words[wordseg->word_sequence[wordseg->word_sequence_size-1]]);
+  }
+
+  if (print_targets) {
+    xfile->printf("desired: ");
+    for (int j=0;j<wordseg->target_word_sequence_size;j++)
+      xfile->printf("%s ",wordseg->lexicon->vocabulary->words[wordseg->target_word_sequence[j]]);
+    xfile->printf("\n");
+  }
+  if (print_desired_timing) {
+    Sequence* targets = data->targets;
+    if (targets->frame_size > 1) {
+      int begin = 0;
+      for (int j=0;j<targets->n_frames;j++) {
+        int end = (int)targets->frames[j][1]*n_per_frame;
+        xfile->printf("%d %d %s\n",begin,end,wordseg->lexicon->vocabulary->words[(int)targets->frames[j][0]]);
+        begin = end;
+      }
+    }
+  }
+  if (edit_distance) {
+    edit_distance->reset();
+    edit_distance->distance(wordseg->word_sequence,wordseg->word_sequence_size,
+      wordseg->target_word_sequence,wordseg->target_word_sequence_size);
+    sum_edit_distance->add(edit_distance);
+  }
+  xfile->flush();
+	
+	if(n_file_list)
+		allocator->free(xfile);	
+		
+}
+
+void WordSegMeasurer::measureIteration()
+{
+  if (sum_edit_distance) {
+    if (sum_edit_distance->is_confusion) {
+      for (int i=0;i<wordseg->lexicon->vocabulary->n_words;i++)
+        file->printf("%s ",wordseg->lexicon->vocabulary->words[i]);
+      file->printf("\n");
+    }
+    sum_edit_distance->print(file);
+    sum_edit_distance->printRatio(file);
+  }
+  file->flush();
+}
+
+void WordSegMeasurer::reset()
+{
+  if (sum_edit_distance) {
+    sum_edit_distance->reset();
+  }
+}
+
+WordSegMeasurer::~WordSegMeasurer()
+{
+}
+
+
+}
+
diff --speed-large-files --minimal -Nru tmp/Torch-3/speech/WordSegMeasurer.h work/main.d/Torch-3/speech/WordSegMeasurer.h
--- tmp/Torch-3/speech/WordSegMeasurer.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/speech/WordSegMeasurer.h	2004-08-11 12:34:42.000000000 -0400
@@ -0,0 +1,80 @@
+// Copyright (C) 2003--2004 Samy Bengio (bengio@idiap.ch)
+//                
+// This file is part of Torch 3.1.
+//
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef WORD_SEG_MEASURER_INC
+#define WORD_SEG_MEASURER_INC
+
+#include "Measurer.h"
+#include "WordSeg.h"
+#include "EditDistance.h"
+
+namespace Torch {
+
+/** This class can be used to save the word segmentation of a 
+    #SimpleDecoderSpeechHMM#
+    in a file. Optionally, it also prints the corresponding target segmentation.
+
+    @author Samy Bengio (bengio@idiap.ch)
+*/
+class WordSegMeasurer : public Measurer
+{
+  public:
+    /// the pointer to the corresponding wordseg object
+    WordSeg *wordseg;
+
+    /// a boolean stating whether we print the obtained word sequence
+    bool print_obtained;
+    /// a boolean stating whether we also print the corresponding targets
+    bool print_targets;
+    /// a boolean stating whether we also print the alignment timings
+    bool print_timing;
+    /// a boolean stating whether we also print the desired alignment timings
+    bool print_desired_timing;
+    /// when timing is required, what is the number of tics per frames
+    int n_per_frame;
+    /// eventually compute the edit_distance
+    EditDistance* edit_distance;
+    /// ... and keep its sum
+    EditDistance* sum_edit_distance;
+
+		char** file_list;
+		int n_file_list;
+
+    ///
+    WordSegMeasurer(WordSeg* wordseg_, DataSet *data_, XFile *file_,EditDistance* edit_distance_=NULL,char** file_list_=NULL,int n_file_list_ = 0);
+    virtual void reset();
+    virtual void measureExample();
+    virtual void measureIteration();
+
+    virtual ~WordSegMeasurer();
+};
+
+
+}
+
+#endif
diff --speed-large-files --minimal -Nru tmp/Torch-3/xmake work/main.d/Torch-3/xmake
--- tmp/Torch-3/xmake	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/Torch-3/xmake	2004-08-11 12:34:36.000000000 -0400
@@ -0,0 +1,395 @@
+#!/usr/bin/python
+#
+# Torch compiler script
+# (c) Ronan Collobert 2003--2004
+#
+#
+# All rights reserved.
+# 
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. The name of the author may not be used to endorse or promote products
+#    derived from this software without specific prior written permission.
+# 
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+import os
+import re
+import sys
+import ConfigParser
+import string
+
+def addPackageFiles(list_of_files, package):
+    files = os.listdir(config.torch_dir + "/" + package)
+    the_re = re.compile(".*?\.(cc|h)$")
+    for file in files:
+        if(the_re.search(file)):
+            list_of_files[file] = package
+            
+def scanFile(file_name, valid_files):
+    file = open(config.torch_dir + "/" + valid_files[file_name] + "/" + file_name, "r")
+    lines = file.readlines()
+    file.close()
+
+    includes = []
+    the_re = re.compile("\s*\#include\s*(\"|<)(.*?)(\"|>).*")
+    for line in lines:
+        zob = the_re.search(line)
+        if(zob):
+            includes.append(zob.group(2))
+
+    return includes
+
+def findDepsOnFile(file_name, deps, valid_files):
+
+# Voir si on a besoin de soi-meme...
+
+    if( (file_name not in deps) and valid_files.has_key(file_name) ):
+        deps.append(file_name)
+#
+
+    new_includes = []
+    includes = scanFile(file_name, valid_files)
+    for include in includes:
+        if( (include not in deps) and valid_files.has_key(include) ):
+            new_includes.append(include)
+            deps.append(include)
+
+    for new_include in new_includes:
+        findDepsOnFile(new_include, deps, valid_files)
+
+# Lecture de la config
+
+class Config:
+    pass
+
+def readConfig(override_debug_mode):
+    config = Config()
+    config.os = os.uname()[0]
+
+    the_current_dir = os.getcwd() + "/"
+    the_torch3_index = string.rfind(the_current_dir, "/Torch3/")
+    if(the_torch3_index < 0):
+        print "$ Torch3 directory not found"
+        sys.exit(0)
+
+    config.torch_dir = the_current_dir[0:the_torch3_index] + "/Torch3"
+    config_file = ConfigParser.ConfigParser()
+    config_file.read(config.torch_dir + "/" + config.os + ".cfg")
+    
+    if(not config_file.has_section("torch")):
+        print "$ Config file <" + config.torch_dir + "/" + config.os + ".cfg> not found or doesn't have any torch section"
+        sys.exit(0)
+
+    options = config_file.options("torch")
+
+    if(override_debug_mode != ""):
+        config.debug = override_debug_mode
+    else:
+        if("debug" in options):
+            config.debug = config_file.get("torch", "debug")
+            if( (config.debug != "opt") and (config.debug != "dbg") ):
+                print "$ debug is not valid (opt or dbg accepted)"
+                sys.exit(0)    
+        else:
+            config.debug = "opt"
+
+    if("floating" in options):
+        config.floating = config_file.get("torch", "floating")
+        if( (config.floating != "float") and (config.floating != "double") ):
+            print "$ floating is not valid (float or double accepted)"
+            sys.exit(0)
+    else:
+        config.floating = "float"
+
+    if("magic_key" in options):
+        config.magic_key = config_file.get("torch", "magic_key")
+    else:
+        config.magic_key = ""
+
+    if("packages" in options):
+        config.packages = ["core"] + string.split(config_file.get("torch", "packages"))
+    else:
+        config.packages = ["core"]
+
+    if("includes" in options):
+        config.includes = config_file.get("torch", "includes")
+    else:
+        config.includes = ""
+
+    if("libraries" in options):
+        config.libraries = config_file.get("torch", "libraries")
+    else:
+        config.libraries = ""
+
+    if("compiler" in options):
+        config.compiler = config_file.get("torch", "compiler")
+    else:
+        print "$ No compiler provided"
+        sys.exit(0)
+
+    if("linker" in options):
+        config.linker = config_file.get("torch", "linker")
+    else:
+        print "$ No linker provided"
+        sys.exit(0)
+
+    if("archiver" in options):
+        config.archiver = config_file.get("torch", "archiver")
+    else:
+        print "$ No archiver provided"
+        sys.exit(0)
+
+    if("verbose" in options):
+        config.verbose = config_file.getboolean("torch", "verbose")
+    else:
+        config.verbose = 0
+
+    if("library_name" in options):
+        config.library_name = config_file.get("torch", "library_name")
+    else:
+        config.library_name = "torch"
+
+    config.mode = config.debug + "_" + config.floating
+    
+    if(config.mode in options):
+        config.flags = config_file.get("torch", config.mode)
+    else:
+        config.flags = ""
+        print "! No compilation flags provided"
+
+    config.version_key = config.magic_key + config.os + "_" + config.mode
+    config.libs_dir = config.torch_dir + "/libs/" + config.version_key
+    config.objs_dir = config.torch_dir + "/objs/" + config.version_key
+    for package in config.packages:
+        config.includes = config.includes + " -I" + config.torch_dir + "/" + package
+
+    config.libraries = "-L" + config.libs_dir + " -l" + config.library_name + " " + config.libraries
+    
+    return config
+
+def getValidFiles():
+    valid_files = {}
+    for package in config.packages:
+        if(os.path.exists(config.torch_dir + "/" + package)):
+            addPackageFiles(valid_files, package)
+        else:
+            print "$ Package <" + package + "> doesn't exist"
+            sys.exit(0)
+    return valid_files
+
+def makeDepend():    
+    valid_files = getValidFiles()
+    file_deps = open(config.torch_dir + "/.deps_" + config.version_key, "w")
+    print "# Computing dependencies... [" + config.version_key + "]"
+    the_re = re.compile(".*?\.cc$")
+    for file in valid_files.keys():
+        if(the_re.search(file)):
+            deps = []
+            findDepsOnFile(file, deps, valid_files)
+            deps_on_file = ""
+            for dep in deps:
+                deps_on_file = deps_on_file + dep + " "
+            file_deps.write(deps_on_file[0:-1] + "\n")
+    file_deps.close()
+    os.system("mkdir -p " + config.objs_dir)
+    os.system("mkdir -p " + config.libs_dir)            
+
+def makeAll():
+    valid_files = getValidFiles()
+    print "# Try to compile Torch... [" + config.version_key + "]"
+    # a) Load dependencies and package associations
+    if(not os.path.exists(config.torch_dir + "/.deps_" + config.version_key)):
+        print "! Dependencies not existent..."
+        return 1
+    
+    file_deps = open(config.torch_dir + "/.deps_" + config.version_key, "r")
+    lines = file_deps.readlines()
+    file_deps.close()
+    deps = {}
+    for line in lines:
+        splitted_line = string.split(line)
+        deps[splitted_line[0][0:-2]+"o"] = splitted_line
+
+    # b) Check if all valid file are in dependencies
+    n_cc_files = 0
+    the_re = re.compile(".*?\.cc$")
+    for file in valid_files.keys():
+        if(the_re.search(file)):
+            n_cc_files = n_cc_files + 1
+            if(not deps.has_key(file[0:-2]+"o")):
+                print "! New cc file detected, re-doing dependencies (" + file + ")"
+                return 1
+
+    if(n_cc_files != len(deps.keys())):
+        print "! Dependencies not up to date..."
+        return 1
+
+    # c) Find last modification dates (for valid source files and object files)
+    valid_file_dates = {}
+    for valid_file in valid_files.keys():
+        valid_file_dates[valid_file] = os.path.getmtime(config.torch_dir + "/" + valid_files[valid_file] + "/" + valid_file)
+        
+    object_file_dates = {}
+    for object_file in deps.keys():
+        full_path_object_file = config.objs_dir + "/" + object_file
+        if(os.path.exists(full_path_object_file)):
+            object_file_dates[object_file] = os.path.getmtime(full_path_object_file)
+        else:
+            object_file_dates[object_file] = 0
+
+    # d) Find objects to update
+    objects_to_update = []
+    for object_file in deps.keys():
+        object_file_date = object_file_dates[object_file]
+        for dep_file in deps[object_file]:
+            if(valid_file_dates[dep_file] > object_file_date):
+                objects_to_update.append(object_file)
+                break
+            
+    # e) Update objects
+    objects_to_update.sort()
+    for object_file in objects_to_update:
+        src_file = object_file[0:-1] + "cc"
+        src_file = config.torch_dir + "/" + valid_files[src_file] + "/" + src_file
+        cmd = config.compiler + " " + config.flags + " " + config.includes + " -o " + config.objs_dir + "/" + object_file + " -c " + src_file
+        if config.verbose:
+            print cmd
+        else:
+            print object_file[0:-2]+".cc"
+        if(os.system(cmd) != 0):
+            print "$ Compilation failed"
+            sys.exit(0)
+
+    # f) Update library
+
+    i_should_archive = 0
+    lib_file = config.libs_dir + "/lib" + config.library_name + ".a"
+    if( (os.path.exists(lib_file)) and (len(objects_to_update) == 0) ):
+        lib_file_date = os.path.getmtime(lib_file)
+        for object_file in deps.keys():
+            full_path_object_file = config.objs_dir + "/" + object_file
+            if(os.path.getmtime(full_path_object_file) > lib_file_date):
+                i_should_archive = 1
+    else:
+        i_should_archive = 1
+        
+    if( (not os.path.exists(lib_file)) or (len(objects_to_update) > 0) ):
+        all_objects = ""
+        for object_file in deps.keys():
+            all_objects = all_objects + config.objs_dir + "/" + object_file + " "
+        cmd = config.archiver + " " + lib_file + " " + all_objects 
+        print "# Archiving..."
+        if config.verbose:
+            print cmd
+        os.system(cmd)
+        
+    return 0
+
+def makeClean():
+    print "# Cleaning all the objects... [" + config.version_key + "]"
+    os.system("rm -Rf " + config.objs_dir)
+    os.system("rm -Rf " + config.libs_dir)
+    os.system("rm -f " + config.torch_dir + "/.deps_" + config.version_key)
+
+def makeDistClean():
+    print "# Atomizing all"
+    os.system("rm -Rf " + config.torch_dir + "/objs/")
+    os.system("rm -Rf " + config.torch_dir + "/libs/")
+    os.system("rm -f " + config.torch_dir + "/.deps_*")
+
+override_debug_mode = ""
+files_to_compile = []
+
+if(len(sys.argv) == 1):
+    cmd = "all"
+else:
+    if( (sys.argv[1] == "-opt") or (sys.argv[1] == "-dbg") ):
+        if(sys.argv[1] == "-opt"):
+            override_debug_mode = "opt"
+        if(sys.argv[1] == "-dbg"):
+            override_debug_mode = "dbg"
+        if(len(sys.argv) == 2):
+            cmd = "all"
+        else:
+            cmd = sys.argv[2]
+            files_to_compile = sys.argv[2:]
+    else:
+        cmd = sys.argv[1]
+        files_to_compile = sys.argv[1:]
+
+if(cmd == "os"):
+    print os.uname()[0]
+    sys.exit(0)
+
+if( (cmd == "help") or (cmd == "--help") or (cmd == "-help") or (cmd == "-h") ):
+    print "# Torch3 compiler script"
+    print "# usage: " + sys.argv[0][string.rfind(sys.argv[0], "/")+1:] + " [-opt,-dbg] [command]"
+    print "# Commands:"
+    print "    - os:              print name of your operating system"
+    print "    - all:             compile all the library [default]"
+    print "    - depend:          make dependencies"
+    print "    - clean:           clean current objects and library"
+    print "    - distclean:       clean all objects and library"
+    print "    - <filename[.cc]>: compile given *main* program(s)"
+    print ""
+    sys.exit(0)
+    
+config = readConfig(override_debug_mode)
+
+if(cmd == "depend"):
+    makeDepend()
+elif(cmd == "all"):
+    if(makeAll()):
+        makeDepend()
+        if(makeAll()):
+            print "$ Something is wrong. What are you doing ?"
+            sys.exit(0)
+    
+elif(cmd == "clean"):
+    makeClean()
+elif(cmd == "distclean"):
+    makeDistClean()
+else:
+    library_is_already_made = 0
+    for sub_cmd in files_to_compile:
+        file_name = ""
+        if(re.search(".*?\.(cc|h)$", sub_cmd)):
+            file_name = sub_cmd
+        else:
+            file_name = sub_cmd + ".cc"
+
+        if(not os.path.exists(file_name)):
+            print "$ Don't know what you want to do with your <" + sub_cmd + ">"
+            sys.exit(0)
+
+        if(not library_is_already_made):
+            library_is_already_made = 1
+            if(makeAll()):
+                makeDepend()
+                if(makeAll()):
+                    print "$ Something is wrong. What are you doing ?"
+                    sys.exit(0)
+            
+        os.system("mkdir -p " + config.version_key)
+        the_compile_cmd = config.compiler + " " + config.flags + " " + config.includes + " -o " + config.version_key + "/" + file_name[0:-3] + " " + file_name + " " + config.libraries
+        print "# Compiling <" + config.version_key + "/" + file_name[0:-3] + ">"
+        if(config.verbose):
+            print the_compile_cmd
+        if(os.system(the_compile_cmd) != 0):
+            sys.exit(0)
