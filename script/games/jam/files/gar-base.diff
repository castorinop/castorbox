Binary files tmp/jam-2.5/bin.linuxx86/jam and work/main.d/jam-2.5/bin.linuxx86/jam differ
Binary files tmp/jam-2.5/bin.linuxx86/jambase.o and work/main.d/jam-2.5/bin.linuxx86/jambase.o differ
Binary files tmp/jam-2.5/bin.linuxx86/jam.o and work/main.d/jam-2.5/bin.linuxx86/jam.o differ
Binary files tmp/jam-2.5/bin.linuxx86/libjam.a and work/main.d/jam-2.5/bin.linuxx86/libjam.a differ
Binary files tmp/jam-2.5/bin.linuxx86/mkjambase and work/main.d/jam-2.5/bin.linuxx86/mkjambase differ
Binary files tmp/jam-2.5/bin.linuxx86/mkjambase.o and work/main.d/jam-2.5/bin.linuxx86/mkjambase.o differ
Binary files tmp/jam-2.5/jam0 and work/main.d/jam-2.5/jam0 differ
diff --speed-large-files --minimal -Nru tmp/jam-2.5/Jambase work/main.d/jam-2.5/Jambase
--- tmp/jam-2.5/Jambase	2003-04-23 01:45:49.000000000 -0300
+++ work/main.d/jam-2.5/Jambase	2007-01-19 12:51:48.000000000 -0300
@@ -541,7 +541,7 @@
 	CRELIB		?= ;
 	DOT		?= . ;
 	DOTDOT		?= .. ;
-	EXEMODE		?= 711 ;
+	EXEMODE		?= 755 ;
 	FILEMODE	?= 644 ;
 	FORTRAN		?= f77 ;
 	FORTRANFLAGS	?= ;
@@ -1129,7 +1129,7 @@
 
 rule Setuid
 {
-	MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4711 ;
+	MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4755 ;
 }
 
 rule Shell
diff --speed-large-files --minimal -Nru tmp/jam-2.5/jambase.c work/main.d/jam-2.5/jambase.c
--- tmp/jam-2.5/jambase.c	2004-08-19 14:19:35.000000000 -0400
+++ work/main.d/jam-2.5/jambase.c	2007-01-19 12:54:37.000000000 -0300
@@ -333,7 +333,7 @@
 "CRELIB		?= ;\n",
 "DOT		?= . ;\n",
 "DOTDOT		?= .. ;\n",
-"EXEMODE		?= 711 ;\n",
+"EXEMODE		?= 755 ;\n",
 "FILEMODE	?= 644 ;\n",
 "FORTRAN		?= f77 ;\n",
 "FORTRANFLAGS	?= ;\n",
@@ -702,7 +702,7 @@
 "}\n",
 "rule Setuid\n",
 "{\n",
-"MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4711 ;\n",
+"MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4755 ;\n",
 "}\n",
 "rule Shell\n",
 "{\n",
diff --speed-large-files --minimal -Nru tmp/jam-2.5/Jamfile work/main.d/jam-2.5/Jamfile
--- tmp/jam-2.5/Jamfile	2004-08-19 14:19:29.000000000 -0400
+++ work/main.d/jam-2.5/Jamfile	2007-01-19 13:07:19.000000000 -0300
@@ -29,6 +29,9 @@
 else if $(MAC)	{ code = execmac.c filemac.c pathmac.c ; }
 else 		{ code = execunix.c fileunix.c pathunix.c ; }
 
+#FIX for cross-compiling
+AR += ru;
+
 # For jam profiling/debugging.
 
 if $(PROFILE)
@@ -62,7 +65,7 @@
 
 if $(YACC) && $(SUFEXE) = ""
 {
-	GenFile jamgram.y jamgramtab.h : yyacc jamgram.yy ;
+	GenFile jamgram.y jamgramtab.h : ./yyacc jamgram.yy ;
 }
 
 #
diff --speed-large-files --minimal -Nru tmp/jam-2.5/Jamfile~ work/main.d/jam-2.5/Jamfile~
--- tmp/jam-2.5/Jamfile~	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/jam-2.5/Jamfile~	2007-01-19 12:51:48.000000000 -0300
@@ -0,0 +1,152 @@
+#
+# Jamfile to build Jam (a make(1)-like program)
+#
+# There are no user-serviceable parts in this file.
+#
+# Put executables in platform-specific  subdirectory.
+
+if $(VMS) 	{ LOCATE_TARGET ?= [.binvms] ; }
+else if $(MAC) 	{ LOCATE_TARGET ?= :bin.mac ; }
+else 		{ LOCATE_TARGET ?= bin.$(OSFULL[1]:L) ; }
+
+# Leave generated source in current directory; it would be nice to use
+# these lines below to build the source into the platform-specific
+# directory, but getting scan.c to include the right jambase.h is
+# hard: with ""'s, it always gets the bootstrap version; with <>'s,
+# it won't find the bootstrap version.
+
+# SEARCH_SOURCE ?= $(LOCATE_TARGET) $(DOT) ;
+# LOCATE_SOURCE ?= $(LOCATE_TARGET) ;
+
+#
+# We have some different files for UNIX, VMS, and NT.
+#
+
+if $(NT) 	{ code = execunix.c filent.c pathunix.c ; } 
+else if $(MINGW) { code = execunix.c filent.c pathunix.c ; } 
+else if $(OS2)	{ code = execunix.c fileos2.c pathunix.c ; } 
+else if $(VMS) 	{ code = execvms.c filevms.c pathvms.c ; } 
+else if $(MAC)	{ code = execmac.c filemac.c pathmac.c ; }
+else 		{ code = execunix.c fileunix.c pathunix.c ; }
+
+# For jam profiling/debugging.
+
+if $(PROFILE)
+{
+	CCFLAGS += -pg ;
+	LINKFLAGS += -pg ;
+	LOCATE_TARGET = $(LOCATE_TARGET)/pg ;
+}
+
+if $(DEBUG)
+{
+	CCFLAGS += -g ;
+	LINKFLAGS += -g ;
+	LOCATE_TARGET = $(LOCATE_TARGET)/g ;
+}
+
+# We have to signal jam.h for these
+
+if $(OS) = NT 			{ CCFLAGS += /DNT ; }
+
+# Do we know yacc?
+
+if $(YACC) 	{ code += jamgram.y ; }
+else            { code += jamgram.c ; }
+
+#
+# Build the jamgram.y from the jamgram.yy
+# yyacc is a slippery script that makes grammars a little
+# easier to read/maintain.
+#
+
+if $(YACC) && $(SUFEXE) = ""
+{
+	GenFile jamgram.y jamgramtab.h : ./yyacc jamgram.yy ;
+}
+
+#
+# How to build the compiled in jambase.
+#
+
+Main		mkjambase : mkjambase.c ;
+
+if $(VMS)
+{
+	CC = cxx ;
+	LINK = cxxlink ;
+	CCFLAGS += /define=VMS ;
+}
+
+#
+# The guts of the Jamfile: how to build Jam
+#
+
+Main 		jam : jam.c jambase.c ;
+LinkLibraries 	jam : libjam.a ;
+GenFile 	jambase.c : mkjambase Jambase ;
+
+Library         libjam.a :
+		    builtins.c command.c compile.c $(code) expand.c
+		    glob.c hash.c headers.c lists.c make.c make1.c
+		    newstr.c option.c parse.c regexp.c rules.c scan.c
+		    search.c timestamp.c variable.c ;
+
+
+if $(BINDIR) 	{ InstallBin $(BINDIR) : jam ; }
+
+#
+# Distribution making from here on out.
+#
+
+ALLSOURCE =
+	Build.com Build.mpw Jam.html Jambase Jambase.html Jamfile
+	Jamfile.html Makefile Porting README RELNOTES builtins.c builtins.h
+	command.c command.h compile.c compile.h execcmd.h execmac.c
+	execunix.c execvms.c expand.c expand.h filemac.c filent.c
+	fileos2.c filesys.h fileunix.c filevms.c glob.c hash.c hash.h
+	headers.c headers.h jam.c jam.h jambase.c jambase.h jamgram.c
+	jamgram.h jamgram.y jamgram.yy jamgramtab.h lists.c lists.h
+	make.c make.h make1.c mkjambase.c newstr.c newstr.h option.c
+	option.h parse.c parse.h patchlevel.h pathmac.c pathsys.h
+	pathunix.c pathvms.c regexp.c regexp.h rules.c rules.h scan.c
+	scan.h search.c search.h timestamp.c timestamp.h variable.c
+	variable.h yyacc ;
+
+rule Ball
+{
+	NotFile balls ;
+	Depends balls : $(<) ;
+
+	DEPENDS $(<) : $(>) ;
+
+	switch $(<) 
+	{
+	case *.tar : Tar $(<) : $(>) ;
+	case *.shar : Shar $(<) : $(>) ;
+	case *.zip : Zip $(<) : $(>) ;
+	}
+}
+
+VERSION = jam-2.5 ;
+
+actions Tar
+{
+	ln -s . $(VERSION)
+	tar cvhf $(<) $(VERSION)/$(>)
+	rm $(VERSION)
+}
+
+actions Shar
+{
+	shar $(>) > $(<)
+}
+
+actions Zip
+{
+	zip $(<) $(>) 
+}
+
+Ball $(VERSION).shar : $(ALLSOURCE) ;
+Ball $(VERSION).tar : $(ALLSOURCE) ;
+Ball $(VERSION).zip : $(ALLSOURCE) ;
diff --speed-large-files --minimal -Nru tmp/jam-2.5/Jamfile.html work/main.d/jam-2.5/Jamfile.html
--- tmp/jam-2.5/Jamfile.html	2003-04-23 01:45:50.000000000 -0300
+++ work/main.d/jam-2.5/Jamfile.html	2007-01-19 12:51:48.000000000 -0300
@@ -290,7 +290,7 @@
               for automatic customizing with autoconf(GNU).
 <P>
 	<LI> 	Optionally, set an environment variable pointing
-		to the root directory of the srouce tree. The
+		to the root directory of the source tree. The
 		variable's name is left up to you, but in these
 		examples, we use TOP.
 </OL>
diff --speed-large-files --minimal -Nru tmp/jam-2.5/jamgram.c work/main.d/jam-2.5/jamgram.c
--- tmp/jam-2.5/jamgram.c	2004-08-19 14:19:34.000000000 -0400
+++ work/main.d/jam-2.5/jamgram.c	2007-01-19 12:54:24.000000000 -0300
@@ -1,23 +1,175 @@
-#ifndef lint
-static char const 
-yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28.2.1 2001/07/19 05:46:39 peter Exp $";
-#endif
-#include <stdlib.h>
-#define YYBYACC 1
-#define YYMAJOR 1
-#define YYMINOR 9
-#define YYLEX yylex()
-#define YYEMPTY -1
-#define yyclearin (yychar=(YYEMPTY))
-#define yyerrok (yyerrflag=0)
-#define YYRECOVERING() (yyerrflag!=0)
-#if defined(__cplusplus) || __STDC__
-static int yygrowstack(void);
-#else
-static int yygrowstack();
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     _SEMIC_t = 258,
+     _COLON_t = 259,
+     _BANG_t = 260,
+     _BANG_EQUALS_t = 261,
+     _QUESTION_EQUALS_t = 262,
+     _LPAREN_t = 263,
+     _RPAREN_t = 264,
+     _LBRACKET_t = 265,
+     _RBRACKET_t = 266,
+     _LBRACE_t = 267,
+     _RBRACE_t = 268,
+     _AMPER_t = 269,
+     _AMPERAMPER_t = 270,
+     _PLUS_EQUALS_t = 271,
+     _LANGLE_t = 272,
+     _LANGLE_EQUALS_t = 273,
+     _EQUALS_t = 274,
+     _RANGLE_t = 275,
+     _RANGLE_EQUALS_t = 276,
+     _BAR_t = 277,
+     _BARBAR_t = 278,
+     ACTIONS_t = 279,
+     BIND_t = 280,
+     BREAK_t = 281,
+     CASE_t = 282,
+     CONTINUE_t = 283,
+     DEFAULT_t = 284,
+     ELSE_t = 285,
+     EXISTING_t = 286,
+     FOR_t = 287,
+     IF_t = 288,
+     IGNORE_t = 289,
+     IN_t = 290,
+     INCLUDE_t = 291,
+     LOCAL_t = 292,
+     MAXLINE_t = 293,
+     ON_t = 294,
+     PIECEMEAL_t = 295,
+     QUIETLY_t = 296,
+     RETURN_t = 297,
+     RULE_t = 298,
+     SWITCH_t = 299,
+     TOGETHER_t = 300,
+     UPDATED_t = 301,
+     WHILE_t = 302,
+     ARG = 303,
+     STRING = 304
+   };
 #endif
-#define YYPREFIX "yy"
-#line 85 "jamgram.y"
+/* Tokens.  */
+#define _SEMIC_t 258
+#define _COLON_t 259
+#define _BANG_t 260
+#define _BANG_EQUALS_t 261
+#define _QUESTION_EQUALS_t 262
+#define _LPAREN_t 263
+#define _RPAREN_t 264
+#define _LBRACKET_t 265
+#define _RBRACKET_t 266
+#define _LBRACE_t 267
+#define _RBRACE_t 268
+#define _AMPER_t 269
+#define _AMPERAMPER_t 270
+#define _PLUS_EQUALS_t 271
+#define _LANGLE_t 272
+#define _LANGLE_EQUALS_t 273
+#define _EQUALS_t 274
+#define _RANGLE_t 275
+#define _RANGLE_EQUALS_t 276
+#define _BAR_t 277
+#define _BARBAR_t 278
+#define ACTIONS_t 279
+#define BIND_t 280
+#define BREAK_t 281
+#define CASE_t 282
+#define CONTINUE_t 283
+#define DEFAULT_t 284
+#define ELSE_t 285
+#define EXISTING_t 286
+#define FOR_t 287
+#define IF_t 288
+#define IGNORE_t 289
+#define IN_t 290
+#define INCLUDE_t 291
+#define LOCAL_t 292
+#define MAXLINE_t 293
+#define ON_t 294
+#define PIECEMEAL_t 295
+#define QUIETLY_t 296
+#define RETURN_t 297
+#define RULE_t 298
+#define SWITCH_t 299
+#define TOGETHER_t 300
+#define UPDATED_t 301
+#define WHILE_t 302
+#define ARG 303
+#define STRING 304
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 84 "jamgram.y"
+
 #include "jam.h"
 
 #include "lists.h"
@@ -56,877 +208,1954 @@
 # define pnode( l,r )    	parse_make( F0,l,r,P0,S0,S0,0 )
 # define psnode( s,l )     	parse_make( F0,l,P0,P0,s,S0,0 )
 
-#line 60 "y.tab.c"
-#define YYERRCODE 256
-#define _BANG_t 257
-#define _BANG_EQUALS_t 258
-#define _AMPER_t 259
-#define _AMPERAMPER_t 260
-#define _LPAREN_t 261
-#define _RPAREN_t 262
-#define _PLUS_EQUALS_t 263
-#define _COLON_t 264
-#define _SEMIC_t 265
-#define _LANGLE_t 266
-#define _LANGLE_EQUALS_t 267
-#define _EQUALS_t 268
-#define _RANGLE_t 269
-#define _RANGLE_EQUALS_t 270
-#define _QUESTION_EQUALS_t 271
-#define _LBRACKET_t 272
-#define _RBRACKET_t 273
-#define ACTIONS_t 274
-#define BIND_t 275
-#define BREAK_t 276
-#define CASE_t 277
-#define CONTINUE_t 278
-#define DEFAULT_t 279
-#define ELSE_t 280
-#define EXISTING_t 281
-#define FOR_t 282
-#define IF_t 283
-#define IGNORE_t 284
-#define IN_t 285
-#define INCLUDE_t 286
-#define LOCAL_t 287
-#define MAXLINE_t 288
-#define ON_t 289
-#define PIECEMEAL_t 290
-#define QUIETLY_t 291
-#define RETURN_t 292
-#define RULE_t 293
-#define SWITCH_t 294
-#define TOGETHER_t 295
-#define UPDATED_t 296
-#define WHILE_t 297
-#define _LBRACE_t 298
-#define _BAR_t 299
-#define _BARBAR_t 300
-#define _RBRACE_t 301
-#define ARG 302
-#define STRING 303
-const short yylhs[] = {                                        -1,
-    0,    0,    2,    2,    1,    1,    1,    1,    3,    3,
-    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-    3,    3,    3,   13,   14,    3,    7,    7,    7,    7,
-    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
-    9,    9,    9,    9,    8,    8,   15,   10,   10,   10,
-    6,    6,    4,   16,   16,    5,   18,    5,   17,   17,
-   17,   11,   11,   19,   19,   19,   19,   19,   19,   19,
-   12,   12,
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 216 of yacc.c.  */
+#line 245 "y.tab.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  39
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   245
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  50
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  21
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  73
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  154
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   304
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49
 };
-const short yylen[] = {                                         2,
-    0,    1,    0,    1,    1,    2,    4,    6,    3,    3,
-    3,    4,    6,    3,    3,    3,    7,    5,    5,    7,
-    5,    6,    3,    0,    0,    9,    1,    1,    1,    2,
-    1,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-    3,    3,    2,    3,    0,    2,    4,    0,    3,    1,
-    1,    3,    1,    0,    2,    1,    0,    4,    2,    4,
-    4,    0,    2,    1,    1,    1,    1,    1,    1,    2,
-    0,    2,
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     4,     6,     7,     9,    11,    14,    19,
+      26,    30,    34,    38,    43,    50,    54,    58,    62,    70,
+      76,    82,    90,    96,   103,   107,   108,   109,   119,   121,
+     123,   125,   128,   130,   134,   138,   142,   146,   150,   154,
+     158,   162,   166,   170,   174,   177,   181,   182,   185,   190,
+     191,   195,   197,   199,   203,   205,   206,   209,   211,   212,
+     217,   220,   225,   230,   231,   234,   236,   238,   240,   242,
+     244,   246,   249,   250
 };
-const short yydefred[] = {                                      0,
-   57,   62,   54,   54,    0,    0,   54,   54,    0,   54,
-    0,   54,    0,    0,   56,    0,    2,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    4,    0,    6,   28,
-   27,   29,    0,   54,    0,    0,   54,    0,   54,    0,
-   69,   66,    0,   68,   67,   65,   64,    0,   63,   14,
-   55,   15,   54,   43,    0,   54,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,   10,    0,   54,
-   23,   16,    0,    0,    0,    0,    9,   30,    0,   54,
-   11,    0,    0,   59,   58,   70,   54,    0,    0,   44,
-   42,    0,    0,    0,   34,   35,    0,   36,   37,    0,
-    0,    0,    7,    0,    0,    0,    0,    0,    0,    0,
-   54,   52,   12,   54,   54,   72,   24,    0,    0,    0,
-   49,    0,    0,   18,   46,   21,    0,   61,   60,    0,
-    0,    0,    8,   22,    0,   13,   25,   17,   20,   47,
-    0,   26,
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      51,     0,    -1,    -1,    53,    -1,    -1,    53,    -1,    54,
+      -1,    54,    53,    -1,    37,    63,     3,    52,    -1,    37,
+      63,    19,    63,     3,    52,    -1,    12,    52,    13,    -1,
+      36,    63,     3,    -1,    65,    62,     3,    -1,    65,    57,
+      63,     3,    -1,    65,    39,    63,    57,    63,     3,    -1,
+      26,    63,     3,    -1,    28,    63,     3,    -1,    42,    63,
+       3,    -1,    32,    48,    35,    63,    12,    52,    13,    -1,
+      44,    63,    12,    59,    13,    -1,    33,    58,    12,    52,
+      13,    -1,    33,    58,    12,    52,    13,    30,    54,    -1,
+      47,    58,    12,    52,    13,    -1,    43,    48,    61,    12,
+      52,    13,    -1,    39,    65,    54,    -1,    -1,    -1,    24,
+      68,    48,    70,    12,    55,    49,    56,    13,    -1,    19,
+      -1,    16,    -1,     7,    -1,    29,    19,    -1,    65,    -1,
+      58,    19,    58,    -1,    58,     6,    58,    -1,    58,    17,
+      58,    -1,    58,    18,    58,    -1,    58,    20,    58,    -1,
+      58,    21,    58,    -1,    58,    14,    58,    -1,    58,    15,
+      58,    -1,    58,    22,    58,    -1,    58,    23,    58,    -1,
+      65,    35,    63,    -1,     5,    58,    -1,     8,    58,     9,
+      -1,    -1,    60,    59,    -1,    27,    48,     4,    52,    -1,
+      -1,    48,     4,    61,    -1,    48,    -1,    63,    -1,    63,
+       4,    62,    -1,    64,    -1,    -1,    64,    65,    -1,    48,
+      -1,    -1,    10,    66,    67,    11,    -1,    65,    62,    -1,
+      39,    65,    65,    62,    -1,    39,    65,    42,    63,    -1,
+      -1,    68,    69,    -1,    46,    -1,    45,    -1,    34,    -1,
+      41,    -1,    40,    -1,    31,    -1,    38,    48,    -1,    -1,
+      25,    63,    -1
 };
-const short yydgoto[] = {                                      16,
-   37,   38,   18,   45,   28,   46,   47,  118,   29,   84,
-   21,   98,  140,  151,  119,   23,   50,   20,   59,
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   127,   127,   129,   141,   142,   146,   148,   150,   152,
+     156,   158,   160,   162,   164,   166,   168,   170,   172,   174,
+     176,   178,   180,   182,   184,   187,   189,   186,   198,   200,
+     202,   204,   212,   214,   216,   218,   220,   222,   224,   226,
+     228,   230,   232,   234,   236,   238,   249,   250,   254,   264,
+     265,   267,   276,   278,   288,   293,   294,   298,   300,   300,
+     309,   311,   313,   323,   324,   328,   330,   332,   334,   336,
+     338,   340,   350,   351
 };
-const short yysindex[] = {                                    -40,
-    0,    0,    0,    0, -295, -233,    0,    0, -240,    0,
- -284,    0, -233,  -40,    0,    0,    0,  -40,   -7, -241,
-   49, -242, -240, -232, -239, -233, -233, -231,  -75, -220,
- -195,   34, -210, -243, -226,  -59,    0, -223,    0,    0,
-    0,    0, -174,    0, -165, -164,    0, -240,    0, -173,
-    0,    0, -199,    0,    0,    0,    0, -166,    0,    0,
-    0,    0,    0,    0, -154,    0, -233, -233, -233, -233,
- -233, -233, -233, -233,  -40, -233, -233,    0,  -40,    0,
-    0,    0, -153, -179, -157,  -40,    0,    0,  -42,    0,
-    0, -144, -185,    0,    0,    0,    0, -171, -170,    0,
-    0,  -54,   94,   94,    0,    0,  -54,    0,    0, -160,
-   88,   88,    0, -140, -243,  -40, -151, -139, -157, -134,
-    0,    0,    0,    0,    0,    0,    0,  -40, -149,  -40,
-    0, -131,  -93,    0,    0,    0,  -85,    0,    0, -121,
- -115,   34,    0,    0,  -40,    0,    0,    0,    0,    0,
- -105,    0,
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "_SEMIC_t", "_COLON_t", "_BANG_t",
+  "_BANG_EQUALS_t", "_QUESTION_EQUALS_t", "_LPAREN_t", "_RPAREN_t",
+  "_LBRACKET_t", "_RBRACKET_t", "_LBRACE_t", "_RBRACE_t", "_AMPER_t",
+  "_AMPERAMPER_t", "_PLUS_EQUALS_t", "_LANGLE_t", "_LANGLE_EQUALS_t",
+  "_EQUALS_t", "_RANGLE_t", "_RANGLE_EQUALS_t", "_BAR_t", "_BARBAR_t",
+  "ACTIONS_t", "BIND_t", "BREAK_t", "CASE_t", "CONTINUE_t", "DEFAULT_t",
+  "ELSE_t", "EXISTING_t", "FOR_t", "IF_t", "IGNORE_t", "IN_t", "INCLUDE_t",
+  "LOCAL_t", "MAXLINE_t", "ON_t", "PIECEMEAL_t", "QUIETLY_t", "RETURN_t",
+  "RULE_t", "SWITCH_t", "TOGETHER_t", "UPDATED_t", "WHILE_t", "ARG",
+  "STRING", "$accept", "run", "block", "rules", "rule", "@1", "@2",
+  "assign", "expr", "cases", "case", "params", "lol", "list", "listp",
+  "arg", "@3", "func", "eflags", "eflag", "bindlist", 0
 };
-const short yyrindex[] = {                                    197,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0, -103,    0,    0,    0,    3, -235,    0,
-    0,    0, -110,    0,    0,    0,    0,  -94,    0,    0,
-    0,    0,    0,  -96,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0, -246,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,  -95,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0, -103,    0,    0,    0,    4,    0,
-    0,    0,  -84,    0,  -79, -103,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0, -202, -224, -176,    0,    0,  -81,    0,    0,    0,
- -257, -209,    0,    0,  -96, -103,    0,    0,  -79,    0,
-    0,    0,    0,    0,    0,    0,    0, -103,    1,    4,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0, -237,    0,    0,    0,    0,    0,
-    0,    0,
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304
 };
-const short yygindex[] = {                                      0,
-   26,  -65,  -32,    5,    2,  -43,  131,  108,   66,  113,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    50,    51,    51,    52,    52,    53,    53,    53,    53,
+      54,    54,    54,    54,    54,    54,    54,    54,    54,    54,
+      54,    54,    54,    54,    54,    55,    56,    54,    57,    57,
+      57,    57,    58,    58,    58,    58,    58,    58,    58,    58,
+      58,    58,    58,    58,    58,    58,    59,    59,    60,    61,
+      61,    61,    62,    62,    63,    64,    64,    65,    66,    65,
+      67,    67,    67,    68,    68,    69,    69,    69,    69,    69,
+      69,    69,    70,    70
 };
-#define YYTABLESIZE 364
-const short yytable[] = {                                      81,
-   19,   19,    5,    3,   40,   94,   25,   22,   24,  110,
-   32,   30,   31,  113,   33,   19,   35,   34,   51,   19,
-  120,   49,   60,   26,   61,   17,   51,   27,   54,   54,
-    1,    1,   62,   19,   38,   38,   54,   38,    1,    3,
-   40,   40,   40,   39,   78,   63,  122,   48,   89,   93,
-  132,   92,   41,   66,   82,   33,   33,   33,   83,   33,
-   15,   15,  141,    3,  143,   33,   54,   99,   15,   79,
-  101,   85,   80,   38,   38,   38,   19,   87,   36,  150,
-   19,  139,   39,   39,  114,   39,    1,   19,   41,   41,
-   41,   64,   65,   88,  125,   33,   33,   33,   90,   95,
-   91,  126,   96,   67,   68,   69,  124,  100,   97,  149,
-  115,   70,   71,   72,   73,   74,   15,   19,  116,  117,
-  123,   39,   39,   39,  130,  137,  127,  128,  138,   19,
-  142,   19,  102,  103,  104,  105,  106,  107,  108,  109,
-  129,  111,  112,   19,   76,   77,   19,   53,   53,   53,
-  133,   53,   53,   53,   53,   53,   53,   53,   53,   53,
-   53,  134,   53,   31,   31,   31,  136,   31,   53,  144,
-  145,   31,   31,   31,   31,   31,   32,   32,   32,  146,
-   32,  147,   67,   68,   69,  148,   32,   53,   53,   53,
-   70,   71,   72,   73,   74,  152,    1,    3,   67,   68,
-   69,   48,   71,   31,   31,   31,   70,   71,   72,   73,
-   74,   70,   71,   50,   73,   74,   32,   32,   32,  121,
-   40,   45,   75,   76,   77,   41,  135,  131,   42,    0,
-    0,    1,    0,    2,    0,    3,   43,    4,   86,   76,
-   77,    5,    6,    0,    0,    7,    8,    0,    9,    0,
-    0,   10,   11,   12,    0,   40,   13,   14,    0,    0,
-   41,   15,    0,   42,    0,    0,    0,    0,    0,    0,
-    0,   43,   19,    0,   19,    0,   19,   19,   19,    5,
-    3,   44,   19,   19,    0,    0,   19,   19,    0,   19,
-    0,    0,   19,   19,   19,    0,    0,   19,   19,    0,
-    0,   19,   19,    5,    3,    1,    0,    2,    0,    3,
-    0,    4,    0,    0,    0,    5,    6,    0,    0,    7,
-    0,    0,    9,    0,    0,   10,   11,   12,    0,   51,
-   13,   14,   52,    0,    0,   15,   53,    0,   54,   55,
-    0,    0,    0,   56,   57,   67,   68,   69,    0,    0,
-   58,   67,    0,   70,   71,   72,   73,   74,    0,   70,
-   71,   72,   73,   74,
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     1,     0,     1,     1,     2,     4,     6,
+       3,     3,     3,     4,     6,     3,     3,     3,     7,     5,
+       5,     7,     5,     6,     3,     0,     0,     9,     1,     1,
+       1,     2,     1,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     2,     3,     0,     2,     4,     0,
+       3,     1,     1,     3,     1,     0,     2,     1,     0,     4,
+       2,     4,     4,     0,     2,     1,     1,     1,     1,     1,
+       1,     2,     0,     2
 };
-const short yycheck[] = {                                      32,
-    0,    0,    0,    0,  262,   49,  302,    3,    4,   75,
-    9,    7,    8,   79,   10,   14,   12,  302,  265,   18,
-   86,   20,  265,  257,   23,    0,  273,  261,  264,  265,
-  272,  272,  265,   32,  259,  260,  272,  262,  272,  277,
-  298,  299,  300,   18,  265,  285,   90,  289,   44,   48,
-  116,   47,  262,  285,  265,  258,  259,  260,  302,  262,
-  302,  302,  128,  301,  130,  268,  302,   63,  302,  265,
-   66,  298,  268,  298,  299,  300,   75,  301,   13,  145,
-   79,  125,  259,  260,   80,  262,  272,   86,  298,  299,
-  300,   26,   27,  268,   93,  298,  299,  300,  264,  273,
-  265,   97,  302,  258,  259,  260,  292,  262,  275,  142,
-  264,  266,  267,  268,  269,  270,  302,  116,  298,  277,
-  265,  298,  299,  300,  265,  121,  298,  298,  124,  128,
-  280,  130,   67,   68,   69,   70,   71,   72,   73,   74,
-  301,   76,   77,  142,  299,  300,  145,  258,  259,  260,
-  302,  262,  263,  264,  265,  266,  267,  268,  269,  270,
-  271,  301,  273,  258,  259,  260,  301,  262,  279,  301,
-  264,  266,  267,  268,  269,  270,  258,  259,  260,  265,
-  262,  303,  258,  259,  260,  301,  268,  298,  299,  300,
-  266,  267,  268,  269,  270,  301,    0,  301,  258,  259,
-  260,  298,  298,  298,  299,  300,  266,  267,  268,  269,
-  270,  266,  267,  298,  269,  270,  298,  299,  300,   89,
-  263,  301,  298,  299,  300,  268,  119,  115,  271,   -1,
-   -1,  272,   -1,  274,   -1,  276,  279,  278,  298,  299,
-  300,  282,  283,   -1,   -1,  286,  287,   -1,  289,   -1,
-   -1,  292,  293,  294,   -1,  263,  297,  298,   -1,   -1,
-  268,  302,   -1,  271,   -1,   -1,   -1,   -1,   -1,   -1,
-   -1,  279,  272,   -1,  274,   -1,  276,  277,  278,  277,
-  277,  289,  282,  283,   -1,   -1,  286,  287,   -1,  289,
-   -1,   -1,  292,  293,  294,   -1,   -1,  297,  298,   -1,
-   -1,  301,  302,  301,  301,  272,   -1,  274,   -1,  276,
-   -1,  278,   -1,   -1,   -1,  282,  283,   -1,   -1,  286,
-   -1,   -1,  289,   -1,   -1,  292,  293,  294,   -1,  281,
-  297,  298,  284,   -1,   -1,  302,  288,   -1,  290,  291,
-   -1,   -1,   -1,  295,  296,  258,  259,  260,   -1,   -1,
-  302,  258,   -1,  266,  267,  268,  269,  270,   -1,  266,
-  267,  268,  269,  270,
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,    58,     4,    63,    55,    55,     0,     0,    55,    55,
+       0,    55,     0,    55,     0,    57,     0,     3,     6,    55,
+       0,     0,     5,     0,     0,    54,     0,     0,     0,     0,
+       0,    32,     0,     0,     0,     0,    49,     0,     0,     1,
+       7,    30,    29,    28,     0,    55,    55,     0,    52,     0,
+      55,     0,    10,    70,    67,     0,    69,    68,    66,    65,
+      72,    64,    15,    56,    16,    55,    44,     0,     0,     4,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    55,
+      11,     4,    55,    24,    17,    51,     0,    46,     4,    31,
+       0,     0,    12,    55,     0,    60,    59,    71,    55,     0,
+       0,    45,    34,     0,    39,    40,    35,    36,    33,    37,
+      38,    41,    42,    43,     8,     0,    49,     4,     0,     0,
+      46,     0,    55,    13,    53,    55,    55,    73,    25,     4,
+      20,     4,    50,     0,     0,    19,    47,    22,     0,    62,
+      61,     0,     0,     0,     9,    23,     4,    14,    26,    18,
+      21,    48,     0,    27
 };
-#define YYFINAL 16
-#ifndef YYDEBUG
-#define YYDEBUG 0
-#endif
-#define YYMAXTOKEN 303
-#if YYDEBUG
-const char * const yyname[] = {
-"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"_BANG_t","_BANG_EQUALS_t",
-"_AMPER_t","_AMPERAMPER_t","_LPAREN_t","_RPAREN_t","_PLUS_EQUALS_t","_COLON_t",
-"_SEMIC_t","_LANGLE_t","_LANGLE_EQUALS_t","_EQUALS_t","_RANGLE_t",
-"_RANGLE_EQUALS_t","_QUESTION_EQUALS_t","_LBRACKET_t","_RBRACKET_t","ACTIONS_t",
-"BIND_t","BREAK_t","CASE_t","CONTINUE_t","DEFAULT_t","ELSE_t","EXISTING_t",
-"FOR_t","IF_t","IGNORE_t","IN_t","INCLUDE_t","LOCAL_t","MAXLINE_t","ON_t",
-"PIECEMEAL_t","QUIETLY_t","RETURN_t","RULE_t","SWITCH_t","TOGETHER_t",
-"UPDATED_t","WHILE_t","_LBRACE_t","_BAR_t","_BARBAR_t","_RBRACE_t","ARG",
-"STRING",
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,    16,    21,    22,    18,   141,   152,    46,    30,   119,
+     120,    86,    47,    48,    25,    31,    20,    51,    23,    61,
+      99
 };
-const char * const yyrule[] = {
-"$accept : run",
-"run :",
-"run : rules",
-"block :",
-"block : rules",
-"rules : rule",
-"rules : rule rules",
-"rules : LOCAL_t list _SEMIC_t block",
-"rules : LOCAL_t list _EQUALS_t list _SEMIC_t block",
-"rule : _LBRACE_t block _RBRACE_t",
-"rule : INCLUDE_t list _SEMIC_t",
-"rule : arg lol _SEMIC_t",
-"rule : arg assign list _SEMIC_t",
-"rule : arg ON_t list assign list _SEMIC_t",
-"rule : BREAK_t list _SEMIC_t",
-"rule : CONTINUE_t list _SEMIC_t",
-"rule : RETURN_t list _SEMIC_t",
-"rule : FOR_t ARG IN_t list _LBRACE_t block _RBRACE_t",
-"rule : SWITCH_t list _LBRACE_t cases _RBRACE_t",
-"rule : IF_t expr _LBRACE_t block _RBRACE_t",
-"rule : IF_t expr _LBRACE_t block _RBRACE_t ELSE_t rule",
-"rule : WHILE_t expr _LBRACE_t block _RBRACE_t",
-"rule : RULE_t ARG params _LBRACE_t block _RBRACE_t",
-"rule : ON_t arg rule",
-"$$1 :",
-"$$2 :",
-"rule : ACTIONS_t eflags ARG bindlist _LBRACE_t $$1 STRING $$2 _RBRACE_t",
-"assign : _EQUALS_t",
-"assign : _PLUS_EQUALS_t",
-"assign : _QUESTION_EQUALS_t",
-"assign : DEFAULT_t _EQUALS_t",
-"expr : arg",
-"expr : expr _EQUALS_t expr",
-"expr : expr _BANG_EQUALS_t expr",
-"expr : expr _LANGLE_t expr",
-"expr : expr _LANGLE_EQUALS_t expr",
-"expr : expr _RANGLE_t expr",
-"expr : expr _RANGLE_EQUALS_t expr",
-"expr : expr _AMPER_t expr",
-"expr : expr _AMPERAMPER_t expr",
-"expr : expr _BAR_t expr",
-"expr : expr _BARBAR_t expr",
-"expr : arg IN_t list",
-"expr : _BANG_t expr",
-"expr : _LPAREN_t expr _RPAREN_t",
-"cases :",
-"cases : case cases",
-"case : CASE_t ARG _COLON_t block",
-"params :",
-"params : ARG _COLON_t params",
-"params : ARG",
-"lol : list",
-"lol : list _COLON_t lol",
-"list : listp",
-"listp :",
-"listp : listp arg",
-"arg : ARG",
-"$$3 :",
-"arg : _LBRACKET_t $$3 func _RBRACKET_t",
-"func : arg lol",
-"func : ON_t arg arg lol",
-"func : ON_t arg RETURN_t list",
-"eflags :",
-"eflags : eflags eflag",
-"eflag : UPDATED_t",
-"eflag : TOGETHER_t",
-"eflag : IGNORE_t",
-"eflag : QUIETLY_t",
-"eflag : PIECEMEAL_t",
-"eflag : EXISTING_t",
-"eflag : MAXLINE_t ARG",
-"bindlist :",
-"bindlist : BIND_t list",
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -67
+static const yytype_int16 yypact[] =
+{
+     108,   -67,   108,   -67,   -67,   -67,   -37,    18,   -67,   -67,
+      -4,   -67,   -34,   -67,    18,   -67,    30,   -67,   108,    29,
+      -6,    16,   -67,   136,    28,    -4,    32,    -3,    18,    18,
+     186,     3,    36,     5,   147,    37,    -2,    35,   204,   -67,
+     -67,   -67,   -67,   -67,    38,   -67,   -67,    56,    63,    -4,
+     -67,    49,   -67,   -67,   -67,    14,   -67,   -67,   -67,   -67,
+      46,   -67,   -67,   -67,   -67,   -67,   -67,   222,    18,   108,
+      18,    18,    18,    18,    18,    18,    18,    18,    18,   -67,
+     -67,   108,   -67,   -67,   -67,    66,    60,    50,   108,   -67,
+      45,    79,   -67,   -67,    -5,   -67,   -67,   -67,   -67,    72,
+      73,   -67,    58,    76,   143,   143,   -67,   -67,    58,   -67,
+     -67,   107,   107,   -67,   -67,    83,    -2,   108,    43,    80,
+      50,    94,   -67,   -67,   -67,   -67,   -67,   -67,   -67,   108,
+      62,   108,   -67,    95,    92,   -67,   -67,   -67,   106,   -67,
+     -67,    65,    98,   147,   -67,   -67,   108,   -67,   -67,   -67,
+     -67,   -67,    99,   -67
 };
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -67,   -67,   -66,     9,   -33,   -67,   -67,    25,    27,    -1,
+     -67,     7,   -43,     8,   -67,     0,   -67,   -67,   -67,   -67,
+     -67
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -1
+static const yytype_uint8 yytable[] =
+{
+      19,    83,    19,   103,     1,     1,     1,    95,    81,    17,
+      34,    27,    24,    26,    36,   114,    32,    33,    19,    35,
+      50,    37,   121,    28,    82,    63,    29,    40,     1,    52,
+      39,    62,    65,    49,    19,    64,    41,   125,    79,    80,
+      84,    38,    15,    15,    15,    42,    85,    87,    43,    94,
+     124,   133,    41,    90,    91,    66,    67,    89,    44,    92,
+      96,    42,    97,   142,    43,   144,    15,    93,    45,    19,
+     116,    98,   117,   100,    44,    72,    73,   118,    75,    76,
+     151,    19,   123,   140,   128,   129,   131,   113,    19,   130,
+     115,   134,   143,   135,   126,   102,   146,   104,   105,   106,
+     107,   108,   109,   110,   111,   112,   127,   137,   145,   147,
+     150,   149,   153,    68,   148,   122,     0,    19,     1,   136,
+       2,    70,    71,   132,    72,    73,    74,    75,    76,    19,
+     138,    19,     3,   139,     4,     0,     5,     0,     0,     0,
+       6,     7,     0,    19,     8,     9,    19,    10,     0,    68,
+      11,    12,    13,     0,     0,    14,    15,     1,     0,     2,
+      72,    73,    74,    75,    76,     0,     0,    53,     0,     0,
+      54,     3,     0,     4,    55,     5,    56,    57,     0,     6,
+       7,    58,    59,     8,    60,     0,    10,     0,     0,    11,
+      12,    13,    68,     0,    14,    15,     0,     0,    69,     0,
+      70,    71,     0,    72,    73,    74,    75,    76,    77,    78,
+      68,     0,     0,     0,     0,     0,    88,     0,    70,    71,
+       0,    72,    73,    74,    75,    76,    77,    78,    68,     0,
+       0,   101,     0,     0,     0,     0,    70,    71,     0,    72,
+      73,    74,    75,    76,    77,    78
+};
+
+static const yytype_int16 yycheck[] =
+{
+       0,    34,     2,    69,    10,    10,    10,    50,     3,     0,
+      10,    48,     4,     5,    48,    81,     8,     9,    18,    11,
+      20,    13,    88,     5,    19,    25,     8,    18,    10,    13,
+       0,     3,    35,    39,    34,     3,     7,    42,    35,     3,
+       3,    14,    48,    48,    48,    16,    48,    12,    19,    49,
+      93,   117,     7,    45,    46,    28,    29,    19,    29,     3,
+      11,    16,    48,   129,    19,   131,    48,     4,    39,    69,
+       4,    25,    12,    65,    29,    17,    18,    27,    20,    21,
+     146,    81,     3,   126,    12,    12,     3,    79,    88,    13,
+      82,    48,    30,    13,    94,    68,     4,    70,    71,    72,
+      73,    74,    75,    76,    77,    78,    98,    13,    13,     3,
+     143,    13,    13,     6,    49,    90,    -1,   117,    10,   120,
+      12,    14,    15,   116,    17,    18,    19,    20,    21,   129,
+     122,   131,    24,   125,    26,    -1,    28,    -1,    -1,    -1,
+      32,    33,    -1,   143,    36,    37,   146,    39,    -1,     6,
+      42,    43,    44,    -1,    -1,    47,    48,    10,    -1,    12,
+      17,    18,    19,    20,    21,    -1,    -1,    31,    -1,    -1,
+      34,    24,    -1,    26,    38,    28,    40,    41,    -1,    32,
+      33,    45,    46,    36,    48,    -1,    39,    -1,    -1,    42,
+      43,    44,     6,    -1,    47,    48,    -1,    -1,    12,    -1,
+      14,    15,    -1,    17,    18,    19,    20,    21,    22,    23,
+       6,    -1,    -1,    -1,    -1,    -1,    12,    -1,    14,    15,
+      -1,    17,    18,    19,    20,    21,    22,    23,     6,    -1,
+      -1,     9,    -1,    -1,    -1,    -1,    14,    15,    -1,    17,
+      18,    19,    20,    21,    22,    23
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    10,    12,    24,    26,    28,    32,    33,    36,    37,
+      39,    42,    43,    44,    47,    48,    51,    53,    54,    65,
+      66,    52,    53,    68,    63,    64,    63,    48,     5,     8,
+      58,    65,    63,    63,    65,    63,    48,    63,    58,     0,
+      53,     7,    16,    19,    29,    39,    57,    62,    63,    39,
+      65,    67,    13,    31,    34,    38,    40,    41,    45,    46,
+      48,    69,     3,    65,     3,    35,    58,    58,     6,    12,
+      14,    15,    17,    18,    19,    20,    21,    22,    23,    35,
+       3,     3,    19,    54,     3,    48,    61,    12,    12,    19,
+      63,    63,     3,     4,    65,    62,    11,    48,    25,    70,
+      63,     9,    58,    52,    58,    58,    58,    58,    58,    58,
+      58,    58,    58,    63,    52,    63,     4,    12,    27,    59,
+      60,    52,    57,     3,    62,    42,    65,    63,    12,    12,
+      13,     3,    61,    52,    48,    13,    59,    13,    63,    63,
+      62,    55,    52,    30,    52,    13,     4,     3,    49,    13,
+      54,    52,    56,    13
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
-#ifndef YYSTYPE
-typedef int YYSTYPE;
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
 #endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
 #if YYDEBUG
-#include <stdio.h>
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
 #endif
-#ifdef YYSTACKSIZE
-#undef YYMAXDEPTH
-#define YYMAXDEPTH YYSTACKSIZE
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
 #else
-#ifdef YYMAXDEPTH
-#define YYSTACKSIZE YYMAXDEPTH
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
-#define YYSTACKSIZE 10000
-#define YYMAXDEPTH 10000
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
 #endif
-#define YYINITSTACKSIZE 200
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
 int yydebug;
-int yynerrs;
-int yyerrflag;
-int yychar;
-short *yyssp;
-YYSTYPE *yyvsp;
-YYSTYPE yyval;
-YYSTYPE yylval;
-short *yyss;
-short *yysslim;
-YYSTYPE *yyvs;
-int yystacksize;
-/* allocate initial stack or double stack size, up to YYMAXDEPTH */
-static int yygrowstack()
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
 {
-    int newsize, i;
-    short *newss;
-    YYSTYPE *newvs;
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
 
-    if ((newsize = yystacksize) == 0)
-        newsize = YYINITSTACKSIZE;
-    else if (newsize >= YYMAXDEPTH)
-        return -1;
-    else if ((newsize *= 2) > YYMAXDEPTH)
-        newsize = YYMAXDEPTH;
-    i = yyssp - yyss;
-    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
-      (short *)malloc(newsize * sizeof *newss);
-    if (newss == NULL)
-        return -1;
-    yyss = newss;
-    yyssp = newss + i;
-    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
-      (YYSTYPE *)malloc(newsize * sizeof *newvs);
-    if (newvs == NULL)
-        return -1;
-    yyvs = newvs;
-    yyvsp = newvs + i;
-    yystacksize = newsize;
-    yysslim = yyss + newsize - 1;
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
     return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
 }
+#endif /* YYERROR_VERBOSE */
+
 
-#define YYABORT goto yyabort
-#define YYREJECT goto yyabort
-#define YYACCEPT goto yyaccept
-#define YYERROR goto yyerrlab
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
 
-#ifndef YYPARSE_PARAM
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG void
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif	/* ANSI-C/C++ */
-#else	/* YYPARSE_PARAM */
-#ifndef YYPARSE_PARAM_TYPE
-#define YYPARSE_PARAM_TYPE void *
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
 #endif
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
-#endif	/* ANSI-C/C++ */
-#endif	/* ! YYPARSE_PARAM */
-
-int
-yyparse (YYPARSE_PARAM_ARG)
-    YYPARSE_PARAM_DECL
 {
-    register int yym, yyn, yystate;
-#if YYDEBUG
-    register const char *yys;
+  YYUSE (yyvaluep);
 
-    if ((yys = getenv("YYDEBUG")))
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
     {
-        yyn = *yys;
-        if (yyn >= '0' && yyn <= '9')
-            yydebug = yyn - '0';
+
+      default:
+	break;
     }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
 #endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
 
-    yynerrs = 0;
-    yyerrflag = 0;
-    yychar = (-1);
 
-    if (yyss == NULL && yygrowstack()) goto yyoverflow;
-    yyssp = yyss;
-    yyvsp = yyvs;
-    *yyssp = yystate = 0;
 
-yyloop:
-    if ((yyn = yydefred[yystate])) goto yyreduce;
-    if (yychar < 0)
-    {
-        if ((yychar = yylex()) < 0) yychar = 0;
-#if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, reading %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
 #endif
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
     }
-    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
     {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: state %d, shifting to state %d\n",
-                    YYPREFIX, yystate, yytable[yyn]);
-#endif
-        if (yyssp >= yysslim && yygrowstack())
-        {
-            goto yyoverflow;
-        }
-        *++yyssp = yystate = yytable[yyn];
-        *++yyvsp = yylval;
-        yychar = (-1);
-        if (yyerrflag > 0)  --yyerrflag;
-        goto yyloop;
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
     }
-    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+
+  if (yychar <= YYEOF)
     {
-        yyn = yytable[yyn];
-        goto yyreduce;
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
-    if (yyerrflag) goto yyinrecovery;
-#if defined(lint) || defined(__GNUC__)
-    goto yynewerror;
-#endif
-yynewerror:
-    yyerror("syntax error");
-#if defined(lint) || defined(__GNUC__)
-    goto yyerrlab;
-#endif
-yyerrlab:
-    ++yynerrs;
-yyinrecovery:
-    if (yyerrflag < 3)
+  else
     {
-        yyerrflag = 3;
-        for (;;)
-        {
-            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
-                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: state %d, error recovery shifting\
- to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
-#endif
-                if (yyssp >= yysslim && yygrowstack())
-                {
-                    goto yyoverflow;
-                }
-                *++yyssp = yystate = yytable[yyn];
-                *++yyvsp = yylval;
-                goto yyloop;
-            }
-            else
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: error recovery discarding state %d\n",
-                            YYPREFIX, *yyssp);
-#endif
-                if (yyssp <= yyss) goto yyabort;
-                --yyssp;
-                --yyvsp;
-            }
-        }
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
-    else
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
     {
-        if (yychar == 0) goto yyabort;
-#if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
-#endif
-        yychar = (-1);
-        goto yyloop;
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
     }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
 yyreduce:
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
-                YYPREFIX, yystate, yyn, yyrule[yyn]);
-#endif
-    yym = yylen[yyn];
-    yyval = yyvsp[1-yym];
-    switch (yyn)
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
     {
-case 2:
+        case 3:
 #line 130 "jamgram.y"
-{ parse_save( yyvsp[0].parse ); }
-break;
-case 3:
+    { parse_save( (yyvsp[(1) - (1)]).parse ); }
+    break;
+
+  case 4:
 #line 141 "jamgram.y"
-{ yyval.parse = pnull(); }
-break;
-case 4:
+    { (yyval).parse = pnull(); }
+    break;
+
+  case 5:
 #line 143 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; }
-break;
-case 5:
+    { (yyval).parse = (yyvsp[(1) - (1)]).parse; }
+    break;
+
+  case 6:
 #line 147 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; }
-break;
-case 6:
+    { (yyval).parse = (yyvsp[(1) - (1)]).parse; }
+    break;
+
+  case 7:
 #line 149 "jamgram.y"
-{ yyval.parse = prules( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 7:
+    { (yyval).parse = prules( (yyvsp[(1) - (2)]).parse, (yyvsp[(2) - (2)]).parse ); }
+    break;
+
+  case 8:
 #line 151 "jamgram.y"
-{ yyval.parse = plocal( yyvsp[-2].parse, pnull(), yyvsp[0].parse ); }
-break;
-case 8:
+    { (yyval).parse = plocal( (yyvsp[(2) - (4)]).parse, pnull(), (yyvsp[(4) - (4)]).parse ); }
+    break;
+
+  case 9:
 #line 153 "jamgram.y"
-{ yyval.parse = plocal( yyvsp[-4].parse, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 9:
+    { (yyval).parse = plocal( (yyvsp[(2) - (6)]).parse, (yyvsp[(4) - (6)]).parse, (yyvsp[(6) - (6)]).parse ); }
+    break;
+
+  case 10:
 #line 157 "jamgram.y"
-{ yyval.parse = yyvsp[-1].parse; }
-break;
-case 10:
+    { (yyval).parse = (yyvsp[(2) - (3)]).parse; }
+    break;
+
+  case 11:
 #line 159 "jamgram.y"
-{ yyval.parse = pincl( yyvsp[-1].parse ); }
-break;
-case 11:
+    { (yyval).parse = pincl( (yyvsp[(2) - (3)]).parse ); }
+    break;
+
+  case 12:
 #line 161 "jamgram.y"
-{ yyval.parse = prule( yyvsp[-2].parse, yyvsp[-1].parse ); }
-break;
-case 12:
+    { (yyval).parse = prule( (yyvsp[(1) - (3)]).parse, (yyvsp[(2) - (3)]).parse ); }
+    break;
+
+  case 13:
 #line 163 "jamgram.y"
-{ yyval.parse = pset( yyvsp[-3].parse, yyvsp[-1].parse, yyvsp[-2].number ); }
-break;
-case 13:
+    { (yyval).parse = pset( (yyvsp[(1) - (4)]).parse, (yyvsp[(3) - (4)]).parse, (yyvsp[(2) - (4)]).number ); }
+    break;
+
+  case 14:
 #line 165 "jamgram.y"
-{ yyval.parse = pset1( yyvsp[-5].parse, yyvsp[-3].parse, yyvsp[-1].parse, yyvsp[-2].number ); }
-break;
-case 14:
+    { (yyval).parse = pset1( (yyvsp[(1) - (6)]).parse, (yyvsp[(3) - (6)]).parse, (yyvsp[(5) - (6)]).parse, (yyvsp[(4) - (6)]).number ); }
+    break;
+
+  case 15:
 #line 167 "jamgram.y"
-{ yyval.parse = pbreak( yyvsp[-1].parse, JMP_BREAK ); }
-break;
-case 15:
+    { (yyval).parse = pbreak( (yyvsp[(2) - (3)]).parse, JMP_BREAK ); }
+    break;
+
+  case 16:
 #line 169 "jamgram.y"
-{ yyval.parse = pbreak( yyvsp[-1].parse, JMP_CONTINUE ); }
-break;
-case 16:
+    { (yyval).parse = pbreak( (yyvsp[(2) - (3)]).parse, JMP_CONTINUE ); }
+    break;
+
+  case 17:
 #line 171 "jamgram.y"
-{ yyval.parse = pbreak( yyvsp[-1].parse, JMP_RETURN ); }
-break;
-case 17:
+    { (yyval).parse = pbreak( (yyvsp[(2) - (3)]).parse, JMP_RETURN ); }
+    break;
+
+  case 18:
 #line 173 "jamgram.y"
-{ yyval.parse = pfor( yyvsp[-5].string, yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 18:
+    { (yyval).parse = pfor( (yyvsp[(2) - (7)]).string, (yyvsp[(4) - (7)]).parse, (yyvsp[(6) - (7)]).parse ); }
+    break;
+
+  case 19:
 #line 175 "jamgram.y"
-{ yyval.parse = pswitch( yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 19:
+    { (yyval).parse = pswitch( (yyvsp[(2) - (5)]).parse, (yyvsp[(4) - (5)]).parse ); }
+    break;
+
+  case 20:
 #line 177 "jamgram.y"
-{ yyval.parse = pif( yyvsp[-3].parse, yyvsp[-1].parse, pnull() ); }
-break;
-case 20:
+    { (yyval).parse = pif( (yyvsp[(2) - (5)]).parse, (yyvsp[(4) - (5)]).parse, pnull() ); }
+    break;
+
+  case 21:
 #line 179 "jamgram.y"
-{ yyval.parse = pif( yyvsp[-5].parse, yyvsp[-3].parse, yyvsp[0].parse ); }
-break;
-case 21:
+    { (yyval).parse = pif( (yyvsp[(2) - (7)]).parse, (yyvsp[(4) - (7)]).parse, (yyvsp[(7) - (7)]).parse ); }
+    break;
+
+  case 22:
 #line 181 "jamgram.y"
-{ yyval.parse = pwhile( yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 22:
+    { (yyval).parse = pwhile( (yyvsp[(2) - (5)]).parse, (yyvsp[(4) - (5)]).parse ); }
+    break;
+
+  case 23:
 #line 183 "jamgram.y"
-{ yyval.parse = psetc( yyvsp[-4].string, yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 23:
+    { (yyval).parse = psetc( (yyvsp[(2) - (6)]).string, (yyvsp[(3) - (6)]).parse, (yyvsp[(5) - (6)]).parse ); }
+    break;
+
+  case 24:
 #line 185 "jamgram.y"
-{ yyval.parse = pon( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 24:
+    { (yyval).parse = pon( (yyvsp[(2) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 25:
 #line 187 "jamgram.y"
-{ yymode( SCAN_STRING ); }
-break;
-case 25:
+    { yymode( SCAN_STRING ); }
+    break;
+
+  case 26:
 #line 189 "jamgram.y"
-{ yymode( SCAN_NORMAL ); }
-break;
-case 26:
+    { yymode( SCAN_NORMAL ); }
+    break;
+
+  case 27:
 #line 191 "jamgram.y"
-{ yyval.parse = psete( yyvsp[-6].string,yyvsp[-5].parse,yyvsp[-2].string,yyvsp[-7].number ); }
-break;
-case 27:
+    { (yyval).parse = psete( (yyvsp[(3) - (9)]).string,(yyvsp[(4) - (9)]).parse,(yyvsp[(7) - (9)]).string,(yyvsp[(2) - (9)]).number ); }
+    break;
+
+  case 28:
 #line 199 "jamgram.y"
-{ yyval.number = VAR_SET; }
-break;
-case 28:
+    { (yyval).number = VAR_SET; }
+    break;
+
+  case 29:
 #line 201 "jamgram.y"
-{ yyval.number = VAR_APPEND; }
-break;
-case 29:
+    { (yyval).number = VAR_APPEND; }
+    break;
+
+  case 30:
 #line 203 "jamgram.y"
-{ yyval.number = VAR_DEFAULT; }
-break;
-case 30:
+    { (yyval).number = VAR_DEFAULT; }
+    break;
+
+  case 31:
 #line 205 "jamgram.y"
-{ yyval.number = VAR_DEFAULT; }
-break;
-case 31:
+    { (yyval).number = VAR_DEFAULT; }
+    break;
+
+  case 32:
 #line 213 "jamgram.y"
-{ yyval.parse = peval( EXPR_EXISTS, yyvsp[0].parse, pnull() ); }
-break;
-case 32:
+    { (yyval).parse = peval( EXPR_EXISTS, (yyvsp[(1) - (1)]).parse, pnull() ); }
+    break;
+
+  case 33:
 #line 215 "jamgram.y"
-{ yyval.parse = peval( EXPR_EQUALS, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 33:
+    { (yyval).parse = peval( EXPR_EQUALS, (yyvsp[(1) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 34:
 #line 217 "jamgram.y"
-{ yyval.parse = peval( EXPR_NOTEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 34:
+    { (yyval).parse = peval( EXPR_NOTEQ, (yyvsp[(1) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 35:
 #line 219 "jamgram.y"
-{ yyval.parse = peval( EXPR_LESS, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 35:
+    { (yyval).parse = peval( EXPR_LESS, (yyvsp[(1) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 36:
 #line 221 "jamgram.y"
-{ yyval.parse = peval( EXPR_LESSEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 36:
+    { (yyval).parse = peval( EXPR_LESSEQ, (yyvsp[(1) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 37:
 #line 223 "jamgram.y"
-{ yyval.parse = peval( EXPR_MORE, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 37:
+    { (yyval).parse = peval( EXPR_MORE, (yyvsp[(1) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 38:
 #line 225 "jamgram.y"
-{ yyval.parse = peval( EXPR_MOREEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 38:
+    { (yyval).parse = peval( EXPR_MOREEQ, (yyvsp[(1) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 39:
 #line 227 "jamgram.y"
-{ yyval.parse = peval( EXPR_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 39:
+    { (yyval).parse = peval( EXPR_AND, (yyvsp[(1) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 40:
 #line 229 "jamgram.y"
-{ yyval.parse = peval( EXPR_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 40:
+    { (yyval).parse = peval( EXPR_AND, (yyvsp[(1) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 41:
 #line 231 "jamgram.y"
-{ yyval.parse = peval( EXPR_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 41:
+    { (yyval).parse = peval( EXPR_OR, (yyvsp[(1) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 42:
 #line 233 "jamgram.y"
-{ yyval.parse = peval( EXPR_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 42:
+    { (yyval).parse = peval( EXPR_OR, (yyvsp[(1) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 43:
 #line 235 "jamgram.y"
-{ yyval.parse = peval( EXPR_IN, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 43:
+    { (yyval).parse = peval( EXPR_IN, (yyvsp[(1) - (3)]).parse, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 44:
 #line 237 "jamgram.y"
-{ yyval.parse = peval( EXPR_NOT, yyvsp[0].parse, pnull() ); }
-break;
-case 44:
+    { (yyval).parse = peval( EXPR_NOT, (yyvsp[(2) - (2)]).parse, pnull() ); }
+    break;
+
+  case 45:
 #line 239 "jamgram.y"
-{ yyval.parse = yyvsp[-1].parse; }
-break;
-case 45:
+    { (yyval).parse = (yyvsp[(2) - (3)]).parse; }
+    break;
+
+  case 46:
 #line 249 "jamgram.y"
-{ yyval.parse = P0; }
-break;
-case 46:
+    { (yyval).parse = P0; }
+    break;
+
+  case 47:
 #line 251 "jamgram.y"
-{ yyval.parse = pnode( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 47:
+    { (yyval).parse = pnode( (yyvsp[(1) - (2)]).parse, (yyvsp[(2) - (2)]).parse ); }
+    break;
+
+  case 48:
 #line 255 "jamgram.y"
-{ yyval.parse = psnode( yyvsp[-2].string, yyvsp[0].parse ); }
-break;
-case 48:
+    { (yyval).parse = psnode( (yyvsp[(2) - (4)]).string, (yyvsp[(4) - (4)]).parse ); }
+    break;
+
+  case 49:
 #line 264 "jamgram.y"
-{ yyval.parse = P0; }
-break;
-case 49:
+    { (yyval).parse = P0; }
+    break;
+
+  case 50:
 #line 266 "jamgram.y"
-{ yyval.parse = psnode( yyvsp[-2].string, yyvsp[0].parse ); }
-break;
-case 50:
+    { (yyval).parse = psnode( (yyvsp[(1) - (3)]).string, (yyvsp[(3) - (3)]).parse ); }
+    break;
+
+  case 51:
 #line 268 "jamgram.y"
-{ yyval.parse = psnode( yyvsp[0].string, P0 ); }
-break;
-case 51:
+    { (yyval).parse = psnode( (yyvsp[(1) - (1)]).string, P0 ); }
+    break;
+
+  case 52:
 #line 277 "jamgram.y"
-{ yyval.parse = pnode( P0, yyvsp[0].parse ); }
-break;
-case 52:
+    { (yyval).parse = pnode( P0, (yyvsp[(1) - (1)]).parse ); }
+    break;
+
+  case 53:
 #line 279 "jamgram.y"
-{ yyval.parse = pnode( yyvsp[0].parse, yyvsp[-2].parse ); }
-break;
-case 53:
+    { (yyval).parse = pnode( (yyvsp[(3) - (3)]).parse, (yyvsp[(1) - (3)]).parse ); }
+    break;
+
+  case 54:
 #line 289 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; yymode( SCAN_NORMAL ); }
-break;
-case 54:
+    { (yyval).parse = (yyvsp[(1) - (1)]).parse; yymode( SCAN_NORMAL ); }
+    break;
+
+  case 55:
 #line 293 "jamgram.y"
-{ yyval.parse = pnull(); yymode( SCAN_PUNCT ); }
-break;
-case 55:
+    { (yyval).parse = pnull(); yymode( SCAN_PUNCT ); }
+    break;
+
+  case 56:
 #line 295 "jamgram.y"
-{ yyval.parse = pappend( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 56:
+    { (yyval).parse = pappend( (yyvsp[(1) - (2)]).parse, (yyvsp[(2) - (2)]).parse ); }
+    break;
+
+  case 57:
 #line 299 "jamgram.y"
-{ yyval.parse = plist( yyvsp[0].string ); }
-break;
-case 57:
+    { (yyval).parse = plist( (yyvsp[(1) - (1)]).string ); }
+    break;
+
+  case 58:
 #line 300 "jamgram.y"
-{ yymode( SCAN_NORMAL ); }
-break;
-case 58:
+    { yymode( SCAN_NORMAL ); }
+    break;
+
+  case 59:
 #line 301 "jamgram.y"
-{ yyval.parse = yyvsp[-1].parse; }
-break;
-case 59:
+    { (yyval).parse = (yyvsp[(3) - (4)]).parse; }
+    break;
+
+  case 60:
 #line 310 "jamgram.y"
-{ yyval.parse = prule( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 60:
+    { (yyval).parse = prule( (yyvsp[(1) - (2)]).parse, (yyvsp[(2) - (2)]).parse ); }
+    break;
+
+  case 61:
 #line 312 "jamgram.y"
-{ yyval.parse = pon( yyvsp[-2].parse, prule( yyvsp[-1].parse, yyvsp[0].parse ) ); }
-break;
-case 61:
+    { (yyval).parse = pon( (yyvsp[(2) - (4)]).parse, prule( (yyvsp[(3) - (4)]).parse, (yyvsp[(4) - (4)]).parse ) ); }
+    break;
+
+  case 62:
 #line 314 "jamgram.y"
-{ yyval.parse = pon( yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 62:
+    { (yyval).parse = pon( (yyvsp[(2) - (4)]).parse, (yyvsp[(4) - (4)]).parse ); }
+    break;
+
+  case 63:
 #line 323 "jamgram.y"
-{ yyval.number = 0; }
-break;
-case 63:
+    { (yyval).number = 0; }
+    break;
+
+  case 64:
 #line 325 "jamgram.y"
-{ yyval.number = yyvsp[-1].number | yyvsp[0].number; }
-break;
-case 64:
+    { (yyval).number = (yyvsp[(1) - (2)]).number | (yyvsp[(2) - (2)]).number; }
+    break;
+
+  case 65:
 #line 329 "jamgram.y"
-{ yyval.number = RULE_UPDATED; }
-break;
-case 65:
+    { (yyval).number = RULE_UPDATED; }
+    break;
+
+  case 66:
 #line 331 "jamgram.y"
-{ yyval.number = RULE_TOGETHER; }
-break;
-case 66:
+    { (yyval).number = RULE_TOGETHER; }
+    break;
+
+  case 67:
 #line 333 "jamgram.y"
-{ yyval.number = RULE_IGNORE; }
-break;
-case 67:
+    { (yyval).number = RULE_IGNORE; }
+    break;
+
+  case 68:
 #line 335 "jamgram.y"
-{ yyval.number = RULE_QUIETLY; }
-break;
-case 68:
+    { (yyval).number = RULE_QUIETLY; }
+    break;
+
+  case 69:
 #line 337 "jamgram.y"
-{ yyval.number = RULE_PIECEMEAL; }
-break;
-case 69:
+    { (yyval).number = RULE_PIECEMEAL; }
+    break;
+
+  case 70:
 #line 339 "jamgram.y"
-{ yyval.number = RULE_EXISTING; }
-break;
-case 70:
+    { (yyval).number = RULE_EXISTING; }
+    break;
+
+  case 71:
 #line 341 "jamgram.y"
-{ yyval.number = atoi( yyvsp[0].string ) * RULE_MAXLINE; }
-break;
-case 71:
+    { (yyval).number = atoi( (yyvsp[(2) - (2)]).string ) * RULE_MAXLINE; }
+    break;
+
+  case 72:
 #line 350 "jamgram.y"
-{ yyval.parse = pnull(); }
-break;
-case 72:
+    { (yyval).parse = pnull(); }
+    break;
+
+  case 73:
 #line 352 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; }
-break;
-#line 877 "y.tab.c"
+    { (yyval).parse = (yyvsp[(2) - (2)]).parse; }
+    break;
+
+
+/* Line 1267 of yacc.c.  */
+#line 1948 "y.tab.c"
+      default: break;
     }
-    yyssp -= yym;
-    yystate = *yyssp;
-    yyvsp -= yym;
-    yym = yylhs[yyn];
-    if (yystate == 0 && yym == 0)
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
     {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: after reduction, shifting from state 0 to\
- state %d\n", YYPREFIX, YYFINAL);
-#endif
-        yystate = YYFINAL;
-        *++yyssp = YYFINAL;
-        *++yyvsp = yyval;
-        if (yychar < 0)
-        {
-            if ((yychar = yylex()) < 0) yychar = 0;
-#if YYDEBUG
-            if (yydebug)
-            {
-                yys = 0;
-                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-                if (!yys) yys = "illegal-symbol";
-                printf("%sdebug: state %d, reading %d (%s)\n",
-                        YYPREFIX, YYFINAL, yychar, yys);
-            }
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
 #endif
-        }
-        if (yychar == 0) goto yyaccept;
-        goto yyloop;
     }
-    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
-        yystate = yytable[yyn];
-    else
-        yystate = yydgoto[yym];
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: after reduction, shifting from state %d \
-to state %d\n", YYPREFIX, *yyssp, yystate);
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
 #endif
-    if (yyssp >= yysslim && yygrowstack())
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
     {
-        goto yyoverflow;
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
     }
-    *++yyssp = yystate;
-    *++yyvsp = yyval;
-    goto yyloop;
-yyoverflow:
-    yyerror("yacc stack overflow");
-yyabort:
-    return (1);
-yyaccept:
-    return (0);
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
+
+
+
diff --speed-large-files --minimal -Nru tmp/jam-2.5/jamgram.h work/main.d/jam-2.5/jamgram.h
--- tmp/jam-2.5/jamgram.h	2004-08-19 14:19:34.000000000 -0400
+++ work/main.d/jam-2.5/jamgram.h	2007-01-19 12:54:24.000000000 -0300
@@ -1,51 +1,151 @@
-#ifndef YYERRCODE
-#define YYERRCODE 256
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     _SEMIC_t = 258,
+     _COLON_t = 259,
+     _BANG_t = 260,
+     _BANG_EQUALS_t = 261,
+     _QUESTION_EQUALS_t = 262,
+     _LPAREN_t = 263,
+     _RPAREN_t = 264,
+     _LBRACKET_t = 265,
+     _RBRACKET_t = 266,
+     _LBRACE_t = 267,
+     _RBRACE_t = 268,
+     _AMPER_t = 269,
+     _AMPERAMPER_t = 270,
+     _PLUS_EQUALS_t = 271,
+     _LANGLE_t = 272,
+     _LANGLE_EQUALS_t = 273,
+     _EQUALS_t = 274,
+     _RANGLE_t = 275,
+     _RANGLE_EQUALS_t = 276,
+     _BAR_t = 277,
+     _BARBAR_t = 278,
+     ACTIONS_t = 279,
+     BIND_t = 280,
+     BREAK_t = 281,
+     CASE_t = 282,
+     CONTINUE_t = 283,
+     DEFAULT_t = 284,
+     ELSE_t = 285,
+     EXISTING_t = 286,
+     FOR_t = 287,
+     IF_t = 288,
+     IGNORE_t = 289,
+     IN_t = 290,
+     INCLUDE_t = 291,
+     LOCAL_t = 292,
+     MAXLINE_t = 293,
+     ON_t = 294,
+     PIECEMEAL_t = 295,
+     QUIETLY_t = 296,
+     RETURN_t = 297,
+     RULE_t = 298,
+     SWITCH_t = 299,
+     TOGETHER_t = 300,
+     UPDATED_t = 301,
+     WHILE_t = 302,
+     ARG = 303,
+     STRING = 304
+   };
+#endif
+/* Tokens.  */
+#define _SEMIC_t 258
+#define _COLON_t 259
+#define _BANG_t 260
+#define _BANG_EQUALS_t 261
+#define _QUESTION_EQUALS_t 262
+#define _LPAREN_t 263
+#define _RPAREN_t 264
+#define _LBRACKET_t 265
+#define _RBRACKET_t 266
+#define _LBRACE_t 267
+#define _RBRACE_t 268
+#define _AMPER_t 269
+#define _AMPERAMPER_t 270
+#define _PLUS_EQUALS_t 271
+#define _LANGLE_t 272
+#define _LANGLE_EQUALS_t 273
+#define _EQUALS_t 274
+#define _RANGLE_t 275
+#define _RANGLE_EQUALS_t 276
+#define _BAR_t 277
+#define _BARBAR_t 278
+#define ACTIONS_t 279
+#define BIND_t 280
+#define BREAK_t 281
+#define CASE_t 282
+#define CONTINUE_t 283
+#define DEFAULT_t 284
+#define ELSE_t 285
+#define EXISTING_t 286
+#define FOR_t 287
+#define IF_t 288
+#define IGNORE_t 289
+#define IN_t 290
+#define INCLUDE_t 291
+#define LOCAL_t 292
+#define MAXLINE_t 293
+#define ON_t 294
+#define PIECEMEAL_t 295
+#define QUIETLY_t 296
+#define RETURN_t 297
+#define RULE_t 298
+#define SWITCH_t 299
+#define TOGETHER_t 300
+#define UPDATED_t 301
+#define WHILE_t 302
+#define ARG 303
+#define STRING 304
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
-#define _BANG_t 257
-#define _BANG_EQUALS_t 258
-#define _AMPER_t 259
-#define _AMPERAMPER_t 260
-#define _LPAREN_t 261
-#define _RPAREN_t 262
-#define _PLUS_EQUALS_t 263
-#define _COLON_t 264
-#define _SEMIC_t 265
-#define _LANGLE_t 266
-#define _LANGLE_EQUALS_t 267
-#define _EQUALS_t 268
-#define _RANGLE_t 269
-#define _RANGLE_EQUALS_t 270
-#define _QUESTION_EQUALS_t 271
-#define _LBRACKET_t 272
-#define _RBRACKET_t 273
-#define ACTIONS_t 274
-#define BIND_t 275
-#define BREAK_t 276
-#define CASE_t 277
-#define CONTINUE_t 278
-#define DEFAULT_t 279
-#define ELSE_t 280
-#define EXISTING_t 281
-#define FOR_t 282
-#define IF_t 283
-#define IGNORE_t 284
-#define IN_t 285
-#define INCLUDE_t 286
-#define LOCAL_t 287
-#define MAXLINE_t 288
-#define ON_t 289
-#define PIECEMEAL_t 290
-#define QUIETLY_t 291
-#define RETURN_t 292
-#define RULE_t 293
-#define SWITCH_t 294
-#define TOGETHER_t 295
-#define UPDATED_t 296
-#define WHILE_t 297
-#define _LBRACE_t 298
-#define _BAR_t 299
-#define _BARBAR_t 300
-#define _RBRACE_t 301
-#define ARG 302
-#define STRING 303
+extern YYSTYPE yylval;
+
diff --speed-large-files --minimal -Nru tmp/jam-2.5/jamgramtab.h work/main.d/jam-2.5/jamgramtab.h
--- tmp/jam-2.5/jamgramtab.h	2003-04-23 01:57:07.000000000 -0300
+++ work/main.d/jam-2.5/jamgramtab.h	2007-01-19 12:54:24.000000000 -0300
@@ -1,20 +1,24 @@
+	{ ";", _SEMIC_t },
+	{ ":", _COLON_t },
 	{ "!", _BANG_t },
 	{ "!=", _BANG_EQUALS_t },
-	{ "&", _AMPER_t },
-	{ "&&", _AMPERAMPER_t },
+	{ "?=", _QUESTION_EQUALS_t },
 	{ "(", _LPAREN_t },
 	{ ")", _RPAREN_t },
+	{ "[", _LBRACKET_t },
+	{ "]", _RBRACKET_t },
+	{ "{", _LBRACE_t },
+	{ "}", _RBRACE_t },
+	{ "&", _AMPER_t },
+	{ "&&", _AMPERAMPER_t },
 	{ "+=", _PLUS_EQUALS_t },
-	{ ":", _COLON_t },
-	{ ";", _SEMIC_t },
 	{ "<", _LANGLE_t },
 	{ "<=", _LANGLE_EQUALS_t },
 	{ "=", _EQUALS_t },
 	{ ">", _RANGLE_t },
 	{ ">=", _RANGLE_EQUALS_t },
-	{ "?=", _QUESTION_EQUALS_t },
-	{ "[", _LBRACKET_t },
-	{ "]", _RBRACKET_t },
+	{ "|", _BAR_t },
+	{ "||", _BARBAR_t },
 	{ "actions", ACTIONS_t },
 	{ "bind", BIND_t },
 	{ "break", BREAK_t },
@@ -39,7 +43,3 @@
 	{ "together", TOGETHER_t },
 	{ "updated", UPDATED_t },
 	{ "while", WHILE_t },
-	{ "{", _LBRACE_t },
-	{ "|", _BAR_t },
-	{ "||", _BARBAR_t },
-	{ "}", _RBRACE_t },
diff --speed-large-files --minimal -Nru tmp/jam-2.5/jamgram.y work/main.d/jam-2.5/jamgram.y
--- tmp/jam-2.5/jamgram.y	2003-04-23 01:57:07.000000000 -0300
+++ work/main.d/jam-2.5/jamgram.y	2007-01-19 12:54:24.000000000 -0300
@@ -1,20 +1,24 @@
+%token _SEMIC_t
+%token _COLON_t
 %token _BANG_t
 %token _BANG_EQUALS_t
-%token _AMPER_t
-%token _AMPERAMPER_t
+%token _QUESTION_EQUALS_t
 %token _LPAREN_t
 %token _RPAREN_t
+%token _LBRACKET_t
+%token _RBRACKET_t
+%token _LBRACE_t
+%token _RBRACE_t
+%token _AMPER_t
+%token _AMPERAMPER_t
 %token _PLUS_EQUALS_t
-%token _COLON_t
-%token _SEMIC_t
 %token _LANGLE_t
 %token _LANGLE_EQUALS_t
 %token _EQUALS_t
 %token _RANGLE_t
 %token _RANGLE_EQUALS_t
-%token _QUESTION_EQUALS_t
-%token _LBRACKET_t
-%token _RBRACKET_t
+%token _BAR_t
+%token _BARBAR_t
 %token ACTIONS_t
 %token BIND_t
 %token BREAK_t
@@ -39,10 +43,6 @@
 %token TOGETHER_t
 %token UPDATED_t
 %token WHILE_t
-%token _LBRACE_t
-%token _BAR_t
-%token _BARBAR_t
-%token _RBRACE_t
 /*
  * Copyright 1993-2002 Christopher Seiwald and Perforce Software, Inc.
  *
diff --speed-large-files --minimal -Nru tmp/jam-2.5/Jam.html work/main.d/jam-2.5/Jam.html
--- tmp/jam-2.5/Jam.html	2003-04-23 01:45:49.000000000 -0300
+++ work/main.d/jam-2.5/Jam.html	2007-01-19 12:51:48.000000000 -0300
@@ -851,7 +851,7 @@
 
 	<DD> Builds a direct dependency: makes each of <I>targets1</I>
 	depend on each of <I>targets2</I>.  Generally, <I>targets1</I>
-	will be rebuilt if <I>targets2</I> are themselves rebuilt are
+	will be rebuilt if <I>targets2</I> are themselves rebuilt
 	or are newer than <I>targets1</I>.
 
 	<P><DT><CODE>
@@ -1069,7 +1069,7 @@
 
 	<P>
 
-	These two variable control header file scanning.  $(HDRSCAN) is
+	These two variables control header file scanning.  $(HDRSCAN) is
 	an <b>egrep</b>(1) pattern, with ()'s surrounding the file name,
 	used to find file inclusion statements in source files.  Jambase
 	uses $(HDRPATTERN) as the pattern for $(HDRSCAN).  $(HDRRULE)
diff --speed-large-files --minimal -Nru tmp/jam-2.5/Makefile work/main.d/jam-2.5/Makefile
--- tmp/jam-2.5/Makefile	2003-04-23 01:45:50.000000000 -0300
+++ work/main.d/jam-2.5/Makefile	2007-01-19 12:51:48.000000000 -0300
@@ -59,7 +59,7 @@
 	rules.c scan.c search.c timestamp.c variable.c
 
 all: $(EXENAME)
-	$(EXENAME)
+	$(EXENAME) -a -dx -s CCFLAGS="$(CFLAGS)"
 
 $(EXENAME):
 	$(CC) $(TARGET) $(CFLAGS) $(SOURCES) $(LINKLIBS)
