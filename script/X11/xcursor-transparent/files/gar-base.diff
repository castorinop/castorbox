diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/autoconf/acconfig.h work/main.d/rxvt-2.6.4/autoconf/acconfig.h
--- tmp/rxvt-2.6.4/autoconf/acconfig.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/autoconf/acconfig.h	1999-06-22 04:52:45.000000000 -0300
@@ -0,0 +1,155 @@
+/* ------------------------------------------------------------------------- */
+/* Set TERMINFO value to the value given by configure */
+#undef RXVT_TERMINFO
+
+/* Set TERM to the value given by configure */
+#undef TERMENV
+
+/* Define if you want to use your system's memset() */
+#undef NO_RMEMSET
+
+/* Define if you don't want any resources read */
+#undef NO_RESOURCES 
+
+/* Define if you want to use XGetDefault instead of our internal version
+ * which only reads ~/.Xdefaults, if it exists, otherwise ~/.Xresources if it
+ * exists, and saves 60-150kB memory */
+#undef USE_XGETDEFAULT
+
+/* Define to remove old rxvt (ver 2.20 and before) style selection */
+#undef NO_OLD_SELECTION
+
+/* Define to remove xterm style selection */
+#undef NO_NEW_SELECTION
+
+/* Define if you want the depth of scrollbars and menus to be less
+ * (width of 3d-look shadows and highlights)  --pjh */
+#undef HALFSHADOW
+
+/* Define if you want KANJI support */
+/* after compilation, rename executable as `kxvt' */
+#undef KANJI
+
+/* Define if you want Chinese BIG5 support */
+/* after compilation, rename executable as `crxvt' */
+#undef ZH
+
+/* Define if you want Chinese GB (zh_CN i.e. GB2312) support */
+/* after compilation, rename executable as `gbxvt' */
+#undef ZHCN
+
+/* Define if Xlocale support doesn't work */
+#undef NO_XLOCALE
+
+/* Define if setlocale (defined to Xsetlocale) doesn't work */
+#undef NO_XSETLOCALE
+ 
+/* Define if plain old setlocale doesn't work */
+#undef NO_SETLOCALE
+
+/* Define if you want Menubar support */
+#undef MENUBAR
+
+/* Define if you don't want support for the backspace key */
+#undef NO_BACKSPACE_KEY
+
+/* Define if you don't want support for the (non-keypad) delete key */
+#undef NO_DELETE_KEY
+
+/* Define if you want Rob Nation's own graphic mode */
+#undef RXVT_GRAPHICS
+
+/* Define if you want to use NeXT style scrollbars */
+#undef NEXT_SCROLLBAR
+
+/* Define if you want to revert to Xterm style scrollbars */
+#undef XTERM_SCROLLBAR
+
+/* Define if you want support for Greek Elot-928 & IBM-437 keyboard */
+/* see doc/README.greek */
+#undef GREEK_SUPPORT
+
+/* Define if you want tty's to be setgid() to the `tty' group */
+#undef TTY_GID_SUPPORT
+
+/* Define if you want to have XIM (X Input Method) protocol support
+ * This is required for multibyte characters input. */
+#undef USE_XIM
+
+/* Define if you want to have utmp/utmpx support */
+#undef UTMP_SUPPORT
+
+/* Define if you want to have wtmp support when utmp/utmpx is enabled */
+#undef WTMP_SUPPORT
+
+/* Define if you want to have sexy-looking background pixmaps. Needs libXpm */
+#undef XPM_BACKGROUND
+
+/* Define if you want your background use the parent window background */
+#undef TRANSPARENT
+
+/* Define if you include <X11/xpm.h> on a normal include path (be careful) */
+#undef XPM_INC_X11
+
+/* Disable the secondary screen ("\E[?47h" / "\E[?47l")
+ * Many programs use the secondary screen as their workplace. The advantage
+ * is, that when you exit those programs, your previous screen contents (in
+ * general the shell as you left it) will be shown again. */
+#undef NO_SECONDARY_SCREEN
+
+/* Define if you want continual scrolling on when you keep the
+ * scrollbar button pressed */
+#undef NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING
+
+/*
+ * Use wheel events (button4 and button5) to scroll.  Even if you don't
+ * have a wheeled mouse, this is harmless unless you have an exotic mouse!
+ */
+#undef NO_MOUSE_WHEEL
+
+/* ------------------------------------------------------------------------- */
+/* Define in utmp.h has struct utmp */
+#undef HAVE_STRUCT_UTMP
+
+/* Define if struct utmp contains ut_host */
+#undef HAVE_UTMP_HOST
+
+/* Define location of utmp */
+#undef RXVT_UTMP_FILE
+
+/* Define in utmpx.h has struct utmpx */
+#undef HAVE_STRUCT_UTMPX
+
+/* Define if struct utmpx contains ut_host */
+#undef HAVE_UTMPX_HOST
+
+/* Define location of utmpx */
+#undef RXVT_UTMPX_FILE
+
+/* Define location of wtmp */
+#undef RXVT_WTMP_FILE
+
+/* Define location of wtmpx */
+#undef RXVT_WTMPX_FILE
+
+/* Define location of ttys/ttytab */
+#undef TTYTAB_FILENAME
+
+/* Define if you need function prototypes */
+#undef PROTOTYPES
+
+/* Define if you have XPointer typedef */
+#undef HAVE_XPOINTER
+
+/* Define if you have _GNU_SOURCE getpt() */
+#undef HAVE_GETPT
+
+/* Define possible pty types */
+#undef PTYS_ARE_NUMERIC
+#undef PTYS_ARE_PTMX
+#undef PTYS_ARE_PTC
+#undef PTYS_ARE__GETPTY
+#undef PTYS_ARE_GETPTY
+#undef PTYS_ARE_GETPT
+#undef PTYS_ARE_CLONE
+#undef PTYS_ARE_SEARCHED
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/autoconf/aclocal.m4 work/main.d/rxvt-2.6.4/autoconf/aclocal.m4
--- tmp/rxvt-2.6.4/autoconf/aclocal.m4	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/autoconf/aclocal.m4	1998-04-20 04:24:15.000000000 -0300
@@ -0,0 +1,225 @@
+dnl> $Id: aclocal.m4,v 1.2 1998/04/20 07:24:15 mason Exp $
+dnl> test to find the hard-to-find libXpm
+dnl> mostly copied from AC_PATH_X & AC_PATH_DIRECT, but explictly set
+
+AC_DEFUN(VT_FIND_LIBXPM,
+[
+AC_REQUIRE_CPP()
+
+# Initialize some more variables set by options.
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+
+# If we find XPM, set shell vars xpm_includes and xpm_libraries to the
+# paths, otherwise set no_xpm=yes.
+# Uses ac_ vars as temps to allow command line to override cache and checks.
+AC_MSG_CHECKING(for libXpm)
+
+AC_ARG_WITH(xpm_includes,
+  [  --with-xpm-includes=DIR use XPM includes in DIR],
+  xpm_includes="$withval", xpm_includes=NO)
+AC_ARG_WITH(xpm_library,
+  [  --with-xpm-library=DIR  use XPM library in DIR],
+  xpm_libraries="$withval", xpm_libraries=NO)
+
+# --without-xpm overrides everything else, but does not touch the cache.
+AC_ARG_WITH(xpm,
+  [  --with-xpm              use XPM])
+if test "$with_xpm" = no; then
+  have_xpm=disabled
+else
+  AC_CACHE_VAL(ac_cv_have_xpm, [
+  vt_xpm_include_X11=no
+  if test -n "$xpm_includes"; then
+    vt_xpm_includes=$xpm_includes
+  else
+    vt_xpm_includes=NO
+  fi
+  if test -n "$xpm_libraries"; then
+    vt_xpm_libraries=$xpm_libraries
+  else
+    vt_xpm_libraries=NO
+  fi
+
+  VT_XPM_DIRECT
+
+  if test "$vt_xpm_includes" = NO -o "$vt_xpm_libraries" = NO; then
+    ac_cv_have_xpm="have_xpm=no"
+  else
+    ac_cv_have_xpm="have_xpm=yes \
+        vt_xpm_includes=$vt_xpm_includes vt_xpm_libraries=$vt_xpm_libraries \
+	vt_xpm_include_X11=$vt_xpm_include_X11"
+  fi])dnl
+  eval "$ac_cv_have_xpm"
+fi
+
+if test "$have_xpm" != yes; then
+  AC_MSG_RESULT($have_xpm)
+  no_xpm=yes
+else
+  if test "$xpm_includes" != NO; then
+    if test "$xpm_includes" != "$vt_xpm_includes"; then
+      vt_xpm_include_X11=no
+      if test -z "$xpm_includes"; then
+	AC_TRY_CPP([#include <X11/xpm.h>],
+	vt_xpm_include_X11=yes)
+      else
+        if test -r "$xpm_includes/X11/xpm.h"; then
+	  vt_xpm_include_X11=yes
+        fi
+      fi
+    fi
+    vt_xpm_includes=$xpm_includes
+  fi
+  if test "x$xpm_libraries" != xNO; then
+    vt_xpm_libraries=$xpm_libraries
+  fi
+  # Update the cache value to reflect the command line values.
+  ac_cv_have_xpm="have_xpm=yes \
+	vt_xpm_includes=$vt_xpm_includes vt_xpm_libraries=$vt_xpm_libraries \
+	vt_xpm_include_X11=$vt_xpm_include_X11"
+  eval "$ac_cv_have_xpm"
+  AC_MSG_RESULT([-I$vt_xpm_includes, -L$vt_xpm_libraries])
+  if test -n "$vt_xpm_includes"; then
+    XPM_CPPFLAGS="-DHAVE_LIBXPM"
+  fi
+  if test -n "$vt_xpm_includes"; then
+    XPM_CFLAGS="-I$vt_xpm_includes"
+  fi
+  XPM_LIBS="-lXpm"
+  if test -n "$vt_xpm_libraries"; then
+    XPM_LIBS="-L$vt_xpm_libraries $XPM_LIBS"
+  fi
+  if test "x$vt_xpm_include_X11" = xyes; then
+    AC_DEFINE(XPM_INC_X11)
+  fi
+fi
+
+AC_SUBST(XPM_CPPFLAGS)
+AC_SUBST(XPM_CFLAGS)
+AC_SUBST(XPM_LIBS)
+])
+
+dnl Internal subroutine of VT_FIND_LIBXPM
+dnl Set vt_xpm_include and vt_xpm_libr
+# -------------- find xpm.h and Xpm.a/Xpm.so/Xpm.sl
+AC_DEFUN(VT_XPM_DIRECT,
+[if test "$vt_xpm_includes" = NO; then
+  # Guess where to find xpm.h
+
+  # First, try using that file with no special directory specified.
+AC_TRY_CPP([#include <X11/xpm.h>],
+[# We can compile using X headers with no special include directory.
+vt_xpm_includes=
+vt_xpm_include_X11=yes],
+[# Look for the header file in a standard set of common directories.
+  for ac_dir in               \
+    /usr/X11/include          \
+    /usr/X11R6/include        \
+    /usr/X11R5/include        \
+    /usr/X11R4/include        \
+                              \
+    /usr/include/X11          \
+    /usr/include/X11R6        \
+    /usr/include/X11R5        \
+    /usr/include/X11R4        \
+                              \
+    /usr/local/X11/include    \
+    /usr/local/X11R6/include  \
+    /usr/local/X11R5/include  \
+    /usr/local/X11R4/include  \
+                              \
+    /usr/local/include/X11    \
+    /usr/local/include/X11R6  \
+    /usr/local/include/X11R5  \
+    /usr/local/include/X11R4  \
+                              \
+    /usr/X386/include         \
+    /usr/x386/include         \
+    /usr/XFree86/include/X11  \
+                              \
+    /usr/include              \
+    /usr/local/include        \
+    /usr/unsupported/include  \
+    /usr/athena/include       \
+    /usr/local/x11r5/include  \
+    /usr/lpp/Xamples/include  \
+                              \
+    /usr/openwin/include      \
+    /usr/openwin/share/include \
+    ; \
+  do
+    if test -r "$ac_dir/X11/xpm.h"; then
+      vt_xpm_includes="$ac_dir"
+      vt_xpm_include_X11=yes
+      break
+    else
+      if test -r "$ac_dir/xpm.h"; then
+        vt_xpm_includes=$ac_dir
+        break
+      fi
+    fi
+  done])
+fi
+
+if test "$vt_xpm_libraries" = NO; then
+  # Check for the libraries.
+
+  # See if we find them without any special options.
+  # Don't add to $LIBS permanently.
+  ac_save_LIBS="$LIBS"
+  LIBS="-lXpm $LIBS"
+AC_TRY_LINK(, [XpmReadFileToPixmap()],
+[LIBS="$ac_save_LIBS"
+# We can link libXpm with no special library path.
+vt_xpm_libraries=],
+[LIBS="$ac_save_LIBS"
+# First see if replacing the include by lib works.
+for ac_dir in \
+    `echo "$vt_xpm_includes" | sed 's,include/X11,lib,;s,include,lib,'` \
+    /usr/X11/lib          \
+    /usr/X11R6/lib        \
+    /usr/X11R5/lib        \
+    /usr/X11R4/lib        \
+                          \
+    /usr/lib/X11          \
+    /usr/lib/X11R6        \
+    /usr/lib/X11R5        \
+    /usr/lib/X11R4        \
+                          \
+    /usr/local/X11/lib    \
+    /usr/local/X11R6/lib  \
+    /usr/local/X11R5/lib  \
+    /usr/local/X11R4/lib  \
+                          \
+    /usr/local/lib/X11    \
+    /usr/local/lib/X11R6  \
+    /usr/local/lib/X11R5  \
+    /usr/local/lib/X11R4  \
+                          \
+    /usr/X386/lib         \
+    /usr/x386/lib         \
+    /usr/XFree86/lib/X11  \
+                          \
+    /usr/lib              \
+    /usr/local/lib        \
+    /usr/unsupported/lib  \
+    /usr/athena/lib       \
+    /usr/local/x11r5/lib  \
+    /usr/lpp/Xamples/lib  \
+                          \
+    /usr/openwin/lib      \
+    /usr/openwin/share/lib \
+    ; \
+do
+dnl XXX Shouldn't this really use AC_TRY_LINK to be portable & robust??
+  for ac_extension in a so sl; do
+    if test -r $ac_dir/libXpm.$ac_extension; then
+      vt_xpm_libraries=$ac_dir
+      break 2
+    fi
+  done
+done])
+fi
+])
+
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/autoconf/config.h.in work/main.d/rxvt-2.6.4/autoconf/config.h.in
--- tmp/rxvt-2.6.4/autoconf/config.h.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/autoconf/config.h.in	2001-11-01 21:20:16.000000000 -0300
@@ -0,0 +1,285 @@
+/* autoconf/config.h.in.  Generated automatically from autoconf/configure.in by autoheader.  */
+
+/* Define if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+#undef _ALL_SOURCE
+#endif
+
+/* Define to empty if the keyword does not work.  */
+#undef const
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+#undef gid_t
+
+/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+#undef HAVE_SYS_WAIT_H
+
+/* Define as __inline if that's what the C compiler calls it.  */
+#undef inline
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+#undef mode_t
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+#undef pid_t
+
+/* Define if you need to in order for stat and other things to work.  */
+#undef _POSIX_SOURCE
+
+/* Define as the return type of signal handlers (int or void).  */
+#undef RETSIGTYPE
+
+/* Define if you have the ANSI C header files.  */
+#undef STDC_HEADERS
+
+/* Define if you can safely include both <sys/time.h> and <time.h>.  */
+#undef TIME_WITH_SYS_TIME
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+#undef uid_t
+
+/* Define if the X Window System is missing or not being used.  */
+#undef X_DISPLAY_MISSING
+
+/* ------------------------------------------------------------------------- */
+/* Set TERMINFO value to the value given by configure */
+#undef RXVT_TERMINFO
+
+/* Set TERM to the value given by configure */
+#undef TERMENV
+
+/* Define if you want to use your system's memset() */
+#undef NO_RMEMSET
+
+/* Define if you don't want any resources read */
+#undef NO_RESOURCES 
+
+/* Define if you want to use XGetDefault instead of our internal version
+ * which only reads ~/.Xdefaults, if it exists, otherwise ~/.Xresources if it
+ * exists, and saves 60-150kB memory */
+#undef USE_XGETDEFAULT
+
+/* Define to remove old rxvt (ver 2.20 and before) style selection */
+#undef NO_OLD_SELECTION
+
+/* Define to remove xterm style selection */
+#undef NO_NEW_SELECTION
+
+/* Define if you want the depth of scrollbars and menus to be less
+ * (width of 3d-look shadows and highlights)  --pjh */
+#undef HALFSHADOW
+
+/* Define if you want KANJI support */
+/* after compilation, rename executable as `kxvt' */
+#undef KANJI
+
+/* Define if you want Chinese BIG5 support */
+/* after compilation, rename executable as `crxvt' */
+#undef ZH
+
+/* Define if you want Chinese GB (zh_CN i.e. GB2312) support */
+/* after compilation, rename executable as `gbxvt' */
+#undef ZHCN
+
+/* Define if Xlocale support doesn't work */
+#undef NO_XLOCALE
+
+/* Define if setlocale (defined to Xsetlocale) doesn't work */
+#undef NO_XSETLOCALE
+
+ 
+/* Define if plain old setlocale doesn't work */
+#undef NO_SETLOCALE
+
+/* Define if you want Menubar support */
+#undef MENUBAR
+
+/* Define if you don't want support for the backspace key */
+#undef NO_BACKSPACE_KEY
+
+/* Define if you don't want support for the (non-keypad) delete key */
+#undef NO_DELETE_KEY
+
+/* Define if you want Rob Nation's own graphic mode */
+#undef RXVT_GRAPHICS
+
+/* Define if you want to use NeXT style scrollbars */
+#undef NEXT_SCROLLBAR
+
+/* Define if you want to revert to Xterm style scrollbars */
+#undef XTERM_SCROLLBAR
+
+/* Define if you want support for Greek Elot-928 & IBM-437 keyboard */
+/* see doc/README.greek */
+#undef GREEK_SUPPORT
+
+/* Define if you want tty's to be setgid() to the `tty' group */
+#undef TTY_GID_SUPPORT
+
+/* Define if you want to have XIM (X Input Method) protocol support
+ * This is required for multibyte characters input. */
+#undef USE_XIM
+
+/* Define if you want to have utmp/utmpx support */
+#undef UTMP_SUPPORT
+
+/* Define if you want to have wtmp support when utmp/utmpx is enabled */
+#undef WTMP_SUPPORT
+
+/* Define if you want to have sexy-looking background pixmaps. Needs libXpm */
+#undef XPM_BACKGROUND
+
+/* Define if you want your background use the parent window background */
+#undef TRANSPARENT
+
+/* Define if you include <X11/xpm.h> on a normal include path (be careful) */
+#undef XPM_INC_X11
+
+/* Disable the secondary screen ("\E[?47h" / "\E[?47l")
+ * Many programs use the secondary screen as their workplace. The advantage
+ * is, that when you exit those programs, your previous screen contents (in
+ * general the shell as you left it) will be shown again. */
+#undef NO_SECONDARY_SCREEN
+
+/* Define if you want continual scrolling on when you keep the
+ * scrollbar button pressed */
+#undef NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING
+
+/*
+ * Use wheel events (button4 and button5) to scroll.  Even if you don't
+ * have a wheeled mouse, this is harmless unless you have an exotic mouse!
+ */
+#undef NO_MOUSE_WHEEL
+
+/* ------------------------------------------------------------------------- */
+/* Define in utmp.h has struct utmp */
+#undef HAVE_STRUCT_UTMP
+
+/* Define if struct utmp contains ut_host */
+#undef HAVE_UTMP_HOST
+
+/* Define location of utmp */
+#undef RXVT_UTMP_FILE
+
+/* Define in utmpx.h has struct utmpx */
+#undef HAVE_STRUCT_UTMPX
+
+/* Define if struct utmpx contains ut_host */
+#undef HAVE_UTMPX_HOST
+
+/* Define location of utmpx */
+#undef RXVT_UTMPX_FILE
+
+/* Define location of wtmp */
+#undef RXVT_WTMP_FILE
+
+/* Define location of wtmpx */
+#undef RXVT_WTMPX_FILE
+
+/* Define location of ttys/ttytab */
+#undef TTYTAB_FILENAME
+
+/* Define if you need function prototypes */
+#undef PROTOTYPES
+
+/* Define if you have XPointer typedef */
+#undef HAVE_XPOINTER
+
+/* Define if you have _GNU_SOURCE getpt() */
+#undef HAVE_GETPT
+
+/* Define possible pty types */
+#undef PTYS_ARE_NUMERIC
+#undef PTYS_ARE_PTMX
+#undef PTYS_ARE_PTC
+#undef PTYS_ARE__GETPTY
+#undef PTYS_ARE_GETPTY
+#undef PTYS_ARE_GETPT
+#undef PTYS_ARE_CLONE
+#undef PTYS_ARE_SEARCHED
+
+/* The number of bytes in a char.  */
+#undef SIZEOF_CHAR
+
+/* The number of bytes in a int.  */
+#undef SIZEOF_INT
+
+/* The number of bytes in a int *.  */
+#undef SIZEOF_INT_P
+
+/* The number of bytes in a long.  */
+#undef SIZEOF_LONG
+
+/* The number of bytes in a long long.  */
+#undef SIZEOF_LONG_LONG
+
+/* The number of bytes in a short.  */
+#undef SIZEOF_SHORT
+
+/* Define if you have the _getpty function.  */
+#undef HAVE__GETPTY
+
+/* Define if you have the atexit function.  */
+#undef HAVE_ATEXIT
+
+/* Define if you have the grantpt function.  */
+#undef HAVE_GRANTPT
+
+/* Define if you have the seteuid function.  */
+#undef HAVE_SETEUID
+
+/* Define if you have the setutent function.  */
+#undef HAVE_SETUTENT
+
+/* Define if you have the unlockpt function.  */
+#undef HAVE_UNLOCKPT
+
+/* Define if you have the unsetenv function.  */
+#undef HAVE_UNSETENV
+
+/* Define if you have the <assert.h> header file.  */
+#undef HAVE_ASSERT_H
+
+/* Define if you have the <fcntl.h> header file.  */
+#undef HAVE_FCNTL_H
+
+/* Define if you have the <grp.h> header file.  */
+#undef HAVE_GRP_H
+
+/* Define if you have the <lastlog.h> header file.  */
+#undef HAVE_LASTLOG_H
+
+/* Define if you have the <libc.h> header file.  */
+#undef HAVE_LIBC_H
+
+/* Define if you have the <stdarg.h> header file.  */
+#undef HAVE_STDARG_H
+
+/* Define if you have the <stdlib.h> header file.  */
+#undef HAVE_STDLIB_H
+
+/* Define if you have the <string.h> header file.  */
+#undef HAVE_STRING_H
+
+/* Define if you have the <sys/byteorder.h> header file.  */
+#undef HAVE_SYS_BYTEORDER_H
+
+/* Define if you have the <sys/ioctl.h> header file.  */
+#undef HAVE_SYS_IOCTL_H
+
+/* Define if you have the <sys/select.h> header file.  */
+#undef HAVE_SYS_SELECT_H
+
+/* Define if you have the <sys/sockio.h> header file.  */
+#undef HAVE_SYS_SOCKIO_H
+
+/* Define if you have the <sys/time.h> header file.  */
+#undef HAVE_SYS_TIME_H
+
+/* Define if you have the <termios.h> header file.  */
+#undef HAVE_TERMIOS_H
+
+/* Define if you have the <unistd.h> header file.  */
+#undef HAVE_UNISTD_H
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/autoconf/configure.in work/main.d/rxvt-2.6.4/autoconf/configure.in
--- tmp/rxvt-2.6.4/autoconf/configure.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/autoconf/configure.in	2000-07-19 04:28:48.000000000 -0300
@@ -0,0 +1,899 @@
+dnl# -*- sh -*-
+dnl#
+dnl# $Id: configure.in,v 1.44.2.18 2000/07/19 07:28:48 gcw Exp $
+dnl#
+dnl# Process this file with autoconf to produce a configure script.
+dnl#
+AC_INIT(src/feature.h)
+AC_CONFIG_AUX_DIR(autoconf)
+AC_CONFIG_HEADER(config.h:autoconf/config.h.in)
+
+dnl RXVT version
+VERSION=`sed -n -e 's/^.*VERSION.*"\(.*\)"$/\1/p' ${srcdir}/src/version.h`
+DATE=`sed -n -e 's/^.*[ \t]*DATE.*"\(.*\)"$/\1/p' ${srcdir}/src/version.h`
+LSMDATE=`sed -n -e 's/^.*LSMDATE.*"\(.*\)"$/\1/p' ${srcdir}/src/version.h`
+AC_SUBST(VERSION)dnl 
+AC_SUBST(DATE)dnl 
+AC_SUBST(LSMDATE)dnl 
+echo "configuring for rxvt $VERSION"
+
+MALLOC_TYPE=S
+
+dnl# --------------------------------------------------------------------------
+dnl# CHECKING COMMAND LINE OPTIONS
+dnl# --------------------------------------------------------------------------
+AC_ARG_ENABLE(utmp,
+  [  --enable-utmp           enable utmp/utmpx support],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(UTMP_SUPPORT) utmp_support=yes
+  fi])
+
+AC_ARG_ENABLE(wtmp,
+  [  --enable-wtmp           enable wtmp support if you have utmp/utmpx support],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(WTMP_SUPPORT) wtmp_support=yes
+  fi])
+
+AC_ARG_ENABLE(xpm-background,
+  [  --enable-xpm-background enable XPM background pixmaps],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(XPM_BACKGROUND) xpm_background=yes
+  fi])
+
+AC_ARG_ENABLE(transparency,
+  [  --enable-transparency   enable transparent backgrounds],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(TRANSPARENT)
+  fi])
+
+AC_ARG_ENABLE(menubar,
+  [  --enable-menubar        enable Menubar],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(MENUBAR)
+  fi])
+
+AC_ARG_ENABLE(graphics,
+  [  --enable-graphics       enable rxvt own graphics mode (see src/graphics)],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(RXVT_GRAPHICS)
+  fi])
+
+AC_ARG_ENABLE(next-scroll,
+  [  --enable-next-scroll    enable NeXT style scrollbar],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(NEXT_SCROLLBAR)
+  fi])
+
+AC_ARG_ENABLE(xterm-scroll,
+  [  --enable-xterm-scroll   revert to Xterm style scrollbar],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(XTERM_SCROLLBAR)
+  fi])
+
+AC_ARG_ENABLE(half-shadow,
+  [  --enable-half-shadow    use half width/height shadows on non-Xterm scrollbar],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(HALFSHADOW)
+  fi])
+
+AC_ARG_ENABLE(xim,
+  [  --enable-xim            XIM (X Input Method) protocol support],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(USE_XIM)
+  fi])
+
+AC_ARG_ENABLE(kanji,
+  [  --enable-kanji          enable kanji support],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(KANJI)
+  fi])
+
+AC_ARG_ENABLE(big5,
+  [  --enable-big5           enable big5 support],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(ZH)
+  fi])
+
+AC_ARG_ENABLE(gb,
+  [  --enable-gb             enable gb support],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(ZHCN)
+  fi])
+
+AC_ARG_ENABLE(greek,
+  [  --enable-greek          enable greek keyboard support],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(GREEK_SUPPORT)
+  fi])
+
+AC_ARG_ENABLE(ttygid,
+  [  --enable-ttygid         enable tty setting to group \"tty\" - use only if
+                          your system uses this type of security],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(TTY_GID_SUPPORT)
+  fi])
+
+AC_ARG_ENABLE(backspace-key,
+  [  --disable-backspace-key disable handling of the backspace key],
+  [if test x$enableval = xno; then
+    AC_DEFINE(NO_BACKSPACE_KEY)
+  fi])
+
+AC_ARG_ENABLE(delete-key,
+  [  --disable-delete-key    disable handling of the delete key],
+  [if test x$enableval = xno; then
+    AC_DEFINE(NO_DELETE_KEY)
+  fi])
+
+AC_ARG_ENABLE(resources,
+  [  --disable-resources     disable all resource checking],
+  [if test x$enableval = xno; then
+    AC_DEFINE(NO_RESOURCES)
+  fi])
+
+AC_ARG_ENABLE(xgetdefault,
+  [  --enable-xgetdefault    enable resources via X instead of our small version],
+  [if test x$enableval = xyes; then
+    AC_DEFINE(USE_XGETDEFAULT)
+  fi])
+
+AC_ARG_ENABLE(memset,
+  [  --disable-memset        disable memset() function, use your system's instead],
+  [if test x$enableval = xno; then
+    AC_DEFINE(NO_RMEMSET)
+  fi])
+
+AC_ARG_ENABLE(swapscreen,
+  [  --disable-swapscreen    disable swap screen support],
+  [if test x$enableval = xno; then
+    AC_DEFINE(NO_SECONDARY_SCREEN)
+  fi])
+
+AC_ARG_ENABLE(keepscrolling,
+  [  --disable-keepscrolling disable continual scrolling on scrollbar arrow press],
+  [if test x$enableval = xno; then
+    AC_DEFINE(NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING)
+  fi])
+
+AC_ARG_ENABLE(mousewheel,
+  [  --disable-mousewheel    disable scrolling via mouse wheel or buttons 4 & 5],
+  [if test x$enableval = xno; then
+    AC_DEFINE(NO_MOUSE_WHEEL)
+  fi])
+
+AC_ARG_ENABLE(old-selection,
+  [  --disable-old-selection disable v2.20 (and prior) mouse selection style support],
+  [if test x$enableval = xno; then
+    AC_DEFINE(NO_OLD_SELECTION)
+  fi])
+
+AC_ARG_ENABLE(new-selection,
+  [  --disable-new-selection disable new mouse selection style (like xterm) support],
+  [if test x$enableval = xno; then
+    AC_DEFINE(NO_NEW_SELECTION)
+  fi])
+
+AC_ARG_ENABLE(dmalloc,
+  [  --enable-dmalloc        enable Gray Watson's malloc - for debugging use],
+  [if test x$enableval = xyes; then
+    MALLOC_TYPE=G
+    DEBUG=-DDEBUG_MALLOC
+    DLIB="-L/usr/local/lib -ldmalloc"
+    DINCLUDE=-I/usr/local/include
+  fi])
+
+AC_ARG_ENABLE(dlmalloc,
+  [  --enable-dlmalloc       enable Doug Lea's malloc - for production use
+                          - enable only one malloc package],
+  [if test x$enableval = xyes; then
+    MALLOC_TYPE=D
+    DEBUG=
+    DLIB="-L/usr/local/lib -ldlmalloc"
+    DINCLUDE=
+  fi])
+
+AC_ARG_WITH(term,
+  [  --with-term=NAME        set the terminal to NAME (default \"xterm\")],
+  [if test x$withval != x; then
+    AC_DEFINE_UNQUOTED(TERMENV,"$withval") term="$withval"
+  fi])
+
+AC_ARG_WITH(terminfo,
+  [  --with-terminfo=PATH    set the path to the terminfo tree to PATH],
+  [if test x$withval != x; then
+    AC_DEFINE_UNQUOTED(RXVT_TERMINFO,"$withval") terminfo="$withval"
+  fi])
+
+dnl# --------------------------------------------------------------------------
+
+AC_DEFINE(PROTOTYPES)
+
+dnl# --------------------------------------------------------------------------
+dnl# Supply default CFLAGS, if not specified by `CFLAGS=flags ./configure'
+dnl#
+if test -z "$CFLAGS"; then
+    if test -z "$CCOPTS"; then
+	CCOPTS='-O'
+dnl>	if test "x$GCC" = xyes; then
+dnl>	    if test x$system = xLinux; then
+dnl>		CCOPTS="$CCOPTS "'-O2 -fno-strength-reduce'
+dnl>	    fi
+dnl>	fi
+    fi
+    CFLAGS="$CCOPTS"
+fi
+
+dnl# Checks for programs.
+dnl AC_MAKE_SET
+
+AC_PROG_CC
+AC_PROG_CPP
+AC_PROG_INSTALL
+
+AC_PATH_PROG(MV, mv, mv)
+AC_PATH_PROG(RM, rm, rm)
+AC_PATH_PROG(CP, cp, cp)
+AC_PATH_PROG(SED, sed, sed)
+AC_PATH_PROG(AWK, awk, awk)
+AC_PATH_PROG(ECHO, echo, echo)
+AC_PATH_PROG(CMP, cmp, cmp)
+AC_PATH_PROG(TBL, tbl)
+
+dnl# system hacks
+AC_AIX
+AC_ISC_POSIX
+
+dnl# need a neat way to detect SVR4 or its features
+dnl# in src/command.c we use these functions:
+dnl# grantpt(), unlockpt(), ptsname(), which are defined in <sys/ptms.h>
+dnl# - but are these also defined for other systems?
+
+dnl# hack to find if this is SVR4 -- who knows?
+dnl## AC_MSG_CHECKING(for SVR4)
+dnl## AC_EGREP_CPP(yes,
+dnl## [#if defined (SVR4) || defined (_SVR4) || defined (__svr4__)
+dnl##   yes;
+dnl## #endif
+dnl## ], [AC_MSG_RESULT(yes); AC_DEFINE(PERHAPS_SVR4)], AC_MSG_RESULT(perhaps not?))
+
+AC_PATH_XTRA
+
+dnl# the only reasonable way to find libXpm is do-it-yourself
+dnl# only check if we want xpm-background
+
+if test x$xpm_background = xyes; then
+  VT_FIND_LIBXPM
+  if test x$no_xpm = xyes; then
+    xpm_background=needsmanualspecification
+  fi
+fi
+
+SAVETHECFLAGS=$CFLAGS
+CFLAGS="$CFLAGS $X_CFLAGS"
+AC_CACHE_CHECK([for XPointer], rxvt_cv_xpointer,
+[AC_TRY_COMPILE([#include <X11/Xlib.h>], [XPointer dummy;],
+rxvt_cv_xpointer=yes, rxvt_cv_xpointer=no)])
+if test x$rxvt_cv_xpointer = xyes; then
+  AC_DEFINE(HAVE_XPOINTER)
+fi
+CFLAGS=$SAVETHECFLAGS
+
+dnl# --------------------------------------------------------------------------
+dnl# CHECKING FOR HEADER FILES
+dnl# --------------------------------------------------------------------------
+AC_HEADER_SYS_WAIT
+AC_CHECK_HEADERS( \
+	assert.h \
+	fcntl.h \
+	grp.h \
+	libc.h \
+	lastlog.h \
+	stdarg.h \
+	stdlib.h \
+	string.h \
+	termios.h \
+	unistd.h \
+	sys/byteorder.h \
+	sys/ioctl.h \
+	sys/select.h \
+	sys/sockio.h \
+	sys/time.h \
+)
+
+AC_HEADER_TIME
+
+AC_C_CONST
+AC_C_INLINE
+
+dnl> AC_HEADER_STDC	 dnl# skip this test, Sun always fails anyhow.
+
+dnl# --------------------------------------------------------------------------
+dnl# CHECKING FOR MISSING TYPEDEFS
+dnl# --------------------------------------------------------------------------
+dnl# Missing typedefs and replacements
+AC_TYPE_MODE_T
+dnl> AC_CHECK_TYPE(umode_t, int)
+dnl> AC_CHECK_TYPE(off_t, long)
+AC_TYPE_PID_T
+AC_TYPE_UID_T
+
+
+AC_CHECK_SIZEOF(char, 1)
+AC_CHECK_SIZEOF(short, 2)
+AC_CHECK_SIZEOF(int, 4)
+AC_CHECK_SIZEOF(long, 4)
+AC_CHECK_SIZEOF(long long, 8)
+AC_CHECK_SIZEOF(int *, 4)
+dnl# ugly
+if test x$cross_compiling = xyes; then
+    AC_MSG_WARN(Define typedefs in src/rsizes.h manually if necessary)
+fi
+
+dnl# see usage below
+AC_DEFUN(RXVT_CHECK_SIZE,
+  [AC_CACHE_CHECK([for $2], $1,
+    [AC_TRY_COMPILE([#include <sys/types.h>], $2 dummy;,
+      [$1=yes],
+      [if test $ac_cv_sizeof_char -ge $3; then
+        $1="$4 char"
+      else
+        if test $ac_cv_sizeof_short -ge $3; then
+          $1="$4 short"
+        else
+          if test $ac_cv_sizeof_int -ge $3; then
+            $1="$4 int"
+          else
+            if test $ac_cv_sizeof_long -ge $3; then
+              $1="$4 long"
+            else
+              if test $ac_cv_sizeof_long_long -ge $3; then
+                $1="$4 long long"
+              else
+                $1="$4 long" # we _must_ have a (possibly wrong) default
+              fi
+            fi
+          fi
+        fi
+      fi
+      ])
+    ])
+  ]
+  if test x"$$1" != xyes; then
+    $5="typedef $$1 $2;"
+  fi
+  )
+dnl#
+dnl# Look for types the system may know about anyway.
+dnl#
+RXVT_CHECK_SIZE(rxvt_cv_int16_t, int16_t, 2, , rxvt_int16_typedef)
+AC_SUBST(rxvt_int16_typedef)
+RXVT_CHECK_SIZE(rxvt_cv_u_int16_t, u_int16_t, 2, unsigned, rxvt_u_int16_typedef)
+AC_SUBST(rxvt_u_int16_typedef)
+RXVT_CHECK_SIZE(rxvt_cv_int32_t, int32_t, 4, , rxvt_int32_typedef)
+AC_SUBST(rxvt_int32_typedef)
+RXVT_CHECK_SIZE(rxvt_cv_u_int32_t, u_int32_t, 4, unsigned, rxvt_u_int32_typedef)
+AC_SUBST(rxvt_u_int32_typedef)
+RXVT_CHECK_SIZE(rxvt_cv_int64_t, int64_t, 8, , rxvt_int64_typedef)
+AC_SUBST(rxvt_int64_typedef)
+RXVT_CHECK_SIZE(rxvt_cv_u_int64_t, u_int64_t, 8, unsigned, rxvt_u_int64_typedef)
+AC_SUBST(rxvt_u_int64_typedef)
+dnl#
+dnl# Now look for another we use
+dnl#
+if test $ac_cv_sizeof_int_p -eq 8; then
+  rxvt_intp_define="#define intp_t int64_t"
+  rxvt_u_intp_define="#define u_intp_t u_int64_t"
+else
+  if test $ac_cv_sizeof_int_p -eq 4; then
+    rxvt_intp_define="#define intp_t int32_t"
+    rxvt_u_intp_define="#define u_intp_t u_int32_t"
+  else
+    if test $ac_cv_sizeof_int_p -eq 2; then
+      rxvt_intp_define="#define intp_t int16_t"
+      rxvt_u_intp_define="#define u_intp_t u_int16_t"
+    else
+      rxvt_intp_define="#error set intp_t"
+      rxvt_u_intp_define="#error set u_intp_t"
+    fi
+  fi
+fi
+AC_SUBST(rxvt_intp_define)
+AC_SUBST(rxvt_u_intp_define)
+
+dnl# --------------------------------------------------------------------------
+dnl# CHECKING FOR LIBRARY FUNCTIONS
+dnl# --------------------------------------------------------------------------
+AC_TYPE_SIGNAL
+dnl> AC_FUNC_VPRINTF
+AC_CHECK_FUNCS( \
+	atexit \
+	unsetenv \
+	setutent \
+	seteuid \
+	_getpty \
+	grantpt \
+	unlockpt \
+)
+
+if test x$utmp_support = xyes; then
+dnl# --------------------------------------------------------------------------
+dnl# DO ALL UTMP AND WTMP CHECKING
+dnl# --------------------------------------------------------------------------
+dnl# check for host field in utmp structure
+
+dnl# --------------------------------------------
+AC_CHECK_HEADER(utmp.h,
+[AC_CACHE_CHECK([for struct utmp], rxvt_cv_struct_utmp,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <utmp.h>],
+[struct utmp ut;],
+rxvt_cv_struct_utmp=yes, rxvt_cv_struct_utmp=no)])
+if test x$rxvt_cv_struct_utmp = xyes; then
+  AC_DEFINE(HAVE_STRUCT_UTMP)
+fi
+]
+
+AC_CACHE_CHECK(for host in utmp struct, rxvt_cv_struct_utmp_host,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <utmp.h>],
+[struct utmp ut; ut.ut_host;],
+rxvt_cv_struct_utmp_host=yes, rxvt_cv_struct_utmp_host=no)])
+if test x$rxvt_cv_struct_utmp_host = xyes; then
+  AC_DEFINE(HAVE_UTMP_HOST)
+fi
+
+dnl# find utmp
+AC_CACHE_CHECK(where utmp is located, rxvt_cv_path_utmp,
+[AC_TRY_RUN([#include <stdio.h>
+#include <sys/types.h>
+#include <utmp.h>
+#include <errno.h>
+main()
+{
+changequote(, )dnl
+    char **u, *utmplist[] = {
+changequote([, ])dnl
+#ifdef UTMP_FILE
+	UTMP_FILE,
+#endif
+#ifdef _PATH_UTMP
+	_PATH_UTMP,
+#endif
+    "/var/run/utmp", "/var/adm/utmp", "/etc/utmp", "/usr/etc/utmp", "/usr/adm/utmp", NULL };
+    FILE *a, *f=fopen("conftestval", "w");
+    if (!f) exit(1);
+    for (u = utmplist; *u; u++) {
+	if ((a = fopen(*u, "r")) != NULL || errno == EACCES) {
+	    fprintf(f, "%s\n", *u);
+	    exit(0);
+	}
+    }
+    exit(0);
+}], rxvt_cv_path_utmp=`cat conftestval`, rxvt_cv_path_utmp=, dnl
+  AC_MSG_WARN([Define/undefine RXVT_UTMP_FILE in config.h manually]))])
+if test x${rxvt_cv_path_utmp} != x; then
+  AC_DEFINE_UNQUOTED(RXVT_UTMP_FILE, "$rxvt_cv_path_utmp")
+fi
+
+) dnl finished if HAVE_UTMP_H
+
+dnl# --------------------------------------------
+
+AC_CHECK_HEADER(utmpx.h,
+[AC_CACHE_CHECK([for struct utmpx], rxvt_cv_struct_utmpx,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <utmpx.h>],
+[struct utmpx ut;],
+rxvt_cv_struct_utmpx=yes, rxvt_cv_struct_utmpx=no)])
+if test x$rxvt_cv_struct_utmpx = xyes; then
+  AC_DEFINE(HAVE_STRUCT_UTMPX)
+fi
+]
+
+AC_CACHE_CHECK(for host in utmpx struct, rxvt_cv_struct_utmpx_host,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <utmpx.h>],
+[struct utmpx utx; utx.ut_host;],
+rxvt_cv_struct_utmpx_host=yes, rxvt_cv_struct_utmpx_host=no)])
+if test x$rxvt_cv_struct_utmpx_host = xyes; then
+  AC_DEFINE(HAVE_UTMPX_HOST)
+fi
+
+
+dnl# find utmpx - if a utmp file exists at the same location and is more than
+dnl# an hour newer, then dump the utmpx.  People leave lots of junk around.
+AC_CACHE_CHECK(where utmpx is located, rxvt_cv_path_utmpx,
+[AC_TRY_RUN([#include <stdio.h>
+#include <sys/types.h>
+#include <utmpx.h>
+#include <errno.h>
+#include <sys/stat.h>
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+main()
+{
+changequote(, )dnl
+    char **u, *p, *utmplist[] = {
+changequote([, ])dnl
+#ifdef UTMPX_FILE
+	UTMPX_FILE,
+#endif
+    "/var/adm/utmpx", "/etc/utmpx", NULL };
+    FILE *a, *f=fopen("conftestval", "w");
+    struct stat statu, statux;
+    if (!f) exit(1);
+    for (u = utmplist; *u; u++) {
+	if ((a = fopen(*u, "r")) != NULL || errno == EACCES) {
+	    if (stat(*u, &statux) < 0)
+		continue;
+	    p = strdup(*u);
+changequote(, )dnl
+	    p[strlen(p) - 1] = '\0';
+changequote([, ])dnl
+	    if (stat(p, &statu) >= 0
+		&& (statu.st_mtime - statux.st_mtime > 3600))
+		continue;
+	    fprintf(f, "%s\n", *u);
+	    exit(0);
+	}
+    }
+    exit(0);
+}], rxvt_cv_path_utmpx=`cat conftestval`, rxvt_cv_path_utmpx=, dnl
+  AC_MSG_WARN([Define/undefine RXVT_UTMPX_FILE in config.h manually]))])
+if test x${rxvt_cv_path_utmpx} != x; then
+  AC_DEFINE_UNQUOTED(RXVT_UTMPX_FILE, "$rxvt_cv_path_utmpx")
+fi
+
+) dnl finished if HAVE_UTMPX_H
+
+dnl# --------------------------------------------
+
+dnl# find wtmp
+AC_CACHE_CHECK(where wtmp is located, rxvt_cv_path_wtmp,
+[AC_TRY_RUN([#include <stdio.h>
+#ifdef HAVE_UTMPX_H
+#include <utmpx.h>
+#endif
+#ifdef HAVE_UTMP_H
+#include <utmp.h>
+#endif
+#include <errno.h>
+main()
+{
+    char **w, *wtmplist[] = {
+#ifdef WTMPX_FILE
+	WTMPX_FILE,
+#endif
+#ifdef WTMP_FILE
+	WTMP_FILE,
+#endif
+#ifdef _PATH_WTMP
+	_PATH_WTMP,
+#endif
+    "/var/log/wtmp", "/var/adm/wtmp", "/etc/wtmp", "/usr/etc/wtmp", "/usr/adm/wtmp", NULL }; 
+    FILE *a, *f=fopen("conftestval", "w");
+    if (!f) exit(1);
+    for (w = wtmplist; *w; w++) {
+	if ((a = fopen(*w, "r")) != NULL || errno == EACCES) {
+	    fprintf(f, "%s\n", *w);
+	    exit(0);
+	}
+    }
+    exit(0);
+}], rxvt_cv_path_wtmp=`cat conftestval`, rxvt_cv_path_wtmp=, dnl
+  AC_MSG_WARN([Define/undefine RXVT_WTMP_FILE in config.h manually]))])
+if test x${rxvt_cv_path_wtmp} != x; then
+  AC_DEFINE_UNQUOTED(RXVT_WTMP_FILE, "$rxvt_cv_path_wtmp")
+fi
+
+dnl# find wtmpx
+AC_CACHE_CHECK(where wtmpx is located, rxvt_cv_path_wtmpx,
+[AC_TRY_RUN([#include <stdio.h>
+#ifdef HAVE_UTMPX_H
+#include <utmpx.h>
+#endif
+#include <errno.h>
+main()
+{
+    char **w, *wtmplist[] = {
+#ifdef WTMPX_FILE
+	WTMPX_FILE,
+#endif
+    "/var/log/wtmpx", "/var/adm/wtmpx", NULL }; 
+    FILE *a, *f=fopen("conftestval", "w");
+    if (!f) exit(1);
+    for (w = wtmplist; *w; w++) {
+	if ((a = fopen(*w, "r")) != NULL || errno == EACCES) {
+	    fprintf(f, "%s\n", *w);
+	    exit(0);
+	}
+    }
+    exit(0);
+}], rxvt_cv_path_wtmpx=`cat conftestval`, rxvt_cv_path_wtmpx=, dnl
+  AC_MSG_WARN([Define/undefine RXVT_WTMPX_FILE in config.h manually]))])
+if test x${rxvt_cv_path_wtmpx} != x; then
+  AC_DEFINE_UNQUOTED(RXVT_WTMPX_FILE, "$rxvt_cv_path_wtmpx")
+fi
+
+fi
+dnl# --------------------------------------------------------------------------
+
+dnl# find ttys/ttytab
+AC_CACHE_CHECK(where ttys/ttytab is located, rxvt_cv_path_ttytab,
+[for ttys_file in   dnl
+  /etc/ttys /etc/ttytab;
+do
+  if test -f "$ttys_file" ; then 
+    rxvt_cv_path_ttytab=$ttys_file
+    break
+  fi
+done
+])
+if test x${rxvt_cv_path_ttytab} != x; then
+  AC_DEFINE_UNQUOTED(TTYTAB_FILENAME, "$rxvt_cv_path_ttytab")
+fi
+
+dnl# this is a really hack test for some basic Xlocale stuff
+SAVETHELIBS=$LIBS
+SAVETHECFLAGS=$CFLAGS
+CFLAGS="$CFLAGS $X_CFLAGS"
+LIBS="$LIBS $X_LIBS $X_EXTRA_LIBS -lX11"
+AC_CACHE_CHECK(for working Xlocale, rxvt_cv_func_xlocale,
+[AC_TRY_RUN([#include <X11/Xlib.h>
+main() {
+char *p;
+if ((p = XSetLocaleModifiers("@im=none")) != NULL && *p)
+exit (XSupportsLocale() ? 0 : 1);
+else
+exit (1);}],  dnl
+  rxvt_cv_func_xlocale=yes, rxvt_cv_func_xlocale=no,  dnl
+  AC_MSG_WARN([Define/undefine NO_XLOCALE in config.h manually]))])
+if test x${rxvt_cv_func_xlocale} = xno; then
+  AC_DEFINE(NO_XLOCALE)
+fi
+
+AC_CACHE_CHECK(for working X setlocale, rxvt_cv_func_xsetlocale,
+[AC_TRY_LINK([#define X_LOCALE 1
+#include <X11/Xlocale.h>],
+  [setlocale(LC_CTYPE, "");],
+  rxvt_cv_func_xsetlocale=yes, rxvt_cv_func_xsetlocale=no)])
+if test x${rxvt_cv_func_xsetlocale} = xno; then
+  AC_DEFINE(NO_XSETLOCALE)
+fi
+LIBS=$SAVETHELIBS
+CFLAGS=$SAVETHECFLAGS
+
+AC_CACHE_CHECK(for working plain setlocale, rxvt_cv_func_setlocale,
+[AC_TRY_LINK([#include <locale.h>],
+  [setlocale(LC_CTYPE, "");],
+  rxvt_cv_func_setlocale=yes, rxvt_cv_func_setlocale=no)])
+if test x${rxvt_cv_func_setlocale} = xno; then
+  AC_DEFINE(NO_SETLOCALE)
+fi
+
+AC_CACHE_CHECK(for getpt, rxvt_cv_func_getpt,
+[AC_TRY_LINK([#define _GNU_SOURCE
+#ifdef HAVE_STDLIB_H
+# include <stdlib.h>
+#endif],
+  [(void)getpt();],
+  rxvt_cv_func_getpt=yes, rxvt_cv_func_getpt=no)])
+if test x${rxvt_cv_func_getpt} = xyes; then
+  AC_DEFINE(HAVE_GETPT)
+fi
+
+# if we don't guess right then it's up to the user
+AC_CACHE_CHECK(for tty/pty type, rxvt_cv_ptys,
+[AC_TRY_RUN([#include <stdio.h>
+#ifdef HAVE_STDLIB_H
+# ifdef HAVE_GETPT
+#  define _GNU_SOURCE
+# endif
+# include <stdlib.h>
+#endif
+#ifdef HAVE_FCNTL_H
+# include <fcntl.h>
+#endif
+#include <sys/stat.h>
+#include <errno.h>
+main()
+{
+    int pty, checkerror;
+    FILE *a, *f=fopen("conftestval", "w");
+    struct stat statbuf;
+    extern int errno;
+
+    if (!f) exit(1);
+/* presume that S_IXOTH is required for people to access devices */
+    if (stat("/dev", &statbuf) < 0)
+	checkerror = 0;
+    else
+	checkerror = ((statbuf.st_mode & S_IXOTH) == S_IXOTH) ? 1 : 0;
+#if defined(__sgi) || defined(sgi) || defined(__sgi__)
+    if (stat("/dev/ptc", &statbuf) >= 0)
+# ifdef HAVE__GETPTY
+	fprintf(f, "SGI4");
+# else
+	fprintf(f, "SGI3");
+# endif
+    else
+	fprintf(f, "SGI4");
+    exit(0);
+#endif
+#ifdef _SCO_DS
+    if (stat("/dev/ttyp20", &statbuf) == 0) {
+	fprintf(f, "SCO");
+	exit(0);
+    }
+#endif
+/* HPUX: before ptmx */
+    pty = open("/dev/ptym/clone", O_RDWR);
+    if (pty >= 0 || (checkerror && errno == EACCES)) {
+	fprintf(f, "HPUX");
+	exit(0);
+    }
+#if defined(HAVE_GRANTPT) && defined(HAVE_UNLOCKPT)
+# ifdef HAVE_GETPT
+    pty = getpt();
+    if (pty >= 0 || errno == EACCES) {
+	fprintf(f, "GLIBC");
+	exit(0);
+    }
+# endif
+    if (stat("/dev/ptmx", &statbuf) >= 0
+	&& ((statbuf.st_mode & S_IFCHR) == S_IFCHR))
+	if (stat("/dev/pts/0", &statbuf) >= 0
+	    && ((statbuf.st_mode & S_IFCHR) == S_IFCHR)
+	    && ((pty = open("/dev/ptmx", O_RDWR)) >= 0
+		|| (checkerror && errno == EACCES))) {
+	    fprintf(f, "USG");
+	    exit(0);
+    }
+#endif
+    if (stat("/dev/ttyp20", &statbuf) == 0) {
+	fprintf(f, "SCO");
+	exit(0);
+    }
+    fprintf(f, "BSD");
+    exit(0);
+}], rxvt_cv_ptys=`cat conftestval`, rxvt_cv_ptys=UNKNOWN, dnl
+  AC_MSG_WARN([Define/undefine PTYS_ARE_* in config.h manually]))])
+
+if test x${rxvt_cv_ptys} = xSCO; then
+  AC_DEFINE(PTYS_ARE_NUMERIC)
+  AC_SUBST(PTYS_ARE_NUMERIC)
+fi
+if test x${rxvt_cv_ptys} = xUSG; then
+  AC_DEFINE(PTYS_ARE_PTMX)
+  AC_SUBST(PTYS_ARE_PTMX)
+  AC_DEFINE(PTYS_ARE_SEARCHED)
+  AC_SUBST(PTYS_ARE_SEARCHED)
+fi
+if test x${rxvt_cv_ptys} = xSGI3; then
+  AC_DEFINE(PTYS_ARE_PTC)
+  AC_SUBST(PTYS_ARE_PTC)
+fi
+if test x${rxvt_cv_ptys} = xSGI4; then
+  AC_DEFINE(PTYS_ARE__GETPTY)
+  AC_SUBST(PTYS_ARE__GETPTY)
+fi
+if test x${rxvt_cv_ptys} = xCONVEX; then
+  AC_DEFINE(PTYS_ARE_GETPTY)
+  AC_SUBST(PTYS_ARE_GETPTY)
+fi
+if test x${rxvt_cv_ptys} = xGLIBC; then
+  AC_DEFINE(PTYS_ARE_GETPT)
+  AC_SUBST(PTYS_ARE_GETPT)
+  AC_DEFINE(PTYS_ARE_SEARCHED)
+  AC_SUBST(PTYS_ARE_SEARCHED)
+fi
+if test x${rxvt_cv_ptys} = xHPUX; then
+  AC_DEFINE(PTYS_ARE_CLONE)
+  AC_SUBST(PTYS_ARE_CLONE)
+  AC_DEFINE(PTYS_ARE_SEARCHED)
+  AC_SUBST(PTYS_ARE_SEARCHED)
+fi
+if test x${rxvt_cv_ptys} = xBSD; then
+  AC_DEFINE(PTYS_ARE_SEARCHED)
+  AC_SUBST(PTYS_ARE_SEARCHED)
+fi
+
+dnl# FreeBSD needs to link libxpg4
+AC_CHECK_LIB(xpg4, setlocale, [LIBS="$LIBS -lxpg4"])
+
+dnl> AC_CHECK_FUNCS(gettimeofday putenv select socket)
+
+CFLAGS=${CFLAGS--O}
+LDFLAGS=${LDFLAGS--O}
+
+CPPFLAGS="$CPPFLAGS"
+AC_SUBST(DEBUG)
+AC_SUBST(DLIB)
+AC_SUBST(DINCLUDE)
+AC_SUBST(CFLAGS)
+AC_SUBST(CPPFLAGS)
+AC_SUBST(LDFLAGS)
+AC_SUBST(LIBS)
+AC_SUBST(X_CFLAGS)
+AC_SUBST(X_LIBS)
+AC_SUBST(X_EXTRA_LIBS)
+
+dnl# common parts of the Makefile
+MCOMMON=./autoconf/Make.common
+AC_SUBST_FILE(MCOMMON)
+
+AC_OUTPUT(autoconf/Make.common \
+Makefile \
+doc/Makefile \
+src/Makefile \
+src/graphics/Makefile \
+src/rsizes.h \
+rclock/Makefile \
+doc/yodl/rxvt.yo \
+doc/yodl/rxvtRef.yo \
+)
+
+echo "Configuration:
+
+  Rxvt version:               ${VERSION} : ${DATE}
+  Source code location:       ${srcdir}
+  Install path:               ${prefix}/bin
+  Compiler:                   ${CC}
+  Compiler flags:             ${CFLAGS}"
+
+if test "$MALLOC_TYPE" = S; then
+  echo "  malloc support:             system default"
+fi
+if test "$MALLOC_TYPE" = G; then
+  echo "  malloc support:             Gray Watson's dmalloc"
+fi
+if test "$MALLOC_TYPE" = D; then
+  echo "  malloc support:             Doug Lea's malloc"
+fi
+if test x${xpm_background} = xyes; then
+  echo "  Xpm library:                ${XPM_LIBS}"
+fi
+
+echo "
+The following are set in config.h
+"
+echo "  pty/tty type:               "${rxvt_cv_ptys}
+if test x${utmp_support} != xyes; then
+  echo "  utmp support:               disabled
+"
+else
+  echo "  utmp support:               enabled
+  utmp file:                  ${rxvt_cv_path_utmp}
+  utmpx file:                 ${rxvt_cv_path_utmpx}
+  wtmp file:                  ${rxvt_cv_path_wtmp}
+  wtmpx file:                 ${rxvt_cv_path_wtmpx}
+  ttys/ttytab file:           ${rxvt_cv_path_ttytab}
+"
+fi
+if test x${term} != x; then
+  echo "  set TERM to:                ${term}
+"
+fi
+if test x${terminfo} != x; then
+  echo "  set TERMINFO to:            ${terminfo}
+"
+fi
+if test x${rxvt_cv_ptys} = xUNKNOWN; then
+  echo ".----------------------------------------------------------------."
+  echo ". WARNING: could not determine tty/pty type.  Do not build until ."
+  echo ".          the appropriate PTYS_ARE_* is defined in config.h     ."
+  echo ".----------------------------------------------------------------."
+fi
+if test x${xpm_background} = xneedsmanualspecification; then
+  echo ".----------------------------------------------------------------."
+  echo ". WARNING: --enable-xpm-background was specified, however the    ."
+  echo ".          XPM includes files and libraries could not be found.  ."
+  echo ".          XPM backgrounds are now being DISABLED!  If you want  ."
+  echo ".          to use them you should rerun   configure   with the   ."
+  echo ".          appropriate --with-xpm-includes=/path/to/xpm/includes ."
+  echo ".          and --with-xpm-library=/path/to/xpm/library lines.    ."
+  echo ".----------------------------------------------------------------."
+fi
+echo "  *** Please check src/feature.h for further options ***
+"
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/autoconf/install-sh work/main.d/rxvt-2.6.4/autoconf/install-sh
--- tmp/rxvt-2.6.4/autoconf/install-sh	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/autoconf/install-sh	1998-04-20 04:30:28.000000000 -0300
@@ -0,0 +1,238 @@
+#! /bin/sh
+#
+# install - install a program, script, or datafile
+# This comes from X11R5.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.
+#
+
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit="${DOITPROG-}"
+
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog="${MVPROG-mv}"
+cpprog="${CPPROG-cp}"
+chmodprog="${CHMODPROG-chmod}"
+chownprog="${CHOWNPROG-chown}"
+chgrpprog="${CHGRPPROG-chgrp}"
+stripprog="${STRIPPROG-strip}"
+rmprog="${RMPROG-rm}"
+mkdirprog="${MKDIRPROG-mkdir}"
+
+tranformbasename=""
+transform_arg=""
+instcmd="$mvprog"
+chmodcmd="$chmodprog 0755"
+chowncmd=""
+chgrpcmd=""
+stripcmd=""
+rmcmd="$rmprog -f"
+mvcmd="$mvprog"
+src=""
+dst=""
+dir_arg=""
+
+while [ x"$1" != x ]; do
+    case $1 in
+	-c) instcmd="$cpprog"
+	    shift
+	    continue;;
+
+	-d) dir_arg=true
+	    shift
+	    continue;;
+
+	-m) chmodcmd="$chmodprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-o) chowncmd="$chownprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-g) chgrpcmd="$chgrpprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-s) stripcmd="$stripprog"
+	    shift
+	    continue;;
+
+	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
+	    shift
+	    continue;;
+
+	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
+	    shift
+	    continue;;
+
+	*)  if [ x"$src" = x ]
+	    then
+		src=$1
+	    else
+		# this colon is to work around a 386BSD /bin/sh bug
+		:
+		dst=$1
+	    fi
+	    shift
+	    continue;;
+    esac
+done
+
+if [ x"$src" = x ]
+then
+	echo "install:	no input file specified"
+	exit 1
+else
+	true
+fi
+
+if [ x"$dir_arg" != x ]; then
+	dst=$src
+	src=""
+	
+	if [ -d $dst ]; then
+		instcmd=:
+	else
+		instcmd=mkdir
+	fi
+else
+
+# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
+# might cause directories to be created, which would be especially bad 
+# if $src (and thus $dsttmp) contains '*'.
+
+	if [ -f $src -o -d $src ]
+	then
+		true
+	else
+		echo "install:  $src does not exist"
+		exit 1
+	fi
+	
+	if [ x"$dst" = x ]
+	then
+		echo "install:	no destination specified"
+		exit 1
+	else
+		true
+	fi
+
+# If destination is a directory, append the input filename; if your system
+# does not like double slashes in filenames, you may need to add some logic
+
+	if [ -d $dst ]
+	then
+		dst="$dst"/`basename $src`
+	else
+		true
+	fi
+fi
+
+## this sed command emulates the dirname command
+dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
+
+# Make sure that the destination directory exists.
+#  this part is taken from Noah Friedman's mkinstalldirs script
+
+# Skip lots of stat calls in the usual case.
+if [ ! -d "$dstdir" ]; then
+defaultIFS='	
+'
+IFS="${IFS-${defaultIFS}}"
+
+oIFS="${IFS}"
+# Some sh's can't handle IFS=/ for some reason.
+IFS='%'
+set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
+IFS="${oIFS}"
+
+pathcomp=''
+
+while [ $# -ne 0 ] ; do
+	pathcomp="${pathcomp}${1}"
+	shift
+
+	if [ ! -d "${pathcomp}" ] ;
+        then
+		$mkdirprog "${pathcomp}"
+	else
+		true
+	fi
+
+	pathcomp="${pathcomp}/"
+done
+fi
+
+if [ x"$dir_arg" != x ]
+then
+	$doit $instcmd $dst &&
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
+else
+
+# If we're going to rename the final executable, determine the name now.
+
+	if [ x"$transformarg" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		dstfile=`basename $dst $transformbasename | 
+			sed $transformarg`$transformbasename
+	fi
+
+# don't allow the sed command to completely eliminate the filename
+
+	if [ x"$dstfile" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		true
+	fi
+
+# Make a temp file name in the proper directory.
+
+	dsttmp=$dstdir/#inst.$$#
+
+# Move or copy the file name to the temp name
+
+	$doit $instcmd $src $dsttmp &&
+
+	trap "rm -f ${dsttmp}" 0 &&
+
+# and set any options; do chmod last to preserve setuid bits
+
+# If any of these fail, we abort the whole thing.  If we want to
+# ignore errors from any of these, just make sure not to ignore
+# errors from the above "$doit $instcmd $src $dsttmp" command.
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&
+
+# Now rename the file to the real destination.
+
+	$doit $rmcmd -f $dstdir/$dstfile &&
+	$doit $mvcmd $dsttmp $dstdir/$dstfile 
+
+fi &&
+
+
+exit 0
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/autoconf/Make.common work/main.d/rxvt-2.6.4/autoconf/Make.common
--- tmp/rxvt-2.6.4/autoconf/Make.common	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/autoconf/Make.common	2007-01-15 18:03:53.000000000 -0300
@@ -0,0 +1,68 @@
+# autoconf/Make.common.in	 -*- Makefile -*-
+# release date (man), LSM date, version number/name, current maintainer
+DATE=02 NOVEMBER 2001
+LSMDATE=02NOV01
+VERSION=2.6.4
+VERNAME=rxvt-$(VERSION)#
+MAINT=Geoff Wing#
+MAINTEMAIL=<gcw@rxvt.org>#
+WEBMAINT=Oezguer Kesim#
+WEBMAINTEMAIL=<oec@rxvt.org>#
+WEBPAGE=<http://www.rxvt.org/>#
+FTPSITENAME=ftp.rxvt.org#
+FTPSITEDIR=/pub/rxvt#
+#-------------------------------------------------------------------------
+
+SHELL = /bin/sh
+
+# This variable makes it possible to move the installation root to another
+# directory. This is useful when you're creating a binary distribution
+# If empty, normal root will be used.
+# You can run eg. 'make install DESTDIR=/packages/rxvt-xx' to accomplish
+# that.
+# DESTDIR = /usr/local/X11/$(VERNAME)
+
+# Installation target directories & other installation stuff
+prefix = //usr
+exec_prefix = //usr
+binprefix =
+manprefix =
+bindir = //usr/bin
+mandir = //usr/share/man/man1
+manext = 1
+
+# Tools & program stuff
+CC = i586-castorbox-linux-gnu-gcc
+CPP = i586-castorbox-linux-gnu-cpp
+MV = //media/gar-castorbox/images/build/usr/bin/mv
+RM = //media/gar-castorbox/images/build/usr/bin/rm
+RMF = //media/gar-castorbox/images/build/usr/bin/rm -f
+CP = //media/gar-castorbox/images/build/usr/bin/cp
+SED = //media/gar-castorbox/images/build/usr/bin/sed
+AWK = //media/gar-castorbox/images/build/usr/bin/awk
+ECHO = //media/gar-castorbox/images/build/usr/bin/echo
+CMP = //media/gar-castorbox/images/build/usr/bin/cmp
+TBL = 
+INSTALL = //media/gar-castorbox/images/build/usr/bin/install -c
+INSTALL_PROGRAM = //media/gar-castorbox/images/build/usr/bin/install -c -s -m 755
+INSTALL_DATA = //media/gar-castorbox/images/build/usr/bin/install -c -m 644
+
+# Flags & libs
+# add -DBINDIR=\""$(bindir)/"\" to CPPFLAGS, if we need to spawn a program
+
+CFLAGS = -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32 
+CPPFLAGS =  
+LDFLAGS = 
+DEFS = -DHAVE_CONFIG_H
+LIBS = 
+DINCLUDE = 
+DLIB = 
+
+# X Include directory
+XINC =  -I/media/gar-castorbox/images/main//usr/include 
+
+# extra libraries needed by X on some systems, X library location
+XLIB =  -L/media/gar-castorbox/images/main//usr/lib  -lX11 
+
+# End of common section of the Makefile
+#-------------------------------------------------------------------------
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/autoconf/Make.common.in work/main.d/rxvt-2.6.4/autoconf/Make.common.in
--- tmp/rxvt-2.6.4/autoconf/Make.common.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/autoconf/Make.common.in	1999-03-28 03:15:42.000000000 -0300
@@ -0,0 +1,68 @@
+# autoconf/Make.common.in	 -*- Makefile -*-
+# release date (man), LSM date, version number/name, current maintainer
+DATE=@DATE@
+LSMDATE=@LSMDATE@
+VERSION=@VERSION@
+VERNAME=rxvt-$(VERSION)#
+MAINT=Geoff Wing#
+MAINTEMAIL=<gcw@rxvt.org>#
+WEBMAINT=Oezguer Kesim#
+WEBMAINTEMAIL=<oec@rxvt.org>#
+WEBPAGE=<http://www.rxvt.org/>#
+FTPSITENAME=ftp.rxvt.org#
+FTPSITEDIR=/pub/rxvt#
+#-------------------------------------------------------------------------
+
+SHELL = /bin/sh
+
+# This variable makes it possible to move the installation root to another
+# directory. This is useful when you're creating a binary distribution
+# If empty, normal root will be used.
+# You can run eg. 'make install DESTDIR=/packages/rxvt-xx' to accomplish
+# that.
+# DESTDIR = /usr/local/X11/$(VERNAME)
+
+# Installation target directories & other installation stuff
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+binprefix =
+manprefix =
+bindir = @bindir@
+mandir = @mandir@/man1
+manext = 1
+
+# Tools & program stuff
+CC = @CC@
+CPP = @CPP@
+MV = @MV@
+RM = @RM@
+RMF = @RM@ -f
+CP = @CP@
+SED = @SED@
+AWK = @AWK@
+ECHO = @ECHO@
+CMP = @CMP@
+TBL = @TBL@
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL@ -s -m 755
+INSTALL_DATA = @INSTALL@ -m 644
+
+# Flags & libs
+# add -DBINDIR=\""$(bindir)/"\" to CPPFLAGS, if we need to spawn a program
+
+CFLAGS = @CFLAGS@ 
+CPPFLAGS = @CPPFLAGS@ @XPM_CPPFLAGS@
+LDFLAGS = @LDFLAGS@
+DEFS = @DEFS@
+LIBS = @LIBS@
+DINCLUDE = @DINCLUDE@
+DLIB = @DLIB@
+
+# X Include directory
+XINC = @X_CFLAGS@ @XPM_CFLAGS@
+
+# extra libraries needed by X on some systems, X library location
+XLIB = @X_LIBS@ @XPM_LIBS@ -lX11 @X_EXTRA_LIBS@
+
+# End of common section of the Makefile
+#-------------------------------------------------------------------------
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/autoconf/mkinstalldirs work/main.d/rxvt-2.6.4/autoconf/mkinstalldirs
--- tmp/rxvt-2.6.4/autoconf/mkinstalldirs	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/autoconf/mkinstalldirs	1998-04-20 04:30:28.000000000 -0300
@@ -0,0 +1,32 @@
+#!/bin/sh
+# mkinstalldirs --- make directory hierarchy
+# Author: Noah Friedman <friedman@prep.ai.mit.edu>
+# Created: 1993-05-16
+# Last modified: 1994-03-25
+# Public domain
+
+errstatus=0
+
+for file in ${1+"$@"} ; do 
+   set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
+   shift
+
+   pathcomp=
+   for d in ${1+"$@"} ; do
+     pathcomp="$pathcomp$d"
+     case "$pathcomp" in
+       -* ) pathcomp=./$pathcomp ;;
+     esac
+
+     if test ! -d "$pathcomp"; then
+        echo "mkdir $pathcomp" 1>&2
+        mkdir "$pathcomp" || errstatus=$?
+     fi
+
+     pathcomp="$pathcomp/"
+   done
+done
+
+exit $errstatus
+
+# mkinstalldirs ends here
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/ChangeLog work/main.d/rxvt-2.6.4/ChangeLog
--- tmp/rxvt-2.6.4/ChangeLog	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/ChangeLog	2001-11-01 21:34:39.000000000 -0300
@@ -0,0 +1,2001 @@
+2001-11-02  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt 1.17.2.23: Update
+
+	* src/command.c 1.85.2.35:
+	pullup 1.212->1.213: fix possible buffer overflow noticed by
+	Samuel Dralet
+
+2000-11-17  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt 1.17.2.22: Update
+
+	* src/screen.c 1.76.2.17: pullup modified: 1.188->1.189
+	(If we move the cursor then unset the WrapNext flag, noticed by
+	witek@mat.uni.torun.pl)
+
+2000-11-11  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c 1.76.2.16:
+	pullup modified 1.185->1.187:
+	extend corrupt multichar check
+
+2000-10-30  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c 1.85.2.34:
+	Reverse previous pullup: it was totally wrong
+
+2000-10-28  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt 1.17.2.21: Update
+
+	* src/main.c 1.66.2.12:
+	pullup (modified) init.c:1.46->1.47, 1.51->1.52
+	fix default icon name, noticed by
+	Jeremy C. Reed <reed@wcug.wwu.edu>
+	fix setting of icon name with -e argument, noticed by
+	John Waggenspack <John_Waggenspack@adc.com>
+
+2000-10-26  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt 1.17.2.20: Update
+
+	* src/command.c 1.85.2.33: pullup init.c:1.50->1.51:
+	We get the current locale by passing NULL, not an empty string
+
+2000-08-07  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt 1.17.2.19: Update
+
+	* src/command.c 1.85.2.32:
+	pullup modified 1.169->1.170:
+	If we're not mapped then don't timeout on the select() - note
+	that want_refresh won't be reset below since scr_refresh() will
+	return early.  Noticed by
+	Tore Bjorkeli <tore.bjorkeli@runit.no>
+
+2000-07-26  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt 1.17.2.18: Update
+
+	* src/command.c 1.85.2.31:
+	pullup modified init.c:1.29->1.30: Fix Meta detection, overriding Alt
+
+2000-07-21  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/rxvtRef-toc.html 1.2.4.1, doc/yodl/rxvt.yo.in 1.2.4.1:
+	oec: (rxvt.yo): Fixed old references to babayaga.math.fu-berlin.de in
+	the documentation.
+
+Fri Jul 21 01:31:43 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* Makefile, configure: Regenerate
+
+	* src/version.h: Bump version to 2.6.3
+
+Wed Jul 19 07:28:48 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* autoconf/configure.in: pullup 1.92->1.93
+
+Fri Jul 14 07:16:28 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: Update
+
+	* doc/BUGS: English
+
+	* doc/changes.txt: Update
+
+	* src/screen.c: pullup (modified) 1.133->1.134
+
+Wed Jul  5 08:59:01 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: Update
+
+	* src/command.c: pullup modified 1.157->1.158
+
+	* doc/yodl/rxvt-options.yo, doc/yodl/rxvt-resources.yo:
+	Note help commands
+
+	* doc/changes.txt: Update
+
+	* src/feature.h: Turn off LOCAL_X_IS_UNIX by default
+
+	* doc/changes.txt, doc/BUGS: Update
+
+	* doc/yodl/rxvt-options.yo: pullup: 1.10->1.11
+
+	* doc/changes.txt: Update
+
+	* doc/yodl/rxvt-options.yo: pullup most of 1.9->1.10
+
+	* doc/yodl/rxvt-resources.yo: pullup: 1.19->1.20
+
+	* src/xdefaults.c: pullup 1.60->1.62: Add -xrm
+
+	* src/command.c: Another fix for Input_Context usage
+
+Mon Jun  5 07:26:59 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: Incomplete fix for Input_Context usage
+
+Sun Jun  4 06:57:17 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/logging.c: Make sure we're using the real wtmp file
+
+	* src/main.c: pullup 1.110->1.112
+
+	* src/feature.h: pullup 1.39->1.40
+
+Mon May 22 01:21:07 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/yodl/rxvt-options.yo: pullup 1.6->1.7
+
+Sat May 20 09:21:52 2000  Oezguer Kesim  <oec@rxvt.org>
+
+	* doc/rxvtRef-toc.html, doc/yodl/rxvt.yo:
+
+	Fixed old references to babayaga.math.fu-berlin.de in the documentation.
+
+Mon May  8 23:58:14 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: STRLEN is a 2.7.x'ism
+
+Thu May  4 01:01:45 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: Update
+
+	* src/command.c:
+	Make sure we get Input_Context variable if USE_XIM, noticed by
+	Mike Miller <mbmiller@taxa.psyc.missouri.edu>
+
+	* src/command.c:
+	We can't use XRegisterIMInstantiateCallback() on Solaris' X in the
+	C locale.  Dump its use altogether unless we can autoconfigure
+	it, noticed by
+	Mike Miller <mbmiller@taxa.psyc.missouri.edu>
+
+Wed May  3 05:52:02 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: Revert previous.
+	Fails where static libraries may not be available, e.g. Solaris
+
+Sat Apr 15 08:07:20 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/Makefile.in: pullup modified 1.16->1.17
+
+	* configure: Regenerate
+
+	* autoconf/configure.in:
+	This branch doesn't have -R flag for ld so avoid shared library
+	use in configure checking, only for X stuff.
+
+	* Makefile: Regenerate
+
+	* src/version.h: Bump version to 2.6.2
+
+Sun Mar 12 05:31:00 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* rclock/rclock.c: pullup 1.2->1.3
+
+Sat Mar 11 05:48:25 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: Update
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: pullup 1.82->1.83
+
+Thu Mar  9 09:41:36 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/xdefaults.c: pullup 1.54->1.56
+
+Wed Jan 26 23:31:19 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/main.c:
+	Use -bd (resource: borderColor) properly (even though it's not
+	visible in normal WM'd windows)
+
+Tue Jan  4 11:20:02 2000  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: pullup 1.146->1.147
+
+Thu Dec 23 00:57:07 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: pullup 1.74->1.75
+
+Wed Dec 22 02:57:29 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: pullup 1.109->1.110 and 1.117->1.118
+
+Sun Dec 12 10:15:22 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/feature.h: Pull up 1.34->1.35
+
+	* src/command.c: Pull up 1.140->1.141
+
+Sat Dec 11 07:30:53 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: pullup 1.119->1.120
+
+Thu Nov 11 11:58:51 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/feature.h: Undo mistaken commit
+
+	* src/screen.c: pullup 1.115->1.116
+
+	* src/rxvt.h:
+	pullup part of 1.56->1.57 needed for main.c/screen.c update
+
+	* src/feature.h: Mistaken commit
+
+	* src/main.c: pullup 1.78->1.79
+
+Thu Oct 14 23:48:55 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Makefile.in: pullup 1.30->1.31
+
+Mon Sep 20 18:39:41 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/scrollbar.c: pullup 1.23->1.24
+
+Tue Sep  7 15:20:54 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/scrollbar.c: pullup 1.21->1.23
+
+	* src/main.c: pullup 1.81->1.82
+
+	* src/rxvt.h: pullup 1.57->1.58
+
+Thu Aug 19 04:23:54 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: pullup 1.91->1.92
+
+Tue Aug 17 08:16:14 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/Makefile.in: 1.13->1.14
+
+	* src/main.c: Whoops, STRNCMP->strncmp while in this branch
+
+	* Makefile: Regenerate
+
+	* doc/Makefile.in: pullup 1.12->1.13
+
+	* src/version.h: Bump version to 2.6.1
+
+	* src/main.c: pullup 1.80->1.81
+
+	* src/feature.h: pullup 1.28->1.29
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: pullup modified 1.67->1.69
+
+Mon Aug 16 07:37:02 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: pullup 1.65->1.66
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: pullup 1.66->1.67
+
+Thu Aug 12 16:32:39 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: pullup 1.119->1.120
+
+Mon Aug  9 07:11:37 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: Update
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: pullup 1.63->1.65
+
+Mon Aug  2 05:23:31 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: Update
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: pullup 1.61->1.62
+
+Sun Aug  1 11:19:26 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: pullup 1.115->1.116
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: pullup 1.60->1.61
+
+	* doc/changes.txt: Update
+
+	* src/command.c: pullup 1.114->1.115: Fix CSI cursor movements.
+
+Wed Jul 28 22:36:29 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: pullup 1.112->1.113: Fix UNSHIFTED_SCROLLKEYS
+
+	* src/xdefaults.c: Accept more values as TRUE, from
+	Andrew J. Schorr <schorr@ead.dsa.com>
+
+	* src/command.c: pullup 1.111->1.112
+
+Sun Jul 18 17:23:55 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: pullup 1.107->1.109
+
+Sat Jul 17 09:47:26 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/scrollbar.c: pullup 1.20->1.21
+
+	* src/command.c: pullup 1.106->1.107
+
+	* src/rxvt.h: pullup 1.54->1.55
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: pullup 1.58->1.59
+
+Wed Jul 14 14:06:17 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: pullup 1.105->1.106: Fix some stupid orderings
+
+Sat Jul 10 04:20:01 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/logging.c:
+	Fix utmp position calculation for BSD to ignore comment/blank lines.
+
+Wed Jul  7 13:22:22 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c:
+	pullup 1.90->1.91: Bounds check properly after type change
+
+Tue Jul  6 17:16:21 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: pullup 1.89->1.90: Comment out now unnecessary checks
+
+	* src/rxvt.h: pullup 1.52->1.53
+	Revert previous.  Make TermWin.nscrolled + TermWin.view_start unsigned to
+	avoid overflows.  Fixes problem with "rxvt -sl 32767" noticed by,
+	Preston Brown <pbrown@redhat.com>
+
+	* src/rxvt.h: pullup 1.51->1.52: Bump row_col_t to 32bit
+
+Sun Jul  4 15:10:18 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/strings.c: 1) remove --disable-rmemset; add --enable-strings
+	remove rmemset.c; add strings.c - in 2.15 Mark Olesen added a
+	strcasecmp() function stating it avoided linking in an extra library.
+	Unstated: what library and what OS.  Add some similar functions, but
+	make the default to be disabled because it will probably add text
+	space for most people.
+	Moved rmemset() -> memset(), my_strcasecmp() -> strcasecmp() and wrote
+	several other replacement string functions.  Note that external
+	programs will also use these.
+	2) CALLOC() had weird argument ordering for dmalloc.  dmalloc versions
+	haven't defined this for a while so go back to normal ordering - if
+	you use an old dmalloc, you may have problems.
+
+Sat Jul  3 07:19:16 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: pullup 1.51->1.52
+	Do proper check for XPM includes & libraries.  Disable and give warnings if
+	either cannot be found when --enable-xpm-background is specified.
+	Semi-standardise some "if test" lines.
+
+Fri Jul  2 14:59:41 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: Note some changes
+
+	* src/main.c:
+	pullup 1.71->1.72: Need default scrollTtyOutput after change of name.
+
+	* doc/yodl/rxvt-options.yo:
+	pullup 1.5->1.6 : Note opposite effect of -si and scrollTtyOutput
+
+	* src/xdefaults.c: pullup 1.37->1.38
+	Allow reverse options/flags.
+	Reverse sense of --scrollTtyOutput, but keep -si.
+
+	* src/rxvt.h: pullup 1.45->1.48
+	Allow reverse options/flags.
+	Reverse sense of --scrollTtyOutput, but keep -si.
+
+	* src/screen.c: pullup 1.82->1.83
+	Allow reverse options/flags.
+	Reverse sense of --scrollTtyOutput, but keep -si.
+
+	* src/command.c: pullup 1.97->1.98
+	Allow reverse options/flags.
+	Reverse sense of --scrollTtyOutput, but keep -si.
+
+Wed Jun 30 08:40:32 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/BUGS: pullup 1.7->1.8: Update bug email
+
+Tue Jun 22 16:53:54 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/main.c: Reversed scrollbar floating logic, noticed by
+	Erik Jacobsen <erik@mint.com>
+
+	* src/rxvt.h: always have want_refresh
+
+	* autoconf/config.h.in: Regenerate
+
+	* autoconf/acconfig.h: Update comment
+
+	* src/command.c: pullup 1.96->1.97
+
+	* src/command.h: pullup 1.14->1.15
+
+	* src/command.c: Check for unlockpt()
+
+	* configure, autoconf/config.h.in: Regenerate
+
+	* autoconf/configure.in: pullup 1.48->1.49
+
+Sat Jun 19 08:06:15 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c:
+	Provide better grantpt() handling, and tty ownership now dependent on
+	grantpt() success.
+
+Thu Jun 17 17:35:27 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c:
+	grantpt() is expected to properly set security on tty device.
+
+Sat Jun 12 07:23:32 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* configure: Regenerate
+
+	* autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in:
+	Better checking for Irix version
+
+Fri Jun 11 16:46:55 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/feature.h: typo
+
+Wed Jun  9 12:59:10 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: pullup 1.93->1.94
+
+	* src/command.c: Remove extra, unbalanced parenthesis, noticed by
+	Fabrice_GONTON@paribas.com
+
+Tue Jun  8 09:53:55 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/Makefile.in:
+	Last Minute: Distribute yodl/rxvt.yo - doing so may stuff up virtual paths for some people but will prevent unnecessary yodl requirement for most.
+Wed Jul  7 13:22:22 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c:
+	pullup 1.90->1.91: Bounds check properly after type change
+
+Tue Jul  6 17:16:21 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: pullup 1.89->1.90: Comment out now unnecessary checks
+
+	* src/rxvt.h: pullup 1.52->1.53
+	Revert previous.  Make TermWin.nscrolled + TermWin.view_start unsigned to
+	avoid overflows.  Fixes problem with "rxvt -sl 32767" noticed by,
+	Preston Brown <pbrown@redhat.com>
+
+	* src/rxvt.h: pullup 1.51->1.52: Bump row_col_t to 32bit
+
+Sun Jul  4 15:10:18 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/strings.c: 1) remove --disable-rmemset; add --enable-strings
+	remove rmemset.c; add strings.c - in 2.15 Mark Olesen added a
+	strcasecmp() function stating it avoided linking in an extra library.
+	Unstated: what library and what OS.  Add some similar functions, but
+	make the default to be disabled because it will probably add text
+	space for most people.
+	Moved rmemset() -> memset(), my_strcasecmp() -> strcasecmp() and wrote
+	several other replacement string functions.  Note that external
+	programs will also use these.
+	2) CALLOC() had weird argument ordering for dmalloc.  dmalloc versions
+	haven't defined this for a while so go back to normal ordering - if
+	you use an old dmalloc, you may have problems.
+
+Sat Jul  3 07:19:16 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: pullup 1.51->1.52
+	Do proper check for XPM includes & libraries.  Disable and give warnings if
+	either cannot be found when --enable-xpm-background is specified.
+	Semi-standardise some "if test" lines.
+
+Fri Jul  2 14:59:41 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: Note some changes
+
+	* src/main.c:
+	pullup 1.71->1.72: Need default scrollTtyOutput after change of name.
+
+	* doc/yodl/rxvt-options.yo:
+	pullup 1.5->1.6 : Note opposite effect of -si and scrollTtyOutput
+
+	* src/xdefaults.c: pullup 1.37->1.38
+	Allow reverse options/flags.
+	Reverse sense of --scrollTtyOutput, but keep -si.
+
+	* src/rxvt.h: pullup 1.45->1.48
+	Allow reverse options/flags.
+	Reverse sense of --scrollTtyOutput, but keep -si.
+
+	* src/screen.c: pullup 1.82->1.83
+	Allow reverse options/flags.
+	Reverse sense of --scrollTtyOutput, but keep -si.
+
+	* src/command.c: pullup 1.97->1.98
+	Allow reverse options/flags.
+	Reverse sense of --scrollTtyOutput, but keep -si.
+
+Wed Jun 30 08:40:32 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/BUGS: pullup 1.7->1.8: Update bug email
+
+Tue Jun 22 16:53:54 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/main.c: Reversed scrollbar floating logic, noticed by
+	Erik Jacobsen <erik@mint.com>
+
+	* src/rxvt.h: always have want_refresh
+
+	* autoconf/config.h.in: Regenerate
+
+	* autoconf/acconfig.h: Update comment
+
+	* src/command.c: pullup 1.96->1.97
+
+	* src/command.h: pullup 1.14->1.15
+
+	* src/command.c: Check for unlockpt()
+
+	* configure, autoconf/config.h.in: Regenerate
+
+	* autoconf/configure.in: pullup 1.48->1.49
+
+Sat Jun 19 08:06:15 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c:
+	Provide better grantpt() handling, and tty ownership now dependent on
+	grantpt() success.
+
+Thu Jun 17 17:35:27 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c:
+	grantpt() is expected to properly set security on tty device.
+
+Sat Jun 12 07:23:32 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* configure: Regenerate
+
+	* autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in:
+	Better checking for Irix version
+
+Fri Jun 11 16:46:55 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/feature.h: typo
+
+Wed Jun  9 12:59:10 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: pullup 1.93->1.94
+
+	* src/command.c: Remove extra, unbalanced parenthesis, noticed by
+	Fabrice_GONTON@paribas.com
+
+Tue Jun  8 09:53:55 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/Makefile.in:
+	Last Minute: Distribute yodl/rxvt.yo - doing so may stuff up virtual paths for some people but will prevent unnecessary yodl requirement for most.
+
+Mon Jun  7 04:44:38 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Makefile.in: Prepare for release
+
+	* src/screen.c: Remove unused variable.
+
+Sun Jun  6 13:50:49 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/LSM.in: Update size.  Again!
+
+	* Makefile: Regenerate
+
+	* doc/changes.txt: Update
+
+	* src/version.h: Bump version to 2.6.0 finally.
+
+	* autoconf/config.h.in:
+	Also check for grantpt() if we're USG/GLIBC like ttys
+
+Thu Jun  3 15:01:38 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/feature.h: Not Linux by default: match distributed termcap
+
+	* configure: Regenerate
+
+	* autoconf/acconfig.h, autoconf/configure.in, src/command.c:
+	Also check for grantpt() if we're USG/GLIBC like ttys
+
+Mon May 31 02:54:35 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: Remove unused variable from selection_paste()
+
+Wed May 26 13:03:06 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: Remove bogon on #else line
+
+Fri May 21 11:54:01 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: Fix two multichar set problems:
+	- writing Kanji during insert mode (by ESC [ 4 h).
+	- writing Kanji in middle of two Kanji characters (e.g. when two Kanji are placed on columns 1,2 and 3,4, and new Kanji is put on columns 2,3), noticed by
+	TATEOKA Takamichi <tate@spa.is.uec.ac.jp>
+
+	* src/screen.c: pullin 1.76.2.3:
+	Fix compilation error on MULTICHAR_SET
+	pullin 1.76.2.4:
+	Fix processing order of tab, carriage return and line feed when in MULTICHAR_SET, reported by
+	TATEOKA Takamichi <tate@spa.is.uec.ac.jp>
+
+Thu May 20 13:37:46 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c:
+	Fix processing order of tab, carriage return and line feed when in MULTICHAR_SET, reported by
+	TATEOKA Takamichi <tate@spa.is.uec.ac.jp>
+
+	* src/screen.c: Fix compilation error on MULTICHAR_SET
+
+	* src/command.c: Cleanup mouse wheel scrolling code.
+
+Wed May 19 13:05:42 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c:
+	Fix compilation with NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING
+
+	* src/command.c:
+	Update scrollbar display when using wheel mouse (buttons 4 & 5), reported by
+	Kikutani Makoto <kikutani@sprintmail.com>
+
+	* src/command.c:
+	In get_pty(), wrap some local variables within their scope so they work properly irrespective of #ifdef's, from
+	Denis N. Antonioli <antonio@ifi.unizh.ch>
+
+Mon May 17 01:22:30 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/main.c:
+	scr_touch() on change of font to force a refresh.  We could do scr_expose() on a calculated size but would be a lot more trouble and bug prone.
+
+	* src/xdefaults.c, src/rxvt.h, src/screen.c, doc/changes.txt, doc/yodl/rxvt-resources.yo, src/feature.h, src/main.c, autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in, README.configure:
+	Integrate ZH_CN (GB2312) (--enable-gb) support from
+	Ha Shao <hashao@china.com>
+
+	* configure: Regenerate
+
+	* autoconf/configure.in:
+	Give fall back behaviour for some pty opening routines.
+
+	* src/command.c: Add PTYS_ARE_CLONE tty opening for HP-UX
+
+Wed May 12 06:28:41 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/main.c:
+	Fix font width check from per_char[] at possible wrong offset,  noticed by
+	<id@windowmaker.org>
+
+Mon May 10 00:48:31 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: Stupid indent command.
+
+	* Makefile: Regenerate
+
+	* src/command.c:
+	Try the indirect opening of tty.  This whole area needs rewriting.
+
+	* src/version.h: Bump version to 2.6.PRE4
+
+	* src/command.c:
+	Try the indirect opening of tty.  This whole area needs rewriting.
+
+Wed May  5 22:08:09 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/xdefaults.c: Was the to_keysym define really worth it?  Remove it
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: Try to avoid another false positive
+
+	* doc/TODO: Note in progress items.
+
+	* src/screen.c: Move some common code into own routine.  Reindent.
+
+	* src/command.c, src/command.h:
+	Back to simple queue for CN requests.  Don't want prev information.
+
+	* src/rmemset.c: No stub if not defined.
+
+	* src/command.c: Fix buffer overrun.
+
+Tue Apr 27 08:19:12 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: Avoid a false positive with EACCES
+
+Mon Apr 19 04:17:29 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c:
+	Fix Multichar selection problems with old selection style, noticed by
+	Yasuda Tsutomu <_tom_@sf.airnet.ne.jp>
+
+	* configure, autoconf/config.h.in: Regenerate
+
+	* src/command.c, autoconf/acconfig.h, autoconf/configure.in:
+	Check for GLIBC getpt() extension, partly from
+	Andreas Jaeger <aj@arthur.rhein-neckar.de>
+
+	* README.configure: Enhance --enable-xim description.
+
+Sat Apr 17 09:02:12 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c:
+	XRegisterIMInstantiateCallback() in C locale if not MULTICHAR_SET.
+	Different method for XIM: try XSetLocaleModifiers() with given options,
+	if any, then with none (allowing XMODIFIERS env. var. to be used), then
+	with "@im=none".  Hopefully this will satisfy everyone's needs.
+
+Fri Apr 16 05:44:06 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/graphics.c: No stubs for internal routines if not defined
+
+Tue Apr 13 12:30:08 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: Fix stuff up in loop for check of preedit type.
+
+	* src/command.c: Fix some of my stuff-ups including
+	do NOT XRegisterIMInstantiateCallback() before we change locale, from
+	MANTANI Nobutaka <nobutaka@nobutaka.com>
+
+	* src/command.c: Minor cleanup.
+
+	* src/command.c: Clean up loops.  Enhance defaults for preedit type.
+
+	* src/command.c: Pasto.
+
+Mon Apr 12 07:40:57 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.h, src/misc.c, src/command.c:
+	strcpy() -> STRCPY(), other small clean ups.
+
+Sun Apr 11 13:56:01 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c:
+	Clean up.  Fix typo.  XRegisterIMInstantiateCallback() before we change locale.
+
+	* configure: Regenerate
+
+	* autoconf/configure.in:
+	Fix botch of checking setting for utmp/x and wtmp/x, noticed by
+	Marc Baudoin <babafou@pasteur.fr>
+
+Fri Apr  9 07:21:11 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c:
+	Be more generous with mapping unmapped keysyms to Latin1, from
+	Pavel Roskin <pavel_roskin@geocities.com>
+
+Mon Apr  5 02:46:10 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: _tom_@sf.airnet.ne.jp  is  Yasuda Tsutomu
+
+Sun Apr  4 03:14:44 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/LSM.in: See previous LSM.in log message
+
+	* Makefile: Regenerate
+
+	* src/version.h: Bump version to 2.6.PRE3
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: Verbose pty/tty type
+
+	* README.configure: Clean up
+
+	* doc/changes.txt: Update
+
+Fri Apr  2 08:13:36 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: Always do proper selection request conversions.
+
+	* src/screen.c:
+	Integrate part of a patch to handle Kanji/multichar stuff better,
+	from _tom_@sf.airnet.ne.jp
+
+Thu Apr  1 06:29:01 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c:
+	Use determined sb_width, not WIDTH for width adjustments.
+
+	* src/command.c: Removed unused variable.
+
+	* src/command.c: Fix two problems on X Input Method:
+	1) Can't display preedit area in "OverTheSpot" input style with some input methods.
+	2) The location of preedit area in "OffTheSpot" input style is wrong.
+	From MANTANI Nobutaka <nobutaka@nobutaka.com>
+
+Wed Mar 31 05:46:38 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* configure: Regenerate
+
+	* src/command.c, autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in:
+	Move pty type to config.h using basic configure check which will
+	probably need enhancing (and testing).
+
+Mon Mar 29 05:31:37 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* Makefile.in: Add ChangeLog to distribution
+
+	* src/command.c, src/xdefaults.c, src/rxvt.h:
+	Remake resource `modifier' as override for probe, from
+	Guillaume Laurent <glaurent@worldnet.fr>
+
+Sun Mar 28 07:36:48 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c, src/command.h, src/feature.h:
+	Clean up up/down-arrow & Prior/Next handling.
+
+	* autoconf/Make.common.in: Update sites and contact information
+
+Wed Mar 24 09:01:09 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: Set want_refresh on window focus change.
+
+	* src/rxvt.h, src/screen.c, src/command.c, src/main.c:
+	Be less avoiding of screen refreshes in case X events have caused updates,
+	from Vaughn Cato <vcato@bellsouth.net>
+	Different strategy to determine screen updates - anything that might have
+	affected the screen now signals via `want_refresh'.  If it's unset, then
+	nothing needs updating - or it's handled within the same routine.  Items
+	which require want_refresh update:
+	 - text added, changed
+	 - cursor moved, changed, made {in,}visible
+	 - view_start changed
+	 - selection changed
+	 - window changed
+
+	* doc/changes.txt: Update
+
+	* doc/yodl/rxvt-options.yo, doc/yodl/rxvt-resources.yo:
+	Document floating/trough better
+
+	* src/main.c:
+	Don't want trough (scrollbar floating) unless normal scrollbar - noticed by
+	Peter H. Chou <pchou@leland.Stanford.EDU>
+
+	* configure: Regenerate
+
+	* autoconf/configure.in: Clarify options slightly
+
+Thu Mar 11 14:09:21 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Attic/xpm.h, src/xpm.c, src/Makefile.in:
+	Move xpm.h back into xpm.c - avoid possible recursive inclusion.
+	Fixes problem noted by Felix Puetsch <Felix.Puetsch@zpr.uni-koeln.de>
+
+Mon Mar  8 08:33:59 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/rxvt.h, src/scrollbar.c:
+	Make NeXT scroller minimum height of 15, suggested by Mike <logan@dct.com>
+	Fix up a miscalculation in its height while we're there.
+
+	* src/command.c:
+	Fix XIM bug: can't input Japanese character when rxvt is started with
+	"-bg white" option.
+	Tsutomu Yasuda <tom@ap.nhe.nec.co.jp>
+
+Sun Feb 28 07:59:19 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: Update
+
+	* src/command.c, src/feature.h:
+	Allow scrolling of single lines with shift and up/down arrow keys
+	(not keypad arrow keys) in a similar manner to shift prior/next
+
+Sun Feb 21 09:33:48 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: Indenting.
+
+Wed Feb  3 06:56:22 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.h, src/command.c: Clean up.
+	Check for matching parent depths if we're transparent, noticed by
+	Jeremie Petit <Jeremie.Petit@Digital.com>
+
+	* src/scrollbar.c: Constify and clean up.
+
+Mon Feb  1 02:29:51 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/main.c: Free  char **r_argv  after we're done with it.
+
+	* src/logging.c:
+	Don't utmpname() - for one thing, it's based on a configure guess.
+	Use whatever the system has for us to use.  Is this dangerous on
+	some systems?  Can invoking programs do utmpname() which we inherit?
+
+Sun Jan 31 14:20:43 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: Update
+
+Fri Jan 29 15:30:00 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: Fix weirdo OOB bug
+
+	* src/screen.c: Be careful examining font struct - don't go OOB.
+
+Thu Jan 28 08:24:39 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/main.c:
+	Fix change_font/move_window bug better - avoids coredump on resize window!
+
+Wed Jan 27 10:42:56 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/LSM.in:
+	Keeping LSM which has a tar.gz size within the tar.gz is a real pain.
+
+	* doc/FAQ:
+	Note different compilation option method in this day and age.
+
+	* doc/changes.txt: Update with latest info.
+
+	* doc/yodl/rxvt-resources.yo:
+	Clarify how resources are read in the default case.
+
+	* Makefile: Regenerate
+
+	* src/version.h: Bump version to 2.6.PRE2
+
+	* src/main.c: Clean up the env var allocation a bit.
+
+Sun Jan 24 05:39:54 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: Clean up.
+
+Sat Jan 23 14:31:32 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/main.c:
+	Fix resize_font/move_window causes blank term bug - reported by
+	Hannu Liljemark <hannu.liljemark@mbnet.fi>
+
+	* src/menubar.c, src/rxvt.h, src/screen.c, src/command.c, src/main.c:
+	Handle issues with transparent windows dying when the parents are away -
+	we're playing around with windows:
+	1) we didn't create
+	2) for which we're not responsible
+	3) nobody else knows we're playing with
+	so we have to make sure we're on the ball.
+
+	Keep up to date information about parent windows we care about.
+
+	* doc/changes.txt: Update
+
+Fri Jan 22 12:27:15 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* Makefile, configure: Regenerate
+
+	* src/main.c: Oops, remove conflict
+
+	* src/screen.c, src/xdefaults.c, src/xpm.c, src/command.c, src/graphics.c, src/main.c, src/menubar.c, autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in, src/command.h, src/rxvt.h:
+	Merge rxvt-xim branch - XIM changes from MANTANI Nobutaka <nobutaka@nobutaka.com>
+
+Thu Jan 21 08:32:15 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* configure: Regenerate
+
+	* autoconf/acconfig.h, src/xpm.c, src/xdefaults.c, src/screen.c, src/menubar.c, src/graphics.c, src/main.c, src/command.c, src/rxvt.h, autoconf/config.h.in, autoconf/configure.in:
+	Merge latest update from MANTANI Nobutaka <nobutaka@nobutaka.com>
+
+	* src/main.c:
+	Fix declaration of COLORFGBG env var to make it long lived,
+	Rob Somerville <somervil@cadvision.com>
+
+Tue Jan 12 15:18:53 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: Typo.
+
+	* src/xdefaults.c, src/rxvt.h, src/screen.c, src/command.h, src/main.c, src/command.c:
+	XIM changes against PRE1 - from patch from
+	HONDA Yasuhiro <honda@kashio.info.mie-u.ac.jp>
+
+Sun Jan 10 12:07:51 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* Makefile: Regenerate
+
+	* doc/LSM.in: Update size
+
+	* README.configure: Document --enable-transparency
+
+	* src/version.h: Bump version to 2.6.PRE1
+
+	* doc/changes.txt: Sync all the latest changes.
+
+	* doc/BUGS: Update
+
+	* src/main.c:
+	We must still export COLORFGBG even with NO_BRIGHTCOLOR defined.
+	Noticed by Moritz Barsnick <barsnick@gmx.net>
+
+	* configure: Regenerate
+
+	* autoconf/configure.in:
+	Check for XPointer typedef.  Make sure we properly include X directory
+
+	* src/rxvt.h: Add check for XPointer typedef.
+
+	* configure: Regenerate
+
+	* autoconf/acconfig.h, autoconf/config.h.in:
+	Check for XPointer typedef.
+
+	* doc/Makefile.in: Idiot.  Fix all: rule
+
+	* configure: Regenerate
+
+	* doc/Makefile.in:
+	Check for TBL.  Premake everything, except maybe rxvt.1, and do not
+	depend all on anything.
+
+	* autoconf/Make.common.in, autoconf/configure.in:
+	Check for ``tbl'' so we can format the manual page on the end system.
+
+	* doc/yodl/rxvt-options.yo, doc/yodl/rxvt-resources.yo:
+	Document ip/inheritPixmap support.
+
+Sat Jan  9 07:34:26 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/feature.h, src/screen.c:
+	Default to not "bw" (termcap) and use xterm-defined undefined behaviour.
+
+Fri Jan  8 22:47:12 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c:
+	Remove, now unnecessary, __CYGWIN__ avoidance of struct winsize members
+
+	* src/xdefaults.c:
+	Options --transparent -> --inheritPixmap, -tr -> -ip,
+	-tr compatibility added.
+
+	* src/menubar.c:
+	Remove use of itimerval.it_value when we're only using it_value
+
+Thu Jan  7 06:27:36 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/misc.c: Stupid comparison.  Change && to ||
+
+Tue Jan  5 06:50:23 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Makefile.in: No ! in if test - from <rednoise@pike.sover.net>
+
+	* configure: Regenerate
+
+	* autoconf/configure.in:
+	Must terminate typedefs, duh! - from Paul D. Smith <psmith@BayNetworks.COM
+
+	* autoconf/Make.common.in:
+	Add back @X_EXTRA_LIBS@ - from Paul D. Smith <psmith@BayNetworks.COM>
+
+Fri Jan  1 07:41:43 1999  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/rxvt.h:
+	In refresh loop, when we're on a space we check w/o FG colour, unless we're
+	inversed then we check w/o BG colour & inverse attribute and move the FG
+	colour into the BG colour position.
+
+	* src/main.c:
+	Must check position of TermWin.parent too, if we're transparent.  As
+	demonstrated by Shade function in AfterStep.
+
+	* src/command.c:
+	Transparency can't take advantage of CNQueue - yet.  Needs x,y info
+
+	* src/screen.c: Prototype scr_clear()
+
+	* src/xpm.c: Fix XSync() arg
+
+Thu Dec 31 15:25:10 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c, src/main.c:
+	Look for AfterStep background change and handle appropriately.  From
+	Sasha Vasko <sashav@sprintmail.com>
+
+	* configure: Regenerate
+
+	* src/xpm.c, src/rxvt.h, src/screen.c, src/scrollbar.c, src/xdefaults.c, src/command.h, src/feature.h, src/main.c, src/command.c, autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in:
+	Integrate NeXTstep scrollbar and transparency additions from
+	Alfredo K. Kojima <kojima@windowmaker.org>
+
+Wed Dec 30 07:41:32 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Makefile.in:
+	Distribute *.intpro and *.extpro - don't presume people have sane enough
+	systems to be able to build them themselves.
+
+Fri Dec 18 14:04:08 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/rxvt.h: Rs_cutchars is required.
+
+Wed Dec  9 06:41:57 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Makefile.in: sed -> $(SED)
+
+Thu Dec  3 03:16:21 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/scrollbar.c, src/rxvt.h:
+	Add minimum scrollbar height.  Fixes bug noticed by
+	Brian Korver <briank@cs.stanford.edu>
+
+Thu Nov 26 06:50:36 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Makefile.in: Missing $
+
+	* src/rsizes.h.in: Magic move: wrong name: rsizes.h -> rsizes.h.in
+
+	* src/screen.c: Cosmetic change.
+
+	* configure: Regenerate
+
+	* autoconf/configure.in:
+	Make default long not long long.  So do checking against long long as well.
+
+	* configure: Regenerate
+
+	* src/graphics/Makefile.in, doc/Makefile.in, rclock/Makefile.in, Makefile.in:
+	Add .PATH
+
+	* src/Makefile.in: Be nicer to more shells
+
+	* src/makeextprotos-awk, src/makeintprotos-awk: Remove old stuff
+
+	* src/makeextprotos-awk, src/makeintprotos-awk: Be nicer to other awks
+
+	* src/Makefile.in: Add srcdir for proto generation
+
+	* autoconf/config.h.in, autoconf/configure.in:
+	Go back to using X_PATH_XTRA() but don't pull in X_PRE_LIBS
+
+Wed Nov 25 16:34:36 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* configure: Regenerate
+
+	* src/rmemset.c, src/rsizes.h.in, src/rxvt.h, src/screen.c, src/screen.h, src/Makefile.in, src/command.h, autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in:
+	Do a different test for sizes of 16bit (2 byte), 32bit (4 byte), etc.
+	Check if we've already typedef'd  int16_t  et al.  Otherwise, typedef
+	them in src/rsizes.h
+
+	* Makefile: Regenerate
+
+	* src/version.h: Bump version to 2.4.11
+
+Mon Nov 23 18:59:54 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c:
+	Fix how hate_those_clicks works on initial click.  selection.beg and
+	selection.end are set at 0 at the start so be careful to either set or
+	use the mark position.  May need to rethink setting selection.{beg,end}
+	Fixes problem noted by Paul Slootman <paul@wau.mis.ah.nl>
+
+	* src/misc.c: Cast the octal value from int to char.
+
+	* src/misc.c:
+	Better fix octal reading before anyone notices it's broken.
+
+	* src/command.c: Remove double comment
+
+	* doc/BUGS: Describe problem with menubar autoraising better.
+
+Sun Nov 22 06:40:47 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/BUGS: Verbose
+
+Sat Nov 21 14:50:55 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c:
+	Close off any file descriptors we don't actually use in rxvt (not the
+	child) and set num_fds to be our maximum (plus one) file descriptor
+	so that select() only passes over those ones.  Maybe in future, look
+	at something better that FD_ZERO in cmd_getc() all the time.
+
+Fri Nov 20 03:59:54 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: Typo is #ifdef .  Define variable for loop.
+
+	* src/screen.c:
+	Initialise selection.len or we can coredump if paste after ESC-c
+
+	* src/logging.h:
+	Protect logging.intpro inclusion by #ifdef UTMP_SUPPORT
+
+Thu Nov 19 11:00:30 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c:
+	Have to do foreground and background cursor colour settings
+	separately.
+
+	* src/makeextprotos-awk, src/makeintprotos-awk:
+	Got carried away quoting.  Remove the incorrect backslashes.
+
+	* src/makeextprotos-awk, src/makeintprotos-awk:
+	Try different escaping method
+
+Wed Nov 18 07:21:51 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* Makefile: Regenerate
+
+	* autoconf/Make.common.in: Remove RCS Id tag
+
+	* doc/Makefile.in: Dependences
+
+	* Makefile: Regenerate
+
+	* src/version.h: can we spell?  s/NOVERMBER/NOVEMBER/
+
+	* src/version.h: bump version to 2.4.10
+
+	* doc/changes.txt: note changes
+
+	* src/xpm.c: Remove testing stuff which was committed accidentally
+
+Tue Nov 17 19:55:57 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/xpm.c: Merge in branch: fix-bufpixmap
+
+	* src/screen.c, src/feature.h, src/main.c, src/rxvt.h:
+	Optimisation for local display
+
+	* src/screen.c: Try to do fewer XDrawString() type calls.
+
+	* src/main.c: Move scr_touch() out of xpm.c
+
+	* src/xpm.c: Setup properly if no pixmap specified
+
+	* src/xpm.c: Fixing XPM_BUFFERING
+
+	* configure: Regenerate
+
+	* autoconf/Make.common.in, autoconf/config.h.in, autoconf/configure.in:
+	Use AC_PATH_X not AC_PATH_XTRA so we don't link in libSM and libICE
+
+	* src/command.c: Small cleanups.
+
+	* src/misc.c: Clean up.  Rewrite part of Str_escaped()
+
+Mon Nov 16 19:55:54 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/scrollbar.c:
+	Optimise button drawing w.r.t. space - combine two similar functions
+
+	* src/screen.c: Fix scr_printscreen()
+
+	* src/command.c, src/main.c: Clean up.  Trim the fat.
+
+	* src/screen.c, src/screen.h: Move some items from screen.h to screen.c
+
+	* src/xpm.c: Make xpmAttr static, thus local.
+
+	* src/main.c, src/menubar.c, src/scrollbar.c:
+	Fix up geometry calculations and mapping order
+
+	* src/main.c: Move routines a bit.  Small cleanup.
+
+	* src/main.c, src/menubar.c, src/rxvt.h, src/scrollbar.c:
+	Reorganise code for mapping of windows.  Remove delay_menu_drawing hack.
+	Still more to do.
+
+	* src/command.c, src/command.h:
+	Remove dynamic allocation of cmdbuf_base[].  Make as BSS
+
+	* src/xdefaults.c, src/xpm.c, src/misc.c, src/screen.c, src/graphics.c, src/main.c, src/menubar.c, src/command.c:
+	Const poisoning.  Rearrange main.c a bit.
+
+	* src/rxvt.h: Const poisoning.
+
+Sun Nov 15 10:14:25 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.h, src/command.c: Dynamic allocation of  cmdbuf_base
+
+	* src/menubar.c, src/misc.c, src/xpm.c:
+	Dynamic allocation in  File_search_path(), thus File_find() now returns
+	a string which needs to be free()d.
+
+	* src/screen.c, src/xdefaults.c, src/command.c, src/graphics.c, src/main.c:
+	Cast formatting.  Const poisoning.  Small cleanups.
+
+	* src/feature.h: Allow PRINT_PIPE by default
+
+	* src/command.c: proto format
+
+	* src/screen.c: Cleanup blank_screen_mem() and slight macro name change
+
+	* src/command.c, src/graphics.c, src/screen.c:
+	Cast arg 1 in tt_printf() calls
+
+	* src/makeintprotos-awk, src/makeextprotos-awk:
+	Format returns slightly nicer
+
+	* src/xpm.c, src/logging.c, src/main.c, src/menubar.c, src/screen.c, src/xdefaults.c, src/command.c, src/graphics.c:
+	Const poisoning and small protos cleanup
+
+	* src/makeextprotos-awk, src/makeintprotos-awk:
+	Awk versions of makeextprotos-sed and makeintprotos-sed
+
+	* src/Makefile.in: Use awk not sed to generate protos
+
+	* configure: Regenerate
+
+	* autoconf/Make.common.in, autoconf/configure.in:
+	Check for AWK as well.
+
+Fri Nov 13 13:50:56 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/xdefaults.c: usage(): output "graphics" if compiled in
+
+	* src/screen.c: Remove unused change to rendition pointer.
+
+	* src/graphics/qplot.c, src/graphics/grxlib.c:
+	Remove rcsid[].  Add commented Id strings.
+
+	* src/main.c: Missing #ifdef XPM_BACKGROUND and #if (MENUBAR_MAX)
+
+Thu Nov 12 04:51:13 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/scrollbar.c, src/xdefaults.c, src/xpm.c, src/grkelot.c, src/logging.c, src/main.c, src/menubar.c, src/misc.c, src/netdisp.c, src/rmemset.c, src/screen.c, src/command.c, src/graphics.c:
+	Add back Id strings, as comments this time.
+
+	* src/screen.c:
+	Invert selection before checking for bold overstrike pixel droppings.
+
+	* src/feature.h, src/main.c:
+	Allow setting of basic colours in feature.h
+
+	* src/grkelot.h, src/logging.c, src/main.c, src/misc.c, src/netdisp.c, src/rmemset.c, src/screen.c, src/xdefaults.c, src/xpm.c, src/command.c, src/graphics.c, src/grkelot.c:
+	Copyright notice changes.
+
+Wed Nov 11 06:35:07 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c, src/misc.c: Clean up.  Be nicer with assignments.
+
+Tue Nov 10 12:49:44 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/xdefaults.c: Tidy const some more.
+
+	* src/main.c: Fix up consts.
+
+	* src/xdefaults.c: Rearrange optList[] a bit.  Fix up consts.
+
+	* src/command.c, src/screen.c:
+	Swap scroll_text() and scr_scroll_text() so that scr_scroll_text() is now
+	the external call name.
+
+Mon Nov  9 05:51:30 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/main.c, src/netdisp.c:
+	Fix up DISPLAY_IS_IP - #ifdef in the wrong spot, and fix a couple of
+	assignments
+
+	* src/main.c, src/xdefaults.c: Add some /* NOTREACHED */
+
+Mon Nov  2 04:11:42 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/LSM.in: Update size
+
+	* Makefile: Regen.
+
+	* src/version.h: bump version to 2.4.9
+
+Thu Oct 29 05:20:14 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Makefile.in, src/main.c, src/version.h: No ident strings
+
+	* doc/changes.txt: Update
+
+	* Makefile: Regen
+
+	* src/main.c: Remove identstring[]
+
+	* src/version.h: Bump to 2.4.8b
+
+	* src/Makefile.in: Fix dependencies on version.h
+
+	* configure: Regenerate
+
+	* autoconf/config.h.in: Regen.
+
+	* src/logging.c, src/logging.h, autoconf/acconfig.h, autoconf/configure.in:
+	Try harder to detect utmp/utmpx stuff
+
+Wed Oct 28 14:04:26 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/yodl/rxvtRef-xpm.yo: Revert - reflects current & old behaviour
+
+Mon Oct 26 15:18:35 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: Malloc on fly some tmp stuff.  Bound it.
+
+	* src/xpm.c, src/graphics.c, src/grkelot.c, src/logging.c, src/main.c, src/menubar.c, src/misc.c, src/netdisp.c, src/rmemset.c, src/screen.c, src/scrollbar.c, src/xdefaults.c, src/command.c:
+	Remove rcsid[] strings - just leave one in main.c
+
+	* src/xdefaults.c, src/menubar.c, src/misc.c, src/rxvt.h, src/screen.c, src/command.c, src/main.c:
+	Resource variable name change.  Also set up resource variables in one for() loop,
+	rather than scattered everywhere.
+
+	* src/command.c, src/command.h, src/main.c, src/rxvt.h:
+	Move window_ops() from main.c to command.c as process_window_ops()
+
+	* src/graphics.c:
+	Gr_ButtonReport() is accessed externally, so change INTPROTO -> EXTPROTO
+
+	* src/screen.c:
+	In OLD_SELECTION, we run around the mark, not the beginning.
+
+	* src/command.c: Free X modifier map after we're finished with it.
+
+	* autoconf/config.h.in, configure: Regenerate
+
+	* README.configure: Recomment for --disable-{new,old}-selection
+
+	* src/screen.h, src/xdefaults.c, doc/yodl/rxvt-resources.yo, src/main.c, src/rxvt.h, src/screen.c, autoconf/acconfig.h, autoconf/configure.in:
+	Allow compilation of old_selection/old_word_selection/new_selection
+	Choice via resource 'selectstyle' - defaults to new.  Possible settings
+	"OLD" and "OLDWORD" (case insensitive).
+
+	* src/Makefile.in: Another go at dependencies
+
+	* src/Makefile.in: Get this dependency stuff working.
+
+	* src/command.c, src/main.c, src/rxvt.h, src/xdefaults.c, doc/yodl/rxvt-resources.yo:
+	Probe for Meta and NumLock mappings.
+	ModMeta and ModNumLock resources have gone away.
+
+Sat Oct 24 10:22:45 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Attic/xpm.h, src/menubar.h, src/misc.c, src/netdisp.h, src/protos.h, src/rmemset.c, src/screen.c, src/scrollbar.c, src/xdefaults.c, src/Makefile.in, src/command.h, src/graphics.c, src/grkelot.c, src/logging.h, src/main.c, configure, autoconf/configure.in:
+	Don't like this protos directory procedure
+
+	* src/command.c, src/feature.h: Make scrolling via mouse wheel smoother
+
+	* autoconf/config.h.in, configure: Regenerate
+
+	* src/command.h, autoconf/acconfig.h, autoconf/configure.in, src/command.c:
+	Better checking for Xsetlocale(), setlocale() from
+	Stanislav Meduna <stano@trillian.eunet.sk>
+
+Thu Oct 22 04:39:05 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Makefile.in: Change dependencies
+
+	* src/Makefile.in: Clean up.
+
+	* src/Makefile.in: Different method of not overmaking targets
+
+	* autoconf/Make.common.in, autoconf/configure.in, Makefile, configure:
+	Add checks for ECHO and CMP
+
+	* src/main.c, src/protos.h: Clean up #ifdef DISPLAY_IS_IP
+
+	* src/menubar.c:
+	Now that we know which are internal routines, improve placement of #ifdef's
+
+	* src/rmemset.c: Cast type correctly
+
+	* src/screen.c: Remove unused variable
+
+	* src/main.c: Lint picking
+
+	* src/Makefile.in: Whoops.  Wrong target in protos/
+
+	* Makefile: Regen
+
+	* doc/Makefile.in: Update distribution list
+
+	* doc/yodl/Attic/versioninfo.yo: Generated file
+
+	* configure, autoconf/configure.in: Subst some more files.
+
+	* doc/Makefile.in: Clean up some srcdir's
+
+	* doc/yodl/rxvtRef.yo.in: yucky chdir()
+
+	* doc/yodl/rxvt.yo.in: Twisted are the ways of vpaths
+
+	* doc/yodl/rxvt.yo.in, doc/yodl/rxvtRef.yo.in:
+	Have to set paths at configure time.
+
+	* doc/yodl/Attic/rxvt.yo, doc/yodl/Attic/rxvtRef.yo:
+	Have to set paths at configure time
+
+	* src/Makefile.in: Typo
+
+	* src/Makefile.in: it's ``be kind to gmake week''
+
+	* src/Makefile.in: Handle dependence better
+
+	* src/Attic/xpm.h, src/logging.h, src/main.c, src/menubar.h, src/misc.c, src/netdisp.h, src/protos.h, src/rmemset.c, src/screen.c, src/scrollbar.c, src/xdefaults.c, src/Makefile.in, src/command.h, src/graphics.c, src/grkelot.c:
+	Rearrange protos into their own directory.
+
+Wed Oct 21 14:37:24 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Attic/xpm.h, src/xpm.c: Cleanup.
+
+	* src/Attic/makeprotos-sed:
+	Changed to similar files: makeintprotos-sed & makeextprotos-sed
+
+	* src/Attic/utmp.c, src/scrollbar.c, src/xdefaults.c, src/xpm.c, src/rmemset.c, src/screen.c, src/command.c, src/graphics.c, src/grkelot.c, src/logging.c, src/main.c, src/menubar.c, src/misc.c, src/netdisp.c, src/Attic/xpm.h, src/Makefile.in, src/command.h, src/feature.h, src/logging.h, src/menubar.h, src/netdisp.h, src/protos.h, src/rxvt.h:
+	Reorganise source:
+	Change PROTO to INTPROTO or EXTPROTO depending on whether it is only called
+	from this source file or also from external files.
+	Move unnecessary stuff out of common rxvt.h into own local header files.
+
+	* src/makeextprotos-sed, src/makeintprotos-sed:
+	Break up protos into those for local and external use
+
+	* doc/Attic/rxvtRef.txt, doc/Attic/rxvt.1, doc/Attic/rxvt.html, doc/Attic/rxvt.pretbl, doc/Attic/rxvtRef.html:
+	Generated files.  Don't bother keeping in CVS.
+
+	* doc/Makefile.in: rename rxvt.pretbl to rxvt.tbl
+
+Tue Oct 20 08:48:17 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/menubar.c:
+	change debug printf() to fprintf(stderr,) - reindent file.
+
+Mon Oct 19 07:33:55 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c:
+	blend make_screen_mem()/blank_line() into  blank_screen_mem() to make us
+	a bit safer.  Rename scroll_text() to scr_scroll_text() and make
+	scroll_text() a somewhat safer (w.r.t. memory allocation) counterpart.
+
+	* src/command.c:
+	Add CSI "T","^" and CSI "S" for scroll/pan down and scroll up
+
+	* src/main.c: Window reporting functions a la XTerm
+
+	* src/command.c, src/main.c, src/rxvt.h, src/screen.c:
+	Clean up some const-ness
+
+Tue Oct  6 14:24:00 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: Typos in cursor movement via CSI "A"
+
+	* src/command.c: Typos in cursor movement via CSI "E" & "F": CPL & CNL
+
+	* src/feature.h: Add NO_FRILLS define
+
+Mon Oct  5 07:01:14 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/main.c:
+	Change CNQueue manipulation slightly.  Better check on screen resizing.
+
+	* src/command.c, src/main.c:
+	Clean up CSI number passing.  Discard ConfigureNotify events we caused.
+	Handle certain CSI window operations a la XTerm.
+
+Fri Oct  2 02:09:41 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c, src/screen.c:
+	Fix scr_tab() - though not yet parsing for scr_tab(0)
+	Add DECBI/DECFI backindex/forwardindex
+
+Thu Oct  1 06:28:00 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/menubar.c: Resize menubar triangles.
+
+	* src/screen.c: Fix outline cursor position calculation and check.
+
+	* src/command.c: Rename rs_modifier to rs_modmeta.  Add rs_modnumlock.
+	Clean up some left over Mod1Mask bogons.  Fix up mouse reporting.
+
+	* src/rxvt.h, doc/yodl/rxvt-resources.yo, src/main.c, src/xdefaults.c:
+	Rename rs_modifier to rs_modmeta.  Add rs_modnumlock.
+
+	* src/menubar.c: Add a pixel vertical space on either side of text.
+	Use a couple of macros to clarify.
+
+Wed Sep 30 15:11:46 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/menubar.c:
+	Fix up menubar display - some funny calculations were going on previously
+
+	* src/main.c, src/misc.c, src/command.c: Tidy up.
+
+	* src/menubar.c:
+	Change calculations for separator lines so HALFSHADOW also works.
+
+Sat Sep 26 14:00:10 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in, configure:
+	Readd --disable-resources  and fix typo
+
+	* src/screen.c: More diligent in checking selection
+
+Thu Sep 24 20:09:14 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/TODO: update.
+
+	* src/main.c: Interpret backspace/delete resources
+
+	* Attic/rxvt-2.4.6.lsm: Don't want this.
+
+	* doc/Attic/rxvt.1, doc/Attic/rxvt.html, doc/Attic/rxvt.pretbl, doc/LSM.in, doc/yodl/Attic/versioninfo.yo, Makefile:
+	Version 2.4.8
+
+	* src/version.h: bump version to 2.4.8
+
+	* src/xdefaults.c: Change reporting of backspace/delete
+
+	* README.configure: Document backspace/delete --enable/--disable
+
+	* autoconf/configure.in, configure: Tidy spacing
+
+	* src/command.c: Shouldn't set PrivMode_BackSpace initially.
+
+	* doc/changes.txt: Update
+
+	* doc/yodl/rxvt-resources.yo, doc/Attic/rxvt.1, doc/Attic/rxvt.html, doc/Attic/rxvt.pretbl:
+	Document resources `backspacekey' and `deletekey'
+
+	* src/command.c, src/feature.h, src/main.c:
+	Better handling of backspace - now use traditional settings if the
+	resource is unset.
+
+	* src/rxvt.h, src/xdefaults.c, src/command.c, src/feature.h, src/main.c:
+	Make backspace/delete key handling configurable via resources
+
+	* autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in, configure:
+	Reverse handling of backspace/delete keys (and it was broken anyway)
+
+	* autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in, configure:
+	Add --enable-backspace and --enable-delete
+
+	* src/command.c: Use NO_SETLOCALE define and cleanup.
+
+	* autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in, configure:
+	Add check for setlocale() - which usually gets defined to _Xsetlocale() by X
+
+	* src/command.c: Cleanup init_xlocale() a bit
+
+	* src/main.c:
+	Don't change pointer colour on change of default fg colour.
+
+	* src/screen.c: Better bounds comparison in scroll_text()
+
+	* src/screen.c:
+	selection_extend_colrow() - hmm, why were we setting begin to mark if we're
+	in the first line?
+
+	* src/screen.c:
+	Clean up some MULTICHAR_SET stuff.  Fix cursor for MULTICHAR_SET
+
+	* src/screen.c:
+	Avoid leaving an out-of-date outline cursor on the screen
+
+Wed Sep 23 09:55:56 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: More selection checks: scr_erase_screen()
+
+	* src/screen.c: Clean up some selection checks
+
+	* src/screen.c:
+	Try a better selection check in scr_add_lines() - check for writing inside
+	a selection area.
+	Remove bogon #ifdef CHAR_SETS
+
+Tue Sep 22 19:39:51 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: Keep the reverse video when resizing the screen
+
+	* src/screen.c, src/screen.h:
+	Moved too much into screen.h so move some back.
+
+	* src/screen.c:
+	Have to set the selection screen when we _start_ selecting.
+
+	* src/screen.c: Forgot to set default flags for swap screen.
+
+	* src/screen.c, src/screen.h, src/rxvt.h: Change some types
+
+	* INSTALL: Update notes about editing config.h on cross-compile
+
+	* src/screen.c: Cleanup.
+
+	* src/Makefile.in: Add distribution of screen.h
+	Depend screen.c on screen.h
+
+	* src/screen.c: Clean up multichar handling of cursor display.
+	Fix scr_insdel_lines() shifting selection.
+	Break up selection reversing screen.rend into its own routine.
+
+	* src/screen.h: Remove unused variables
+
+	* src/rxvt.h, src/screen.c, src/screen.h, src/main.c:
+	Remove RS_Cursor/RS_Select - handle differently
+	Default cursorColor/cursorColor2/colorBD/colorUL to the appropriate
+	_current_ settings if unset.
+
+	* src/screen.h:
+	Split up some defines for screen.c - allow manipulation from outside.
+
+	* src/xdefaults.c, src/rxvt.h:
+	Start removing CHAR_SETS - always have ACS graphics/UK char sets now
+	that RS_Cursor and RS_Select are being removed.
+	Split some of rxvt.h into screen.h - make import of Nat Friedman's Dingus
+	easier.
+
+	* autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in, README.configure, configure:
+	Remove --enable-small : it is now automatic
+
+	* autoconf/configure.in, configure:
+	Report on which types will be used for 16bit/32bit/pointer
+
+Mon Sep 21 03:56:37 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in, src/rmemset.c, src/rxvt.h, configure:
+	Move size type checking into configure
+
+	* autoconf/config.h.in, autoconf/configure.in, configure:
+	Add check for sizeof(int *)
+
+	* src/screen.c: Not again, and it's #if not #ifdef
+
+	* src/screen.c: Whoops, NSWAP is really NSCREENS
+
+	* doc/TODO: Fixed Xlocale.
+	Add note about char/short/int/long sizes
+
+	* src/Makefile.in, src/command.c: Remove DEBUG_SELECTION define
+
+Sun Sep 20 23:51:02 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* INSTALL: Update info about doc/rxvt.pretbl
+
+	* doc/Makefile.in: Remove RMF in rxvt.1 rule
+
+	* doc/Makefile.in: Make rxvt.pretbl a target and depend rxvt.1 on it.
+
+	* src/xpm.c: Resurrect negative positioning.
+
+	* src/main.c: Remove inline's
+
+	* Makefile.in: Distribute README.configure
+
+	* INSTALL, README.configure:
+	Update memory stuff a bit and point INSTALL to README.configure
+
+	* doc/Attic/rxvt.pretbl: Manual page before being run through tbl
+
+	* doc/yodl/rxvt-resources.yo, doc/Attic/rxvt.1, doc/Attic/rxvt.html:
+	Document modifier resource
+
+	* doc/Makefile.in: Depend rxvt.1 better and leave pre-tbl version
+
+	* configure, autoconf/configure.in: Fix check for Xlocale stuff.
+	Be a bit nicer on cross compiles
+
+	* src/rxvt.h: rmemset() uses longs now, not integers
+
+	* src/rmemset.c: Use longs now, not integers.
+
+	* src/xpm.c: scale_pixmap() returns 0 if XPM_BACKGROUND not defined
+
+Sat Sep 19 14:40:50 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/xpm.c: Cleanup.
+
+	* doc/changes.txt: Refix XPM position
+
+	* src/xpm.c, doc/yodl/rxvt-resources.yo, doc/yodl/rxvtRef-xpm.yo, doc/Attic/rxvt.html, doc/Attic/rxvtRef.html, doc/Attic/rxvtRef.txt, doc/Attic/rxvt.1:
+	Refix handling of positioning in pixmap geometry
+
+	* README.configure: Document --enable-half-shadow
+
+	* src/feature.h: Turn off SB_BORDER by default
+
+	* doc/changes.txt: sync
+
+	* src/main.c:
+	Border pixel should be foreground colour, not background colour
+
+	* autoconf/acconfig.h, autoconf/configure.in, src/feature.h, configure:
+	Move HALFSHADOW from src/feature.h to ./configure
+
+	* src/command.c: Formatting
+
+	* autoconf/config.h.in:
+	Regen OLD_SELECTION, OLD_WORD_SELECTION, HALFSHADOW
+
+	* doc/yodl/rxvt-resources.yo, doc/Attic/rxvt.1, doc/Attic/rxvt.html, src/rxvt.h, src/xdefaults.c, src/main.c, src/scrollbar.c:
+	Add troughColor and appropriate resource as colour of scrollbar trough area
+
+	* doc/BUGS: Note bug in selection with swap screen use.
+
+	* doc/BUGS: Fixed XPM
+
+	* doc/TODO: Update to current status.
+
+	* README.configure:
+	Start adding slightly better documentation for the ./configure options
+
+	* autoconf/configure.in, src/feature.h, configure:
+	Move OLD_SELECTION and OLD_WORD_SELECTION into ./configure
+
+	* autoconf/configure.in, configure:
+	Stupidly used the wrong enable names in autoconf/configure.in
+
+	* autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in, src/feature.h, configure:
+	Move USE_XGETDEFAULTS and NO_RESOURCES from src/feature.h to ./configure
+
+Tue Sep 15 02:03:37 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/xpm.c: Clean up code/comments
+
+Mon Sep 14 02:04:05 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c:
+	Display fixes.  Pixel dropping fix - now go backwards in the check since we
+	don't want to overwrite what we're going to test next.
+
+Fri Sep  4 05:43:56 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/changes.txt: Document XPM changes
+
+	* doc/Attic/rxvt.1, doc/yodl/rxvt-resources.yo, doc/yodl/rxvtRef-xpm.yo, src/xpm.c, doc/Attic/rxvtRef.txt, doc/Attic/rxvt.html, doc/Attic/rxvtRef.html:
+	Change default XPM geom to 0x0-0-0:
+	x/y position of -0 means centre pixmap in that axis
+
+	* doc/yodl/rxvt-resources.yo, doc/yodl/rxvtRef-xpm.yo, src/xpm.c, doc/Attic/rxvt.1, doc/Attic/rxvtRef.txt:
+	Change XPM geometry defaults and handling.  When not tiled in a direction
+	  then a position of 0 means centred.  Handle negative positions as being from
+	  the right/bottom of the window.
+	Use X's tiling for base tiling.  We should use more of it (future changes)
+
+Sat Aug 29 10:54:25 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c, src/scrollbar.c, src/xdefaults.c, src/xpm.c, src/graphics.c, src/main.c, src/menubar.c, src/rxvt.h, src/command.c:
+	Update colour name definitions
+
+Fri Aug 28 01:52:14 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/TODO: More stuff
+
+	* doc/changes.txt: Update for 2.4.7
+
+	* src/feature.h: No default FORCE_*
+
+	* Makefile, configure: Regenerate
+
+	* src/grkelot.h: nitpick
+
+	* doc/yodl/Attic/versioninfo.yo, doc/Attic/rxvt.1, doc/Attic/rxvt.html, doc/Attic/rxvtRef.html, doc/Attic/rxvtRef.txt:
+	Regenerate
+
+	* autoconf/acconfig.h, autoconf/config.h.in, autoconf/configure.in, src/rxvt.h:
+	Rename SMALL to SMALLREND
+
+	* src/xdefaults.c, src/xpm.c, src/Attic/utmp.c, src/scrollbar.c, src/misc.c, src/netdisp.c, src/rmemset.c, src/screen.c, src/graphics.c, src/grkelot.c, src/main.c, src/menubar.c, src/command.c:
+	Attribute authors better
+
+	* src/version.h: bump version to 2.4.7
+
+Mon Aug 10 12:17:10 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/xpm.c, src/rxvt.h: Move xpm.h include into xpm.c
+
+	* src/screen.c, src/command.c: Clean up some prototypes.
+
+Sun Aug  9 08:21:46 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: Fix test which was changed with RS_Dirty removal.
+
+	* autoconf/config.h.in: RMEMSET
+
+Sat Aug  8 23:26:14 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: Whoops.  Set **drawn_text to 0, not OR it
+
+	* src/rxvt.h, autoconf/configure.in, autoconf/acconfig.h, configure:
+	Add --disable-memset routine to use system's memset routine.
+
+	* src/screen.c, src/rxvt.h, autoconf/configure.in, autoconf/config.h.in, autoconf/acconfig.h, configure:
+	First cut --enable-small to shrink rend_t if possible
+
+	* src/xpm.c, src/menubar.c:
+	Clean up some #ifdef's to commit out procedure body's
+
+	* autoconf/configure.in, autoconf/config.h.in, configure, INSTALL:
+	Check for sizeof(char), sizeof(short), sizeof(long)
+
+	* src/scrollbar.c, src/menubar.c, src/main.c:
+	Move some stuff out of main.c into menubar.c & scrollbar.c
+
+	* src/graphics.c, src/rxvt.h: Move XPM defines out of graphics.c
+
+	* src/main.c: Remove some XPM and MenuBar stuff.
+
+	* src/menubar.c: Move map_menuBar() here
+
+	* src/xdefaults.c: Indent
+
+	* src/command.c, src/feature.h, configure, autoconf/configure.in, autoconf/config.h.in, autoconf/acconfig.h:
+	Move some options into configure
+
+Fri Aug  7 12:38:30 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/Makefile.in: Add xpm.c stuff
+
+	* src/main.c, src/xpm.c: Id
+
+	* src/protos.h: Add xpm.pro
+
+	* src/main.c: Split XPM only routines out of here
+
+	* src/xpm.c: Split XPM only routines out of main.c
+
+Tue Jul 28 11:53:22 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/rxvt.h, src/xdefaults.c, src/Attic/utmp.c, src/scrollbar.c, src/screen.c, src/misc.c, src/netdisp.c, src/rmemset.c, src/main.c, src/menubar.c, src/graphics.c, src/grkelot.c, src/command.c:
+	Partially delint
+
+	* src/screen.c: REMALLOC() -> REALLOC()
+
+Mon Jul 20 11:15:09 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/yodl/Attic/versioninfo.yo, Makefile: 2.4.7a
+
+	* src/version.h: bump version to 2.4.7a
+
+	* doc/yodl/rxvtRef-menubar.yo: Typo
+
+	* src/rxvt.h, src/menubar.c, src/xdefaults.c, src/command.c:
+	REMALLOC() --> REALLOC()
+
+Sat Jul 18 09:11:48 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/command.c: REALLOC() --> REMALLOC()
+
+Fri Jul 17 16:01:16 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/screen.c: Be careful with swap too.
+
+	* src/rmemset.c: Optimise slightly.
+
+	* src/command.c: Small cleanup.
+
+	* src/command.c: Let print mode accept ESC sequence variation:
+	John E. Davis <davis@space.mit.edu>
+
+Thu Jul 16 04:55:57 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* src/rxvt.h, src/xdefaults.c, src/main.c, src/command.c:
+	Meta Modifier selectable via resource:
+	Guillaume Laurent <glaurent@worldnet.fr>
+
+	* src/command.c: malloc() -> MALLOC()
+
+Mon Apr 20 08:19:40 1998  Geoff C. Wing  <gcw@rxvt.org>
+
+	* doc/yodl/rxvtRef-menubar.yo: Typo ) --> }
+
+	* src/graphics/README, src/graphics/data: Add rcsid[] strings
+
+	* src/version.h: bump version to 2.4.6
+
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/config.cache work/main.d/rxvt-2.6.4/config.cache
--- tmp/rxvt-2.6.4/config.cache	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/config.cache	2007-01-15 18:03:32.000000000 -0300
@@ -0,0 +1,6 @@
+ac_cv_sizeof_char=1
+ac_cv_sizeof_short=2
+ac_cv_sizeof_int=4
+ac_cv_sizeof_long=4
+ac_cv_sizeof_long_long=8
+ac_cv_sizeof_int_p=4
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/config.h work/main.d/rxvt-2.6.4/config.h
--- tmp/rxvt-2.6.4/config.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/config.h	2007-01-15 18:03:54.000000000 -0300
@@ -0,0 +1,286 @@
+/* config.h.  Generated automatically by configure.  */
+/* autoconf/config.h.in.  Generated automatically from autoconf/configure.in by autoheader.  */
+
+/* Define if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* #undef _ALL_SOURCE */
+#endif
+
+/* Define to empty if the keyword does not work.  */
+/* #undef const */
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef gid_t */
+
+/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define as __inline if that's what the C compiler calls it.  */
+/* #undef inline */
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef mode_t */
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef pid_t */
+
+/* Define if you need to in order for stat and other things to work.  */
+/* #undef _POSIX_SOURCE */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define if you have the ANSI C header files.  */
+#define STDC_HEADERS 1
+
+/* Define if you can safely include both <sys/time.h> and <time.h>.  */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef uid_t */
+
+/* Define if the X Window System is missing or not being used.  */
+/* #undef X_DISPLAY_MISSING */
+
+/* ------------------------------------------------------------------------- */
+/* Set TERMINFO value to the value given by configure */
+/* #undef RXVT_TERMINFO */
+
+/* Set TERM to the value given by configure */
+/* #undef TERMENV */
+
+/* Define if you want to use your system's memset() */
+/* #undef NO_RMEMSET */
+
+/* Define if you don't want any resources read */
+/* #undef NO_RESOURCES */ 
+
+/* Define if you want to use XGetDefault instead of our internal version
+ * which only reads ~/.Xdefaults, if it exists, otherwise ~/.Xresources if it
+ * exists, and saves 60-150kB memory */
+/* #undef USE_XGETDEFAULT */
+
+/* Define to remove old rxvt (ver 2.20 and before) style selection */
+/* #undef NO_OLD_SELECTION */
+
+/* Define to remove xterm style selection */
+/* #undef NO_NEW_SELECTION */
+
+/* Define if you want the depth of scrollbars and menus to be less
+ * (width of 3d-look shadows and highlights)  --pjh */
+/* #undef HALFSHADOW */
+
+/* Define if you want KANJI support */
+/* after compilation, rename executable as `kxvt' */
+/* #undef KANJI */
+
+/* Define if you want Chinese BIG5 support */
+/* after compilation, rename executable as `crxvt' */
+/* #undef ZH */
+
+/* Define if you want Chinese GB (zh_CN i.e. GB2312) support */
+/* after compilation, rename executable as `gbxvt' */
+/* #undef ZHCN */
+
+/* Define if Xlocale support doesn't work */
+/* #undef NO_XLOCALE */
+
+/* Define if setlocale (defined to Xsetlocale) doesn't work */
+#define NO_XSETLOCALE 1
+
+ 
+/* Define if plain old setlocale doesn't work */
+/* #undef NO_SETLOCALE */
+
+/* Define if you want Menubar support */
+/* #undef MENUBAR */
+
+/* Define if you don't want support for the backspace key */
+/* #undef NO_BACKSPACE_KEY */
+
+/* Define if you don't want support for the (non-keypad) delete key */
+/* #undef NO_DELETE_KEY */
+
+/* Define if you want Rob Nation's own graphic mode */
+/* #undef RXVT_GRAPHICS */
+
+/* Define if you want to use NeXT style scrollbars */
+/* #undef NEXT_SCROLLBAR */
+
+/* Define if you want to revert to Xterm style scrollbars */
+/* #undef XTERM_SCROLLBAR */
+
+/* Define if you want support for Greek Elot-928 & IBM-437 keyboard */
+/* see doc/README.greek */
+/* #undef GREEK_SUPPORT */
+
+/* Define if you want tty's to be setgid() to the `tty' group */
+/* #undef TTY_GID_SUPPORT */
+
+/* Define if you want to have XIM (X Input Method) protocol support
+ * This is required for multibyte characters input. */
+/* #undef USE_XIM */
+
+/* Define if you want to have utmp/utmpx support */
+/* #undef UTMP_SUPPORT */
+
+/* Define if you want to have wtmp support when utmp/utmpx is enabled */
+/* #undef WTMP_SUPPORT */
+
+/* Define if you want to have sexy-looking background pixmaps. Needs libXpm */
+/* #undef XPM_BACKGROUND */
+
+/* Define if you want your background use the parent window background */
+/* #undef TRANSPARENT */
+
+/* Define if you include <X11/xpm.h> on a normal include path (be careful) */
+/* #undef XPM_INC_X11 */
+
+/* Disable the secondary screen ("\E[?47h" / "\E[?47l")
+ * Many programs use the secondary screen as their workplace. The advantage
+ * is, that when you exit those programs, your previous screen contents (in
+ * general the shell as you left it) will be shown again. */
+/* #undef NO_SECONDARY_SCREEN */
+
+/* Define if you want continual scrolling on when you keep the
+ * scrollbar button pressed */
+/* #undef NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING */
+
+/*
+ * Use wheel events (button4 and button5) to scroll.  Even if you don't
+ * have a wheeled mouse, this is harmless unless you have an exotic mouse!
+ */
+/* #undef NO_MOUSE_WHEEL */
+
+/* ------------------------------------------------------------------------- */
+/* Define in utmp.h has struct utmp */
+/* #undef HAVE_STRUCT_UTMP */
+
+/* Define if struct utmp contains ut_host */
+/* #undef HAVE_UTMP_HOST */
+
+/* Define location of utmp */
+/* #undef RXVT_UTMP_FILE */
+
+/* Define in utmpx.h has struct utmpx */
+/* #undef HAVE_STRUCT_UTMPX */
+
+/* Define if struct utmpx contains ut_host */
+/* #undef HAVE_UTMPX_HOST */
+
+/* Define location of utmpx */
+/* #undef RXVT_UTMPX_FILE */
+
+/* Define location of wtmp */
+/* #undef RXVT_WTMP_FILE */
+
+/* Define location of wtmpx */
+/* #undef RXVT_WTMPX_FILE */
+
+/* Define location of ttys/ttytab */
+/* #undef TTYTAB_FILENAME */
+
+/* Define if you need function prototypes */
+#define PROTOTYPES 1
+
+/* Define if you have XPointer typedef */
+#define HAVE_XPOINTER 1
+
+/* Define if you have _GNU_SOURCE getpt() */
+#define HAVE_GETPT 1
+
+/* Define possible pty types */
+/* #undef PTYS_ARE_NUMERIC */
+/* #undef PTYS_ARE_PTMX */
+/* #undef PTYS_ARE_PTC */
+/* #undef PTYS_ARE__GETPTY */
+/* #undef PTYS_ARE_GETPTY */
+#define PTYS_ARE_GETPT 1
+/* #undef PTYS_ARE_CLONE */
+#define PTYS_ARE_SEARCHED 1
+
+/* The number of bytes in a char.  */
+#define SIZEOF_CHAR 1
+
+/* The number of bytes in a int.  */
+#define SIZEOF_INT 4
+
+/* The number of bytes in a int *.  */
+#define SIZEOF_INT_P 4
+
+/* The number of bytes in a long.  */
+#define SIZEOF_LONG 4
+
+/* The number of bytes in a long long.  */
+#define SIZEOF_LONG_LONG 8
+
+/* The number of bytes in a short.  */
+#define SIZEOF_SHORT 2
+
+/* Define if you have the _getpty function.  */
+/* #undef HAVE__GETPTY */
+
+/* Define if you have the atexit function.  */
+#define HAVE_ATEXIT 1
+
+/* Define if you have the grantpt function.  */
+#define HAVE_GRANTPT 1
+
+/* Define if you have the seteuid function.  */
+#define HAVE_SETEUID 1
+
+/* Define if you have the setutent function.  */
+#define HAVE_SETUTENT 1
+
+/* Define if you have the unlockpt function.  */
+#define HAVE_UNLOCKPT 1
+
+/* Define if you have the unsetenv function.  */
+#define HAVE_UNSETENV 1
+
+/* Define if you have the <assert.h> header file.  */
+#define HAVE_ASSERT_H 1
+
+/* Define if you have the <fcntl.h> header file.  */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the <grp.h> header file.  */
+#define HAVE_GRP_H 1
+
+/* Define if you have the <lastlog.h> header file.  */
+#define HAVE_LASTLOG_H 1
+
+/* Define if you have the <libc.h> header file.  */
+/* #undef HAVE_LIBC_H */
+
+/* Define if you have the <stdarg.h> header file.  */
+#define HAVE_STDARG_H 1
+
+/* Define if you have the <stdlib.h> header file.  */
+#define HAVE_STDLIB_H 1
+
+/* Define if you have the <string.h> header file.  */
+#define HAVE_STRING_H 1
+
+/* Define if you have the <sys/byteorder.h> header file.  */
+/* #undef HAVE_SYS_BYTEORDER_H */
+
+/* Define if you have the <sys/ioctl.h> header file.  */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define if you have the <sys/select.h> header file.  */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define if you have the <sys/sockio.h> header file.  */
+/* #undef HAVE_SYS_SOCKIO_H */
+
+/* Define if you have the <sys/time.h> header file.  */
+#define HAVE_SYS_TIME_H 1
+
+/* Define if you have the <termios.h> header file.  */
+#define HAVE_TERMIOS_H 1
+
+/* Define if you have the <unistd.h> header file.  */
+#define HAVE_UNISTD_H 1
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/config.log work/main.d/rxvt-2.6.4/config.log
--- tmp/rxvt-2.6.4/config.log	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/config.log	2007-01-15 18:03:52.000000000 -0300
@@ -0,0 +1,225 @@
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+configure:986: checking for gcc
+configure:1099: checking whether the C compiler (i586-castorbox-linux-gnu-gcc -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32 ) works
+configure:1115: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:1141: checking whether the C compiler (i586-castorbox-linux-gnu-gcc -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32 ) is a cross-compiler
+configure:1146: checking whether we are using GNU C
+configure:1155: i586-castorbox-linux-gnu-gcc -E conftest.c
+configure:1174: checking whether i586-castorbox-linux-gnu-gcc accepts -g
+configure:1206: checking how to run the C preprocessor
+configure:1297: checking for a BSD compatible install
+configure:1353: checking for mv
+configure:1389: checking for rm
+configure:1425: checking for cp
+configure:1461: checking for sed
+configure:1497: checking for awk
+configure:1533: checking for echo
+configure:1569: checking for cmp
+configure:1605: checking for tbl
+configure:1639: checking for AIX
+configure:1663: checking for POSIXized ISC
+configure:1691: checking for X
+configure:2005: checking for dnet_ntoa in -ldnet
+configure:2024: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c -ldnet   1>&5
+/media/gar-castorbox/images/build/usr/lib/gcc/i586-castorbox-linux-gnu/4.1.2/../../../../i586-castorbox-linux-gnu/bin/ld: cannot find -ldnet
+collect2: ld returned 1 exit status
+configure: failed program was:
+#line 2013 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char dnet_ntoa();
+
+int main() {
+dnet_ntoa()
+; return 0; }
+configure:2046: checking for dnet_ntoa in -ldnet_stub
+configure:2065: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c -ldnet_stub   1>&5
+/media/gar-castorbox/images/build/usr/lib/gcc/i586-castorbox-linux-gnu/4.1.2/../../../../i586-castorbox-linux-gnu/bin/ld: cannot find -ldnet_stub
+collect2: ld returned 1 exit status
+configure: failed program was:
+#line 2054 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char dnet_ntoa();
+
+int main() {
+dnet_ntoa()
+; return 0; }
+configure:2094: checking for gethostbyname
+configure:2122: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:2192: checking for connect
+configure:2220: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:2284: checking for remove
+configure:2312: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:2376: checking for shmat
+configure:2404: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:2477: checking for IceConnectionNumber in -lICE
+configure:2496: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   -L/media/gar-castorbox/images/main//usr/lib conftest.c -lICE   1>&5
+configure:2811: checking for XPointer
+configure:2823: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  -I/media/gar-castorbox/images/main//usr/include  conftest.c 1>&5
+configure:2845: checking for sys/wait.h that is POSIX.1 compatible
+configure:2866: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  conftest.c 1>&5
+configure:2906: checking for assert.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2906: checking for fcntl.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2906: checking for grp.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2906: checking for libc.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2912:18: error: libc.h: No such file or directory
+configure: failed program was:
+#line 2911 "configure"
+#include "confdefs.h"
+#include <libc.h>
+configure:2906: checking for lastlog.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2906: checking for stdarg.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2906: checking for stdlib.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2906: checking for string.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2906: checking for termios.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2906: checking for unistd.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2906: checking for sys/byteorder.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2912:27: error: sys/byteorder.h: No such file or directory
+configure: failed program was:
+#line 2911 "configure"
+#include "confdefs.h"
+#include <sys/byteorder.h>
+configure:2906: checking for sys/ioctl.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2906: checking for sys/select.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2906: checking for sys/sockio.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2912:24: error: sys/sockio.h: No such file or directory
+configure: failed program was:
+#line 2911 "configure"
+#include "confdefs.h"
+#include <sys/sockio.h>
+configure:2906: checking for sys/time.h
+configure:2916: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:2944: checking whether time.h and sys/time.h may both be included
+configure:2958: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  conftest.c 1>&5
+configure:2980: checking for working const
+configure:3034: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  conftest.c 1>&5
+configure:3055: checking for inline
+configure:3069: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  conftest.c 1>&5
+configure:3097: checking for ANSI C header files
+configure:3110: i586-castorbox-linux-gnu-cpp  conftest.c >/dev/null 2>conftest.out
+configure:3177: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure: In function 'main':
+configure:3172: warning: incompatible implicit declaration of built-in function 'exit'
+configure:3201: checking for mode_t
+configure:3234: checking for pid_t
+configure:3267: checking for uid_t in sys/types.h
+configure:3303: checking size of char
+configure:3342: checking size of short
+configure:3381: checking size of int
+configure:3420: checking size of long
+configure:3459: checking size of long long
+configure:3498: checking size of int *
+configure:3542: checking for int16_t
+configure:3554: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  conftest.c 1>&5
+configure:3596: checking for u_int16_t
+configure:3608: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  conftest.c 1>&5
+configure:3650: checking for int32_t
+configure:3662: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  conftest.c 1>&5
+configure:3704: checking for u_int32_t
+configure:3716: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  conftest.c 1>&5
+configure:3758: checking for int64_t
+configure:3770: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  conftest.c 1>&5
+configure:3812: checking for u_int64_t
+configure:3824: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  conftest.c 1>&5
+configure:3886: checking return type of signal handlers
+configure:3908: i586-castorbox-linux-gnu-gcc -c -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  conftest.c 1>&5
+configure:3937: checking for atexit
+configure:3965: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:3937: checking for unsetenv
+configure:3965: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:3937: checking for setutent
+configure:3965: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:3937: checking for seteuid
+configure:3965: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:3937: checking for _getpty
+configure:3965: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+/home/pablo/tmp/ccJcYJB8.o: In function `main':
+conftest.c:(.text+0x12): undefined reference to `_getpty'
+collect2: ld returned 1 exit status
+configure: failed program was:
+#line 3942 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char _getpty(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char _getpty();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub__getpty) || defined (__stub____getpty)
+choke me
+#else
+_getpty();
+#endif
+
+; return 0; }
+configure:3937: checking for grantpt
+configure:3965: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:3937: checking for unlockpt
+configure:3965: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:4448: checking where ttys/ttytab is located
+configure:4475: checking for working Xlocale
+configure:4493: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  -I/media/gar-castorbox/images/main//usr/include   conftest.c   -L/media/gar-castorbox/images/main//usr/lib  -lX11 1>&5
+configure: In function 'main':
+configure:4488: warning: incompatible implicit declaration of built-in function 'exit'
+configure:4516: checking for working X setlocale
+configure:4529: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32  -I/media/gar-castorbox/images/main//usr/include   conftest.c   -L/media/gar-castorbox/images/main//usr/lib  -lX11 1>&5
+/home/pablo/tmp/ccgk4C4c.o: In function `main':
+conftest.c:(.text+0x19): undefined reference to `_Xsetlocale'
+collect2: ld returned 1 exit status
+configure: failed program was:
+#line 4521 "configure"
+#include "confdefs.h"
+#define X_LOCALE 1
+#include <X11/Xlocale.h>
+int main() {
+setlocale(LC_CTYPE, "");
+; return 0; }
+configure:4552: checking for working plain setlocale
+configure:4564: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:4585: checking for getpt
+configure:4600: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:4622: checking for tty/pty type
+configure:4706: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c  1>&5
+configure:4795: checking for setlocale in -lxpg4
+configure:4814: i586-castorbox-linux-gnu-gcc -o conftest -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32   conftest.c -lxpg4   1>&5
+/media/gar-castorbox/images/build/usr/lib/gcc/i586-castorbox-linux-gnu/4.1.2/../../../../i586-castorbox-linux-gnu/bin/ld: cannot find -lxpg4
+collect2: ld returned 1 exit status
+configure: failed program was:
+#line 4803 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char setlocale();
+
+int main() {
+setlocale()
+; return 0; }
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/config.status work/main.d/rxvt-2.6.4/config.status
--- tmp/rxvt-2.6.4/config.status	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/config.status	2007-01-15 18:03:52.000000000 -0300
@@ -0,0 +1,411 @@
+#! /bin/sh
+# Generated automatically by configure.
+# Run this file to recreate the current configuration.
+# This directory was configured as follows,
+# on host devcsp.intra.csps.com.ar:
+#
+# ./configure  --prefix=//usr --exec_prefix=//usr --bindir=//usr/bin --sbindir=//usr/sbin --libexecdir=//usr/libexec --datadir=//usr/share --sysconfdir=//etc --sharedstatedir=//usr/share --localstatedir=//var --libdir=//usr/lib --infodir=//usr/info --includedir=//usr/include --oldincludedir=//usr/include --mandir=//usr/share/man --build=i586-mandriva-linux-gnu --host=i586-castorbox-linux-gnu --cache-file=config.cache --x-includes=/media/gar-castorbox/images/main//usr/include --x-libraries=/media/gar-castorbox/images/main//usr/lib --with-gnu-ld
+#
+# Compiler output produced by configure, useful for debugging
+# configure, is in ./config.log if it exists.
+
+ac_cs_usage="Usage: ./config.status [--recheck] [--version] [--help]"
+for ac_option
+do
+  case "$ac_option" in
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    echo "running ${CONFIG_SHELL-/bin/sh} ./configure  --prefix=//usr --exec_prefix=//usr --bindir=//usr/bin --sbindir=//usr/sbin --libexecdir=//usr/libexec --datadir=//usr/share --sysconfdir=//etc --sharedstatedir=//usr/share --localstatedir=//var --libdir=//usr/lib --infodir=//usr/info --includedir=//usr/include --oldincludedir=//usr/include --mandir=//usr/share/man --build=i586-mandriva-linux-gnu --host=i586-castorbox-linux-gnu --cache-file=config.cache --x-includes=/media/gar-castorbox/images/main//usr/include --x-libraries=/media/gar-castorbox/images/main//usr/lib --with-gnu-ld --no-create --no-recursion"
+    exec ${CONFIG_SHELL-/bin/sh} ./configure  --prefix=//usr --exec_prefix=//usr --bindir=//usr/bin --sbindir=//usr/sbin --libexecdir=//usr/libexec --datadir=//usr/share --sysconfdir=//etc --sharedstatedir=//usr/share --localstatedir=//var --libdir=//usr/lib --infodir=//usr/info --includedir=//usr/include --oldincludedir=//usr/include --mandir=//usr/share/man --build=i586-mandriva-linux-gnu --host=i586-castorbox-linux-gnu --cache-file=config.cache --x-includes=/media/gar-castorbox/images/main//usr/include --x-libraries=/media/gar-castorbox/images/main//usr/lib --with-gnu-ld --no-create --no-recursion ;;
+  -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
+    echo "./config.status generated by autoconf version 2.13"
+    exit 0 ;;
+  -help | --help | --hel | --he | --h)
+    echo "$ac_cs_usage"; exit 0 ;;
+  *) echo "$ac_cs_usage"; exit 1 ;;
+  esac
+done
+
+ac_given_srcdir=.
+ac_given_INSTALL="//media/gar-castorbox/images/build/usr/bin/install -c"
+
+trap 'rm -fr autoconf/Make.common Makefile doc/Makefile src/Makefile src/graphics/Makefile src/rsizes.h rclock/Makefile doc/yodl/rxvt.yo doc/yodl/rxvtRef.yo  config.h conftest*; exit 1' 1 2 15
+
+# Protect against being on the right side of a sed subst in config.status.
+sed 's/%@/@@/; s/@%/@@/; s/%g$/@g/; /@g$/s/[\\&%]/\\&/g;
+ s/@@/%@/; s/@@/@%/; s/@g$/%g/' > conftest.subs <<\CEOF
+/^[ 	]*VPATH[ 	]*=[^:]*$/d
+
+s%@SHELL@%/bin/sh%g
+s%@CFLAGS@%-pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32%g
+s%@CPPFLAGS@%%g
+s%@CXXFLAGS@%-pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32%g
+s%@FFLAGS@%%g
+s%@DEFS@%-DHAVE_CONFIG_H%g
+s%@LDFLAGS@%%g
+s%@LIBS@%%g
+s%@exec_prefix@%//usr%g
+s%@prefix@%//usr%g
+s%@program_transform_name@%s,x,x,%g
+s%@bindir@%//usr/bin%g
+s%@sbindir@%//usr/sbin%g
+s%@libexecdir@%//usr/libexec%g
+s%@datadir@%//usr/share%g
+s%@sysconfdir@%//etc%g
+s%@sharedstatedir@%//usr/share%g
+s%@localstatedir@%//var%g
+s%@libdir@%//usr/lib%g
+s%@includedir@%//usr/include%g
+s%@oldincludedir@%//usr/include%g
+s%@infodir@%//usr/info%g
+s%@mandir@%//usr/share/man%g
+s%@VERSION@%2.6.4%g
+s%@DATE@%02 NOVEMBER 2001%g
+s%@LSMDATE@%02NOV01%g
+s%@CC@%i586-castorbox-linux-gnu-gcc%g
+s%@CPP@%i586-castorbox-linux-gnu-cpp%g
+s%@INSTALL_PROGRAM@%${INSTALL}%g
+s%@INSTALL_SCRIPT@%${INSTALL_PROGRAM}%g
+s%@INSTALL_DATA@%${INSTALL} -m 644%g
+s%@MV@%//media/gar-castorbox/images/build/usr/bin/mv%g
+s%@RM@%//media/gar-castorbox/images/build/usr/bin/rm%g
+s%@CP@%//media/gar-castorbox/images/build/usr/bin/cp%g
+s%@SED@%//media/gar-castorbox/images/build/usr/bin/sed%g
+s%@AWK@%//media/gar-castorbox/images/build/usr/bin/awk%g
+s%@ECHO@%//media/gar-castorbox/images/build/usr/bin/echo%g
+s%@CMP@%//media/gar-castorbox/images/build/usr/bin/cmp%g
+s%@TBL@%%g
+s%@X_CFLAGS@% -I/media/gar-castorbox/images/main//usr/include%g
+s%@X_PRE_LIBS@% -lSM -lICE%g
+s%@X_LIBS@% -L/media/gar-castorbox/images/main//usr/lib%g
+s%@X_EXTRA_LIBS@%%g
+s%@XPM_CPPFLAGS@%%g
+s%@XPM_CFLAGS@%%g
+s%@XPM_LIBS@%%g
+s%@rxvt_int16_typedef@%%g
+s%@rxvt_u_int16_typedef@%%g
+s%@rxvt_int32_typedef@%%g
+s%@rxvt_u_int32_typedef@%%g
+s%@rxvt_int64_typedef@%%g
+s%@rxvt_u_int64_typedef@%%g
+s%@rxvt_intp_define@%#define intp_t int32_t%g
+s%@rxvt_u_intp_define@%#define u_intp_t u_int32_t%g
+s%@PTYS_ARE_NUMERIC@%%g
+s%@PTYS_ARE_PTMX@%%g
+s%@PTYS_ARE_SEARCHED@%%g
+s%@PTYS_ARE_PTC@%%g
+s%@PTYS_ARE__GETPTY@%%g
+s%@PTYS_ARE_GETPTY@%%g
+s%@PTYS_ARE_GETPT@%%g
+s%@PTYS_ARE_CLONE@%%g
+s%@DEBUG@%%g
+s%@DLIB@%%g
+s%@DINCLUDE@%%g
+/@MCOMMON@/r ./autoconf/Make.common
+s%@MCOMMON@%%g
+
+CEOF
+
+# Split the substitutions into bite-sized pieces for seds with
+# small command number limits, like on Digital OSF/1 and HP-UX.
+ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
+ac_file=1 # Number of current file.
+ac_beg=1 # First line for current file.
+ac_end=$ac_max_sed_cmds # Line after last line for current file.
+ac_more_lines=:
+ac_sed_cmds=""
+while $ac_more_lines; do
+  if test $ac_beg -gt 1; then
+    sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
+  else
+    sed "${ac_end}q" conftest.subs > conftest.s$ac_file
+  fi
+  if test ! -s conftest.s$ac_file; then
+    ac_more_lines=false
+    rm -f conftest.s$ac_file
+  else
+    if test -z "$ac_sed_cmds"; then
+      ac_sed_cmds="sed -f conftest.s$ac_file"
+    else
+      ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
+    fi
+    ac_file=`expr $ac_file + 1`
+    ac_beg=$ac_end
+    ac_end=`expr $ac_end + $ac_max_sed_cmds`
+  fi
+done
+if test -z "$ac_sed_cmds"; then
+  ac_sed_cmds=cat
+fi
+
+CONFIG_FILES=${CONFIG_FILES-"autoconf/Make.common Makefile doc/Makefile src/Makefile src/graphics/Makefile src/rsizes.h rclock/Makefile doc/yodl/rxvt.yo doc/yodl/rxvtRef.yo "}
+for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
+
+  # Remove last slash and all that follows it.  Not all systems have dirname.
+  ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+  if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+    # The file is in a subdirectory.
+    test ! -d "$ac_dir" && mkdir "$ac_dir"
+    ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
+    # A "../" for each directory in $ac_dir_suffix.
+    ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
+  else
+    ac_dir_suffix= ac_dots=
+  fi
+
+  case "$ac_given_srcdir" in
+  .)  srcdir=.
+      if test -z "$ac_dots"; then top_srcdir=.
+      else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
+  /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
+  *) # Relative path.
+    srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
+    top_srcdir="$ac_dots$ac_given_srcdir" ;;
+  esac
+
+  case "$ac_given_INSTALL" in
+  [/$]*) INSTALL="$ac_given_INSTALL" ;;
+  *) INSTALL="$ac_dots$ac_given_INSTALL" ;;
+  esac
+
+  echo creating "$ac_file"
+  rm -f "$ac_file"
+  configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
+  case "$ac_file" in
+  *Makefile*) ac_comsub="1i\\
+# $configure_input" ;;
+  *) ac_comsub= ;;
+  esac
+
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  sed -e "$ac_comsub
+s%@configure_input@%$configure_input%g
+s%@srcdir@%$srcdir%g
+s%@top_srcdir@%$top_srcdir%g
+s%@INSTALL@%$INSTALL%g
+" $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
+fi; done
+rm -f conftest.s*
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
+ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
+ac_dC='\3'
+ac_dD='%g'
+# ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
+ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_uB='\([ 	]\)%\1#\2define\3'
+ac_uC=' '
+ac_uD='\4%g'
+# ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_eB='$%\1#\2define\3'
+ac_eC=' '
+ac_eD='%g'
+
+if test "${CONFIG_HEADERS+set}" != set; then
+  CONFIG_HEADERS="config.h:autoconf/config.h.in"
+fi
+for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  echo creating $ac_file
+
+  rm -f conftest.frag conftest.in conftest.out
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  cat $ac_file_inputs > conftest.in
+
+  cat > conftest.frag <<CEOF
+${ac_dA}PROTOTYPES${ac_dB}PROTOTYPES${ac_dC}1${ac_dD}
+${ac_uA}PROTOTYPES${ac_uB}PROTOTYPES${ac_uC}1${ac_uD}
+${ac_eA}PROTOTYPES${ac_eB}PROTOTYPES${ac_eC}1${ac_eD}
+${ac_dA}HAVE_XPOINTER${ac_dB}HAVE_XPOINTER${ac_dC}1${ac_dD}
+${ac_uA}HAVE_XPOINTER${ac_uB}HAVE_XPOINTER${ac_uC}1${ac_uD}
+${ac_eA}HAVE_XPOINTER${ac_eB}HAVE_XPOINTER${ac_eC}1${ac_eD}
+${ac_dA}HAVE_SYS_WAIT_H${ac_dB}HAVE_SYS_WAIT_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_SYS_WAIT_H${ac_uB}HAVE_SYS_WAIT_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_SYS_WAIT_H${ac_eB}HAVE_SYS_WAIT_H${ac_eC}1${ac_eD}
+${ac_dA}HAVE_ASSERT_H${ac_dB}HAVE_ASSERT_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_ASSERT_H${ac_uB}HAVE_ASSERT_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_ASSERT_H${ac_eB}HAVE_ASSERT_H${ac_eC}1${ac_eD}
+CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+
+  cat > conftest.frag <<CEOF
+${ac_dA}HAVE_FCNTL_H${ac_dB}HAVE_FCNTL_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_FCNTL_H${ac_uB}HAVE_FCNTL_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_FCNTL_H${ac_eB}HAVE_FCNTL_H${ac_eC}1${ac_eD}
+${ac_dA}HAVE_GRP_H${ac_dB}HAVE_GRP_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_GRP_H${ac_uB}HAVE_GRP_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_GRP_H${ac_eB}HAVE_GRP_H${ac_eC}1${ac_eD}
+${ac_dA}HAVE_LASTLOG_H${ac_dB}HAVE_LASTLOG_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_LASTLOG_H${ac_uB}HAVE_LASTLOG_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_LASTLOG_H${ac_eB}HAVE_LASTLOG_H${ac_eC}1${ac_eD}
+${ac_dA}HAVE_STDARG_H${ac_dB}HAVE_STDARG_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_STDARG_H${ac_uB}HAVE_STDARG_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_STDARG_H${ac_eB}HAVE_STDARG_H${ac_eC}1${ac_eD}
+CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+
+  cat > conftest.frag <<CEOF
+${ac_dA}HAVE_STDLIB_H${ac_dB}HAVE_STDLIB_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_STDLIB_H${ac_uB}HAVE_STDLIB_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_STDLIB_H${ac_eB}HAVE_STDLIB_H${ac_eC}1${ac_eD}
+${ac_dA}HAVE_STRING_H${ac_dB}HAVE_STRING_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_STRING_H${ac_uB}HAVE_STRING_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_STRING_H${ac_eB}HAVE_STRING_H${ac_eC}1${ac_eD}
+${ac_dA}HAVE_TERMIOS_H${ac_dB}HAVE_TERMIOS_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_TERMIOS_H${ac_uB}HAVE_TERMIOS_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_TERMIOS_H${ac_eB}HAVE_TERMIOS_H${ac_eC}1${ac_eD}
+${ac_dA}HAVE_UNISTD_H${ac_dB}HAVE_UNISTD_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_UNISTD_H${ac_uB}HAVE_UNISTD_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_UNISTD_H${ac_eB}HAVE_UNISTD_H${ac_eC}1${ac_eD}
+CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+
+  cat > conftest.frag <<CEOF
+${ac_dA}HAVE_SYS_IOCTL_H${ac_dB}HAVE_SYS_IOCTL_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_SYS_IOCTL_H${ac_uB}HAVE_SYS_IOCTL_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_SYS_IOCTL_H${ac_eB}HAVE_SYS_IOCTL_H${ac_eC}1${ac_eD}
+${ac_dA}HAVE_SYS_SELECT_H${ac_dB}HAVE_SYS_SELECT_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_SYS_SELECT_H${ac_uB}HAVE_SYS_SELECT_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_SYS_SELECT_H${ac_eB}HAVE_SYS_SELECT_H${ac_eC}1${ac_eD}
+${ac_dA}HAVE_SYS_TIME_H${ac_dB}HAVE_SYS_TIME_H${ac_dC}1${ac_dD}
+${ac_uA}HAVE_SYS_TIME_H${ac_uB}HAVE_SYS_TIME_H${ac_uC}1${ac_uD}
+${ac_eA}HAVE_SYS_TIME_H${ac_eB}HAVE_SYS_TIME_H${ac_eC}1${ac_eD}
+${ac_dA}TIME_WITH_SYS_TIME${ac_dB}TIME_WITH_SYS_TIME${ac_dC}1${ac_dD}
+${ac_uA}TIME_WITH_SYS_TIME${ac_uB}TIME_WITH_SYS_TIME${ac_uC}1${ac_uD}
+${ac_eA}TIME_WITH_SYS_TIME${ac_eB}TIME_WITH_SYS_TIME${ac_eC}1${ac_eD}
+CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+
+  cat > conftest.frag <<CEOF
+${ac_dA}STDC_HEADERS${ac_dB}STDC_HEADERS${ac_dC}1${ac_dD}
+${ac_uA}STDC_HEADERS${ac_uB}STDC_HEADERS${ac_uC}1${ac_uD}
+${ac_eA}STDC_HEADERS${ac_eB}STDC_HEADERS${ac_eC}1${ac_eD}
+${ac_dA}SIZEOF_CHAR${ac_dB}SIZEOF_CHAR${ac_dC}1${ac_dD}
+${ac_uA}SIZEOF_CHAR${ac_uB}SIZEOF_CHAR${ac_uC}1${ac_uD}
+${ac_eA}SIZEOF_CHAR${ac_eB}SIZEOF_CHAR${ac_eC}1${ac_eD}
+${ac_dA}SIZEOF_SHORT${ac_dB}SIZEOF_SHORT${ac_dC}2${ac_dD}
+${ac_uA}SIZEOF_SHORT${ac_uB}SIZEOF_SHORT${ac_uC}2${ac_uD}
+${ac_eA}SIZEOF_SHORT${ac_eB}SIZEOF_SHORT${ac_eC}2${ac_eD}
+${ac_dA}SIZEOF_INT${ac_dB}SIZEOF_INT${ac_dC}4${ac_dD}
+${ac_uA}SIZEOF_INT${ac_uB}SIZEOF_INT${ac_uC}4${ac_uD}
+${ac_eA}SIZEOF_INT${ac_eB}SIZEOF_INT${ac_eC}4${ac_eD}
+CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+
+  cat > conftest.frag <<CEOF
+${ac_dA}SIZEOF_LONG${ac_dB}SIZEOF_LONG${ac_dC}4${ac_dD}
+${ac_uA}SIZEOF_LONG${ac_uB}SIZEOF_LONG${ac_uC}4${ac_uD}
+${ac_eA}SIZEOF_LONG${ac_eB}SIZEOF_LONG${ac_eC}4${ac_eD}
+${ac_dA}SIZEOF_LONG_LONG${ac_dB}SIZEOF_LONG_LONG${ac_dC}8${ac_dD}
+${ac_uA}SIZEOF_LONG_LONG${ac_uB}SIZEOF_LONG_LONG${ac_uC}8${ac_uD}
+${ac_eA}SIZEOF_LONG_LONG${ac_eB}SIZEOF_LONG_LONG${ac_eC}8${ac_eD}
+${ac_dA}SIZEOF_INT_P${ac_dB}SIZEOF_INT_P${ac_dC}4${ac_dD}
+${ac_uA}SIZEOF_INT_P${ac_uB}SIZEOF_INT_P${ac_uC}4${ac_uD}
+${ac_eA}SIZEOF_INT_P${ac_eB}SIZEOF_INT_P${ac_eC}4${ac_eD}
+${ac_dA}RETSIGTYPE${ac_dB}RETSIGTYPE${ac_dC}void${ac_dD}
+${ac_uA}RETSIGTYPE${ac_uB}RETSIGTYPE${ac_uC}void${ac_uD}
+${ac_eA}RETSIGTYPE${ac_eB}RETSIGTYPE${ac_eC}void${ac_eD}
+CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+
+  cat > conftest.frag <<CEOF
+${ac_dA}HAVE_ATEXIT${ac_dB}HAVE_ATEXIT${ac_dC}1${ac_dD}
+${ac_uA}HAVE_ATEXIT${ac_uB}HAVE_ATEXIT${ac_uC}1${ac_uD}
+${ac_eA}HAVE_ATEXIT${ac_eB}HAVE_ATEXIT${ac_eC}1${ac_eD}
+${ac_dA}HAVE_UNSETENV${ac_dB}HAVE_UNSETENV${ac_dC}1${ac_dD}
+${ac_uA}HAVE_UNSETENV${ac_uB}HAVE_UNSETENV${ac_uC}1${ac_uD}
+${ac_eA}HAVE_UNSETENV${ac_eB}HAVE_UNSETENV${ac_eC}1${ac_eD}
+${ac_dA}HAVE_SETUTENT${ac_dB}HAVE_SETUTENT${ac_dC}1${ac_dD}
+${ac_uA}HAVE_SETUTENT${ac_uB}HAVE_SETUTENT${ac_uC}1${ac_uD}
+${ac_eA}HAVE_SETUTENT${ac_eB}HAVE_SETUTENT${ac_eC}1${ac_eD}
+${ac_dA}HAVE_SETEUID${ac_dB}HAVE_SETEUID${ac_dC}1${ac_dD}
+${ac_uA}HAVE_SETEUID${ac_uB}HAVE_SETEUID${ac_uC}1${ac_uD}
+${ac_eA}HAVE_SETEUID${ac_eB}HAVE_SETEUID${ac_eC}1${ac_eD}
+CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+
+  cat > conftest.frag <<CEOF
+${ac_dA}HAVE_GRANTPT${ac_dB}HAVE_GRANTPT${ac_dC}1${ac_dD}
+${ac_uA}HAVE_GRANTPT${ac_uB}HAVE_GRANTPT${ac_uC}1${ac_uD}
+${ac_eA}HAVE_GRANTPT${ac_eB}HAVE_GRANTPT${ac_eC}1${ac_eD}
+${ac_dA}HAVE_UNLOCKPT${ac_dB}HAVE_UNLOCKPT${ac_dC}1${ac_dD}
+${ac_uA}HAVE_UNLOCKPT${ac_uB}HAVE_UNLOCKPT${ac_uC}1${ac_uD}
+${ac_eA}HAVE_UNLOCKPT${ac_eB}HAVE_UNLOCKPT${ac_eC}1${ac_eD}
+${ac_dA}NO_XSETLOCALE${ac_dB}NO_XSETLOCALE${ac_dC}1${ac_dD}
+${ac_uA}NO_XSETLOCALE${ac_uB}NO_XSETLOCALE${ac_uC}1${ac_uD}
+${ac_eA}NO_XSETLOCALE${ac_eB}NO_XSETLOCALE${ac_eC}1${ac_eD}
+${ac_dA}HAVE_GETPT${ac_dB}HAVE_GETPT${ac_dC}1${ac_dD}
+${ac_uA}HAVE_GETPT${ac_uB}HAVE_GETPT${ac_uC}1${ac_uD}
+${ac_eA}HAVE_GETPT${ac_eB}HAVE_GETPT${ac_eC}1${ac_eD}
+CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+
+  cat > conftest.frag <<CEOF
+${ac_dA}PTYS_ARE_GETPT${ac_dB}PTYS_ARE_GETPT${ac_dC}1${ac_dD}
+${ac_uA}PTYS_ARE_GETPT${ac_uB}PTYS_ARE_GETPT${ac_uC}1${ac_uD}
+${ac_eA}PTYS_ARE_GETPT${ac_eB}PTYS_ARE_GETPT${ac_eC}1${ac_eD}
+${ac_dA}PTYS_ARE_SEARCHED${ac_dB}PTYS_ARE_SEARCHED${ac_dC}1${ac_dD}
+${ac_uA}PTYS_ARE_SEARCHED${ac_uB}PTYS_ARE_SEARCHED${ac_uC}1${ac_uD}
+${ac_eA}PTYS_ARE_SEARCHED${ac_eB}PTYS_ARE_SEARCHED${ac_eC}1${ac_eD}
+s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
+CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+
+  rm -f conftest.frag conftest.h
+  echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
+  cat conftest.in >> conftest.h
+  rm -f conftest.in
+  if cmp -s $ac_file conftest.h 2>/dev/null; then
+    echo "$ac_file is unchanged"
+    rm -f conftest.h
+  else
+    # Remove last slash and all that follows it.  Not all systems have dirname.
+      ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+      if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+      # The file is in a subdirectory.
+      test ! -d "$ac_dir" && mkdir "$ac_dir"
+    fi
+    rm -f $ac_file
+    mv conftest.h $ac_file
+  fi
+fi; done
+
+
+
+exit 0
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/configure work/main.d/rxvt-2.6.4/configure
--- tmp/rxvt-2.6.4/configure	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/configure	2000-07-20 22:31:11.000000000 -0300
@@ -0,0 +1,5330 @@
+#! /bin/sh
+
+# Guess values for system-dependent variables and create Makefiles.
+# Generated automatically using autoconf version 2.13 
+# Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+
+# Defaults:
+ac_help=
+ac_default_prefix=/usr/local
+# Any additions from configure.in:
+ac_help="$ac_help
+  --enable-utmp           enable utmp/utmpx support"
+ac_help="$ac_help
+  --enable-wtmp           enable wtmp support if you have utmp/utmpx support"
+ac_help="$ac_help
+  --enable-xpm-background enable XPM background pixmaps"
+ac_help="$ac_help
+  --enable-transparency   enable transparent backgrounds"
+ac_help="$ac_help
+  --enable-menubar        enable Menubar"
+ac_help="$ac_help
+  --enable-graphics       enable rxvt own graphics mode (see src/graphics)"
+ac_help="$ac_help
+  --enable-next-scroll    enable NeXT style scrollbar"
+ac_help="$ac_help
+  --enable-xterm-scroll   revert to Xterm style scrollbar"
+ac_help="$ac_help
+  --enable-half-shadow    use half width/height shadows on non-Xterm scrollbar"
+ac_help="$ac_help
+  --enable-xim            XIM (X Input Method) protocol support"
+ac_help="$ac_help
+  --enable-kanji          enable kanji support"
+ac_help="$ac_help
+  --enable-big5           enable big5 support"
+ac_help="$ac_help
+  --enable-gb             enable gb support"
+ac_help="$ac_help
+  --enable-greek          enable greek keyboard support"
+ac_help="$ac_help
+  --enable-ttygid         enable tty setting to group \"tty\" - use only if
+                          your system uses this type of security"
+ac_help="$ac_help
+  --disable-backspace-key disable handling of the backspace key"
+ac_help="$ac_help
+  --disable-delete-key    disable handling of the delete key"
+ac_help="$ac_help
+  --disable-resources     disable all resource checking"
+ac_help="$ac_help
+  --enable-xgetdefault    enable resources via X instead of our small version"
+ac_help="$ac_help
+  --disable-memset        disable memset() function, use your system's instead"
+ac_help="$ac_help
+  --disable-swapscreen    disable swap screen support"
+ac_help="$ac_help
+  --disable-keepscrolling disable continual scrolling on scrollbar arrow press"
+ac_help="$ac_help
+  --disable-mousewheel    disable scrolling via mouse wheel or buttons 4 & 5"
+ac_help="$ac_help
+  --disable-old-selection disable v2.20 (and prior) mouse selection style support"
+ac_help="$ac_help
+  --disable-new-selection disable new mouse selection style (like xterm) support"
+ac_help="$ac_help
+  --enable-dmalloc        enable Gray Watson's malloc - for debugging use"
+ac_help="$ac_help
+  --enable-dlmalloc       enable Doug Lea's malloc - for production use
+                          - enable only one malloc package"
+ac_help="$ac_help
+  --with-term=NAME        set the terminal to NAME (default \"xterm\")"
+ac_help="$ac_help
+  --with-terminfo=PATH    set the path to the terminfo tree to PATH"
+ac_help="$ac_help
+  --with-x                use the X Window System"
+ac_help="$ac_help
+  --with-xpm-includes=DIR use XPM includes in DIR"
+ac_help="$ac_help
+  --with-xpm-library=DIR  use XPM library in DIR"
+ac_help="$ac_help
+  --with-xpm              use XPM"
+
+# Initialize some variables set by options.
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+build=NONE
+cache_file=./config.cache
+exec_prefix=NONE
+host=NONE
+no_create=
+nonopt=NONE
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+target=NONE
+verbose=
+x_includes=NONE
+x_libraries=NONE
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+# Initialize some other variables.
+subdirs=
+MFLAGS= MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+# Maximum number of lines to put in a shell here document.
+ac_max_here_lines=12
+
+ac_prev=
+for ac_option
+do
+
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  case "$ac_option" in
+  -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) ac_optarg= ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case "$ac_option" in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir="$ac_optarg" ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build="$ac_optarg" ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file="$ac_optarg" ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir="$ac_optarg" ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    eval "enable_${ac_feature}=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_${ac_feature}='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix="$ac_optarg" ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he)
+    # Omit some internal or obsolete options to make the list less imposing.
+    # This message is too long to be a string in the A/UX 3.1 sh.
+    cat << EOF
+Usage: configure [options] [host]
+Options: [defaults in brackets after descriptions]
+Configuration:
+  --cache-file=FILE       cache test results in FILE
+  --help                  print this message
+  --no-create             do not create output files
+  --quiet, --silent       do not print \`checking...' messages
+  --version               print the version of autoconf that created configure
+Directory and file names:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [same as prefix]
+  --bindir=DIR            user executables in DIR [EPREFIX/bin]
+  --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
+  --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
+  --datadir=DIR           read-only architecture-independent data in DIR
+                          [PREFIX/share]
+  --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data in DIR
+                          [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
+  --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
+  --includedir=DIR        C header files in DIR [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
+  --infodir=DIR           info documentation in DIR [PREFIX/info]
+  --mandir=DIR            man documentation in DIR [PREFIX/man]
+  --srcdir=DIR            find the sources in DIR [configure dir or ..]
+  --program-prefix=PREFIX prepend PREFIX to installed program names
+  --program-suffix=SUFFIX append SUFFIX to installed program names
+  --program-transform-name=PROGRAM
+                          run sed PROGRAM on installed program names
+EOF
+    cat << EOF
+Host type:
+  --build=BUILD           configure for building on BUILD [BUILD=HOST]
+  --host=HOST             configure for HOST [guessed]
+  --target=TARGET         configure for TARGET [TARGET=HOST]
+Features and packages:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --x-includes=DIR        X include files are in DIR
+  --x-libraries=DIR       X library files are in DIR
+EOF
+    if test -n "$ac_help"; then
+      echo "--enable and --with options recognized:$ac_help"
+    fi
+    exit 0 ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host="$ac_optarg" ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir="$ac_optarg" ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir="$ac_optarg" ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir="$ac_optarg" ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir="$ac_optarg" ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir="$ac_optarg" ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir="$ac_optarg" ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir="$ac_optarg" ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix="$ac_optarg" ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix="$ac_optarg" ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix="$ac_optarg" ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name="$ac_optarg" ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir="$ac_optarg" ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir="$ac_optarg" ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site="$ac_optarg" ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir="$ac_optarg" ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir="$ac_optarg" ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target="$ac_optarg" ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers)
+    echo "configure generated by autoconf version 2.13"
+    exit 0 ;;
+
+  -with-* | --with-*)
+    ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_${ac_package}='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`echo $ac_option|sed -e 's/-*without-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    eval "with_${ac_package}=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes="$ac_optarg" ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries="$ac_optarg" ;;
+
+  -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
+    ;;
+
+  *)
+    if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
+      echo "configure: warning: $ac_option: invalid host type" 1>&2
+    fi
+    if test "x$nonopt" != xNONE; then
+      { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
+    fi
+    nonopt="$ac_option"
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
+fi
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+# File descriptor usage:
+# 0 standard input
+# 1 file creation
+# 2 errors and warnings
+# 3 some systems may open it to /dev/tty
+# 4 used on the Kubota Titan
+# 6 checking for... messages and results
+# 5 compiler messages saved in config.log
+if test "$silent" = yes; then
+  exec 6>/dev/null
+else
+  exec 6>&1
+fi
+exec 5>./config.log
+
+echo "\
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+" 1>&5
+
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Also quote any args containing shell metacharacters.
+ac_configure_args=
+for ac_arg
+do
+  case "$ac_arg" in
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c) ;;
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
+  *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
+  ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+  *) ac_configure_args="$ac_configure_args $ac_arg" ;;
+  esac
+done
+
+# NLS nuisances.
+# Only set these to C if already set.  These must not be set unconditionally
+# because not all systems understand e.g. LANG=C (notably SCO).
+# Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
+# Non-C LC_CTYPE values break the ctype check.
+if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
+if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
+if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
+if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo > confdefs.h
+
+# A filename unique to this package, relative to the directory that
+# configure is in, which we can look for to find out if srcdir is correct.
+ac_unique_file=src/feature.h
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_prog=$0
+  ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
+  test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
+  else
+    { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
+  fi
+fi
+srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
+
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    echo "loading site script $ac_site_file"
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  echo "loading cache $cache_file"
+  . $cache_file
+else
+  echo "creating cache $cache_file"
+  > $cache_file
+fi
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+ac_exeext=
+ac_objext=o
+if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
+  # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
+  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
+    ac_n= ac_c='
+' ac_t='	'
+  else
+    ac_n=-n ac_c= ac_t=
+  fi
+else
+  ac_n= ac_c='\c' ac_t=
+fi
+
+
+ac_aux_dir=
+for ac_dir in autoconf $srcdir/autoconf; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { echo "configure: error: can not find install-sh or install.sh in autoconf $srcdir/autoconf" 1>&2; exit 1; }
+fi
+ac_config_guess=$ac_aux_dir/config.guess
+ac_config_sub=$ac_aux_dir/config.sub
+ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
+
+
+
+VERSION=`sed -n -e 's/^.*VERSION.*"\(.*\)"$/\1/p' ${srcdir}/src/version.h`
+DATE=`sed -n -e 's/^.* \t*DATE.*"\(.*\)"$/\1/p' ${srcdir}/src/version.h`
+LSMDATE=`sed -n -e 's/^.*LSMDATE.*"\(.*\)"$/\1/p' ${srcdir}/src/version.h`
+echo "configuring for rxvt $VERSION"
+
+MALLOC_TYPE=S
+
+# Check whether --enable-utmp or --disable-utmp was given.
+if test "${enable_utmp+set}" = set; then
+  enableval="$enable_utmp"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define UTMP_SUPPORT 1
+EOF
+ utmp_support=yes
+  fi
+fi
+
+
+# Check whether --enable-wtmp or --disable-wtmp was given.
+if test "${enable_wtmp+set}" = set; then
+  enableval="$enable_wtmp"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define WTMP_SUPPORT 1
+EOF
+ wtmp_support=yes
+  fi
+fi
+
+
+# Check whether --enable-xpm-background or --disable-xpm-background was given.
+if test "${enable_xpm_background+set}" = set; then
+  enableval="$enable_xpm_background"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define XPM_BACKGROUND 1
+EOF
+ xpm_background=yes
+  fi
+fi
+
+
+# Check whether --enable-transparency or --disable-transparency was given.
+if test "${enable_transparency+set}" = set; then
+  enableval="$enable_transparency"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define TRANSPARENT 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-menubar or --disable-menubar was given.
+if test "${enable_menubar+set}" = set; then
+  enableval="$enable_menubar"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define MENUBAR 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-graphics or --disable-graphics was given.
+if test "${enable_graphics+set}" = set; then
+  enableval="$enable_graphics"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define RXVT_GRAPHICS 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-next-scroll or --disable-next-scroll was given.
+if test "${enable_next_scroll+set}" = set; then
+  enableval="$enable_next_scroll"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define NEXT_SCROLLBAR 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-xterm-scroll or --disable-xterm-scroll was given.
+if test "${enable_xterm_scroll+set}" = set; then
+  enableval="$enable_xterm_scroll"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define XTERM_SCROLLBAR 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-half-shadow or --disable-half-shadow was given.
+if test "${enable_half_shadow+set}" = set; then
+  enableval="$enable_half_shadow"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define HALFSHADOW 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-xim or --disable-xim was given.
+if test "${enable_xim+set}" = set; then
+  enableval="$enable_xim"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define USE_XIM 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-kanji or --disable-kanji was given.
+if test "${enable_kanji+set}" = set; then
+  enableval="$enable_kanji"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define KANJI 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-big5 or --disable-big5 was given.
+if test "${enable_big5+set}" = set; then
+  enableval="$enable_big5"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define ZH 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-gb or --disable-gb was given.
+if test "${enable_gb+set}" = set; then
+  enableval="$enable_gb"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define ZHCN 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-greek or --disable-greek was given.
+if test "${enable_greek+set}" = set; then
+  enableval="$enable_greek"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define GREEK_SUPPORT 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-ttygid or --disable-ttygid was given.
+if test "${enable_ttygid+set}" = set; then
+  enableval="$enable_ttygid"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define TTY_GID_SUPPORT 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-backspace-key or --disable-backspace-key was given.
+if test "${enable_backspace_key+set}" = set; then
+  enableval="$enable_backspace_key"
+  if test x$enableval = xno; then
+    cat >> confdefs.h <<\EOF
+#define NO_BACKSPACE_KEY 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-delete-key or --disable-delete-key was given.
+if test "${enable_delete_key+set}" = set; then
+  enableval="$enable_delete_key"
+  if test x$enableval = xno; then
+    cat >> confdefs.h <<\EOF
+#define NO_DELETE_KEY 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-resources or --disable-resources was given.
+if test "${enable_resources+set}" = set; then
+  enableval="$enable_resources"
+  if test x$enableval = xno; then
+    cat >> confdefs.h <<\EOF
+#define NO_RESOURCES 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-xgetdefault or --disable-xgetdefault was given.
+if test "${enable_xgetdefault+set}" = set; then
+  enableval="$enable_xgetdefault"
+  if test x$enableval = xyes; then
+    cat >> confdefs.h <<\EOF
+#define USE_XGETDEFAULT 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-memset or --disable-memset was given.
+if test "${enable_memset+set}" = set; then
+  enableval="$enable_memset"
+  if test x$enableval = xno; then
+    cat >> confdefs.h <<\EOF
+#define NO_RMEMSET 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-swapscreen or --disable-swapscreen was given.
+if test "${enable_swapscreen+set}" = set; then
+  enableval="$enable_swapscreen"
+  if test x$enableval = xno; then
+    cat >> confdefs.h <<\EOF
+#define NO_SECONDARY_SCREEN 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-keepscrolling or --disable-keepscrolling was given.
+if test "${enable_keepscrolling+set}" = set; then
+  enableval="$enable_keepscrolling"
+  if test x$enableval = xno; then
+    cat >> confdefs.h <<\EOF
+#define NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-mousewheel or --disable-mousewheel was given.
+if test "${enable_mousewheel+set}" = set; then
+  enableval="$enable_mousewheel"
+  if test x$enableval = xno; then
+    cat >> confdefs.h <<\EOF
+#define NO_MOUSE_WHEEL 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-old-selection or --disable-old-selection was given.
+if test "${enable_old_selection+set}" = set; then
+  enableval="$enable_old_selection"
+  if test x$enableval = xno; then
+    cat >> confdefs.h <<\EOF
+#define NO_OLD_SELECTION 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-new-selection or --disable-new-selection was given.
+if test "${enable_new_selection+set}" = set; then
+  enableval="$enable_new_selection"
+  if test x$enableval = xno; then
+    cat >> confdefs.h <<\EOF
+#define NO_NEW_SELECTION 1
+EOF
+
+  fi
+fi
+
+
+# Check whether --enable-dmalloc or --disable-dmalloc was given.
+if test "${enable_dmalloc+set}" = set; then
+  enableval="$enable_dmalloc"
+  if test x$enableval = xyes; then
+    MALLOC_TYPE=G
+    DEBUG=-DDEBUG_MALLOC
+    DLIB="-L/usr/local/lib -ldmalloc"
+    DINCLUDE=-I/usr/local/include
+  fi
+fi
+
+
+# Check whether --enable-dlmalloc or --disable-dlmalloc was given.
+if test "${enable_dlmalloc+set}" = set; then
+  enableval="$enable_dlmalloc"
+  if test x$enableval = xyes; then
+    MALLOC_TYPE=D
+    DEBUG=
+    DLIB="-L/usr/local/lib -ldlmalloc"
+    DINCLUDE=
+  fi
+fi
+
+
+# Check whether --with-term or --without-term was given.
+if test "${with_term+set}" = set; then
+  withval="$with_term"
+  if test x$withval != x; then
+    cat >> confdefs.h <<EOF
+#define TERMENV "$withval"
+EOF
+ term="$withval"
+  fi
+fi
+
+
+# Check whether --with-terminfo or --without-terminfo was given.
+if test "${with_terminfo+set}" = set; then
+  withval="$with_terminfo"
+  if test x$withval != x; then
+    cat >> confdefs.h <<EOF
+#define RXVT_TERMINFO "$withval"
+EOF
+ terminfo="$withval"
+  fi
+fi
+
+
+
+cat >> confdefs.h <<\EOF
+#define PROTOTYPES 1
+EOF
+
+
+if test -z "$CFLAGS"; then
+    if test -z "$CCOPTS"; then
+	CCOPTS='-O'
+    fi
+    CFLAGS="$CCOPTS"
+fi
+
+
+# Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:986: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_CC="gcc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1016: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_prog_rejected=no
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
+        ac_prog_rejected=yes
+	continue
+      fi
+      ac_cv_prog_CC="cc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# -gt 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    set dummy "$ac_dir/$ac_word" "$@"
+    shift
+    ac_cv_prog_CC="$@"
+  fi
+fi
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+  if test -z "$CC"; then
+    case "`uname -s`" in
+    *win32* | *WIN32*)
+      # Extract the first word of "cl", so it can be a program name with args.
+set dummy cl; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1067: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_CC="cl"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+ ;;
+    esac
+  fi
+  test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
+echo "configure:1099: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+cat > conftest.$ac_ext << EOF
+
+#line 1110 "configure"
+#include "confdefs.h"
+
+main(){return(0);}
+EOF
+if { (eval echo configure:1115: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  ac_cv_prog_cc_works=yes
+  # If we can't run a trivial program, we are probably using a cross compiler.
+  if (./conftest; exit) 2>/dev/null; then
+    ac_cv_prog_cc_cross=no
+  else
+    ac_cv_prog_cc_cross=yes
+  fi
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  ac_cv_prog_cc_works=no
+fi
+rm -fr conftest*
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
+if test $ac_cv_prog_cc_works = no; then
+  { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
+fi
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
+echo "configure:1141: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
+cross_compiling=$ac_cv_prog_cc_cross
+
+echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
+echo "configure:1146: checking whether we are using GNU C" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.c <<EOF
+#ifdef __GNUC__
+  yes;
+#endif
+EOF
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1155: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+  ac_cv_prog_gcc=yes
+else
+  ac_cv_prog_gcc=no
+fi
+fi
+
+echo "$ac_t""$ac_cv_prog_gcc" 1>&6
+
+if test $ac_cv_prog_gcc = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+
+ac_test_CFLAGS="${CFLAGS+set}"
+ac_save_CFLAGS="$CFLAGS"
+CFLAGS=
+echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
+echo "configure:1174: checking whether ${CC-cc} accepts -g" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  echo 'void f(){}' > conftest.c
+if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
+  ac_cv_prog_cc_g=yes
+else
+  ac_cv_prog_cc_g=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$ac_cv_prog_cc_g" 1>&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS="$ac_save_CFLAGS"
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+
+echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
+echo "configure:1206: checking how to run the C preprocessor" >&5
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    # This must be in double quotes, not single quotes, because CPP may get
+  # substituted into the Makefile and "${CC-cc}" will confuse make.
+  CPP="${CC-cc} -E"
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp.
+  cat > conftest.$ac_ext <<EOF
+#line 1221 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1227: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP="${CC-cc} -E -traditional-cpp"
+  cat > conftest.$ac_ext <<EOF
+#line 1238 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1244: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP="${CC-cc} -nologo -E"
+  cat > conftest.$ac_ext <<EOF
+#line 1255 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1261: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP=/lib/cpp
+fi
+rm -f conftest*
+fi
+rm -f conftest*
+fi
+rm -f conftest*
+  ac_cv_prog_CPP="$CPP"
+fi
+  CPP="$ac_cv_prog_CPP"
+else
+  ac_cv_prog_CPP="$CPP"
+fi
+echo "$ac_t""$CPP" 1>&6
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# ./install, which can be erroneously created by make from ./install.sh.
+echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
+echo "configure:1297: checking for a BSD compatible install" >&5
+if test -z "$INSTALL"; then
+if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS=":"
+  for ac_dir in $PATH; do
+    # Account for people who put trailing slashes in PATH elements.
+    case "$ac_dir/" in
+    /|./|.//|/etc/*|/usr/sbin/*|/usr/etc/*|/sbin/*|/usr/afsws/bin/*|/usr/ucb/*) ;;
+    *)
+      # OSF1 and SCO ODT 3.0 have their own names for install.
+      # Don't use installbsd from OSF since it installs stuff as root
+      # by default.
+      for ac_prog in ginstall scoinst install; do
+        if test -f $ac_dir/$ac_prog; then
+	  if test $ac_prog = install &&
+            grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  else
+	    ac_cv_path_install="$ac_dir/$ac_prog -c"
+	    break 2
+	  fi
+	fi
+      done
+      ;;
+    esac
+  done
+  IFS="$ac_save_IFS"
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL="$ac_cv_path_install"
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL="$ac_install_sh"
+  fi
+fi
+echo "$ac_t""$INSTALL" 1>&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+# Extract the first word of "mv", so it can be a program name with args.
+set dummy mv; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1353: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_MV'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$MV" in
+  /*)
+  ac_cv_path_MV="$MV" # Let the user override the test with a path.
+  ;;
+  ?:/*)			 
+  ac_cv_path_MV="$MV" # Let the user override the test with a dos path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do 
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_MV="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_MV" && ac_cv_path_MV="mv"
+  ;;
+esac
+fi
+MV="$ac_cv_path_MV"
+if test -n "$MV"; then
+  echo "$ac_t""$MV" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+# Extract the first word of "rm", so it can be a program name with args.
+set dummy rm; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1389: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_RM'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$RM" in
+  /*)
+  ac_cv_path_RM="$RM" # Let the user override the test with a path.
+  ;;
+  ?:/*)			 
+  ac_cv_path_RM="$RM" # Let the user override the test with a dos path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do 
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_RM="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_RM" && ac_cv_path_RM="rm"
+  ;;
+esac
+fi
+RM="$ac_cv_path_RM"
+if test -n "$RM"; then
+  echo "$ac_t""$RM" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+# Extract the first word of "cp", so it can be a program name with args.
+set dummy cp; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1425: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_CP'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$CP" in
+  /*)
+  ac_cv_path_CP="$CP" # Let the user override the test with a path.
+  ;;
+  ?:/*)			 
+  ac_cv_path_CP="$CP" # Let the user override the test with a dos path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do 
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_CP="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_CP" && ac_cv_path_CP="cp"
+  ;;
+esac
+fi
+CP="$ac_cv_path_CP"
+if test -n "$CP"; then
+  echo "$ac_t""$CP" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+# Extract the first word of "sed", so it can be a program name with args.
+set dummy sed; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1461: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_SED'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$SED" in
+  /*)
+  ac_cv_path_SED="$SED" # Let the user override the test with a path.
+  ;;
+  ?:/*)			 
+  ac_cv_path_SED="$SED" # Let the user override the test with a dos path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do 
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_SED="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_SED" && ac_cv_path_SED="sed"
+  ;;
+esac
+fi
+SED="$ac_cv_path_SED"
+if test -n "$SED"; then
+  echo "$ac_t""$SED" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+# Extract the first word of "awk", so it can be a program name with args.
+set dummy awk; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1497: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_AWK'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$AWK" in
+  /*)
+  ac_cv_path_AWK="$AWK" # Let the user override the test with a path.
+  ;;
+  ?:/*)			 
+  ac_cv_path_AWK="$AWK" # Let the user override the test with a dos path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do 
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_AWK="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_AWK" && ac_cv_path_AWK="awk"
+  ;;
+esac
+fi
+AWK="$ac_cv_path_AWK"
+if test -n "$AWK"; then
+  echo "$ac_t""$AWK" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+# Extract the first word of "echo", so it can be a program name with args.
+set dummy echo; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1533: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_ECHO'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$ECHO" in
+  /*)
+  ac_cv_path_ECHO="$ECHO" # Let the user override the test with a path.
+  ;;
+  ?:/*)			 
+  ac_cv_path_ECHO="$ECHO" # Let the user override the test with a dos path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do 
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_ECHO="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_ECHO" && ac_cv_path_ECHO="echo"
+  ;;
+esac
+fi
+ECHO="$ac_cv_path_ECHO"
+if test -n "$ECHO"; then
+  echo "$ac_t""$ECHO" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+# Extract the first word of "cmp", so it can be a program name with args.
+set dummy cmp; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1569: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_CMP'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$CMP" in
+  /*)
+  ac_cv_path_CMP="$CMP" # Let the user override the test with a path.
+  ;;
+  ?:/*)			 
+  ac_cv_path_CMP="$CMP" # Let the user override the test with a dos path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do 
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_CMP="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_CMP" && ac_cv_path_CMP="cmp"
+  ;;
+esac
+fi
+CMP="$ac_cv_path_CMP"
+if test -n "$CMP"; then
+  echo "$ac_t""$CMP" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+# Extract the first word of "tbl", so it can be a program name with args.
+set dummy tbl; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1605: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_TBL'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$TBL" in
+  /*)
+  ac_cv_path_TBL="$TBL" # Let the user override the test with a path.
+  ;;
+  ?:/*)			 
+  ac_cv_path_TBL="$TBL" # Let the user override the test with a dos path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do 
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_TBL="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  ;;
+esac
+fi
+TBL="$ac_cv_path_TBL"
+if test -n "$TBL"; then
+  echo "$ac_t""$TBL" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+
+echo $ac_n "checking for AIX""... $ac_c" 1>&6
+echo "configure:1639: checking for AIX" >&5
+cat > conftest.$ac_ext <<EOF
+#line 1641 "configure"
+#include "confdefs.h"
+#ifdef _AIX
+  yes
+#endif
+
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "yes" >/dev/null 2>&1; then
+  rm -rf conftest*
+  echo "$ac_t""yes" 1>&6; cat >> confdefs.h <<\EOF
+#define _ALL_SOURCE 1
+EOF
+
+else
+  rm -rf conftest*
+  echo "$ac_t""no" 1>&6
+fi
+rm -f conftest*
+
+
+echo $ac_n "checking for POSIXized ISC""... $ac_c" 1>&6
+echo "configure:1663: checking for POSIXized ISC" >&5
+if test -d /etc/conf/kconfig.d &&
+  grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
+then
+  echo "$ac_t""yes" 1>&6
+  ISC=yes # If later tests want to check for ISC.
+  cat >> confdefs.h <<\EOF
+#define _POSIX_SOURCE 1
+EOF
+
+  if test "$GCC" = yes; then
+    CC="$CC -posix"
+  else
+    CC="$CC -Xp"
+  fi
+else
+  echo "$ac_t""no" 1>&6
+  ISC=
+fi
+
+
+
+
+# If we find X, set shell vars x_includes and x_libraries to the
+# paths, otherwise set no_x=yes.
+# Uses ac_ vars as temps to allow command line to override cache and checks.
+# --without-x overrides everything else, but does not touch the cache.
+echo $ac_n "checking for X""... $ac_c" 1>&6
+echo "configure:1691: checking for X" >&5
+
+# Check whether --with-x or --without-x was given.
+if test "${with_x+set}" = set; then
+  withval="$with_x"
+  :
+fi
+
+# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
+if test "x$with_x" = xno; then
+  # The user explicitly disabled X.
+  have_x=disabled
+else
+  if test "x$x_includes" != xNONE && test "x$x_libraries" != xNONE; then
+    # Both variables are already set.
+    have_x=yes
+  else
+if eval "test \"`echo '$''{'ac_cv_have_x'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  # One or both of the vars are not set, and there is no cached value.
+ac_x_includes=NO ac_x_libraries=NO
+rm -fr conftestdir
+if mkdir conftestdir; then
+  cd conftestdir
+  # Make sure to not put "make" in the Imakefile rules, since we grep it out.
+  cat > Imakefile <<'EOF'
+acfindx:
+	@echo 'ac_im_incroot="${INCROOT}"; ac_im_usrlibdir="${USRLIBDIR}"; ac_im_libdir="${LIBDIR}"'
+EOF
+  if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then
+    # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+    eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`
+    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
+    for ac_extension in a so sl; do
+      if test ! -f $ac_im_usrlibdir/libX11.$ac_extension &&
+        test -f $ac_im_libdir/libX11.$ac_extension; then
+        ac_im_usrlibdir=$ac_im_libdir; break
+      fi
+    done
+    # Screen out bogus values from the imake configuration.  They are
+    # bogus both because they are the default anyway, and because
+    # using them would break gcc on systems where it needs fixed includes.
+    case "$ac_im_incroot" in
+	/usr/include) ;;
+	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes="$ac_im_incroot" ;;
+    esac
+    case "$ac_im_usrlibdir" in
+	/usr/lib | /lib) ;;
+	*) test -d "$ac_im_usrlibdir" && ac_x_libraries="$ac_im_usrlibdir" ;;
+    esac
+  fi
+  cd ..
+  rm -fr conftestdir
+fi
+
+if test "$ac_x_includes" = NO; then
+  # Guess where to find include files, by looking for this one X11 .h file.
+  test -z "$x_direct_test_include" && x_direct_test_include=X11/Intrinsic.h
+
+  # First, try using that file with no special directory specified.
+cat > conftest.$ac_ext <<EOF
+#line 1753 "configure"
+#include "confdefs.h"
+#include <$x_direct_test_include>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1758: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  # We can compile using X headers with no special include directory.
+ac_x_includes=
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  # Look for the header file in a standard set of common directories.
+# Check X11 before X11Rn because it is often a symlink to the current release.
+  for ac_dir in               \
+    /usr/X11/include          \
+    /usr/X11R6/include        \
+    /usr/X11R5/include        \
+    /usr/X11R4/include        \
+                              \
+    /usr/include/X11          \
+    /usr/include/X11R6        \
+    /usr/include/X11R5        \
+    /usr/include/X11R4        \
+                              \
+    /usr/local/X11/include    \
+    /usr/local/X11R6/include  \
+    /usr/local/X11R5/include  \
+    /usr/local/X11R4/include  \
+                              \
+    /usr/local/include/X11    \
+    /usr/local/include/X11R6  \
+    /usr/local/include/X11R5  \
+    /usr/local/include/X11R4  \
+                              \
+    /usr/X386/include         \
+    /usr/x386/include         \
+    /usr/XFree86/include/X11  \
+                              \
+    /usr/include              \
+    /usr/local/include        \
+    /usr/unsupported/include  \
+    /usr/athena/include       \
+    /usr/local/x11r5/include  \
+    /usr/lpp/Xamples/include  \
+                              \
+    /usr/openwin/include      \
+    /usr/openwin/share/include \
+    ; \
+  do
+    if test -r "$ac_dir/$x_direct_test_include"; then
+      ac_x_includes=$ac_dir
+      break
+    fi
+  done
+fi
+rm -f conftest*
+fi # $ac_x_includes = NO
+
+if test "$ac_x_libraries" = NO; then
+  # Check for the libraries.
+
+  test -z "$x_direct_test_library" && x_direct_test_library=Xt
+  test -z "$x_direct_test_function" && x_direct_test_function=XtMalloc
+
+  # See if we find them without any special options.
+  # Don't add to $LIBS permanently.
+  ac_save_LIBS="$LIBS"
+  LIBS="-l$x_direct_test_library $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1827 "configure"
+#include "confdefs.h"
+
+int main() {
+${x_direct_test_function}()
+; return 0; }
+EOF
+if { (eval echo configure:1834: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  LIBS="$ac_save_LIBS"
+# We can link X programs with no special library path.
+ac_x_libraries=
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  LIBS="$ac_save_LIBS"
+# First see if replacing the include by lib works.
+# Check X11 before X11Rn because it is often a symlink to the current release.
+for ac_dir in `echo "$ac_x_includes" | sed s/include/lib/` \
+    /usr/X11/lib          \
+    /usr/X11R6/lib        \
+    /usr/X11R5/lib        \
+    /usr/X11R4/lib        \
+                          \
+    /usr/lib/X11          \
+    /usr/lib/X11R6        \
+    /usr/lib/X11R5        \
+    /usr/lib/X11R4        \
+                          \
+    /usr/local/X11/lib    \
+    /usr/local/X11R6/lib  \
+    /usr/local/X11R5/lib  \
+    /usr/local/X11R4/lib  \
+                          \
+    /usr/local/lib/X11    \
+    /usr/local/lib/X11R6  \
+    /usr/local/lib/X11R5  \
+    /usr/local/lib/X11R4  \
+                          \
+    /usr/X386/lib         \
+    /usr/x386/lib         \
+    /usr/XFree86/lib/X11  \
+                          \
+    /usr/lib              \
+    /usr/local/lib        \
+    /usr/unsupported/lib  \
+    /usr/athena/lib       \
+    /usr/local/x11r5/lib  \
+    /usr/lpp/Xamples/lib  \
+    /lib/usr/lib/X11	  \
+                          \
+    /usr/openwin/lib      \
+    /usr/openwin/share/lib \
+    ; \
+do
+  for ac_extension in a so sl; do
+    if test -r $ac_dir/lib${x_direct_test_library}.$ac_extension; then
+      ac_x_libraries=$ac_dir
+      break 2
+    fi
+  done
+done
+fi
+rm -f conftest*
+fi # $ac_x_libraries = NO
+
+if test "$ac_x_includes" = NO || test "$ac_x_libraries" = NO; then
+  # Didn't find X anywhere.  Cache the known absence of X.
+  ac_cv_have_x="have_x=no"
+else
+  # Record where we found X for the cache.
+  ac_cv_have_x="have_x=yes \
+	        ac_x_includes=$ac_x_includes ac_x_libraries=$ac_x_libraries"
+fi
+fi
+  fi
+  eval "$ac_cv_have_x"
+fi # $with_x != no
+
+if test "$have_x" != yes; then
+  echo "$ac_t""$have_x" 1>&6
+  no_x=yes
+else
+  # If each of the values was on the command line, it overrides each guess.
+  test "x$x_includes" = xNONE && x_includes=$ac_x_includes
+  test "x$x_libraries" = xNONE && x_libraries=$ac_x_libraries
+  # Update the cache value to reflect the command line values.
+  ac_cv_have_x="have_x=yes \
+		ac_x_includes=$x_includes ac_x_libraries=$x_libraries"
+  echo "$ac_t""libraries $x_libraries, headers $x_includes" 1>&6
+fi
+
+if test "$no_x" = yes; then
+  # Not all programs may use this symbol, but it does not hurt to define it.
+  cat >> confdefs.h <<\EOF
+#define X_DISPLAY_MISSING 1
+EOF
+
+  X_CFLAGS= X_PRE_LIBS= X_LIBS= X_EXTRA_LIBS=
+else
+  if test -n "$x_includes"; then
+    X_CFLAGS="$X_CFLAGS -I$x_includes"
+  fi
+
+  # It would also be nice to do this for all -L options, not just this one.
+  if test -n "$x_libraries"; then
+    X_LIBS="$X_LIBS -L$x_libraries"
+    # For Solaris; some versions of Sun CC require a space after -R and
+    # others require no space.  Words are not sufficient . . . .
+    case "`(uname -sr) 2>/dev/null`" in
+    "SunOS 5"*)
+      echo $ac_n "checking whether -R must be followed by a space""... $ac_c" 1>&6
+echo "configure:1940: checking whether -R must be followed by a space" >&5
+      ac_xsave_LIBS="$LIBS"; LIBS="$LIBS -R$x_libraries"
+      cat > conftest.$ac_ext <<EOF
+#line 1943 "configure"
+#include "confdefs.h"
+
+int main() {
+
+; return 0; }
+EOF
+if { (eval echo configure:1950: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  ac_R_nospace=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_R_nospace=no
+fi
+rm -f conftest*
+      if test $ac_R_nospace = yes; then
+	echo "$ac_t""no" 1>&6
+	X_LIBS="$X_LIBS -R$x_libraries"
+      else
+	LIBS="$ac_xsave_LIBS -R $x_libraries"
+	cat > conftest.$ac_ext <<EOF
+#line 1966 "configure"
+#include "confdefs.h"
+
+int main() {
+
+; return 0; }
+EOF
+if { (eval echo configure:1973: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  ac_R_space=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_R_space=no
+fi
+rm -f conftest*
+	if test $ac_R_space = yes; then
+	  echo "$ac_t""yes" 1>&6
+	  X_LIBS="$X_LIBS -R $x_libraries"
+	else
+	  echo "$ac_t""neither works" 1>&6
+	fi
+      fi
+      LIBS="$ac_xsave_LIBS"
+    esac
+  fi
+
+  # Check for system-dependent libraries X programs must link with.
+  # Do this before checking for the system-independent R6 libraries
+  # (-lICE), since we may need -lsocket or whatever for X linking.
+
+  if test "$ISC" = yes; then
+    X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl_s -linet"
+  else
+    # Martyn.Johnson@cl.cam.ac.uk says this is needed for Ultrix, if the X
+    # libraries were built with DECnet support.  And karl@cs.umb.edu says
+    # the Alpha needs dnet_stub (dnet does not exist).
+    echo $ac_n "checking for dnet_ntoa in -ldnet""... $ac_c" 1>&6
+echo "configure:2005: checking for dnet_ntoa in -ldnet" >&5
+ac_lib_var=`echo dnet'_'dnet_ntoa | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-ldnet  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2013 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char dnet_ntoa();
+
+int main() {
+dnet_ntoa()
+; return 0; }
+EOF
+if { (eval echo configure:2024: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+    if test $ac_cv_lib_dnet_dnet_ntoa = no; then
+      echo $ac_n "checking for dnet_ntoa in -ldnet_stub""... $ac_c" 1>&6
+echo "configure:2046: checking for dnet_ntoa in -ldnet_stub" >&5
+ac_lib_var=`echo dnet_stub'_'dnet_ntoa | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-ldnet_stub  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2054 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char dnet_ntoa();
+
+int main() {
+dnet_ntoa()
+; return 0; }
+EOF
+if { (eval echo configure:2065: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet_stub"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+    fi
+
+    # msh@cis.ufl.edu says -lnsl (and -lsocket) are needed for his 386/AT,
+    # to get the SysV transport functions.
+    # chad@anasazi.com says the Pyramis MIS-ES running DC/OSx (SVR4)
+    # needs -lnsl.
+    # The nsl library prevents programs from opening the X display
+    # on Irix 5.2, according to dickey@clark.net.
+    echo $ac_n "checking for gethostbyname""... $ac_c" 1>&6
+echo "configure:2094: checking for gethostbyname" >&5
+if eval "test \"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2099 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char gethostbyname(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char gethostbyname();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_gethostbyname) || defined (__stub___gethostbyname)
+choke me
+#else
+gethostbyname();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2122: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_gethostbyname=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_gethostbyname=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'gethostbyname`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  :
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+    if test $ac_cv_func_gethostbyname = no; then
+      echo $ac_n "checking for gethostbyname in -lnsl""... $ac_c" 1>&6
+echo "configure:2143: checking for gethostbyname in -lnsl" >&5
+ac_lib_var=`echo nsl'_'gethostbyname | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lnsl  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2151 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char gethostbyname();
+
+int main() {
+gethostbyname()
+; return 0; }
+EOF
+if { (eval echo configure:2162: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+    fi
+
+    # lieder@skyler.mavd.honeywell.com says without -lsocket,
+    # socket/setsockopt and other routines are undefined under SCO ODT
+    # 2.0.  But -lsocket is broken on IRIX 5.2 (and is not necessary
+    # on later versions), says simon@lia.di.epfl.ch: it contains
+    # gethostby* variants that don't use the nameserver (or something).
+    # -lsocket must be given before -lnsl if both are needed.
+    # We assume that if connect needs -lnsl, so does gethostbyname.
+    echo $ac_n "checking for connect""... $ac_c" 1>&6
+echo "configure:2192: checking for connect" >&5
+if eval "test \"`echo '$''{'ac_cv_func_connect'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2197 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char connect(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char connect();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_connect) || defined (__stub___connect)
+choke me
+#else
+connect();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2220: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_connect=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_connect=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'connect`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  :
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+    if test $ac_cv_func_connect = no; then
+      echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
+echo "configure:2241: checking for connect in -lsocket" >&5
+ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lsocket $X_EXTRA_LIBS $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2249 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char connect();
+
+int main() {
+connect()
+; return 0; }
+EOF
+if { (eval echo configure:2260: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  X_EXTRA_LIBS="-lsocket $X_EXTRA_LIBS"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+    fi
+
+    # gomez@mi.uni-erlangen.de says -lposix is necessary on A/UX.
+    echo $ac_n "checking for remove""... $ac_c" 1>&6
+echo "configure:2284: checking for remove" >&5
+if eval "test \"`echo '$''{'ac_cv_func_remove'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2289 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char remove(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char remove();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_remove) || defined (__stub___remove)
+choke me
+#else
+remove();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2312: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_remove=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_remove=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'remove`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  :
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+    if test $ac_cv_func_remove = no; then
+      echo $ac_n "checking for remove in -lposix""... $ac_c" 1>&6
+echo "configure:2333: checking for remove in -lposix" >&5
+ac_lib_var=`echo posix'_'remove | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lposix  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2341 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char remove();
+
+int main() {
+remove()
+; return 0; }
+EOF
+if { (eval echo configure:2352: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -lposix"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+    fi
+
+    # BSDI BSD/OS 2.1 needs -lipc for XOpenDisplay.
+    echo $ac_n "checking for shmat""... $ac_c" 1>&6
+echo "configure:2376: checking for shmat" >&5
+if eval "test \"`echo '$''{'ac_cv_func_shmat'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2381 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char shmat(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char shmat();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_shmat) || defined (__stub___shmat)
+choke me
+#else
+shmat();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2404: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_shmat=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_shmat=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'shmat`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  :
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+    if test $ac_cv_func_shmat = no; then
+      echo $ac_n "checking for shmat in -lipc""... $ac_c" 1>&6
+echo "configure:2425: checking for shmat in -lipc" >&5
+ac_lib_var=`echo ipc'_'shmat | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lipc  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2433 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char shmat();
+
+int main() {
+shmat()
+; return 0; }
+EOF
+if { (eval echo configure:2444: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  X_EXTRA_LIBS="$X_EXTRA_LIBS -lipc"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+    fi
+  fi
+
+  # Check for libraries that X11R6 Xt/Xaw programs need.
+  ac_save_LDFLAGS="$LDFLAGS"
+  test -n "$x_libraries" && LDFLAGS="$LDFLAGS -L$x_libraries"
+  # SM needs ICE to (dynamically) link under SunOS 4.x (so we have to
+  # check for ICE first), but we must link in the order -lSM -lICE or
+  # we get undefined symbols.  So assume we have SM if we have ICE.
+  # These have to be linked with before -lX11, unlike the other
+  # libraries we check for below, so use a different variable.
+  #  --interran@uluru.Stanford.EDU, kb@cs.umb.edu.
+  echo $ac_n "checking for IceConnectionNumber in -lICE""... $ac_c" 1>&6
+echo "configure:2477: checking for IceConnectionNumber in -lICE" >&5
+ac_lib_var=`echo ICE'_'IceConnectionNumber | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lICE $X_EXTRA_LIBS $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2485 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char IceConnectionNumber();
+
+int main() {
+IceConnectionNumber()
+; return 0; }
+EOF
+if { (eval echo configure:2496: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  X_PRE_LIBS="$X_PRE_LIBS -lSM -lICE"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+  LDFLAGS="$ac_save_LDFLAGS"
+
+fi
+
+
+
+if test x$xpm_background = xyes; then
+  
+
+
+# Initialize some more variables set by options.
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+
+# If we find XPM, set shell vars xpm_includes and xpm_libraries to the
+# paths, otherwise set no_xpm=yes.
+# Uses ac_ vars as temps to allow command line to override cache and checks.
+echo $ac_n "checking for libXpm""... $ac_c" 1>&6
+echo "configure:2534: checking for libXpm" >&5
+
+# Check whether --with-xpm_includes or --without-xpm_includes was given.
+if test "${with_xpm_includes+set}" = set; then
+  withval="$with_xpm_includes"
+  xpm_includes="$withval"
+else
+  xpm_includes=NO
+fi
+
+# Check whether --with-xpm_library or --without-xpm_library was given.
+if test "${with_xpm_library+set}" = set; then
+  withval="$with_xpm_library"
+  xpm_libraries="$withval"
+else
+  xpm_libraries=NO
+fi
+
+
+# --without-xpm overrides everything else, but does not touch the cache.
+# Check whether --with-xpm or --without-xpm was given.
+if test "${with_xpm+set}" = set; then
+  withval="$with_xpm"
+  :
+fi
+
+if test "$with_xpm" = no; then
+  have_xpm=disabled
+else
+  if eval "test \"`echo '$''{'ac_cv_have_xpm'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  
+  vt_xpm_include_X11=no
+  if test -n "$xpm_includes"; then
+    vt_xpm_includes=$xpm_includes
+  else
+    vt_xpm_includes=NO
+  fi
+  if test -n "$xpm_libraries"; then
+    vt_xpm_libraries=$xpm_libraries
+  else
+    vt_xpm_libraries=NO
+  fi
+
+  if test "$vt_xpm_includes" = NO; then
+  # Guess where to find xpm.h
+
+  # First, try using that file with no special directory specified.
+cat > conftest.$ac_ext <<EOF
+#line 2584 "configure"
+#include "confdefs.h"
+#include <X11/xpm.h>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:2589: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  # We can compile using X headers with no special include directory.
+vt_xpm_includes=
+vt_xpm_include_X11=yes
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  # Look for the header file in a standard set of common directories.
+  for ac_dir in               \
+    /usr/X11/include          \
+    /usr/X11R6/include        \
+    /usr/X11R5/include        \
+    /usr/X11R4/include        \
+                              \
+    /usr/include/X11          \
+    /usr/include/X11R6        \
+    /usr/include/X11R5        \
+    /usr/include/X11R4        \
+                              \
+    /usr/local/X11/include    \
+    /usr/local/X11R6/include  \
+    /usr/local/X11R5/include  \
+    /usr/local/X11R4/include  \
+                              \
+    /usr/local/include/X11    \
+    /usr/local/include/X11R6  \
+    /usr/local/include/X11R5  \
+    /usr/local/include/X11R4  \
+                              \
+    /usr/X386/include         \
+    /usr/x386/include         \
+    /usr/XFree86/include/X11  \
+                              \
+    /usr/include              \
+    /usr/local/include        \
+    /usr/unsupported/include  \
+    /usr/athena/include       \
+    /usr/local/x11r5/include  \
+    /usr/lpp/Xamples/include  \
+                              \
+    /usr/openwin/include      \
+    /usr/openwin/share/include \
+    ; \
+  do
+    if test -r "$ac_dir/X11/xpm.h"; then
+      vt_xpm_includes="$ac_dir"
+      vt_xpm_include_X11=yes
+      break
+    else
+      if test -r "$ac_dir/xpm.h"; then
+        vt_xpm_includes=$ac_dir
+        break
+      fi
+    fi
+  done
+fi
+rm -f conftest*
+fi
+
+if test "$vt_xpm_libraries" = NO; then
+  # Check for the libraries.
+
+  # See if we find them without any special options.
+  # Don't add to $LIBS permanently.
+  ac_save_LIBS="$LIBS"
+  LIBS="-lXpm $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2661 "configure"
+#include "confdefs.h"
+
+int main() {
+XpmReadFileToPixmap()
+; return 0; }
+EOF
+if { (eval echo configure:2668: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  LIBS="$ac_save_LIBS"
+# We can link libXpm with no special library path.
+vt_xpm_libraries=
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  LIBS="$ac_save_LIBS"
+# First see if replacing the include by lib works.
+for ac_dir in \
+    `echo "$vt_xpm_includes" | sed 's,include/X11,lib,;s,include,lib,'` \
+    /usr/X11/lib          \
+    /usr/X11R6/lib        \
+    /usr/X11R5/lib        \
+    /usr/X11R4/lib        \
+                          \
+    /usr/lib/X11          \
+    /usr/lib/X11R6        \
+    /usr/lib/X11R5        \
+    /usr/lib/X11R4        \
+                          \
+    /usr/local/X11/lib    \
+    /usr/local/X11R6/lib  \
+    /usr/local/X11R5/lib  \
+    /usr/local/X11R4/lib  \
+                          \
+    /usr/local/lib/X11    \
+    /usr/local/lib/X11R6  \
+    /usr/local/lib/X11R5  \
+    /usr/local/lib/X11R4  \
+                          \
+    /usr/X386/lib         \
+    /usr/x386/lib         \
+    /usr/XFree86/lib/X11  \
+                          \
+    /usr/lib              \
+    /usr/local/lib        \
+    /usr/unsupported/lib  \
+    /usr/athena/lib       \
+    /usr/local/x11r5/lib  \
+    /usr/lpp/Xamples/lib  \
+                          \
+    /usr/openwin/lib      \
+    /usr/openwin/share/lib \
+    ; \
+do
+  for ac_extension in a so sl; do
+    if test -r $ac_dir/libXpm.$ac_extension; then
+      vt_xpm_libraries=$ac_dir
+      break 2
+    fi
+  done
+done
+fi
+rm -f conftest*
+fi
+
+
+  if test "$vt_xpm_includes" = NO -o "$vt_xpm_libraries" = NO; then
+    ac_cv_have_xpm="have_xpm=no"
+  else
+    ac_cv_have_xpm="have_xpm=yes \
+        vt_xpm_includes=$vt_xpm_includes vt_xpm_libraries=$vt_xpm_libraries \
+	vt_xpm_include_X11=$vt_xpm_include_X11"
+  fi
+fi
+  eval "$ac_cv_have_xpm"
+fi
+
+if test "$have_xpm" != yes; then
+  echo "$ac_t""$have_xpm" 1>&6
+  no_xpm=yes
+else
+  if test "$xpm_includes" != NO; then
+    if test "$xpm_includes" != "$vt_xpm_includes"; then
+      vt_xpm_include_X11=no
+      if test -z "$xpm_includes"; then
+	cat > conftest.$ac_ext <<EOF
+#line 2748 "configure"
+#include "confdefs.h"
+#include <X11/xpm.h>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:2753: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  vt_xpm_include_X11=yes
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+fi
+rm -f conftest*
+      else
+        if test -r "$xpm_includes/X11/xpm.h"; then
+	  vt_xpm_include_X11=yes
+        fi
+      fi
+    fi
+    vt_xpm_includes=$xpm_includes
+  fi
+  if test "x$xpm_libraries" != xNO; then
+    vt_xpm_libraries=$xpm_libraries
+  fi
+  # Update the cache value to reflect the command line values.
+  ac_cv_have_xpm="have_xpm=yes \
+	vt_xpm_includes=$vt_xpm_includes vt_xpm_libraries=$vt_xpm_libraries \
+	vt_xpm_include_X11=$vt_xpm_include_X11"
+  eval "$ac_cv_have_xpm"
+  echo "$ac_t""-I$vt_xpm_includes, -L$vt_xpm_libraries" 1>&6
+  if test -n "$vt_xpm_includes"; then
+    XPM_CPPFLAGS="-DHAVE_LIBXPM"
+  fi
+  if test -n "$vt_xpm_includes"; then
+    XPM_CFLAGS="-I$vt_xpm_includes"
+  fi
+  XPM_LIBS="-lXpm"
+  if test -n "$vt_xpm_libraries"; then
+    XPM_LIBS="-L$vt_xpm_libraries $XPM_LIBS"
+  fi
+  if test "x$vt_xpm_include_X11" = xyes; then
+    cat >> confdefs.h <<\EOF
+#define XPM_INC_X11 1
+EOF
+
+  fi
+fi
+
+
+
+
+
+  if test x$no_xpm = xyes; then
+    xpm_background=needsmanualspecification
+  fi
+fi
+
+SAVETHECFLAGS=$CFLAGS
+CFLAGS="$CFLAGS $X_CFLAGS"
+echo $ac_n "checking for XPointer""... $ac_c" 1>&6
+echo "configure:2811: checking for XPointer" >&5
+if eval "test \"`echo '$''{'rxvt_cv_xpointer'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2816 "configure"
+#include "confdefs.h"
+#include <X11/Xlib.h>
+int main() {
+XPointer dummy;
+; return 0; }
+EOF
+if { (eval echo configure:2823: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  rxvt_cv_xpointer=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  rxvt_cv_xpointer=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$rxvt_cv_xpointer" 1>&6
+if test x$rxvt_cv_xpointer = xyes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_XPOINTER 1
+EOF
+
+fi
+CFLAGS=$SAVETHECFLAGS
+
+echo $ac_n "checking for sys/wait.h that is POSIX.1 compatible""... $ac_c" 1>&6
+echo "configure:2845: checking for sys/wait.h that is POSIX.1 compatible" >&5
+if eval "test \"`echo '$''{'ac_cv_header_sys_wait_h'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2850 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/wait.h>
+#ifndef WEXITSTATUS
+#define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
+#endif
+#ifndef WIFEXITED
+#define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
+#endif
+int main() {
+int s;
+wait (&s);
+s = WIFEXITED (s) ? WEXITSTATUS (s) : 1;
+; return 0; }
+EOF
+if { (eval echo configure:2866: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_header_sys_wait_h=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_header_sys_wait_h=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_header_sys_wait_h" 1>&6
+if test $ac_cv_header_sys_wait_h = yes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_SYS_WAIT_H 1
+EOF
+
+fi
+
+for ac_hdr in \
+	assert.h \
+	fcntl.h \
+	grp.h \
+	libc.h \
+	lastlog.h \
+	stdarg.h \
+	stdlib.h \
+	string.h \
+	termios.h \
+	unistd.h \
+	sys/byteorder.h \
+	sys/ioctl.h \
+	sys/select.h \
+	sys/sockio.h \
+	sys/time.h \
+
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:2906: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2911 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:2916: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+
+echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
+echo "configure:2944: checking whether time.h and sys/time.h may both be included" >&5
+if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2949 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+int main() {
+struct tm *tp;
+; return 0; }
+EOF
+if { (eval echo configure:2958: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_header_time=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_header_time=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_header_time" 1>&6
+if test $ac_cv_header_time = yes; then
+  cat >> confdefs.h <<\EOF
+#define TIME_WITH_SYS_TIME 1
+EOF
+
+fi
+
+
+echo $ac_n "checking for working const""... $ac_c" 1>&6
+echo "configure:2980: checking for working const" >&5
+if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2985 "configure"
+#include "confdefs.h"
+
+int main() {
+
+/* Ultrix mips cc rejects this.  */
+typedef int charset[2]; const charset x;
+/* SunOS 4.1.1 cc rejects this.  */
+char const *const *ccp;
+char **p;
+/* NEC SVR4.0.2 mips cc rejects this.  */
+struct point {int x, y;};
+static struct point const zero = {0,0};
+/* AIX XL C 1.02.0.0 rejects this.
+   It does not let you subtract one const X* pointer from another in an arm
+   of an if-expression whose if-part is not a constant expression */
+const char *g = "string";
+ccp = &g + (g ? g-g : 0);
+/* HPUX 7.0 cc rejects these. */
+++ccp;
+p = (char**) ccp;
+ccp = (char const *const *) p;
+{ /* SCO 3.2v4 cc rejects this.  */
+  char *t;
+  char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+  *t++ = 0;
+}
+{ /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+  int x[] = {25, 17};
+  const int *foo = &x[0];
+  ++foo;
+}
+{ /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+  typedef const int *iptr;
+  iptr p = 0;
+  ++p;
+}
+{ /* AIX XL C 1.02.0.0 rejects this saying
+     "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+  struct s { int j; const int *ap[3]; };
+  struct s *b; b->j = 5;
+}
+{ /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+  const int foo = 10;
+}
+
+; return 0; }
+EOF
+if { (eval echo configure:3034: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_c_const=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_c_const=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_c_const" 1>&6
+if test $ac_cv_c_const = no; then
+  cat >> confdefs.h <<\EOF
+#define const 
+EOF
+
+fi
+
+echo $ac_n "checking for inline""... $ac_c" 1>&6
+echo "configure:3055: checking for inline" >&5
+if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat > conftest.$ac_ext <<EOF
+#line 3062 "configure"
+#include "confdefs.h"
+
+int main() {
+} $ac_kw foo() {
+; return 0; }
+EOF
+if { (eval echo configure:3069: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_c_inline=$ac_kw; break
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+fi
+rm -f conftest*
+done
+
+fi
+
+echo "$ac_t""$ac_cv_c_inline" 1>&6
+case "$ac_cv_c_inline" in
+  inline | yes) ;;
+  no) cat >> confdefs.h <<\EOF
+#define inline 
+EOF
+ ;;
+  *)  cat >> confdefs.h <<EOF
+#define inline $ac_cv_c_inline
+EOF
+ ;;
+esac
+
+
+
+echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
+echo "configure:3097: checking for ANSI C header files" >&5
+if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3102 "configure"
+#include "confdefs.h"
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:3110: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  ac_cv_header_stdc=yes
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+cat > conftest.$ac_ext <<EOF
+#line 3127 "configure"
+#include "confdefs.h"
+#include <string.h>
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "memchr" >/dev/null 2>&1; then
+  :
+else
+  rm -rf conftest*
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+cat > conftest.$ac_ext <<EOF
+#line 3145 "configure"
+#include "confdefs.h"
+#include <stdlib.h>
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "free" >/dev/null 2>&1; then
+  :
+else
+  rm -rf conftest*
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+if test "$cross_compiling" = yes; then
+  :
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3166 "configure"
+#include "confdefs.h"
+#include <ctype.h>
+#define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+#define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int main () { int i; for (i = 0; i < 256; i++)
+if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
+exit (0); }
+
+EOF
+if { (eval echo configure:3177: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  :
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_header_stdc=no
+fi
+rm -fr conftest*
+fi
+
+fi
+fi
+
+echo "$ac_t""$ac_cv_header_stdc" 1>&6
+if test $ac_cv_header_stdc = yes; then
+  cat >> confdefs.h <<\EOF
+#define STDC_HEADERS 1
+EOF
+
+fi
+
+echo $ac_n "checking for mode_t""... $ac_c" 1>&6
+echo "configure:3201: checking for mode_t" >&5
+if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3206 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "(^|[^a-zA-Z_0-9])mode_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_type_mode_t=yes
+else
+  rm -rf conftest*
+  ac_cv_type_mode_t=no
+fi
+rm -f conftest*
+
+fi
+echo "$ac_t""$ac_cv_type_mode_t" 1>&6
+if test $ac_cv_type_mode_t = no; then
+  cat >> confdefs.h <<\EOF
+#define mode_t int
+EOF
+
+fi
+
+echo $ac_n "checking for pid_t""... $ac_c" 1>&6
+echo "configure:3234: checking for pid_t" >&5
+if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3239 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "(^|[^a-zA-Z_0-9])pid_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_type_pid_t=yes
+else
+  rm -rf conftest*
+  ac_cv_type_pid_t=no
+fi
+rm -f conftest*
+
+fi
+echo "$ac_t""$ac_cv_type_pid_t" 1>&6
+if test $ac_cv_type_pid_t = no; then
+  cat >> confdefs.h <<\EOF
+#define pid_t int
+EOF
+
+fi
+
+echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
+echo "configure:3267: checking for uid_t in sys/types.h" >&5
+if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3272 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "uid_t" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_type_uid_t=yes
+else
+  rm -rf conftest*
+  ac_cv_type_uid_t=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$ac_cv_type_uid_t" 1>&6
+if test $ac_cv_type_uid_t = no; then
+  cat >> confdefs.h <<\EOF
+#define uid_t int
+EOF
+
+  cat >> confdefs.h <<\EOF
+#define gid_t int
+EOF
+
+fi
+
+
+
+echo $ac_n "checking size of char""... $ac_c" 1>&6
+echo "configure:3303: checking size of char" >&5
+if eval "test \"`echo '$''{'ac_cv_sizeof_char'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_sizeof_char=1
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3311 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+main()
+{
+  FILE *f=fopen("conftestval", "w");
+  if (!f) exit(1);
+  fprintf(f, "%d\n", sizeof(char));
+  exit(0);
+}
+EOF
+if { (eval echo configure:3322: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_sizeof_char=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_sizeof_char=0
+fi
+rm -fr conftest*
+fi
+
+fi
+echo "$ac_t""$ac_cv_sizeof_char" 1>&6
+cat >> confdefs.h <<EOF
+#define SIZEOF_CHAR $ac_cv_sizeof_char
+EOF
+
+
+echo $ac_n "checking size of short""... $ac_c" 1>&6
+echo "configure:3342: checking size of short" >&5
+if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_sizeof_short=2
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3350 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+main()
+{
+  FILE *f=fopen("conftestval", "w");
+  if (!f) exit(1);
+  fprintf(f, "%d\n", sizeof(short));
+  exit(0);
+}
+EOF
+if { (eval echo configure:3361: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_sizeof_short=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_sizeof_short=0
+fi
+rm -fr conftest*
+fi
+
+fi
+echo "$ac_t""$ac_cv_sizeof_short" 1>&6
+cat >> confdefs.h <<EOF
+#define SIZEOF_SHORT $ac_cv_sizeof_short
+EOF
+
+
+echo $ac_n "checking size of int""... $ac_c" 1>&6
+echo "configure:3381: checking size of int" >&5
+if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_sizeof_int=4
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3389 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+main()
+{
+  FILE *f=fopen("conftestval", "w");
+  if (!f) exit(1);
+  fprintf(f, "%d\n", sizeof(int));
+  exit(0);
+}
+EOF
+if { (eval echo configure:3400: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_sizeof_int=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_sizeof_int=0
+fi
+rm -fr conftest*
+fi
+
+fi
+echo "$ac_t""$ac_cv_sizeof_int" 1>&6
+cat >> confdefs.h <<EOF
+#define SIZEOF_INT $ac_cv_sizeof_int
+EOF
+
+
+echo $ac_n "checking size of long""... $ac_c" 1>&6
+echo "configure:3420: checking size of long" >&5
+if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_sizeof_long=4
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3428 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+main()
+{
+  FILE *f=fopen("conftestval", "w");
+  if (!f) exit(1);
+  fprintf(f, "%d\n", sizeof(long));
+  exit(0);
+}
+EOF
+if { (eval echo configure:3439: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_sizeof_long=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_sizeof_long=0
+fi
+rm -fr conftest*
+fi
+
+fi
+echo "$ac_t""$ac_cv_sizeof_long" 1>&6
+cat >> confdefs.h <<EOF
+#define SIZEOF_LONG $ac_cv_sizeof_long
+EOF
+
+
+echo $ac_n "checking size of long long""... $ac_c" 1>&6
+echo "configure:3459: checking size of long long" >&5
+if eval "test \"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_sizeof_long_long=8
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3467 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+main()
+{
+  FILE *f=fopen("conftestval", "w");
+  if (!f) exit(1);
+  fprintf(f, "%d\n", sizeof(long long));
+  exit(0);
+}
+EOF
+if { (eval echo configure:3478: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_sizeof_long_long=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_sizeof_long_long=0
+fi
+rm -fr conftest*
+fi
+
+fi
+echo "$ac_t""$ac_cv_sizeof_long_long" 1>&6
+cat >> confdefs.h <<EOF
+#define SIZEOF_LONG_LONG $ac_cv_sizeof_long_long
+EOF
+
+
+echo $ac_n "checking size of int *""... $ac_c" 1>&6
+echo "configure:3498: checking size of int *" >&5
+if eval "test \"`echo '$''{'ac_cv_sizeof_int_p'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_sizeof_int_p=4
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3506 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+main()
+{
+  FILE *f=fopen("conftestval", "w");
+  if (!f) exit(1);
+  fprintf(f, "%d\n", sizeof(int *));
+  exit(0);
+}
+EOF
+if { (eval echo configure:3517: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_sizeof_int_p=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_sizeof_int_p=0
+fi
+rm -fr conftest*
+fi
+
+fi
+echo "$ac_t""$ac_cv_sizeof_int_p" 1>&6
+cat >> confdefs.h <<EOF
+#define SIZEOF_INT_P $ac_cv_sizeof_int_p
+EOF
+
+
+if test x$cross_compiling = xyes; then
+    echo "configure: warning: Define typedefs in src/rsizes.h manually if necessary" 1>&2
+fi
+
+
+echo $ac_n "checking for int16_t""... $ac_c" 1>&6
+echo "configure:3542: checking for int16_t" >&5
+if eval "test \"`echo '$''{'rxvt_cv_int16_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3547 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+int main() {
+int16_t dummy;
+; return 0; }
+EOF
+if { (eval echo configure:3554: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  rxvt_cv_int16_t=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  if test $ac_cv_sizeof_char -ge 2; then
+        rxvt_cv_int16_t=" char"
+      else
+        if test $ac_cv_sizeof_short -ge 2; then
+          rxvt_cv_int16_t=" short"
+        else
+          if test $ac_cv_sizeof_int -ge 2; then
+            rxvt_cv_int16_t=" int"
+          else
+            if test $ac_cv_sizeof_long -ge 2; then
+              rxvt_cv_int16_t=" long"
+            else
+              if test $ac_cv_sizeof_long_long -ge 2; then
+                rxvt_cv_int16_t=" long long"
+              else
+                rxvt_cv_int16_t=" long" # we _must_ have a (possibly wrong) default
+              fi
+            fi
+          fi
+        fi
+      fi
+      
+fi
+rm -f conftest*
+    
+fi
+
+echo "$ac_t""$rxvt_cv_int16_t" 1>&6
+  
+  if test x"$rxvt_cv_int16_t" != xyes; then
+    rxvt_int16_typedef="typedef $rxvt_cv_int16_t int16_t;"
+  fi
+  
+
+echo $ac_n "checking for u_int16_t""... $ac_c" 1>&6
+echo "configure:3596: checking for u_int16_t" >&5
+if eval "test \"`echo '$''{'rxvt_cv_u_int16_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3601 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+int main() {
+u_int16_t dummy;
+; return 0; }
+EOF
+if { (eval echo configure:3608: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  rxvt_cv_u_int16_t=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  if test $ac_cv_sizeof_char -ge 2; then
+        rxvt_cv_u_int16_t="unsigned char"
+      else
+        if test $ac_cv_sizeof_short -ge 2; then
+          rxvt_cv_u_int16_t="unsigned short"
+        else
+          if test $ac_cv_sizeof_int -ge 2; then
+            rxvt_cv_u_int16_t="unsigned int"
+          else
+            if test $ac_cv_sizeof_long -ge 2; then
+              rxvt_cv_u_int16_t="unsigned long"
+            else
+              if test $ac_cv_sizeof_long_long -ge 2; then
+                rxvt_cv_u_int16_t="unsigned long long"
+              else
+                rxvt_cv_u_int16_t="unsigned long" # we _must_ have a (possibly wrong) default
+              fi
+            fi
+          fi
+        fi
+      fi
+      
+fi
+rm -f conftest*
+    
+fi
+
+echo "$ac_t""$rxvt_cv_u_int16_t" 1>&6
+  
+  if test x"$rxvt_cv_u_int16_t" != xyes; then
+    rxvt_u_int16_typedef="typedef $rxvt_cv_u_int16_t u_int16_t;"
+  fi
+  
+
+echo $ac_n "checking for int32_t""... $ac_c" 1>&6
+echo "configure:3650: checking for int32_t" >&5
+if eval "test \"`echo '$''{'rxvt_cv_int32_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3655 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+int main() {
+int32_t dummy;
+; return 0; }
+EOF
+if { (eval echo configure:3662: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  rxvt_cv_int32_t=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  if test $ac_cv_sizeof_char -ge 4; then
+        rxvt_cv_int32_t=" char"
+      else
+        if test $ac_cv_sizeof_short -ge 4; then
+          rxvt_cv_int32_t=" short"
+        else
+          if test $ac_cv_sizeof_int -ge 4; then
+            rxvt_cv_int32_t=" int"
+          else
+            if test $ac_cv_sizeof_long -ge 4; then
+              rxvt_cv_int32_t=" long"
+            else
+              if test $ac_cv_sizeof_long_long -ge 4; then
+                rxvt_cv_int32_t=" long long"
+              else
+                rxvt_cv_int32_t=" long" # we _must_ have a (possibly wrong) default
+              fi
+            fi
+          fi
+        fi
+      fi
+      
+fi
+rm -f conftest*
+    
+fi
+
+echo "$ac_t""$rxvt_cv_int32_t" 1>&6
+  
+  if test x"$rxvt_cv_int32_t" != xyes; then
+    rxvt_int32_typedef="typedef $rxvt_cv_int32_t int32_t;"
+  fi
+  
+
+echo $ac_n "checking for u_int32_t""... $ac_c" 1>&6
+echo "configure:3704: checking for u_int32_t" >&5
+if eval "test \"`echo '$''{'rxvt_cv_u_int32_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3709 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+int main() {
+u_int32_t dummy;
+; return 0; }
+EOF
+if { (eval echo configure:3716: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  rxvt_cv_u_int32_t=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  if test $ac_cv_sizeof_char -ge 4; then
+        rxvt_cv_u_int32_t="unsigned char"
+      else
+        if test $ac_cv_sizeof_short -ge 4; then
+          rxvt_cv_u_int32_t="unsigned short"
+        else
+          if test $ac_cv_sizeof_int -ge 4; then
+            rxvt_cv_u_int32_t="unsigned int"
+          else
+            if test $ac_cv_sizeof_long -ge 4; then
+              rxvt_cv_u_int32_t="unsigned long"
+            else
+              if test $ac_cv_sizeof_long_long -ge 4; then
+                rxvt_cv_u_int32_t="unsigned long long"
+              else
+                rxvt_cv_u_int32_t="unsigned long" # we _must_ have a (possibly wrong) default
+              fi
+            fi
+          fi
+        fi
+      fi
+      
+fi
+rm -f conftest*
+    
+fi
+
+echo "$ac_t""$rxvt_cv_u_int32_t" 1>&6
+  
+  if test x"$rxvt_cv_u_int32_t" != xyes; then
+    rxvt_u_int32_typedef="typedef $rxvt_cv_u_int32_t u_int32_t;"
+  fi
+  
+
+echo $ac_n "checking for int64_t""... $ac_c" 1>&6
+echo "configure:3758: checking for int64_t" >&5
+if eval "test \"`echo '$''{'rxvt_cv_int64_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3763 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+int main() {
+int64_t dummy;
+; return 0; }
+EOF
+if { (eval echo configure:3770: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  rxvt_cv_int64_t=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  if test $ac_cv_sizeof_char -ge 8; then
+        rxvt_cv_int64_t=" char"
+      else
+        if test $ac_cv_sizeof_short -ge 8; then
+          rxvt_cv_int64_t=" short"
+        else
+          if test $ac_cv_sizeof_int -ge 8; then
+            rxvt_cv_int64_t=" int"
+          else
+            if test $ac_cv_sizeof_long -ge 8; then
+              rxvt_cv_int64_t=" long"
+            else
+              if test $ac_cv_sizeof_long_long -ge 8; then
+                rxvt_cv_int64_t=" long long"
+              else
+                rxvt_cv_int64_t=" long" # we _must_ have a (possibly wrong) default
+              fi
+            fi
+          fi
+        fi
+      fi
+      
+fi
+rm -f conftest*
+    
+fi
+
+echo "$ac_t""$rxvt_cv_int64_t" 1>&6
+  
+  if test x"$rxvt_cv_int64_t" != xyes; then
+    rxvt_int64_typedef="typedef $rxvt_cv_int64_t int64_t;"
+  fi
+  
+
+echo $ac_n "checking for u_int64_t""... $ac_c" 1>&6
+echo "configure:3812: checking for u_int64_t" >&5
+if eval "test \"`echo '$''{'rxvt_cv_u_int64_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3817 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+int main() {
+u_int64_t dummy;
+; return 0; }
+EOF
+if { (eval echo configure:3824: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  rxvt_cv_u_int64_t=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  if test $ac_cv_sizeof_char -ge 8; then
+        rxvt_cv_u_int64_t="unsigned char"
+      else
+        if test $ac_cv_sizeof_short -ge 8; then
+          rxvt_cv_u_int64_t="unsigned short"
+        else
+          if test $ac_cv_sizeof_int -ge 8; then
+            rxvt_cv_u_int64_t="unsigned int"
+          else
+            if test $ac_cv_sizeof_long -ge 8; then
+              rxvt_cv_u_int64_t="unsigned long"
+            else
+              if test $ac_cv_sizeof_long_long -ge 8; then
+                rxvt_cv_u_int64_t="unsigned long long"
+              else
+                rxvt_cv_u_int64_t="unsigned long" # we _must_ have a (possibly wrong) default
+              fi
+            fi
+          fi
+        fi
+      fi
+      
+fi
+rm -f conftest*
+    
+fi
+
+echo "$ac_t""$rxvt_cv_u_int64_t" 1>&6
+  
+  if test x"$rxvt_cv_u_int64_t" != xyes; then
+    rxvt_u_int64_typedef="typedef $rxvt_cv_u_int64_t u_int64_t;"
+  fi
+  
+
+if test $ac_cv_sizeof_int_p -eq 8; then
+  rxvt_intp_define="#define intp_t int64_t"
+  rxvt_u_intp_define="#define u_intp_t u_int64_t"
+else
+  if test $ac_cv_sizeof_int_p -eq 4; then
+    rxvt_intp_define="#define intp_t int32_t"
+    rxvt_u_intp_define="#define u_intp_t u_int32_t"
+  else
+    if test $ac_cv_sizeof_int_p -eq 2; then
+      rxvt_intp_define="#define intp_t int16_t"
+      rxvt_u_intp_define="#define u_intp_t u_int16_t"
+    else
+      rxvt_intp_define="#error set intp_t"
+      rxvt_u_intp_define="#error set u_intp_t"
+    fi
+  fi
+fi
+
+
+
+echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
+echo "configure:3886: checking return type of signal handlers" >&5
+if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3891 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+#undef signal
+#endif
+#ifdef __cplusplus
+extern "C" void (*signal (int, void (*)(int)))(int);
+#else
+void (*signal ()) ();
+#endif
+
+int main() {
+int i;
+; return 0; }
+EOF
+if { (eval echo configure:3908: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_type_signal=void
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_type_signal=int
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_type_signal" 1>&6
+cat >> confdefs.h <<EOF
+#define RETSIGTYPE $ac_cv_type_signal
+EOF
+
+
+for ac_func in \
+	atexit \
+	unsetenv \
+	setutent \
+	seteuid \
+	_getpty \
+	grantpt \
+	unlockpt \
+
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:3937: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3942 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:3965: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+
+if test x$utmp_support = xyes; then
+
+ac_safe=`echo "utmp.h" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for utmp.h""... $ac_c" 1>&6
+echo "configure:3994: checking for utmp.h" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3999 "configure"
+#include "confdefs.h"
+#include <utmp.h>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:4004: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  echo $ac_n "checking for struct utmp""... $ac_c" 1>&6
+echo "configure:4021: checking for struct utmp" >&5
+if eval "test \"`echo '$''{'rxvt_cv_struct_utmp'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4026 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <utmp.h>
+int main() {
+struct utmp ut;
+; return 0; }
+EOF
+if { (eval echo configure:4034: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  rxvt_cv_struct_utmp=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  rxvt_cv_struct_utmp=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$rxvt_cv_struct_utmp" 1>&6
+if test x$rxvt_cv_struct_utmp = xyes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_STRUCT_UTMP 1
+EOF
+
+fi
+
+
+echo $ac_n "checking for host in utmp struct""... $ac_c" 1>&6
+echo "configure:4056: checking for host in utmp struct" >&5
+if eval "test \"`echo '$''{'rxvt_cv_struct_utmp_host'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4061 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <utmp.h>
+int main() {
+struct utmp ut; ut.ut_host;
+; return 0; }
+EOF
+if { (eval echo configure:4069: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  rxvt_cv_struct_utmp_host=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  rxvt_cv_struct_utmp_host=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$rxvt_cv_struct_utmp_host" 1>&6
+if test x$rxvt_cv_struct_utmp_host = xyes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_UTMP_HOST 1
+EOF
+
+fi
+
+echo $ac_n "checking where utmp is located""... $ac_c" 1>&6
+echo "configure:4090: checking where utmp is located" >&5
+if eval "test \"`echo '$''{'rxvt_cv_path_utmp'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+    echo "configure: warning: Define/undefine RXVT_UTMP_FILE in config.h manually" 1>&2
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4098 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+#include <sys/types.h>
+#include <utmp.h>
+#include <errno.h>
+main()
+{
+    char **u, *utmplist[] = {
+#ifdef UTMP_FILE
+	UTMP_FILE,
+#endif
+#ifdef _PATH_UTMP
+	_PATH_UTMP,
+#endif
+    "/var/run/utmp", "/var/adm/utmp", "/etc/utmp", "/usr/etc/utmp", "/usr/adm/utmp", NULL };
+    FILE *a, *f=fopen("conftestval", "w");
+    if (!f) exit(1);
+    for (u = utmplist; *u; u++) {
+	if ((a = fopen(*u, "r")) != NULL || errno == EACCES) {
+	    fprintf(f, "%s\n", *u);
+	    exit(0);
+	}
+    }
+    exit(0);
+}
+EOF
+if { (eval echo configure:4125: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  rxvt_cv_path_utmp=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  rxvt_cv_path_utmp=
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$rxvt_cv_path_utmp" 1>&6
+if test x${rxvt_cv_path_utmp} != x; then
+  cat >> confdefs.h <<EOF
+#define RXVT_UTMP_FILE "$rxvt_cv_path_utmp"
+EOF
+
+fi
+
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+ 
+
+ac_safe=`echo "utmpx.h" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for utmpx.h""... $ac_c" 1>&6
+echo "configure:4155: checking for utmpx.h" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4160 "configure"
+#include "confdefs.h"
+#include <utmpx.h>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:4165: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  echo $ac_n "checking for struct utmpx""... $ac_c" 1>&6
+echo "configure:4182: checking for struct utmpx" >&5
+if eval "test \"`echo '$''{'rxvt_cv_struct_utmpx'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4187 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <utmpx.h>
+int main() {
+struct utmpx ut;
+; return 0; }
+EOF
+if { (eval echo configure:4195: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  rxvt_cv_struct_utmpx=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  rxvt_cv_struct_utmpx=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$rxvt_cv_struct_utmpx" 1>&6
+if test x$rxvt_cv_struct_utmpx = xyes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_STRUCT_UTMPX 1
+EOF
+
+fi
+
+
+echo $ac_n "checking for host in utmpx struct""... $ac_c" 1>&6
+echo "configure:4217: checking for host in utmpx struct" >&5
+if eval "test \"`echo '$''{'rxvt_cv_struct_utmpx_host'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4222 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <utmpx.h>
+int main() {
+struct utmpx utx; utx.ut_host;
+; return 0; }
+EOF
+if { (eval echo configure:4230: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  rxvt_cv_struct_utmpx_host=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  rxvt_cv_struct_utmpx_host=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$rxvt_cv_struct_utmpx_host" 1>&6
+if test x$rxvt_cv_struct_utmpx_host = xyes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_UTMPX_HOST 1
+EOF
+
+fi
+
+
+echo $ac_n "checking where utmpx is located""... $ac_c" 1>&6
+echo "configure:4252: checking where utmpx is located" >&5
+if eval "test \"`echo '$''{'rxvt_cv_path_utmpx'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+    echo "configure: warning: Define/undefine RXVT_UTMPX_FILE in config.h manually" 1>&2
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4260 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+#include <sys/types.h>
+#include <utmpx.h>
+#include <errno.h>
+#include <sys/stat.h>
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+main()
+{
+    char **u, *p, *utmplist[] = {
+#ifdef UTMPX_FILE
+	UTMPX_FILE,
+#endif
+    "/var/adm/utmpx", "/etc/utmpx", NULL };
+    FILE *a, *f=fopen("conftestval", "w");
+    struct stat statu, statux;
+    if (!f) exit(1);
+    for (u = utmplist; *u; u++) {
+	if ((a = fopen(*u, "r")) != NULL || errno == EACCES) {
+	    if (stat(*u, &statux) < 0)
+		continue;
+	    p = strdup(*u);
+	    p[strlen(p) - 1] = '\0';
+	    if (stat(p, &statu) >= 0
+		&& (statu.st_mtime - statux.st_mtime > 3600))
+		continue;
+	    fprintf(f, "%s\n", *u);
+	    exit(0);
+	}
+    }
+    exit(0);
+}
+EOF
+if { (eval echo configure:4296: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  rxvt_cv_path_utmpx=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  rxvt_cv_path_utmpx=
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$rxvt_cv_path_utmpx" 1>&6
+if test x${rxvt_cv_path_utmpx} != x; then
+  cat >> confdefs.h <<EOF
+#define RXVT_UTMPX_FILE "$rxvt_cv_path_utmpx"
+EOF
+
+fi
+
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+ 
+
+echo $ac_n "checking where wtmp is located""... $ac_c" 1>&6
+echo "configure:4325: checking where wtmp is located" >&5
+if eval "test \"`echo '$''{'rxvt_cv_path_wtmp'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+    echo "configure: warning: Define/undefine RXVT_WTMP_FILE in config.h manually" 1>&2
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4333 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+#ifdef HAVE_UTMPX_H
+#include <utmpx.h>
+#endif
+#ifdef HAVE_UTMP_H
+#include <utmp.h>
+#endif
+#include <errno.h>
+main()
+{
+    char **w, *wtmplist[] = {
+#ifdef WTMPX_FILE
+	WTMPX_FILE,
+#endif
+#ifdef WTMP_FILE
+	WTMP_FILE,
+#endif
+#ifdef _PATH_WTMP
+	_PATH_WTMP,
+#endif
+    "/var/log/wtmp", "/var/adm/wtmp", "/etc/wtmp", "/usr/etc/wtmp", "/usr/adm/wtmp", NULL }; 
+    FILE *a, *f=fopen("conftestval", "w");
+    if (!f) exit(1);
+    for (w = wtmplist; *w; w++) {
+	if ((a = fopen(*w, "r")) != NULL || errno == EACCES) {
+	    fprintf(f, "%s\n", *w);
+	    exit(0);
+	}
+    }
+    exit(0);
+}
+EOF
+if { (eval echo configure:4367: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  rxvt_cv_path_wtmp=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  rxvt_cv_path_wtmp=
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$rxvt_cv_path_wtmp" 1>&6
+if test x${rxvt_cv_path_wtmp} != x; then
+  cat >> confdefs.h <<EOF
+#define RXVT_WTMP_FILE "$rxvt_cv_path_wtmp"
+EOF
+
+fi
+
+echo $ac_n "checking where wtmpx is located""... $ac_c" 1>&6
+echo "configure:4390: checking where wtmpx is located" >&5
+if eval "test \"`echo '$''{'rxvt_cv_path_wtmpx'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+    echo "configure: warning: Define/undefine RXVT_WTMPX_FILE in config.h manually" 1>&2
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4398 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+#ifdef HAVE_UTMPX_H
+#include <utmpx.h>
+#endif
+#include <errno.h>
+main()
+{
+    char **w, *wtmplist[] = {
+#ifdef WTMPX_FILE
+	WTMPX_FILE,
+#endif
+    "/var/log/wtmpx", "/var/adm/wtmpx", NULL }; 
+    FILE *a, *f=fopen("conftestval", "w");
+    if (!f) exit(1);
+    for (w = wtmplist; *w; w++) {
+	if ((a = fopen(*w, "r")) != NULL || errno == EACCES) {
+	    fprintf(f, "%s\n", *w);
+	    exit(0);
+	}
+    }
+    exit(0);
+}
+EOF
+if { (eval echo configure:4423: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  rxvt_cv_path_wtmpx=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  rxvt_cv_path_wtmpx=
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$rxvt_cv_path_wtmpx" 1>&6
+if test x${rxvt_cv_path_wtmpx} != x; then
+  cat >> confdefs.h <<EOF
+#define RXVT_WTMPX_FILE "$rxvt_cv_path_wtmpx"
+EOF
+
+fi
+
+fi
+
+echo $ac_n "checking where ttys/ttytab is located""... $ac_c" 1>&6
+echo "configure:4448: checking where ttys/ttytab is located" >&5
+if eval "test \"`echo '$''{'rxvt_cv_path_ttytab'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  for ttys_file in     /etc/ttys /etc/ttytab;
+do
+  if test -f "$ttys_file" ; then 
+    rxvt_cv_path_ttytab=$ttys_file
+    break
+  fi
+done
+
+fi
+
+echo "$ac_t""$rxvt_cv_path_ttytab" 1>&6
+if test x${rxvt_cv_path_ttytab} != x; then
+  cat >> confdefs.h <<EOF
+#define TTYTAB_FILENAME "$rxvt_cv_path_ttytab"
+EOF
+
+fi
+
+SAVETHELIBS=$LIBS
+SAVETHECFLAGS=$CFLAGS
+CFLAGS="$CFLAGS $X_CFLAGS"
+LIBS="$LIBS $X_LIBS $X_EXTRA_LIBS -lX11"
+echo $ac_n "checking for working Xlocale""... $ac_c" 1>&6
+echo "configure:4475: checking for working Xlocale" >&5
+if eval "test \"`echo '$''{'rxvt_cv_func_xlocale'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+    echo "configure: warning: Define/undefine NO_XLOCALE in config.h manually" 1>&2
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4483 "configure"
+#include "confdefs.h"
+#include <X11/Xlib.h>
+main() {
+char *p;
+if ((p = XSetLocaleModifiers("@im=none")) != NULL && *p)
+exit (XSupportsLocale() ? 0 : 1);
+else
+exit (1);}
+EOF
+if { (eval echo configure:4493: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+    rxvt_cv_func_xlocale=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  rxvt_cv_func_xlocale=no
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$rxvt_cv_func_xlocale" 1>&6
+if test x${rxvt_cv_func_xlocale} = xno; then
+  cat >> confdefs.h <<\EOF
+#define NO_XLOCALE 1
+EOF
+
+fi
+
+echo $ac_n "checking for working X setlocale""... $ac_c" 1>&6
+echo "configure:4516: checking for working X setlocale" >&5
+if eval "test \"`echo '$''{'rxvt_cv_func_xsetlocale'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4521 "configure"
+#include "confdefs.h"
+#define X_LOCALE 1
+#include <X11/Xlocale.h>
+int main() {
+setlocale(LC_CTYPE, "");
+; return 0; }
+EOF
+if { (eval echo configure:4529: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  rxvt_cv_func_xsetlocale=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  rxvt_cv_func_xsetlocale=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$rxvt_cv_func_xsetlocale" 1>&6
+if test x${rxvt_cv_func_xsetlocale} = xno; then
+  cat >> confdefs.h <<\EOF
+#define NO_XSETLOCALE 1
+EOF
+
+fi
+LIBS=$SAVETHELIBS
+CFLAGS=$SAVETHECFLAGS
+
+echo $ac_n "checking for working plain setlocale""... $ac_c" 1>&6
+echo "configure:4552: checking for working plain setlocale" >&5
+if eval "test \"`echo '$''{'rxvt_cv_func_setlocale'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4557 "configure"
+#include "confdefs.h"
+#include <locale.h>
+int main() {
+setlocale(LC_CTYPE, "");
+; return 0; }
+EOF
+if { (eval echo configure:4564: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  rxvt_cv_func_setlocale=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  rxvt_cv_func_setlocale=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$rxvt_cv_func_setlocale" 1>&6
+if test x${rxvt_cv_func_setlocale} = xno; then
+  cat >> confdefs.h <<\EOF
+#define NO_SETLOCALE 1
+EOF
+
+fi
+
+echo $ac_n "checking for getpt""... $ac_c" 1>&6
+echo "configure:4585: checking for getpt" >&5
+if eval "test \"`echo '$''{'rxvt_cv_func_getpt'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4590 "configure"
+#include "confdefs.h"
+#define _GNU_SOURCE
+#ifdef HAVE_STDLIB_H
+# include <stdlib.h>
+#endif
+int main() {
+(void)getpt();
+; return 0; }
+EOF
+if { (eval echo configure:4600: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  rxvt_cv_func_getpt=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  rxvt_cv_func_getpt=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$rxvt_cv_func_getpt" 1>&6
+if test x${rxvt_cv_func_getpt} = xyes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_GETPT 1
+EOF
+
+fi
+
+# if we don't guess right then it's up to the user
+echo $ac_n "checking for tty/pty type""... $ac_c" 1>&6
+echo "configure:4622: checking for tty/pty type" >&5
+if eval "test \"`echo '$''{'rxvt_cv_ptys'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+    echo "configure: warning: Define/undefine PTYS_ARE_* in config.h manually" 1>&2
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4630 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+#ifdef HAVE_STDLIB_H
+# ifdef HAVE_GETPT
+#  define _GNU_SOURCE
+# endif
+# include <stdlib.h>
+#endif
+#ifdef HAVE_FCNTL_H
+# include <fcntl.h>
+#endif
+#include <sys/stat.h>
+#include <errno.h>
+main()
+{
+    int pty, checkerror;
+    FILE *a, *f=fopen("conftestval", "w");
+    struct stat statbuf;
+    extern int errno;
+
+    if (!f) exit(1);
+/* presume that S_IXOTH is required for people to access devices */
+    if (stat("/dev", &statbuf) < 0)
+	checkerror = 0;
+    else
+	checkerror = ((statbuf.st_mode & S_IXOTH) == S_IXOTH) ? 1 : 0;
+#if defined(__sgi) || defined(sgi) || defined(__sgi__)
+    if (stat("/dev/ptc", &statbuf) >= 0)
+# ifdef HAVE__GETPTY
+	fprintf(f, "SGI4");
+# else
+	fprintf(f, "SGI3");
+# endif
+    else
+	fprintf(f, "SGI4");
+    exit(0);
+#endif
+#ifdef _SCO_DS
+    if (stat("/dev/ttyp20", &statbuf) == 0) {
+	fprintf(f, "SCO");
+	exit(0);
+    }
+#endif
+/* HPUX: before ptmx */
+    pty = open("/dev/ptym/clone", O_RDWR);
+    if (pty >= 0 || (checkerror && errno == EACCES)) {
+	fprintf(f, "HPUX");
+	exit(0);
+    }
+#if defined(HAVE_GRANTPT) && defined(HAVE_UNLOCKPT)
+# ifdef HAVE_GETPT
+    pty = getpt();
+    if (pty >= 0 || errno == EACCES) {
+	fprintf(f, "GLIBC");
+	exit(0);
+    }
+# endif
+    if (stat("/dev/ptmx", &statbuf) >= 0
+	&& ((statbuf.st_mode & S_IFCHR) == S_IFCHR))
+	if (stat("/dev/pts/0", &statbuf) >= 0
+	    && ((statbuf.st_mode & S_IFCHR) == S_IFCHR)
+	    && ((pty = open("/dev/ptmx", O_RDWR)) >= 0
+		|| (checkerror && errno == EACCES))) {
+	    fprintf(f, "USG");
+	    exit(0);
+    }
+#endif
+    if (stat("/dev/ttyp20", &statbuf) == 0) {
+	fprintf(f, "SCO");
+	exit(0);
+    }
+    fprintf(f, "BSD");
+    exit(0);
+}
+EOF
+if { (eval echo configure:4706: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  rxvt_cv_ptys=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  rxvt_cv_ptys=UNKNOWN
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$rxvt_cv_ptys" 1>&6
+
+if test x${rxvt_cv_ptys} = xSCO; then
+  cat >> confdefs.h <<\EOF
+#define PTYS_ARE_NUMERIC 1
+EOF
+
+  
+fi
+if test x${rxvt_cv_ptys} = xUSG; then
+  cat >> confdefs.h <<\EOF
+#define PTYS_ARE_PTMX 1
+EOF
+
+  
+  cat >> confdefs.h <<\EOF
+#define PTYS_ARE_SEARCHED 1
+EOF
+
+  
+fi
+if test x${rxvt_cv_ptys} = xSGI3; then
+  cat >> confdefs.h <<\EOF
+#define PTYS_ARE_PTC 1
+EOF
+
+  
+fi
+if test x${rxvt_cv_ptys} = xSGI4; then
+  cat >> confdefs.h <<\EOF
+#define PTYS_ARE__GETPTY 1
+EOF
+
+  
+fi
+if test x${rxvt_cv_ptys} = xCONVEX; then
+  cat >> confdefs.h <<\EOF
+#define PTYS_ARE_GETPTY 1
+EOF
+
+  
+fi
+if test x${rxvt_cv_ptys} = xGLIBC; then
+  cat >> confdefs.h <<\EOF
+#define PTYS_ARE_GETPT 1
+EOF
+
+  
+  cat >> confdefs.h <<\EOF
+#define PTYS_ARE_SEARCHED 1
+EOF
+
+  
+fi
+if test x${rxvt_cv_ptys} = xHPUX; then
+  cat >> confdefs.h <<\EOF
+#define PTYS_ARE_CLONE 1
+EOF
+
+  
+  cat >> confdefs.h <<\EOF
+#define PTYS_ARE_SEARCHED 1
+EOF
+
+  
+fi
+if test x${rxvt_cv_ptys} = xBSD; then
+  cat >> confdefs.h <<\EOF
+#define PTYS_ARE_SEARCHED 1
+EOF
+
+  
+fi
+
+echo $ac_n "checking for setlocale in -lxpg4""... $ac_c" 1>&6
+echo "configure:4795: checking for setlocale in -lxpg4" >&5
+ac_lib_var=`echo xpg4'_'setlocale | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lxpg4  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 4803 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char setlocale();
+
+int main() {
+setlocale()
+; return 0; }
+EOF
+if { (eval echo configure:4814: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  LIBS="$LIBS -lxpg4"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+
+
+CFLAGS=${CFLAGS--O}
+LDFLAGS=${LDFLAGS--O}
+
+CPPFLAGS="$CPPFLAGS"
+
+
+
+
+
+
+
+
+
+
+
+MCOMMON=./autoconf/Make.common
+
+
+trap '' 1 2 15
+cat > confcache <<\EOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs.  It is not useful on other systems.
+# If it contains results you don't want to keep, you may remove or edit it.
+#
+# By default, configure uses ./config.cache as the cache file,
+# creating it if it does not exist already.  You can give configure
+# the --cache-file=FILE option to use a different cache file; that is
+# what configure does when it calls configure scripts in
+# subdirectories, so they share the cache.
+# Giving --cache-file=/dev/null disables caching, for debugging configure.
+# config.status only pays attention to the cache file if you give it the
+# --recheck option to rerun configure.
+#
+EOF
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(set) 2>&1 |
+  case `(ac_space=' '; set | grep ac_space) 2>&1` in
+  *ac_space=\ *)
+    # `set' does not quote correctly, so add quotes (double-quote substitution
+    # turns \\\\ into \\, and sed turns \\ into \).
+    sed -n \
+      -e "s/'/'\\\\''/g" \
+      -e "s/^\\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\\)=\\(.*\\)/\\1=\${\\1='\\2'}/p"
+    ;;
+  *)
+    # `set' quotes correctly as required by POSIX, so do not add quotes.
+    sed -n -e 's/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=${\1=\2}/p'
+    ;;
+  esac >> confcache
+if cmp -s $cache_file confcache; then
+  :
+else
+  if test -w $cache_file; then
+    echo "updating cache $cache_file"
+    cat confcache > $cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# Any assignment to VPATH causes Sun make to only execute
+# the first set of double-colon rules, so remove it if not needed.
+# If there is a colon in the path, we need to keep it.
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
+fi
+
+trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
+
+DEFS=-DHAVE_CONFIG_H
+
+# Without the "./", some shells look in PATH for config.status.
+: ${CONFIG_STATUS=./config.status}
+
+echo creating $CONFIG_STATUS
+rm -f $CONFIG_STATUS
+cat > $CONFIG_STATUS <<EOF
+#! /bin/sh
+# Generated automatically by configure.
+# Run this file to recreate the current configuration.
+# This directory was configured as follows,
+# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+#
+# $0 $ac_configure_args
+#
+# Compiler output produced by configure, useful for debugging
+# configure, is in ./config.log if it exists.
+
+ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
+for ac_option
+do
+  case "\$ac_option" in
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
+    exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
+  -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
+    echo "$CONFIG_STATUS generated by autoconf version 2.13"
+    exit 0 ;;
+  -help | --help | --hel | --he | --h)
+    echo "\$ac_cs_usage"; exit 0 ;;
+  *) echo "\$ac_cs_usage"; exit 1 ;;
+  esac
+done
+
+ac_given_srcdir=$srcdir
+ac_given_INSTALL="$INSTALL"
+
+trap 'rm -fr `echo "autoconf/Make.common \
+Makefile \
+doc/Makefile \
+src/Makefile \
+src/graphics/Makefile \
+src/rsizes.h \
+rclock/Makefile \
+doc/yodl/rxvt.yo \
+doc/yodl/rxvtRef.yo \
+ config.h:autoconf/config.h.in" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+# Protect against being on the right side of a sed subst in config.status.
+sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
+ s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
+$ac_vpsub
+$extrasub
+s%@SHELL@%$SHELL%g
+s%@CFLAGS@%$CFLAGS%g
+s%@CPPFLAGS@%$CPPFLAGS%g
+s%@CXXFLAGS@%$CXXFLAGS%g
+s%@FFLAGS@%$FFLAGS%g
+s%@DEFS@%$DEFS%g
+s%@LDFLAGS@%$LDFLAGS%g
+s%@LIBS@%$LIBS%g
+s%@exec_prefix@%$exec_prefix%g
+s%@prefix@%$prefix%g
+s%@program_transform_name@%$program_transform_name%g
+s%@bindir@%$bindir%g
+s%@sbindir@%$sbindir%g
+s%@libexecdir@%$libexecdir%g
+s%@datadir@%$datadir%g
+s%@sysconfdir@%$sysconfdir%g
+s%@sharedstatedir@%$sharedstatedir%g
+s%@localstatedir@%$localstatedir%g
+s%@libdir@%$libdir%g
+s%@includedir@%$includedir%g
+s%@oldincludedir@%$oldincludedir%g
+s%@infodir@%$infodir%g
+s%@mandir@%$mandir%g
+s%@VERSION@%$VERSION%g
+s%@DATE@%$DATE%g
+s%@LSMDATE@%$LSMDATE%g
+s%@CC@%$CC%g
+s%@CPP@%$CPP%g
+s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
+s%@INSTALL_SCRIPT@%$INSTALL_SCRIPT%g
+s%@INSTALL_DATA@%$INSTALL_DATA%g
+s%@MV@%$MV%g
+s%@RM@%$RM%g
+s%@CP@%$CP%g
+s%@SED@%$SED%g
+s%@AWK@%$AWK%g
+s%@ECHO@%$ECHO%g
+s%@CMP@%$CMP%g
+s%@TBL@%$TBL%g
+s%@X_CFLAGS@%$X_CFLAGS%g
+s%@X_PRE_LIBS@%$X_PRE_LIBS%g
+s%@X_LIBS@%$X_LIBS%g
+s%@X_EXTRA_LIBS@%$X_EXTRA_LIBS%g
+s%@XPM_CPPFLAGS@%$XPM_CPPFLAGS%g
+s%@XPM_CFLAGS@%$XPM_CFLAGS%g
+s%@XPM_LIBS@%$XPM_LIBS%g
+s%@rxvt_int16_typedef@%$rxvt_int16_typedef%g
+s%@rxvt_u_int16_typedef@%$rxvt_u_int16_typedef%g
+s%@rxvt_int32_typedef@%$rxvt_int32_typedef%g
+s%@rxvt_u_int32_typedef@%$rxvt_u_int32_typedef%g
+s%@rxvt_int64_typedef@%$rxvt_int64_typedef%g
+s%@rxvt_u_int64_typedef@%$rxvt_u_int64_typedef%g
+s%@rxvt_intp_define@%$rxvt_intp_define%g
+s%@rxvt_u_intp_define@%$rxvt_u_intp_define%g
+s%@PTYS_ARE_NUMERIC@%$PTYS_ARE_NUMERIC%g
+s%@PTYS_ARE_PTMX@%$PTYS_ARE_PTMX%g
+s%@PTYS_ARE_SEARCHED@%$PTYS_ARE_SEARCHED%g
+s%@PTYS_ARE_PTC@%$PTYS_ARE_PTC%g
+s%@PTYS_ARE__GETPTY@%$PTYS_ARE__GETPTY%g
+s%@PTYS_ARE_GETPTY@%$PTYS_ARE_GETPTY%g
+s%@PTYS_ARE_GETPT@%$PTYS_ARE_GETPT%g
+s%@PTYS_ARE_CLONE@%$PTYS_ARE_CLONE%g
+s%@DEBUG@%$DEBUG%g
+s%@DLIB@%$DLIB%g
+s%@DINCLUDE@%$DINCLUDE%g
+/@MCOMMON@/r $MCOMMON
+s%@MCOMMON@%%g
+
+CEOF
+EOF
+
+cat >> $CONFIG_STATUS <<\EOF
+
+# Split the substitutions into bite-sized pieces for seds with
+# small command number limits, like on Digital OSF/1 and HP-UX.
+ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
+ac_file=1 # Number of current file.
+ac_beg=1 # First line for current file.
+ac_end=$ac_max_sed_cmds # Line after last line for current file.
+ac_more_lines=:
+ac_sed_cmds=""
+while $ac_more_lines; do
+  if test $ac_beg -gt 1; then
+    sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
+  else
+    sed "${ac_end}q" conftest.subs > conftest.s$ac_file
+  fi
+  if test ! -s conftest.s$ac_file; then
+    ac_more_lines=false
+    rm -f conftest.s$ac_file
+  else
+    if test -z "$ac_sed_cmds"; then
+      ac_sed_cmds="sed -f conftest.s$ac_file"
+    else
+      ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
+    fi
+    ac_file=`expr $ac_file + 1`
+    ac_beg=$ac_end
+    ac_end=`expr $ac_end + $ac_max_sed_cmds`
+  fi
+done
+if test -z "$ac_sed_cmds"; then
+  ac_sed_cmds=cat
+fi
+EOF
+
+cat >> $CONFIG_STATUS <<EOF
+
+CONFIG_FILES=\${CONFIG_FILES-"autoconf/Make.common \
+Makefile \
+doc/Makefile \
+src/Makefile \
+src/graphics/Makefile \
+src/rsizes.h \
+rclock/Makefile \
+doc/yodl/rxvt.yo \
+doc/yodl/rxvtRef.yo \
+"}
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
+
+  # Remove last slash and all that follows it.  Not all systems have dirname.
+  ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+  if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+    # The file is in a subdirectory.
+    test ! -d "$ac_dir" && mkdir "$ac_dir"
+    ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
+    # A "../" for each directory in $ac_dir_suffix.
+    ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
+  else
+    ac_dir_suffix= ac_dots=
+  fi
+
+  case "$ac_given_srcdir" in
+  .)  srcdir=.
+      if test -z "$ac_dots"; then top_srcdir=.
+      else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
+  /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
+  *) # Relative path.
+    srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
+    top_srcdir="$ac_dots$ac_given_srcdir" ;;
+  esac
+
+  case "$ac_given_INSTALL" in
+  [/$]*) INSTALL="$ac_given_INSTALL" ;;
+  *) INSTALL="$ac_dots$ac_given_INSTALL" ;;
+  esac
+
+  echo creating "$ac_file"
+  rm -f "$ac_file"
+  configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
+  case "$ac_file" in
+  *Makefile*) ac_comsub="1i\\
+# $configure_input" ;;
+  *) ac_comsub= ;;
+  esac
+
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  sed -e "$ac_comsub
+s%@configure_input@%$configure_input%g
+s%@srcdir@%$srcdir%g
+s%@top_srcdir@%$top_srcdir%g
+s%@INSTALL@%$INSTALL%g
+" $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
+fi; done
+rm -f conftest.s*
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
+ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
+ac_dC='\3'
+ac_dD='%g'
+# ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
+ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_uB='\([ 	]\)%\1#\2define\3'
+ac_uC=' '
+ac_uD='\4%g'
+# ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_eB='$%\1#\2define\3'
+ac_eC=' '
+ac_eD='%g'
+
+if test "${CONFIG_HEADERS+set}" != set; then
+EOF
+cat >> $CONFIG_STATUS <<EOF
+  CONFIG_HEADERS="config.h:autoconf/config.h.in"
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+fi
+for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  echo creating $ac_file
+
+  rm -f conftest.frag conftest.in conftest.out
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  cat $ac_file_inputs > conftest.in
+
+EOF
+
+# Transform confdefs.h into a sed script conftest.vals that substitutes
+# the proper values into config.h.in to produce config.h.  And first:
+# Protect against being on the right side of a sed subst in config.status.
+# Protect against being in an unquoted here document in config.status.
+rm -f conftest.vals
+cat > conftest.hdr <<\EOF
+s/[\\&%]/\\&/g
+s%[\\$`]%\\&%g
+s%#define \([A-Za-z_][A-Za-z0-9_]*\) *\(.*\)%${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD}%gp
+s%ac_d%ac_u%gp
+s%ac_u%ac_e%gp
+EOF
+sed -n -f conftest.hdr confdefs.h > conftest.vals
+rm -f conftest.hdr
+
+# This sed command replaces #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+cat >> conftest.vals <<\EOF
+s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
+EOF
+
+# Break up conftest.vals because some shells have a limit on
+# the size of here documents, and old seds have small limits too.
+
+rm -f conftest.tail
+while :
+do
+  ac_lines=`grep -c . conftest.vals`
+  # grep -c gives empty output for an empty file on some AIX systems.
+  if test -z "$ac_lines" || test "$ac_lines" -eq 0; then break; fi
+  # Write a limited-size here document to conftest.frag.
+  echo '  cat > conftest.frag <<CEOF' >> $CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.vals >> $CONFIG_STATUS
+  echo 'CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+' >> $CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.vals > conftest.tail
+  rm -f conftest.vals
+  mv conftest.tail conftest.vals
+done
+rm -f conftest.vals
+
+cat >> $CONFIG_STATUS <<\EOF
+  rm -f conftest.frag conftest.h
+  echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
+  cat conftest.in >> conftest.h
+  rm -f conftest.in
+  if cmp -s $ac_file conftest.h 2>/dev/null; then
+    echo "$ac_file is unchanged"
+    rm -f conftest.h
+  else
+    # Remove last slash and all that follows it.  Not all systems have dirname.
+      ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+      if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+      # The file is in a subdirectory.
+      test ! -d "$ac_dir" && mkdir "$ac_dir"
+    fi
+    rm -f $ac_file
+    mv conftest.h $ac_file
+  fi
+fi; done
+
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+
+exit 0
+EOF
+chmod +x $CONFIG_STATUS
+rm -fr confdefs* $ac_clean_files
+test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
+
+
+echo "Configuration:
+
+  Rxvt version:               ${VERSION} : ${DATE}
+  Source code location:       ${srcdir}
+  Install path:               ${prefix}/bin
+  Compiler:                   ${CC}
+  Compiler flags:             ${CFLAGS}"
+
+if test "$MALLOC_TYPE" = S; then
+  echo "  malloc support:             system default"
+fi
+if test "$MALLOC_TYPE" = G; then
+  echo "  malloc support:             Gray Watson's dmalloc"
+fi
+if test "$MALLOC_TYPE" = D; then
+  echo "  malloc support:             Doug Lea's malloc"
+fi
+if test x${xpm_background} = xyes; then
+  echo "  Xpm library:                ${XPM_LIBS}"
+fi
+
+echo "
+The following are set in config.h
+"
+echo "  pty/tty type:               "${rxvt_cv_ptys}
+if test x${utmp_support} != xyes; then
+  echo "  utmp support:               disabled
+"
+else
+  echo "  utmp support:               enabled
+  utmp file:                  ${rxvt_cv_path_utmp}
+  utmpx file:                 ${rxvt_cv_path_utmpx}
+  wtmp file:                  ${rxvt_cv_path_wtmp}
+  wtmpx file:                 ${rxvt_cv_path_wtmpx}
+  ttys/ttytab file:           ${rxvt_cv_path_ttytab}
+"
+fi
+if test x${term} != x; then
+  echo "  set TERM to:                ${term}
+"
+fi
+if test x${terminfo} != x; then
+  echo "  set TERMINFO to:            ${terminfo}
+"
+fi
+if test x${rxvt_cv_ptys} = xUNKNOWN; then
+  echo ".----------------------------------------------------------------."
+  echo ". WARNING: could not determine tty/pty type.  Do not build until ."
+  echo ".          the appropriate PTYS_ARE_* is defined in config.h     ."
+  echo ".----------------------------------------------------------------."
+fi
+if test x${xpm_background} = xneedsmanualspecification; then
+  echo ".----------------------------------------------------------------."
+  echo ". WARNING: --enable-xpm-background was specified, however the    ."
+  echo ".          XPM includes files and libraries could not be found.  ."
+  echo ".          XPM backgrounds are now being DISABLED!  If you want  ."
+  echo ".          to use them you should rerun   configure   with the   ."
+  echo ".          appropriate --with-xpm-includes=/path/to/xpm/includes ."
+  echo ".          and --with-xpm-library=/path/to/xpm/library lines.    ."
+  echo ".----------------------------------------------------------------."
+fi
+echo "  *** Please check src/feature.h for further options ***
+"
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/BUGS work/main.d/rxvt-2.6.4/doc/BUGS
--- tmp/rxvt-2.6.4/doc/BUGS	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/BUGS	2000-07-14 02:29:35.000000000 -0300
@@ -0,0 +1,25 @@
+                              === Rxvt BUGS ===
+
+Please send all bugs you have conceived and they are not listed here to 
+     rxvt-bugs@rxvt.org
+
+   O v e r v i e w 
+   ---------------
+
+  1) swap screen selection
+  2) inheritPixmap/transparency
+
+
+1) swap screen selection
+
+	mason: Sometimes selection fails after or in swap screen use
+	mason: I haven't seen this lately (Nov 98).  May have been fixed
+		as part of another fix?
+
+2) inheritPixmap/transparency
+
+	rxvt currently modifies parent windows to have inherited pixmaps,
+	down to the root window.  A non-blank parent window which relied on
+	its background colour, even outside the rxvt area, may look
+	strange/corrupt.  This is being/will be addressed in 2.7.5 or
+	later.
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/changes.txt work/main.d/rxvt-2.6.4/doc/changes.txt
--- tmp/rxvt-2.6.4/doc/changes.txt	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/changes.txt	2001-11-01 21:19:24.000000000 -0300
@@ -0,0 +1,1490 @@
+2.6.3 to 2.6.4
+\-----------------------------------
+Geoff Wing <gcw@pobox.com>  et al.
+	fixed Meta key detection - has priority over Alt, noticed by
+		Paul D. Smith <psmith@baynetworks.com>
+	fixed timeout in select() call when unmapped, noticed by
+		Tore Bjorkeli <tore.bjorkeli@runit.no>
+	fixed query of locale ("Setting locale failed.") when locale is set
+	fixed default icon name, noticed by
+		Jeremy C. Reed <reed@wcug.wwu.edu>
+	fixed setting of icon name with -e argument, noticed by
+		John Waggenspack <John_Waggenspack@adc.com>
+	fixed autowrap bug when restoring cursor from last column, noticed by
+		witek@mat.uni.torun.pl
+	fixed a possible buffer overflow problem, noticed by
+		Samuel Dralet <samuel.dralet@mastersecurity.fr>
+
+2.6.2 to 2.6.3
+\-----------------------------------
+Geoff Wing <gcw@pobox.com>  et al.
+	fixed problems on Solaris with --enable-xim, noticed by
+		Mike Miller <mbmiller@taxa.psyc.missouri.edu>
+	added -xrm option to accept dummy invocation arguments, from
+		Christian W. Zuckschwerdt <zany@triq.net>
+		& Chris Green <cgreen@matthaak.com>
+	fixed documentation for options: -tr, -ic, -pt, -im, -mod, -xrm;
+		and resources: scrollBar_right, scrollBar_floating,
+		scrollTtyOutput, scrollTtyKeypress, preeditType, inputMethod,
+		modifier.
+	fixed some compile problems.  no Xlocale with XIM specified;
+		s/STRLEN/strlen/; s/RXVT_WTMP_FILE/RXVT_REAL_WTMP_FILE/
+	added MAX_COLS & MAX_ROWS in feature.h to limit columns/rows on resize
+	changed feature.h LOCAL_X_IS_UNIX (currently needed by some Irix
+		systems) to be off by default
+	fixed scrollTtyKeypress not active for all keypresses, noticed by
+		Reuben Thomas <Reuben.Thomas@cl.cam.ac.uk>
+	fixed allocation of new lines to not set underline information, noticed
+		by Brian Mays <brian@debian.org>
+
+2.6.1 to 2.6.2
+\-----------------------------------
+Geoff Wing <gcw@pobox.com>  et al.
+	fixed detection of struct utmpx, noticed by
+		Paul 'TBBle' Hampson <Paul.Hampson@Pobox.Com>
+	fixed -si/+si option, noticed by
+		Thomas Lofgren <tlofgren@cup.hp.com>
+	fixed some character display permutations
+	fixed variable name in selection_paste and thus handle large pastes
+		again, noticed by Dominik Vogt <dominik.vogt@gmx.de>
+	added paste even if conversion to locale fails
+	fixed scrollbar jumping to top when slider reaches bottom
+
+Jim Knoble <jmknoble@pobox.com>
+	fixed scrollbar slider jitter
+	added named constants for scrollbar calculations
+
+Jun Morimoto <morimoto@xantia.citroen.org>
+	added basic argument checking for rclock to detect missing arguments
+
+Tung-Han Hsieh <thhsieh@linux.org.tw>
+	fixed configure notify bypass checking for self window configurations
+	fixed empty paste coredump with MULTICHAR_SET
+
+Oskar Liljeblad <osk@hem.passagen.se>
+	added SCROLL_ON_UPDOWN_KEYS to feature.h to allow scrollback via
+		(shift|meta|ctrl) modifier and up/down keys, default off
+		for backwards compatibility
+
+2.6.0 to 2.6.1
+\-----------------------------------
+
+Geoff Wing <gcw@pobox.com>  et al.
+	fixed setting of tty permission/ownership with grantpt(). ie. don't.
+	fixed configure for some systems
+	changed a timeout to previous setting thus giving smoother scrolling
+	fixed reversed --scrollTtyOutput (noticed (this time) by
+		Thomas Lofgren <lofgren@sics.se>)
+	fixed offset for writing into BSD utmp file
+	added seperate cursor save/restore information for secondary screen
+	fixed CSI cursor movement
+	fixed typos causing compile failure - reported by various
+	fixed UNSHIFTED_SCROLLKEYS
+
+Mike Hopkirk (Hops) <hops@sco.COM>
+	fixed SB_BORDER scrollbar delineator
+
+2.6.PRE3 to 2.6.0
+\-----------------------------------
+
+Geoff Wing <gcw@pobox.com>  et al.
+	fixed configure for many systems
+
+Ha Shao <hashao@china.com>
+	added support for ZH_CN (GB2312) fonts and encoding.
+
+2.6.PRE2 to 2.6.PRE3
+\-----------------------------------
+
+Geoff Wing <gcw@pobox.com>
+	fixed several OOB memory accesses and leaks (mostly found by
+		Rob Somerville <somervil@cadvision.com>)
+	added shift up/down arrows a la shift prior/next
+	added SCROLL_ON_SHIFT, SCROLL_ON_META, SCROLL_ON_CTRL to feature.h
+
+Vaughn Cato <vcato@bellsouth.net>
+	fixed jerky selection for some people (esp. Linux)
+
+Peter H. Chou <pchou@leland.Stanford.EDU>
+	fixed floating scrollbar (trough) to not affect NeXT scrollbar 
+
+MANTANI Nobutaka <nobutaka@nobutaka.com>
+	fixed two problems on X Input Method: 1) Can't display preedit area
+		in "OverTheSpot" input style with some input methods.
+		2) The location of preedit area in "OffTheSpot" input style
+		is wrong.
+
+Yasuda Tsutomu <_tom_@sf.airnet.ne.jp>
+	fixed some multichar set (Kanji) selection
+	added better selection request type conversion
+
+2.6.PRE1 to 2.6.PRE2
+\-----------------------------------
+
+Geoff Wing <gcw@pobox.com>
+	fixed declaration position for COLORFGBG env var - really fixed this
+		time (noticed by Rob Somerville <somervil@cadvision.com>)
+	fixed transparent term reparenting/configure issues
+	fixed some documentation (noticed by
+		Richard Browne <richb@timestone.com.au>)
+
+MANTANI Nobutaka <nobutaka@nobutaka.com>
+	added XIM (X Input Method) enhancements
+	added input of multibyte characters with XIM (X Input Method)
+		enhancements via input styles "OverTheSpot",
+		"OffTheSpot" and "Root"
+	added configure option --enable-xim
+	added resources "inputMethod" (-im), "preeditType" (-pt)
+	changed configure to search for libxpg4, needed for FreeBSD's
+		setlocale()
+
+2.4.10 to 2.6.PRE1
+\-----------------------------------
+
+Geoff Wing <gcw@pobox.com>
+	fixed scrollbar slider drawing to have a minimum size (noticed by
+		Brian Korver <briank@cs.stanford.edu>)
+	fixed backward #ifdef's on JUMP_MOUSE_WHEEL
+	fixed coredump on paste after terminal reset
+	fixed bad marking on selection with old selection (noticed by
+		Paul Slootman <paul@wau.mis.ah.nl>)
+	fixed bad cursor colour setting (noticed by
+		Louis-David Mitterrand <mito@aparima.com>)
+	fixed octal recognition from strings (hopefully no-one noticed)
+	fixed proto generation awk script (noticed by
+		Paul D. Smith <psmith@BayNetworks.COM>)
+	changed distribution to include protos, for bad systems
+	added configure check for XPointer (needed for SunOS; comments by
+		Moritz Barsnick <barsnick@gmx.net>)
+	fixed export of COLORFGBG (noticed by
+		Moritz Barsnick <barsnick@gmx.net>)
+
+Alfredo K. Kojima <kojima@windowmaker.org>
+	changed NEXT_SCROLLBAR code to produce real NEXTSTEP scrollers
+	added inheritPixmap support - terminal window uses parent pixmap
+
+Sasha Vasko <sashav@sprintmail.com>
+	fixed handling of background change via property _XROOTPMAP_ID
+
+2.4.9 to 2.4.10
+\-----------------------------------
+
+Geoff Wing <gcw@pobox.com>
+	fixed screen refreshing - significant reduction of XDrawString() et al
+		calls in many cases leading to large speed increase,
+		especially for remote X clients
+	fixed source code const stuff
+	fixed DISPLAY_IS_IP feature
+	changed window creation, menubar reading, etc. order and removed one of
+		my earlier hacks
+	changed configure to be less extreme about X libs
+
+2.4.8 to 2.4.9
+\-----------------------------------
+
+Geoff Wing <gcw@pobox.com>
+	changed screen allocation to be safer
+	added several xterm style window operations and reports DEC style
+		escape sequences
+	fixed handling of some DEC style escape sequences
+	fixed menubar display
+	fixed outline cursor removal
+	fixed clear selection when writing within a selection
+	added resources to handle backspace and delete
+	changed source code organisation again - also be nicer when making
+		in a different directory
+	added probe of ModifierMapping for Meta/Alt and NumLock keys
+	removed resource to set Meta/Alt key
+	added support to allow compilation of both old and new selection
+		styles
+	changed internals - allocate rs_* as rs[Rs_*]
+
+Stanislav Meduna <stano@trillian.eunet.sk>
+	fixed checking of Xsetlocale(), setlocale() in configure
+
+2.4.7 to 2.4.8
+\-----------------------------------
+
+Geoff Wing <gcw@pobox.com>
+	fixed XPM handling of position in geometry
+	changed XPM tiling to have the X server tile in the basic case
+	moved several configuration options from feature.h to configure
+	fixed introduced pixel dropping bug when RS_DIRTY was removed
+	added `troughColor' resource - the original patch written by
+		Reid D Rivenburgh (noted below) was lost and never added
+	fixed border pixel colour - if not set, use foreground not background
+	fixed handling of cursorColor/cursorColor/colorBD/colorUL to always
+		use the _current_ fg/bg colours appropriately if unset
+	changed source code organisation - moved some things into screen.h -
+		to allow other add-ons to access screen structures without
+		including all of rxvt.h
+	changed internals - ripped out RS_Cursor/RS_Select to make basic
+		multichar sets (not Kanji/Big5) always enabled - thus handle
+		selection and cursor display differently
+	fixed bug on scroll lines affecting selection
+	changed rmemset to use a type which is the same size as an (int *) -
+		based on comments by Paul Slootman <paul@wurtel.demon.nl>
+	fixed pointer colour change on default fg colour change
+	changed handling of backspace/delete keys - if not disabled during
+		./configure then settable via resources - defaults similar
+		to previous
+
+2.4.6 to 2.4.7
+\-----------------------------------
+
+Geoff Wing <gcw@pobox.com>
+	moved several configuration options from feature.h to configure
+	added configure option to use system memset()
+	added support for no multichar sets to allow 2 byte rendition type
+	changed rmemset for slightly more optimised execution
+	changed source code organisation slightly
+
+Guillaume Laurent <glaurent@worldnet.fr>
+	added Meta modifier selectable via resource ``modifier''
+
+John E. Davis <davis@space.mit.edu>
+	added print mode to accept ESC sequence variation
+
+2.4.5 to 2.4.6
+\-----------------------------------
+
+Geoff Wing <gcw@pobox.com>
+	merged support for Big5 & Kanji.
+	changed short option: fk --> fm
+	changed long options: kfont/cfont --> mfont
+	changed long option: kanji_encoding --> multichar_encoding
+	changed font list in feature.h - user define list of fonts
+	fixed configure check for Xlocale()
+	added configure option --enable-dmalloc (Gray Watson's malloc)
+	added configure option --enable-dlmalloc (Doug Lea's malloc)
+	added support for Cygnus Solution's GNU-Win32 extensions (b18 tested)
+	fixed utmp/wtmp handling on machines with updwtmpx()
+	added support for old rxvt style selection - OLD_SELECTION
+	changed define of struct screen_t to rxvt.h
+	changed internal handling of bold overstrike pixel dropping - prescan
+	      line
+	changed internal handling of selection mechanism to properly support
+	      multiple methods - and optimized
+	changed internal handling of selection sync'ing - and optimized
+	added assert()s via DEBUG_STRICT define to catch some possible bugs
+	fixed scrollbar colour on mono displays
+	changed privilege revocation to before we do anything
+	fixed selection clearing when across the screen boundary and we swap
+	      screens
+	fixed resize / screen refresh order when changing scrollbar display
+	fixed font handling when we're given  per_char of NULL
+	changed internal handling of row width - maximum line length is now
+	      bound by a short - not enforced
+	changed rxvt.1 and refer.html to yodl source
+	
+Bruce Stephens <bruce@cenderis.demon.co.uk>
+	added support for buttons 4 and 5 (eg. on a mouse with wheel) to
+	      scroll screen
+
+Frank Chen Hsiung Chan <frankch@life.nthu.edu.tw>
+	fixed clash of use of BIG5 as define and enum.  Also typo fix.
+
+John Eikenberry <jae@ai.uga.edu>
+	added window_group use to window manager properties
+	added NeXT scrollbar style - group up and down buttons together
+
+Denis N. Antonioli <antonio@ifi.unizh.ch>
+	fixed setting of application icon name and title
+
+Adam Spiers <adam@thelonious.new.ox.ac.uk>
+	fixed enumeration of *.keysym.* in resources
+
+
+2.4.4 to 2.4.5 *_Official Release_*
+\-----------------------------------
+
+Geoff Wing <gcw@pobox.com>
+	changed the approach at the Boldoverstrike-Pixeldroppings front
+	temporarily fixed a bug in the exposure handling
+	added the --enable-ttygid
+	
+Oezguer Kesim <kesim@math.fu-berlin.de>
+	switched rxvt licence to GPL
+	changed copyrights of the modules
+	fixed the terminfo/termcap entries
+
+Mark Olesen <olesen@me.queensu.ca>
+	FINALLY added Double-Click mouse reporting.  Uses the upper bits
+	of the Button character for X11 reporting so should cause no 
+	compatibility problems.
+	     * State = (<b> - SPACE) & 60
+		4    = Shift
+		8    = Meta
+		16   = Control
+		32   = Double Click (Rxvt extension)
+	NOTE: no Release is reported after a double-click and the
+	Release for the first click of a double-click is not reported.
+	This also means the Release event of a very fast click/release
+	won't be reported.
+
+2.4.3 to 2.4.4
+\-----------------------------------
+
+Geoff Wing <mason@primenet.com.au>
+	fixed a bug in the selection mechanism
+
+Oezguer Kesim <kesim@math.fu-berlin.de>
+	fixed the fontchange-windowresize-racecondition-bug (thanks Geoff!)
+	fixed the broken console-support under solaris
+	added a new terminfo entry for rxvt, based on the one which comes
+	      with ncurses (thanks Larry!)
+	some changes on aclocal.m4 and configure
+	removed the XTERM_COLOR_TERM option from feature.h - use
+	      --with-term=NAME instead
+	updated the man-page
+
+Kikutani Makoto <kikutani@jdc.ericsson.se>
+	fixed a bug when copy&paste with kanji
+
+Paul D. Smith <psmith@BayNetworks.COM>
+	fixed a bug which prevented rxvt to compile when configured with
+	      --enable-xterm-scroll
+
+2.4.2 to 2.4.3
+\-----------------------------------
+
+Geoff Wing <mason@primenet.com.au>
+	fixed a bug in scrolling lots of text
+	more work on avoiding the pixel droppings
+	further cleanups
+
+Oezguer Kesim <kesim@math.fu-berlin.de>
+	some changes on the configure script
+
+Frank Chen Hsiung Chan <frankch@waru.life.nthu.edu.tw>
+	added experimental big5 support
+
+Reid D Rivenburgh <reid@lanl.gov>
+	added the "troughColor" resource
+
+Mike Hopkirk (Hops) <hops@sco.COM>
+	added support of SCO OSr5 pty naming (also UW SysVr5)
+        correction of pty hang with large paste buffer
+            (happens on on all tested platforms)
+        fixed Weird default scroll thumb behaviour
+        fixed incorrect setting of WM_COMMAND if specified with -e switch
+        fixed # of lines of context between screen pages (Shift-Prior/Next)
+        Visual delineation of Scrollbar and vt wdw with dark internal border    
+
+2.4.1 to 2.4.2
+\-----------------------------------
+
+Geoff Wing <mason@primnet.com.au>
+	new anti-bold-overstrike-pixel-dropping (plan 3)
+
+Oezguer Kesim <kesim@math.fu-berlin.de>
+	fixed a bug which caused rxvt to dump core after resizing and
+	      selecting
+
+2.4.0 to 2.4.1
+\-----------------------------------
+
+Geoff Wing  <mason@primnet.com.au>
+	added --with-xpm-{include,library} to autoconf/a4local.m4
+	added VERYBOLD feature
+	fixed some misspelling in autoconf/configure.in
+	added `DEC private modes' 1010 and 1011 for scroll-to-bottom on
+	      TTY output inhibit and scroll-to-bottom on keypress
+	      together with resources and switches
+	fixed Bold Overstrike Pixel Dropping (Yes Sir!)
+	fixed a bug in scr_E()
+	fixed ^[[*J behaviour - clear to end, clear to beginning, clear
+	      whole screen was broken
+
+Oezguer Kesim <kesim@math.fu-berlin.de>
+	removed DONT_GUESS_BACKSPACE. Instead, you may define either
+	        FORCE_BACKSPACE or FORCE_DELETE or leave both undefined
+		in order to get ^H, ^? or the current stty settings for
+		'erase'
+	fixed positioning of text in the top menubar.
+	fixed some missing #define's
+	fixed conditions for MONO_BOLD in scr_refresh() to make 
+	      VERYBOLD work.
+
+Christoph L. Spiel <Christoph_Spiel@physik.tu-muenchen.de>
+	fixed usage of KEYSYM_RESOURCE only when NO_RESOURCES is
+	      *not* defined
+	
+Paul Slootman <paul@wau.mis.ah.nl>
+	added a few XK_KP_* ifdef's in order to get rxvt work with X11R4
+
+
+Major changes from 2.21b* to 2.4.0
+\-----------------------------------
+
+Geoff Wing  <mason@primenet.com.au>
+	screen.c rewritten with changes including:
+		internal management of screen lines changed
+		rmemset() used as a fast memset() replacement
+		selection now the same as XTerm selection
+		several Kanji display fixes
+		Kanji properly selectable for EUC JP encoding
+	added continuous scrolling with scrollbar buttons
+	fixed colours when using XPM background pixmaps smaller than the window
+	added resources -sr/+sr, -st/+st
+	fixed application Cursor Keys
+	added many configure enhancements
+	added delimiting line between XTerm scrollbars as per XTerm
+	fixed utmp support
+	added minimal support for proportional fonts
+	added integrated use for Gray Watson's dmalloc package
+	added automatic prototype generation via src/makeprotos-sed
+
+Grant McDorman  <grant@isgtec.com>
+	added PREFER_24BIT: if the screen is 24 bit, then use 24 bit windows
+	      even if default is 8 bit
+	fixed utmpx support
+	added handling for Keypad left/right/up/down, etc.
+	added META8_OPTION for all function keys
+	added RXVT_TERMINFO for setting TERMINFO
+	fixed some bugs in menubar
+	added expanded keysym support
+
+Paul D. Smith  <psmith@BayNetworks.COM>
+	fixed title setting
+	fixed for building in other directories
+	added pointerColor for changing pointer colour
+	added borderColor for changing border line colour in XTerm scrollbar
+
+
+2.21a3 to 2.21b*
+\---------------
+     1. From: Conrad Link <conrad@akira.resnet.rochester.edu>
+	Fixed a bug in the OffiX Drag and Drop support.
+	rxvt inserted two instances of directories or links when they 
+	were dropped onto rxvt.
+	
+     2. From: <aner@zenith.att.com>
+	Fixed a bug that makes rxvt getting constantly "NoExpose" events
+	which it is not handling.
+
+     3. From: Mark Olesen <olesen@weber.me.queensu.ca>
+	Fixed a bug that caused rxvt to hang indefinitly waiting for a 
+	terminating ^G on an XTerm `ESC]' sequence.
+
+     4. From: Bernard PERROT <perrot@lal.in2p3.fr>
+	      Mark Olesen <olesen@weber.me.queensu.ca>
+	Fixed a bug that prevented to handle DEC VT2xx's ApLineDel correctly
+
+     5. From: <vikas@insight.att.com>
+	      Mark Olesen <olesen@weber.me.queensu.ca>
+	Now the Shift/Ctrl cursor key mappings are enabled regardless of
+	App-Cursor settings
+
+     6. From: Kai Petzke <wpp@mail.physik.TU-Berlin.DE>
+	Fixed a bug with respect to cursor movement. rxvt now handles the
+	'G' and 'd' sequences correctly
+
+     7. From: Geoff Wing <mason@primenet.com.au>
+	Fixed a couple of things in utmp.c 
+
+     8. From: Denis N. Antonioli <antonio@ifi.unizh.ch>
+	Added the "-tn" option and corresponding Xresource variable "termcap".
+	This option specifies the name of the terminal type to be set in the
+	TERM environment variable. 
+
+2.20 to 2.21a*
+\-------------
+     1.	Oops, forgot to include time headers in menubar.c
+
+     2.	Finally got the correct DEC sequence to toggling the behaviour
+	of the backspace key and removed the other non-standard ones.
+	If anyone has a listing of DEC escape sequences they'd like to
+	donate ...
+
+     3.	Fixed a bug that prevented an XPM file from being found if it
+	were specified with an absolute path and a geometry string.
+	Made the default scaling zero (tiled) since this is by far the
+	most popular use.
+
+     4.	The Motif-style scrollbar is back as a compile-time option.
+
+     5.	Added BUGS file and (thankfully) moved coordination of the
+	project to Oezguer Kesim <kesim@math.fu-berlin.de> who also
+	has a mailing list for rxvt development
+
+	Rxvt Workers <rxvt-workers@math.fu-berlin.de>
+
+	To subscribe to the list send email to
+	<rxvt@math.fu-berlin.de> with the body: subscribe
+
+     6.	Semi-retirement and finish my thesis ... bye for now - /mark
+
+   --- Oezguer started working on rxvt
+
+     7. Fixed a bug in the new menubar-feature. There were several unchecked
+	strings strcpy'ed which caused rxvt immediately to dump core.
+
+     8. From: Robert Bihlmeyer <robbe@orcus.priv.at>
+        Fixed a bug in rclock.c which prevented it to compile correctly.
+
+     9. From: Mark Olesen <olesen@weber.me.queensu.ca>
+        Overstrike boldfonts and pixmaps now work together without pixel
+        droppings on the screen (at least under Linux).
+
+    10. From: Mark Olesen <olesen@weber.me.queensu.ca>
+	Modified autoconf support: memmove() replacement function
+	supplied for those systems that need it, libXpm should now be
+	correctly found (set in src/Makefile *not* in config.h)
+
+    11.	From: Mark Olesen <olesen@weber.me.queensu.ca>
+	Converted doc/rxvt.ref to HTML format.
+		doc/html/refer.html = master copy
+		doc/refer.txt  = text version saved using Netscape.
+
+	All HTML documents are put in here, to ease installation
+	elsewhere.
+
+    12.	From: Mark Olesen <olesen@weber.me.queensu.ca>
+	Moved some file search function from main.c and some string
+	functions from xdefaults.c to misc.c.
+
+	Changed the implementation details so that `keysym' resource
+	is also available as a command-line long option ... even if
+	you have compiled with USE_XGETDEFAULT.
+
+    13.	From: Mark Olesen <olesen@weber.me.queensu.ca>
+	When a new pixmap is loaded, revert to the default scaling.
+
+    14.	From: Mark Olesen <olesen@weber.me.queensu.ca>
+	Reworked the menubar to permit multiple menubars in a circular
+	linked list (and all the management functions that entains)
+	and new functions including the following:
+
+		* reading from files
+		* dumping all the menubars
+		* clearing a menu (without removing it)
+		* setting a backgroudPixmap
+		* and many other features.
+
+	The menu syntax has changed very slightly from the last
+	version, but now provides greater flexibility ... see
+	refer.html for details.
+
+	Added the `menu' resource/long-option so a startup menu
+	can be specified. eg,
+		rxvt -menu my.menu -e rlogin machine -l user
+
+2.19 to 2.20
+\-----------
+     1.	You can now add snazzy looking menus to any plain (non-X) text
+	application.  At the moment, the menuing system is simple but
+	functional.
+
+	The syntax for controlling the menubar is documented in
+	doc/rxvt.doc, but note that an XTerm sequence `ESC ] 10; Pt
+	BEL' is used so menus created for rxvt will be ignored by an
+	ordinary XTerm.
+
+	It provides sub-menus, click-and-drag, and even some user
+	definable `quick' arrows keys.  However menu manipulation
+	could use refinement to permit multiple menus to be defined --
+	and the menu refreshing could also use some improvement, but
+	it can be extended and refined later as required/desired.
+
+	The files doc/menu.sh and doc/jedmenu.sl show sample
+	implementations of menus.
+
+	  -->	It compiles and runs on my machine (AIX 3.2.5)
+		but THIS IS CONSIDERED BETA (or even ALPHA) CODE!
+
+     2.	DEC private modes: Bug fix for 's'ave and 'r'estore parameters,
+	added a 't'oggle parameter to DEC private modes.
+
+     3.	Made Backspace key selectable with DEC private mode
+	ESC [ ? 36 h/l/s/r/t (high/low/save/restore/toggle)
+
+     4.	Changed the way the scrollBar is realized to permit on-the-fly
+	toggling of the scrollBar display and added a DEC private mode
+	escape sequence for that.  Smoother redraw of scrollBar.
+	Better proportions for the arrows allows a slightly narrower
+	scrollBar.
+
+     5.	Added support for XTerm font changing sequence:
+	`ESC ] 50; Pt BEL', with (as usual) a few extras.
+	See doc/rxvt.ref
+
+     6.	Adapted experimental XPM buffering from that supplied by
+	Carsten Haitzler <raster@zip.com.au>.
+
+     7.	Replaced `wait' with `waitpid' in src/command.c::Child_signal
+	to avoid a race condition and permit use of pclose() on SunOS.
+	Patch provided by <davis@space.mit.edu>, Thanks John!
+
+     8.	For easier XPM handling, added `path' resource/long-option and
+	substantially enhanced pixmap scaling to provide very exact
+	control over scaling and positioning of the XPM background
+	image.  The XPM XTerm escape sequence has been extended to
+	provide a convenient facility for on-the-fly rescaling.
+	Export COLORTERM="rxvt-xpm" instead of COLORTERM="rxvt"
+
+     9.	Added export COLORFGBG to give hints to color applications.
+	Typically one of these values is exported, in which `fg' and
+	`bg' are numbers 00-15:
+
+	COLORFGBG="default;default"
+		-fg -bg colors don't match any of color 0-15
+
+	COLORFGBG="fg;default"
+		-fg color matches color 0-15, but -bg color doesn't
+
+	COLORFGBG="default;bg"
+		-bg color matches color 0-15, but -fg color doesn't
+
+	COLORFGBG="fg;bg"
+		-fg -bg colors match color 0-15
+
+	When compiled with XPM support, the last two values are
+	rendered as follows:
+
+	COLORFGBG="default;default;bg"
+		-bg color matches color 0-15, but -fg color doesn't
+
+	COLORFGBG="fg;default;bg"
+		-fg -bg colors match color 0-15
+
+    10.	Disable Shift+Prior/Next and scrollBar if saveLines == 0.
+	Slight change to key-processing so `shift+meta+key' and
+	`shift+ctrl+key' gets processed as `shift+key'.  This provides
+	a way to avoid interpretating `Shift+Prior', `Shift+Next', and
+	`Shift+Insert'.
+
+	Also, added DEC private mode sequence `ESC [ ? 35 h/l/s/r/t'
+	to disable Shift+key interpretation.
+
+	Provide for Ctrl+Shift+<KEY> combinations for function keys.
+	See doc/rxvt.ref
+
+    11.	Always match long-option names, even when only preceded by a
+	single -/+.
+
+2.18 to 2.19
+\-----------
+     1.	Minor alteration to input mode for Kanji processing.
+
+     2.	rclock: -adjust option, support for exec on startup syntax,
+	date format may now also include the century
+
+     3.	Made mouse double-click respect autowrap lines.
+
+     4.	Added marks for folded editing.
+
+     5.	Added Offix DND (Drag 'n' Drop) protocol.
+	Added support for XA_TARGETS.
+
+     6.	added Carsten Haitzler <raster@zip.com.au> XPM patches to load
+	an XPM file for the background of the terminal window.
+	Uses resource `Rxvt.backgroundPixmap' or long-option
+	`--backgroundPixmap'
+
+     7.	Use these (XTerm) keybindings exclusively and remove the old
+	equivalent bindings:
+		Shift-Prior  = scroll up
+		Shift-Next   = scroll down
+		Shift-Insert = paste mouse selection
+
+		Shift-KP_Add      = bigger font
+		Shift-KP_Subtract = smaller font
+
+2.17 to 2.18
+\-----------
+     1.	Check for NULL pointers in command-line processing (oops)
+	Also fixed processing of `hidden' arguments such as -d, -g, -T
+
+     2.	Fixed terminfo hpa/vpa: was `\E..' instead of `\E[..'
+	added invisible cursor (ESC[?25h / ESC[?25l)
+
+     3.	Fixed broken kanji characters (?? and disappeared cursor box ??)
+	thanks to <manabe@Roy.dsl.tutics.tut.ac.jp>
+
+     4.	In privileges(), changed setuid/setgid to seteuid/seteguid so that
+	it's possible to switch back to root later.
+
+	Perhaps fixed svr4 problems (reports no tty, no job control) in
+	get_tty() ... need to detect these SVR4 features in the configure
+	script.
+
+     5.	Restored scrollColor, topShadowColor, bottomShadowColor resources
+	that somehow got lost between the beta and release versions.  For
+	monochrome displays, fixed scrollbar so it will be visible and
+	suppress color changes.
+
+     6.	Final? iteration on selection.  Store selection text with LF
+	line-endings but paste into rxvt with CR endings.  Selection now
+	preserves the newline when trailing space is stripped from
+	non-autowrap lines.  Compile-time support for using a keystroke to
+	paste from the cut-buffer.
+
+     7.	Fixed utmp.c to handle both sysv and bsd pty names.  More changes in
+	the works to improve documentation and eliminate race conditions ...
+	this, thankfully, is being done by someone else.
+
+     8.	Added European language support (X11R6) - let me know of problems
+	and fixes since I only have X11R5.
+
+     9.	Changed names of color10-color17 to color8-color15 to match with
+	those used by color_xterm ... sorry for the inconvenience, but I
+	didn't have an X11R6 xterm manpage until now and long-term
+	compatibility is quite important.
+
+	Added a real bold font (define USE_BOLDFONT).  I still think it's
+	too much work to avoid pixel droppings for overstrike fonts.
+	Added support for specifying colors for bold/underline
+	(colorBD/colorUL) but it's only done when the foreground = the default
+	foreground ... see the manpage.
+
+	Compile-time selection of TERM="xterm-color".
+
+	Reduced the number of rarely-used command-line options since they
+	are accessible on the command-line via their resource names as long
+	options.  More rigid differentiation between long and short options:
+	long options are --/++ prefixed; short options -/+ prefixed.  Added
+	long-option help to give the resource names.
+	Removed run-time selection of right-hand scrollbar and arrows.
+	Removed run-time selection of (pageup_key/pagedown_key/alert_key).
+
+    10.	Changed Ctrl-Up,Down,Left,Right to emit "\EOa,b,c,d" instead of the
+	previous "\E[^A,^B,^C,^D" to avoid problems associated with having
+	an embedded "^C" in a key-sequence.  Disallow 80/132 column
+	switching as the default (same as xterm).
+
+    11.	Check for seteuid().  Add "ttcompat" module for SVR4.
+
+    12.	A few people suggested removing the keystroke for toggling MapAlert
+	and so I have.  I agree that it was pointless and/or annoying since
+	there was no way of determining the current toggled state anyhow.
+
+    13.	Fixed missing `ttydev' for _sgi.  Fixes for BSD utmp support.
+	Exported WINDOWID before the window was created (oops).
+
+    14.	Mouse cut&paste of autowrapped lines should be improved, fixed
+	bug in screen.c::scroll_text().
+
+    15.	As was pointed by a user -->> in keeping with X conventions, only an
+	application that starts with 'x' should capitalize the first two
+	letters of the resource file, so the rxvt resource file (and class
+	name) should be named Rxvt not RXvt, this is a minor point.
+
+    16.	rclock: As well as message reminders, rclock can launch programs and
+	(if no message text is given) act as a cron-type of program.  Made
+	default font `7x14'.  Fixed graphics context when mail is waiting
+	and a reminder is issued - so the message is actually visible!
+
+    17.	As suggested by a user, changed the bolding algorithm to be slightly
+	more intuitive:
+		1. colorBD (if specified)
+		2. color0-7 -> color8-15 (if possible)
+		3. boldFont (if specified and found)
+		4. overstrike (last resort)
+
+	This takes advantage of the color capability and is the most
+	consistent when toggling font sizes on-the-fly.  If you never want
+	overstrike (looks ugly and leaves pixel droppings) or boldFont (you
+	like to switch font sizes on-the-fly), you can remove them at
+	compile-time.  The other elements are similarly compile-time
+	selectable.
+
+    18.	Another user suggestion: scrollbar made more distinct by having the
+	`trough' a different color from the slider -- I opted for making it
+	the same as the default background color so that the slider and
+	arrows appear to `float' on the window.  Also removed topShadowColor,
+	bottomShadowColor resources as unnecessary.
+
+    19.	Dropped distribution of vttest since Tom Dickey <dickey@clark.net>
+	is working on an improved version.
+
+2.16 to 2.17
+\-----------
+     1.	Fixed problem in scr_refesh_region() that was introduced in v2.16
+	The problem of `pixel droppings' continues when bold is simulated
+	using overstrike.  Using XCopyArea() sometimes helps, but the
+	preferred and simplest solution is item 4 below.
+
+    2.	Removed 7bit mode.
+
+	Changed definition of meta so that the ESCAPE is the default and
+	using meta to set the 8bit on an option that can be made run-time
+	configurable (assuming people still use this).
+
+	Added -/+rv command-line option, resource reverseVideo.  NB: it works
+	slightly differently from xterm's in that foreground/background are
+	swapped even if they have been explicitly set.
+
+	Removed NO_COLOR option -- no more monochrome rxvt (one too #ifdef's).
+
+	Inherit existing stty settings (at least for control characters)
+	and set value of BackSpace appropriately.
+
+	Added defines DONT_GUESS_BACKSPACE and NO_DELETE_KEY
+
+    3.	Added 3D style scrollbar and removed all the old bitmapped
+	scrollbars and arrows with the only exception being the xterm
+	lookalike XTERM_SCROLLBAR which is available in a single width.
+	With arrows, scrollbar behaviour somewhat resembles Motif
+	behaviour.  Without arrows, it's the standard xterm behaviour.
+
+	The default scrollbar (defined at compile-time or set by using
+	scrollBar: True) is to have a scrollbar with arrows arranged on the
+	right-hand side. The scrollBar resource is now exclusively a boolean
+	value
+
+	scrollbar resources:
+
+		scrollColor
+		topShadowColor
+		bottomShadowColor
+
+	NB: if topShadowColor/bottomShadowColor are unset, their values are
+	    calculated from scrollColor using an algorithm adapted from
+	    fvwm so it shouldn't be too hard to find scrollbar colours that
+	    look good with your window manager and don't consume an entire
+	    colormap.
+
+    4.	Added smarter handling of bold/blink when applied to the default
+	fg/bg colours:
+
+	If the pixel value of fg/bg matches the pixel value of colour COLOR0
+	through COLOR7, then applying bold/blink to the default fg/bg will
+	select the appropriate colour from BOLD0 through BOLD7 instead of
+	using the overstrike bold.
+
+	This seems to be the best way to handle bold/blink attributes when
+	the foreground/background match and ANSI colour anyhow.  For
+	convenience, it is possible to use colour aliases (next item) for
+	the foreground/background colours instead.
+
+	My preference is a dull Canadian look:
+
+		RXvt*foreground:	7
+		RXvt*background:	10
+
+    5.	Changed colour aliases (item 7 of last change) and dropped the `#'
+	prefix.  This avoids confusion with the regular #rrggbb format of
+	specifying colours and is unambiguous since there are no X11 colours
+	starting with a digit.  This also avoids the need to quote the `#'
+	to protect against shell interpretation.
+
+    6.	Added colour cursor support.
+	    -cr (cursorColor), as per XTerm -> the (rectangle) cursor colour
+	    -cr2 (cursorColor2), only RXvt -> the text colour.
+
+	The cursorColor2 maintains contrast in a colour environment and
+	is optional.
+
+	Thanks Raul Garcia Garcia <rgg@tid.es> for the idea.
+	Cleaned up scr_refresh (again <sigh>) to avoid some unnecessary
+	colour changes and removed the reverse video graphics context and
+	just swap foreground/background colours instead.
+
+    7.	Typo in command.c: had seteuid() instead of seteguid() <sigh>
+	Use cfsetospeed()/cfsetispeed() for POSIX termios handling.
+
+    8.	Ignore the loginShell option/resource for programs that DON'T end
+	with "sh".  A hack but it keeps `rxvt -ls -e rlogin machine' from
+	failing and I don't know of (m)any shells that don't end in "sh".
+
+    9.	Hard-code dependencies in Makefiles to avoid using X11 makedepend.
+	Added check for atexit() to catch the problem that exists on SunOS
+	but not on Solaris.
+
+   10.  Collected command-line option parsing and X11 resources into a
+	single file (xdefaults.c), and introduced a monolithic structure
+	(with bit-flags for logical options) to eliminate the massive
+	if-else-if parsing and to reduce possible overlaps/oversights
+
+	Short help provided for an incorrect argument.
+
+	For more consistency, more flexibility, and fewer switches,
+	made -grk4/-grk9 options obsolete, and replaced with `-grk mode'.
+	Added the resource `greek_keyboard' while I was there.
+
+	It is also possible to use a `--' or `++' prefix to get so-called
+	`long options' that correspond to the resource name.
+	For example,
+
+		rxvt +ls -bg Blue
+		rxvt +loginShell -background Blue
+		rxvt ++loginShell --background Blue
+
+		rxvt ++ls --bg Blue		Error!
+
+   11.	Changed REFRESH_PERIOD to 1 in command.c, the old idea of providing
+	for fast and furious scrolling needs to be reconsidered so that `cat'
+	works.  Still needs some investigation.
+
+   12.	Changed scr_poweron(), which corresponds to `ESC c', to also reset
+	the scrollback buffer.
+
+   13.	Changed scr_change_screen() (when compiled with NO_SECONDARY_SCREEN)
+	so that switching from the secondary to primary screen will push the
+	old secondary screen into the scrollback buffer.  This is fairly
+	useful if your terminfo has have rmcup=\E[?47l\E8, smcup=\E7\E[?47h.
+	It is NOT particularly useful if rmcup includes \E[2J, like some do.
+
+	Running with NO_SECONDARY_SCREEN provides faster switching than
+	with a real secondary screen and saves memory too.
+
+   14.	Now that key values have mostly stabilized, moved the compile-time
+	key choices to "feature.h" ("keys.h" now obsolete).
+
+2.15 to 2.16
+\-----------
+    1.	Misc cleanup, rxvt once again passes the vttest (and reverse video
+	works again).  Kanji support tested and seems to be okay.  Finally,
+	an okay set of regular/bold colours.  Compile-time option for a
+	right-side scrollbar.
+
+    2.	Ctrl-minus now (correctly) generates ^_ [0x1F].
+	Changed termcap/terminfo to use normal cursor keys instead of
+	application cursor keys (rmkx/smkx, ke/ks) -- otherwise subsequent
+	rxvt/xterm starts with the application cursor keys active.
+
+    3.	Fixed scr_reset() so that resizing is a lot more sensible.
+	Implemented the equivalent SouthWest resizeGravity (xterm X11R5) so
+	the bottom line of text on the screen stays fixed.  If the window is
+	made taller, additional saved lines will be scrolled down onto the
+	screen; if the window is made shorter, lines will be scrolled off
+	the top of the screen, and the top saved lines will be dropped. The
+	old resizing code is available with -DOLD_UGLY_RESIZE.
+
+    4.	Altered code so all man-page documented command-line options will
+	not trigger errors even if the feature wasn't compiled into rxvt.
+	Added old, backward compatibility command-line options, but they're
+	simply ignored. Eventually they can be removed -- perhaps Jan'97?
+
+		`-8':		use `+7'
+		`-fat':		use `-sb'
+		`-thin':	use `-arrows'
+		`-meta8thbit'	use `-meta8'
+		`-metaescape'	use `-meta'
+		`-font_list'	use `-font1', `-font2', etc.
+
+	These ones are just too weird to support:
+
+		`-ls-':		use `+ls'
+		`-ma-':		use `+ma'
+
+    5.	Removed secure-keyboard option, too problematic and obscure.
+
+    6.	First attempt at GNU autoconfig.
+	Still needs some work, but it's mostly okay.
+
+    7.	Added minor aliases for foreground/background colours.  This permits
+	colour specifications like -fg "#13" -bg "#10", which would set the
+	foreground to colour 13 (bright yellow) and the background to colour
+	10 (bright black).  It's not terribly useful yet, but might
+	eventually be a nice way to have bold/blink colour work even on with
+	the standard fg/bg colours.
+
+2.14 to 2.15
+\-----------
+    1.	Small bug: initial width incorrect when there was no scrollBar.
+
+    2.	Close the gaping security hole.  Renounce setuid/setgid privileges
+	immediately and only take them up as needed -- chown() or writing
+	into /etc/utmp.
+
+    3.	Reverted to using `<' and '>' to toggle smaller/bigger fonts. It
+	seems that many didn't like KP_Subtract/XK_KP_Add -- conflicts with
+	some editors, and not all terminals have a Keypad anyhow.
+
+    4.	Man page reformatted by Piercarlo Grandi <piercarl@sabi.demon.co.uk>
+	so that it "now is done in the most delightful [sic] elegant 'roff
+	style :-)"
+
+    5.	Started to integrate the Kanji support based on old patches from the
+	Linux-JE (Japanese Extensions) project.  Consider it alpha until one
+	of the JE authors gives it a thorough check.
+
+    6.	Added compile-time selection of a few different scrollbar widths.
+
+    7.	When reading X resources, rxvt now recognizes two class names:
+	"XTerm" and "RXvt".  The reason for two distinct names is that there
+	are many options common between rxvt and xterm -- to which the class
+	name "XTerm" permits easy access and configuration -- but there are
+	also several options, notably colours and key-handling, unique to
+	rxvt but which are useful to share between different rxvt
+	configurations; the class name "RXvt" permits this.
+
+	NB: The "RXvt" class takes precedence (in the event of a clash) and
+	    is the only one ever used for the application defaults file.
+
+    8.	The initial value used for the Backspace key (^H or ^?) is now
+	determined from the value of CERASE used to set the termios
+	structures.  This removes the need for the BACKSPACE_AS_DELETE
+	compile-time option.
+
+2.13 to 2.14
+\-----------
+    1.	Default HOTKEY prefix can now be choosen as `meta', `ctrl' or
+	`shift'. Moved font toggle to KP_Add/KP_Subtract to resemble
+	resolution toggling of the XFree86 server (Linux) and so that Alt-<
+	can generate ESC-< for Emacs usage.  Man page and usage() reflect
+	the changes. Note that if you choose the hotkey to be `shift', to
+	mimic the Linux console scrollback, you'll probably want different
+	keybindings for mapAlert and Secure.
+
+	The choice of the HOTKEY (ctrl or meta) prefix and some of the
+	key-strings can be compile-time defined in "rxvtkeys.h", although
+	probably the only changes desired will be in the string value
+	associated with XK_Delete and in the choice of a HOTKEY (ctrl or
+	meta) prefix.
+
+	Use shift or ctrl to temporarily toggle Backspace from ^H to ^?.
+	Use shift to temporarily toggle the application keypad.
+
+    2.	Patch so that setting bold or blink works before or after changing
+	the colour (it used to only work before changing the colour). Also
+	added the option of having DOS VGA colours.
+	Thanks Avery Pennarun <apenwarr@foxnet.net>
+
+    3.	Extensive reworking of pseudo-tty handling and addition of BSD sgtty
+	terminal handling and new utmpx (Solaris 2.x) support. MANY thanks
+	to Raul Garcia Garcia (rgg@tid.es).
+
+	POSIX wtmp support added by Piet W. Plomp (piet@icce.rug.nl)
+
+	Added -/+ut option (resource: utmpInhibit) so you can sometimes be
+	harder to find :)
+
+    4.	Finally? cleaned-up selection so that it works properly -- clears a
+	previously selected region without causing a core dump -- define
+	NEW_SELECTION.
+
+	I believe that this should fix a long-standing problem with the
+	selection mechanism -- probably back from when selection of the
+	scrollback was added -- whereby all accounting was done in terms of
+	screen row values [0 .. RxvtWin.rows-1] plus the current offset
+	value.  The anchor and end points were scrolled with the screen, but
+	the beginning point wasn't and extending a region that had its
+	anchor scrolled-off would give complete garbage.  The new selection
+	scheme has lots of bounds-checking (too much?) to prevent these
+	problems.  If PRINT_PIPE is not defined, then you can use
+	PrintScreen to dump some of the current selection state -- this
+	should help debugging.
+
+	Thanks to John Davis (davis@space.mit.edu) and Piet W. Plomp
+	(piet@icce.rug.nl) for helping to diagnose the problem.
+
+    5.	Use information request `ESC [ 8 n' to change the window title
+	to the current rxvt version so you can find out what version you
+	have.
+
+    6.	Added simple code to permit run-time definition of the keysyms
+	0xFF00 - 0xFFFF if KEYSYM_RESOURCE (for FAKE_RESOURCES only) is
+	defined.  It's not as pretty as that used by xterm since it only
+	works with keysym values rather that key names, but the impact on
+	code size is quite minimal.  I use it in conjunction with `-name vm'
+	to remap arrow and function keys for tn3270 ... quite handy.
+	At the moment the string length is only limited by the line length
+	(currently 256) used in "resources.c"
+
+	The syntax (at the moment) is
+
+		rxvt*keysym.0xFFnn:	"a string value"
+
+	where `nn' is a 2 digit hex value 00 to FF.  Of course if there were
+	an easy and small means of converting key names to keysym values,
+	then that would be better.
+
+	The enclosing quotes are required to start/end with whitespace.
+	Most of the usual escape values can be used:
+
+		\b - backspace
+		\e - escape
+		\n - newline
+		\r - carriage return
+		\t - tab
+		\000 - octal number
+
+	Anyhow, here's a brief example of what it looks like
+	in ~/.Xdefaults:
+
+	! F11 key - mimic the output of F1
+	rxvt*keysym.0xFFC8: \e[11~
+
+	! F12 key - whatever
+	rxvt*keysym.0xFFC9: Hello World!\n"\"String\" ends with whitespace  "
+
+	! Delete key - remap
+	rxvt*keysym.0xFFFF: "Delete :)"
+
+	!Scroll_Lock as flow-control (^S)
+	rxvt*keysym.0xFF14: \023
+
+    7.	Oops -- fixed resource name from scrollbar to scrollBar. Fixed
+	cursor colours to black on white (like xterm) for the scrollbar
+	cursors, but I've left the xterm (`I'-bar) cursor as foreground on
+	background because it looks so nice.  Allocate all colours when
+	creating the window so that we don't have to worry about it later
+	and so that we can avoid potential hassles with colour-hungry
+	applications like Netscape.
+
+    8.  Added a way to distinguish an rxvt from an xterm via the obsolete
+	ESC Z sending the vt100 answer string with 'c' -> 'C'.
+
+	Added support for resolving the actual IP number of the host for
+	remote DISPLAYs.  Changed the answer back for ESC[7n to add a
+	trailing newline to support easier input into the shell.  When the
+	display is local (i.e. :0), we add support for sending the first
+	non-loopback interface IP number as the DISPLAY instead of just
+	sending the incorrect ":0".  This way telnet/rlogin shells can
+	actually get the correct information into DISPLAY for xclients.
+
+	Courtesy of Chuck Blake <cblake@BBN.COM>
+	[Note: I've not had a chance to thoroughly test this -- mjo]
+
+2.12 to 2.13
+\-----------
+    1.	Shift and Control now only work for non-application mode cursor
+	keys and with function keys.
+
+    2.	Override XTerm mouse reporting with either Mod1 or Shift.  X11
+	mouse reporting now properly includes modifier keys (see rxvt.ref).
+	Although this effectively degenerates to the Control modifier alone
+	since both Shift and Meta are used to temporarily disable mouse
+	reporting -- I don't know an easy way around this but that's what
+	XTerm does, although since it uses Control to pop-up menus, that
+	doesn't get transmitted either.
+
+    3.  Moved a few more configuration items from Imakefile to configure.h
+
+    4.	Added XAPPLOADDIR define to the Imakefile to allow use of the
+	application defaults file XAPPLOADDIR/RXvt when rxvt has been
+	compiled with FAKE_RESOURCES.  Now, the following files are
+	checked:
+		XAPPLOADDIR/RXvt	(compile-time defined)
+		$HOME/.Xdefaults or $HOME/.Xresources
+	suggested by John Gotts <jgotts@engin.umich.edu>
+
+    5.	Applied patches by Edward D.H. Liu <dhliu@solar.csie.ntu.edu.tw>
+	to fix the speed of pasting rxvt's selection to motif, xew or tk.
+	Finally! reasonable pasting speed to these applications.
+
+    6.	patches by Gregory Margo <gmargo@newton.vip.best.com>
+	for xterm-style proportional scrollbar behaviour:
+		If pointer is near top, scroll one line.
+		If pointer is near bottom, scroll full page.
+	refreshPeriod resource and -refresh option ... still wishing
+	for faster screen refreshing.
+
+    7.	Bug fix for partial matches (FAKE_RESOURCES).  In addition to
+	resources for resource name `rxvt', also get resources for class
+	name `XTerm' as well.  Remove checking for `command' resource since
+	it's not found in xterm nor was there any code in place to parse the
+	command arguments ... better just to use the command-line -e option.
+	Replace `fontList' with font1, font2, ... etc. for better xterm
+	compatibility and for ease of configuration.  Changed processing of
+	string resources and command-line string options to avoid allocating
+	redundant memory.
+
+    8.	Previously selected region is now properly cleared when Button1 is
+	pressed.  Still have problems with click-and-drag when Mod1 or Shift
+	is used to override mouse reporting -- argh!  Until someone gets
+	this properly patched, use Button1 followed by Button3 (to extend
+	region) in these instances.
+
+    9.	Understands ANSI set default fg/bg colour (\E[39m / \E[49m)
+
+   10.	In the screen accounting used in screen.c, use a '\n' to terminate
+	wrapped lines instead of '\0'.  This should avoid mouse selection of
+	wrapped lines from including a bogus newline.  No known
+	side-effects, but changes isolated by #define NEW_WRAPTYPE.
+
+2.11 to 2.12
+\-----------
+    1.	Extra functionality for XTerm mouse report mode.  If mouse reporting
+	is enabled (the application will handle mouse events) the normal
+	scrollbar operation is disabled -- instead rxvt sends UP/DOWN for
+	the arrow buttons and PageUp/PageDown when Button1 or Button3 are
+	clicked on the scrollbar.  Use Mod1 (Alt) key to get the normal
+	scrollbar/arrow button actions and also to get the normal selection
+	functions -- so that you can still cut/paste between X applications.
+
+    2.	New colour possibilities -- 16 colours.  Instead of using fatter
+	characters, a bold attribute now uses a brighter foreground colour.
+	Similarly, a blink attribute will use a brighter background colour.
+	It is also possible to choose these colours through the resources
+	(color0 -- color7) permit specification of the ANSI colours (black,
+	red, green, yellow, blue, magenta, cyan, white), the resources
+	(color10 -- color17) are the brighter bold/blink equivalents.
+	Define USE_FAKE_BOLD to disable.
+
+    3.	Extensive clean-up of source and headers to separate
+	interdependencies, remove unused variables.  Introduced static
+	variables wherever possible to limit scoping and reduced the number
+	of external variables.
+
+    4.	Allow NumLock to toggle on/off the application keypad.
+
+	Backspace sends '\b', Ctrl-Backspace sends '\177'.
+	Define BACKSPACE_AS_DELETE to reverse these values or use the
+	escape sequence:
+
+		ESC [ 36 h		Backspace key sends BS
+		ESC [ 36 l		Backspace key sends DEL
+
+	XK_End used to send "\033Ow", which is identical to XK_KP_7 and
+	confuses EDT-type editors. Now,
+	Home = "\033[7~"
+	End  = "\033[8~"
+
+	Changed Alert & Secure keys from Alt-i & Alt-s to Alt-I & Alt-S so
+	they aren't so easily toggled.
+
+    5.	Extra keystroke info.  Pass Control and Shift indicators for
+	function keys (similar to the XJed editor)
+	eg,
+		F1	= ESC [11~
+		C-F1	= ESC [11^
+		S-F1	= ESC [11$
+
+	also, pass indication of shift status for arrow-keys
+	eg,
+		Up, Down, Right, Left
+		  = ESC [A, ESC [B, ESC [C, ESC [D
+		S-Up, S-Down, S-Right, S-Left
+		  = ESC [a, ESC [b, ESC [c, ESC [d
+
+	You wouldn't be able to use these keys for termcap/terminfo
+	applications, but the key sequences are available for remapping
+	within an application.
+
+    6.	Added configure.h which is included by each source file and by the
+	Imakefile.  Common compilation defines are now all contained in
+	configure.h with minor system defines remaining in Imakefile --
+	makes it much easier to configure.  Used XCOMM macro in Imakefile so
+	that it actually works.  Also added defaults.h for defining
+	user-specific startup defaults.
+
+    7.	Added rxvt.ref to provide documentation of the various terminal
+	sequences that are processed.  Updated man page to reflect changes.
+
+    8.	Use xterm-style -/+ to turn on/off options, rationalized resource
+	names to more closely resemble xterm.
+
+		Option			Resource
+		-help			-
+		-display displayname	-
+		-geometry geom		geometry:
+		-bg color		background:
+		-fg color		foreground:
+          	-color<n> color		color<n>: <string>
+					where <n> = [0-7], 1[0-7]
+		-fn fontname		font: <string>
+		-fontList names		fontList: <string> <string> ...
+		-name string		-
+		-/+ls			loginShell: True/False
+		-/+ma			mapAlert: True/False
+		-/+vb			visualBell: True/False
+		-/+sb			scrollbar: True/False
+		-/+arrows		scrollbar: Arrows/True/False
+		-ic			-
+		-meta8			meta: 8bit
+		-/+meta			meta: True/False
+		-sl number		saveLines: <num>
+		-grk4			-
+		-grk9			-
+		-print-pipe name	pipe-pipe: <string>
+		-e command arg ...	command: <string>
+		-T string		title: <string>
+		-n string		iconName: <string>
+		-C			-
+		-/+7                    bits: 7/8
+		-secure keysym		secure_key: <string>
+		-pageup keysym		pageup_key: <string>
+		-pagedown keysym	pagedown_key: <string>
+		-bigfont keysym		bigfont_key: <string>
+		-smallfont keysym	smallfont_key: <string>
+		-prkey keysym		printscreen_key: <string>
+          				greektoggle_key: <string>
+          				cutchars: <string>
+
+    9.	Fixed Button actions for XTerm-style scrollbar so that Button1 and
+	Button3 do different things as they are supposed to.  Replace -/+fat
+	with -/+sb and -/+arrows for more consistency with XTerm. Decreased
+	width of `fat' scrollbar (make closer to xterm) and increased width
+	of `thin' scrollbar (arrows too small) -- they are now the same
+	width.  Also made it possible to remove the scrollbar altogether.
+	Added a visual bell.
+
+	Added many more defines to further reduce code size for various
+	cases, see "configure.h".  It is also possible to alter settings in
+	"defaults.h" for configuration options that will only affect
+	screen.c and xsetup.c, this should help with compile-time
+	customization for those who don't want to use Xdefaults.
+
+	Added the define REPLACE_SELECTION_NEWLINE to make the substitution
+	of newlines with carriage returns for selection pasting a
+	compile-time option.
+
+   10.	Fixed the graphics samples so that if you want to it's actually
+	possible to compile them.  Added -name command-line option so that
+	it's possible to select different sets of resources.
+
+   11.  Integrated initial support for X11 mouse reporting and added
+	Shift + Function Keys support.
+
+2.10 to 2.11
+    1.	If NEW_COLOR_MODEL is defined in screen.c, the new model I described
+	in an earlier email is used. (apparantly there are two, slightly
+	differnt models for using color extensions in a vt-compatible
+	terminal. This flag lets you switch.
+
+    2.	If XTERM_MOUSE_REPORT is defined in command.c, mouse reporting is
+	turned on/off via the appropriate escape sequences.  XTerm already
+	provides this support.
+
+    3.	If .Xdefaults does not exist, .Xresources is searched for.  It seems
+	that many here use .Xresources.
+
+2.09 to 2.10
+    1.	Really fixed the color problem (?) Got color-ls, and it works now.
+    2.	Added patch to allow run-time selection of font list.
+
+2.07 to 2.09
+    1.	Fixed some color-usage errors.
+    2.	Added double and triple-click support
+	compliments of ah@doc.ic.ac.uk (Angelo Haritsis)
+    3.	Added Print Screen capability, as in most vt-100's
+2.06 to 2.07
+    1.	Fixed problems with rxvt screwing up tty permisssions (?)
+2.03 to 2.06
+    1.	Fixed a limit which imposed a maximum width for the
+	terminal window of 255 characters. There is no limit now.
+    2.	Made provision for applications to get mouse-click feedback
+	when user clicks in a graphics window. See graphics_sample
+2.02 to 2.03
+    1.	Fixed memory management just a little.
+
+2.0 to 2.02
+    1.	Bug fixes for color and graphics.
+
+1.97 to 2.0
+    1.	Added ANSI color support. Compile with -DCOLOR
+    2.	Added a graphics mode. Compile with -DGRAPHICS
+1.96 to 1.97
+    1.	Bug in refresh() which was causing slow refreshes after
+	clear-screens was fixed. Showed up during emacs start-up.
+
+1.95 to 1.96
+    1.	rxvt did bad things if it received mouse - Motion events
+	without a preceeding button-press. Fixed.
+1.94 to 1.95
+    1.	Created a substitute for XGetDefaults, which seemed to account for
+	1/2 to 2/3 of the memory used by rxvt (according to the SIZE field
+	of ps output). My substitute only reads the .Xdefaults file. Compile
+	with -DFAKE_RESOURCES to get my mini- XDefaults handling,
+	-DREAL_RESOURCES to keep XGetDefault.
+
+1.93 to 1.94
+    1.	Fixed some minor long-standing errors in the vt100 emulation.
+    2.	Fixed ALT-<char> handling in command.c
+    3.	Fixed minor bug with start-of-selection location.
+    4.	Added xterm-type "extend selection" feature using
+	mouse button 3. Button 1 always starts a new selection. Button3
+	tries to extend the current selection if possible.
+    5.	Fixed problem with bold-face fonts overflowing into
+    	the next character for some fonts.
+
+1.92 to 1.93
+    1.	ran gprof to find bottle-necks in the code. Halved user
+	time, but had little effect on total time required to
+	update the display. Seems worth keeping for the more efficient
+	user-time, though. At this point, I think that most of the elapsed
+	time is spent waiting for input or waiting for the X buffers
+	to flush.
+    2.	Used to refresh the screen every 2.2 screen-fulls during
+	flat-out scrolling. Really cuts down on scroll-time. Now,
+	refresh every screen-full (or when there's a pause in activity),
+	but when flat-out scrolling starts, decrease the refresh period,
+	so that its every 10th screenful after a little while. This has
+	no noticeable visible effect, since the scrolling text is
+	absolutely unintelligible anyway, but will improve the scroll
+	"feel" when doing just one or two screenfulls, ie in an ls -l.
+    3.	Surrounded  the code which uses XCopyArea with #ifdef's
+	I have never seen this help performance, but I think that there
+	may be some video-systems which benefit from this, particularly
+	in a full-screen editor or slow scrolling type of setting.
+    4.	Performance in flat out scrolling, text only, on a sparc-10,
+	displaying rxvt on an HDS x-terminal:
+	  nation@snoopy>/usr/bin/time rxvt -e cat k
+		6.1 real         3.1 user         2.5 sys
+	  nation@snoopy>/usr/bin/time xterm -e cat k
+		40.8 real         4.6 user         3.4 sys
+
+1.91 to 1.92
+    1.	Added greek-keyboard support patches.
+1.85 to 1.91
+    1.	assorted minor patches
+1.82 to 1.85
+    1.	Fixed ESC c handling.
+    2.	Fixed minor selection handling bug.
+
+1.81 to 1.82
+    1.	Fixed slow refresh during selection process
+    2.	Fixed problem of not correctly clearing selections of 1 character.
+
+1.80 to 1.81
+    1.	Fixed some scrolling problems, problems with partially obscured
+	windows.
+    2.	Added some neat debugging capability in debug.c
+    3.	Patched up rclock.
+
+1.74 to 1.80
+    1.	Fixed core dump from selecting past the bottom of the screen
+    2.	Fixed a few escape sequences, per the vttest program
+    3.	Broke and fixed handling of moved/resize/new-font handling.
+    4.	Still can't change tab stops correctly.
+    5.	Ran vt-100 test suite. Added capability to change tab stops
+	and enter reverse video, and to switch from 80 to 132
+	columns and back. Fixed a seg-fault in scroll().
+
+1.70 to 1.74
+    1.	Fixed cursor drawing errors.
+    2.	Improved smoothness of scroll-back operations.
+    3.	Applied some SVR4 patches.
+    4.	Applied HPUX patches, and a few cursor display patches
+    5.	Fixed up font-changing routines a bit.
+    6.	Fixed a scrolling problem for windows taller than the scroll-back
+	buffer.
+
+1.6 to 1.7
+    1.	Fixed the problem with random rendition flags in the scroll
+	back buffer
+    2.	Fiddled with re-drawing on the scroll-bar, and with
+	how often refreshing occurs.
+    3.	Incorporated some AIX patches.
+    4.	Included #ifdef'd changes to support vt100 printer.
+    5.	Fixed send_string routine, so that it doesn't loose
+	data.
+    6.	Complete re-write of screen.c
+1.5 to 1.6
+    1.	Removed all use of a seperate bold font. Now uses
+	over-striking exclusively.
+    2.	Added some more optimizations for drawing speed when
+	the window is re-sized or moved.
+    3.	Implemented speed ups in screen.c
+
+1.47 to 1.48
+    1.	Cleaned up re-drawing on expose events, so rxvt only
+	re-draws the newly exposed parts of the screen.
+    2.	Fixed backspace, which must have broken in 1.45.
+    3.	Added command line option of iconic startup.
+
+from 1.45 to 1.47
+    1.	Incorporated improved bsd utmp handling from
+        dperry@ringer.cs.utsa.edu (David Perry)
+    2.	Fixed a very minor bug where the solid-cursor can leave a
+    	a bit of a ghost when you resize the window. Its stupid,
+	but it always bothered me.
+
+from 1.4 to 1.45
+    1.	Fixed scrolling error when switching to larger fonts
+    2.	Fixed utmp-entry removal for SYSV type systems.
+    3.	Icorportated patches for FreeBSD and svr4
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/etc/rxvt.termcap work/main.d/rxvt-2.6.4/doc/etc/rxvt.termcap
--- tmp/rxvt-2.6.4/doc/etc/rxvt.termcap	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/etc/rxvt.termcap	1998-04-20 04:30:36.000000000 -0300
@@ -0,0 +1,19 @@
+#	Reconstructed via infocmp from file: /usr/share/terminfo/r/rxvt
+rxvt|rxvt terminal emulator (X Window System):\
+	:am:eo:km:mi:ms:xn:xo:\
+	:co#80:it#8:li#24:\
+	:AL=\E[%dL:DC=\E[%dP:DL=\E[%dM:DO=\E[%dB:IC=\E[%d@:\
+	:K1=\EOw:K2=\EOu:K3=\EOy:K4=\EOq:K5=\EOs:LE=\E[%dD:\
+	:RI=\E[%dC:UP=\E[%dA:ae=^O:al=\E[L:as=^N:bl=^G:cd=\E[J:\
+	:ce=\E[K:cl=\E[H\E[2J:cm=\E[%i%d;%dH:cr=^M:\
+	:cs=\E[%i%d;%dr:ct=\E[3g:dc=\E[P:dl=\E[M:do=^J:ei=\E[4l:\
+	:ho=\E[H:i1=\E[?47l\E=\E[?1l:ic=\E[@:im=\E[4h:\
+	:is=\E[r\E[m\E[2J\E[H\E[?7h\E[?1;3;4;6l\E[4l:\
+	:k0=\E[21~:k1=\E[11~:k2=\E[12~:k3=\E[13~:k4=\E[14~:\
+	:k5=\E[15~:k6=\E[17~:k7=\E[18~:k8=\E[19~:k9=\E[20~:\
+	:kD=\E[3~:kI=\E[2~:kN=\E[6~:kP=\E[5~:kb=^H:kd=\E[B:ke=\E>:\
+	:kh=\E[7~:kl=\E[D:kr=\E[C:ks=\E=:ku=\E[A:le=^H:mb=\E[5m:\
+	:md=\E[1m:me=\E[m\017:mr=\E[7m:nd=\E[C:rc=\E8:sc=\E7:\
+	:se=\E[27m:sf=^J:so=\E[7m:sr=\EM:st=\EH:ta=^I:\
+	:te=\E[?47l\E8:ti=\E7\E[?47h:ue=\E[24m:up=\E[A:us=\E[4m:\
+	:vb=\E[?5h\E[?5l:ve=\E[?25h:vi=\E[?25l:vs=\E[?25h:
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/etc/rxvt.terminfo work/main.d/rxvt-2.6.4/doc/etc/rxvt.terminfo
--- tmp/rxvt-2.6.4/doc/etc/rxvt.terminfo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/etc/rxvt.terminfo	1998-04-20 04:30:36.000000000 -0300
@@ -0,0 +1,53 @@
+# From: Thomas Dickey <dickey@clark.net> 04 Oct 1997
+# Updated: zgr Kesim <kesim@math.fu-berlin.de> 02 Nov 1997
+# Notes:
+# rxvt 2.21b uses
+#       smacs=\E(B\E)U^N, rmacs=\E(B\E)0^O,
+# but some applications don't work with that.
+# It also has an AIX extension
+#       box2=lqkxjmwuvtn,
+# and
+#       ech=\E[%p1%dX,
+# but the latter does not work correctly.
+#
+# rxvt is normally configured to look for "xterm" or "xterm-color" as $TERM.
+# Since rxvt is not really compatible with xterm, it should be configured as
+# "rxvt-basic" (monochrom) and "rxvt"
+rxvt-basic|rxvt terminal base (X Window System), 
+        am, bce, eo, km, mir, msgr, xenl, xon, 
+        cols#80, it#8, lines#24, 
+        acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~, 
+        bel=^G, blink=\E[5m, bold=\E[1m, civis=\E[?25l, 
+        clear=\E[H\E[2J, cnorm=\E[?25h, cr=^M, 
+        csr=\E[%i%p1%d;%p2%dr, cub=\E[%p1%dD, cub1=^H, 
+        cud=\E[%p1%dB, cud1=^J, cuf=\E[%p1%dC, cuf1=\E[C, 
+        cup=\E[%i%p1%d;%p2%dH, cuu=\E[%p1%dA, cuu1=\E[A, 
+        cvvis=\E[?25h, dch=\E[%p1%dP, dch1=\E[P, dl=\E[%p1%dM, 
+        dl1=\E[M, ed=\E[J, el=\E[K, el1=\E[1K, enacs=\E(B\E)0, 
+        flash=\E[?5h\E[?5l, home=\E[H, hpa=\E[%i%p1%dG, ht=^I, 
+        hts=\EH, ich=\E[%p1%d@, ich1=\E[@, il=\E[%p1%dL, il1=\E[L, 
+        ind=^J, is1=\E[?47l\E=\E[?1l, 
+        is2=\E[r\E[m\E[2J\E[H\E[?7h\E[?1;3;4;6l\E[4l, 
+        kDC=\E[3$, kEND=\E[8$, kHOM=\E[7$, kLFT=\E[d, kNXT=\E[6$, 
+        kPRV=\E[5$, kRIT=\E[c, ka1=\EOw, ka3=\EOy, kb2=\EOu, kbs=^H, 
+        kc1=\EOq, kc3=\EOs, kcbt=\E[Z, kcub1=\E[D, kcud1=\E[B, 
+        kcuf1=\E[C, kcuu1=\E[A, kdch1=\E[3~, kel=\E[8\^, 
+        kend=\E[8~, kent=\EOM, kf0=\E[21~, kf1=\E[11~, kf10=\E[21~, 
+        kf11=\E[23~, kf12=\E[24~, kf13=\E[25~, kf14=\E[26~, 
+        kf15=\E[28~, kf16=\E[29~, kf17=\E[31~, kf18=\E[32~, 
+        kf19=\E[33~, kf2=\E[12~, kf20=\E[34~, kf3=\E[13~, 
+        kf4=\E[14~, kf5=\E[15~, kf6=\E[17~, kf7=\E[18~, kf8=\E[19~, 
+        kf9=\E[20~, kfnd=\E[1~, khome=\E[7~, kich1=\E[2~, 
+        kmous=\E[M, knp=\E[6~, kpp=\E[5~, kslt=\E[4~, rc=\E8, 
+        rev=\E[7m, ri=\EM, rmacs=^O, rmcup=\E[?47l\E8, rmir=\E[4l, 
+        rmkx=\E>, rmso=\E[27m, rmul=\E[24m, 
+        rs1=\E>\E[1;3;4;5;6l\E[?7h\E[m\E[r\E[2J\E[H, 
+        rs2=\E[r\E[m\E[2J\E[H\E[?7h\E[?1;3;4;6l\E[4l\E>, 
+        s0ds=\E(B, s1ds=\E(0, sc=\E7, smacs=^N, smcup=\E7\E[?47h, 
+        smir=\E[4h, smkx=\E=, smso=\E[7m, smul=\E[4m, tbc=\E[3g, 
+        vpa=\E[%i%p1%dd, 
+rxvt|rxvt terminal emulator (X Window System), 
+        colors#8, pairs#64, 
+        op=\E[39;49m, setab=\E[%p1%{40}%+%dm, 
+        sgr0=\E[m\017, setaf=\E[%p1%{30}%+%dm,
+        use=rxvt-basic, 
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/etc/XTerm.ad work/main.d/rxvt-2.6.4/doc/etc/XTerm.ad
--- tmp/rxvt-2.6.4/doc/etc/XTerm.ad	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/etc/XTerm.ad	1998-04-20 04:30:35.000000000 -0300
@@ -0,0 +1,56 @@
+! Put this into ~/.Xdefaults, or to app-defaults/XTerm or wherever
+! xrm will loaded it.
+!
+! This will match the key sequences for a regular xterm to those used
+! by rxvt and the enclosed termcap and terminfo files.
+!
+! As usual, the most annoying xterm keys are Home/End and the ubiquitous
+! BackSpace/Delete confusion.
+
+XTerm*vt100.translations: #override \
+	<Key>BackSpace:	string("\010") \n\
+	Shift<Key>Tab:	string("\033[Z") \n\
+	Ctrl<Key>minus:	string("\037") \n\
+	<Key>Home:	string("\033[1~") \n\
+	<Key>End:	string("\033[4~") \n\
+	<Key>Delete:	string("\033[3~") \n\
+	Shift<Key>Delete:	string("\177") \n\
+	Ctrl<Key>Delete:	string("\010") \n\
+	Alt<Key>Return:	string("\033\015") \n\
+	Alt<Key>space:	string("\033\040") \n\
+	Alt<Key>a:	string("\033a") \n\
+	Alt<Key>b:	string("\033b") \n\
+	Alt<Key>c:	string("\033c") \n\
+	Alt<Key>d:	string("\033d") \n\
+	Alt<Key>e:	string("\033e") \n\
+	Alt<Key>f:	string("\033f") \n\
+	Alt<Key>g:	string("\033g") \n\
+	Alt<Key>h:	string("\033h") \n\
+	Alt<Key>i:	string("\033i") \n\
+	Alt<Key>j:	string("\033j") \n\
+	Alt<Key>k:	string("\033k") \n\
+	Alt<Key>l:	string("\033l") \n\
+	Alt<Key>m:	string("\033m") \n\
+	Alt<Key>n:	string("\033n") \n\
+	Alt<Key>o:	string("\033o") \n\
+	Alt<Key>p:	string("\033p") \n\
+	Alt<Key>q:	string("\033q") \n\
+	Alt<Key>r:	string("\033r") \n\
+	Alt<Key>s:	string("\033s") \n\
+	Alt<Key>t:	string("\033t") \n\
+	Alt<Key>u:	string("\033u") \n\
+	Alt<Key>v:	string("\033v") \n\
+	Alt<Key>w:	string("\033w") \n\
+	Alt<Key>x:	string("\033x") \n\
+	Alt<Key>y:	string("\033y") \n\
+  	Alt<Key>z:	string("\033z") \n\
+	Ctrl<Key>Up:		string("\033Oa") \n\
+	Ctrl<Key>Down:		string("\033Ob") \n\
+	Ctrl<Key>Right:		string("\033Oc") \n\
+	Ctrl<Key>Left:		string("\033Od") \n\
+	Shift<Key>Up:		string("\033[a") \n\
+	Shift<Key>Down:		string("\033[b") \n\
+	Shift<Key>Right:	string("\033[c") \n\
+	Shift<Key>Left:		string("\033[d") \n
+
+!EOF
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/FAQ work/main.d/rxvt-2.6.4/doc/FAQ
--- tmp/rxvt-2.6.4/doc/FAQ	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/FAQ	1999-01-27 07:35:21.000000000 -0300
@@ -0,0 +1,308 @@
+--------------------------------------------------------------------------
+				   FAQ
+--------------------------------------------------------------------------
+
+-----
+
+    Q:	How do I know which rxvt version I'm using?
+
+    A:	The version number is displayed with the usage (-h).
+	For rxvt version 2.14 and later, the escape sequence `ESC[8n'
+	sets the window title to the version number.
+
+-----
+
+    Q:	Mouse cut/paste suddenly no longer works.
+
+    A:	Make sure that mouse reporting is actually turned off since
+	killing some editors prematurely may leave the mouse in mouse
+	report mode.  I've heard that tcsh may use mouse reporting
+	unless it otherwise specified.  A quick check is to see if
+	cut/paste works when the Alt or Shift keys are depressed. See
+	doc/refer.txt
+
+-----
+
+    Q:	What's with this bold/blink stuff?  I can never get blinking text!
+
+    A:	It is not possible, and likely will never be, for rxvt to have
+	actual blinking text. Instead (if rxvt was compiled without
+	NO_BOLDCOLOR), bold/blink attributes are used to set high-intensity
+	foreground/background colors ... like what you'd see on a PC video
+	adapter.  There are programs, notably John Davis' SLang-based ones
+	<ftp://space.mit.edu/pub/davis>, that use bold/blink attributes to
+	permit 16 colors.
+
+	color0-7 are the low-intensity colors.
+	color8-15 are the corresponding high-intensity colors.
+
+	A side issue of this bold/blink stuff is the question of how the
+	normal default foreground/background colors are to be treated.  If
+	the default foreground/background match one of the low-intensity
+	colors (color0-7), the bold/blink attribute will invoke the
+	appropriate high-intensity color (color8-15).
+
+	In the case that the default foreground doesn't match one of the
+	low-intensity colors, the bold attribute will use an `overstrike'
+	to simulate a bold font. But note this leaves pixel-droppings and
+	so, rather than wasting an inordinate amounts of energy to fix it,
+	its use is simply deprecated.
+
+	In the case that the default background doesn't match one of the
+	low-intensity colors, the blink attribute is simply ignored
+	(rather than representing it as bold as xterm does).
+
+-----
+
+    Q:	I don't like the screen colors.  How do I change them?
+
+    A:	You can change the screen colors at run-time using ~/.Xdefaults
+	resources (or as long-options) ... see the man-page.
+
+	Here are values that are supposed to resemble a VGA screen,
+	including the murky brown that passes for low-intensity yellow:
+
+		Rxvt*color0:	#000000
+		Rxvt*color1:	#A80000
+		Rxvt*color2:	#00A800
+		Rxvt*color3:	#A8A800
+		Rxvt*color4:	#0000A8
+		Rxvt*color5:	#A800A8
+		Rxvt*color6:	#00A8A8
+		Rxvt*color7:	#A8A8A8
+
+		Rxvt*color8:	#000054
+		Rxvt*color9:	#FF0054
+		Rxvt*color10:	#00FF54
+		Rxvt*color11:	#FFFF54
+		Rxvt*color12:	#0000FF
+		Rxvt*color13:	#FF00FF
+		Rxvt*color14:	#00FFFF
+		Rxvt*color15:	#FFFFFF
+
+-----
+
+    Q:	What's with the strange Backspace/Delete key behaviour?
+
+    A:	Assuming that the physical Backspace key corresponds to the
+	BackSpace keysym (not likely for Linux ... see the following
+	question) there are two standard values that can be used for
+	Backspace: ^H and ^?.
+
+	Rxvt tries to inherit the current stty settings and uses the value
+	of `erase' to guess the value for backspace.  If rxvt wasn't started
+	from a terminal (say, from a menu or by remote shell), then the
+	system value of `erase', which corresponds to CERASE in <termios.h>,
+	will be used (which may not be the same as your stty setting).
+
+	For starting a new rxvt:
+
+	    use Backspace = ^H
+		$ stty erase ^H
+		$ rxvt
+
+	    use Backspace = ^?
+		$ stty erase ^?
+		$ rxvt
+
+	NB: generate either value with BackSpace and Ctrl/Shift-BackSpace.
+	    Toggle with "ESC[36h" / "ESC[36l" as documented in "doc/refer.txt"
+
+	For an existing rxvt:
+	    use Backspace = ^H
+		$ stty erase ^H
+		$ echo -n "^[[36h"
+
+	    use Backspace = ^?
+		$ stty erase ^?
+		$ echo -n "^[[36l"
+
+	This helps satisfy some of the Backspace discrepancies that occur,
+	but if you use Backspace = ^?, make sure that the termcap/terminfo
+	value properly reflects that.
+
+	The Delete key (which one would expect to emit ^?) is a another
+	casualty of the ill-defined Backspace problem.  To avoid confusion
+	between the Backspace and Delete keys, the Delete key has been
+	assigned an escape sequence to match the vt100 for Execute (ESC[3~)
+	and is in the supplied termcap/terminfo.
+
+	Some other Backspace problems:
+		some editors use termcap/terminfo,
+		some editors (vim I'm told) expect Backspace = ^H,
+		GNU Emacs (and Emacs-like editors) use ^H for help.
+
+	Perhaps someday this will all be resolved in a consistent manner
+	... and maybe xterm will have Home/End values too!
+
+-----
+
+    Q:	Why doesn't the Backspace key work on my Linux machine?
+
+    A:	The XFree86 server has a notorious problem of mapping the Backspace
+	key as Delete in order to match the Linux console.
+
+	The correct way to fix this:
+
+	  0 - Complain to your Linux distributer and the XFree86 team, maybe
+	      they'll fix it.
+
+	  1 - Use xmodmap to correct the Backspace mapping
+
+		! ~/.Xmodmap
+
+		! a correctly-mapped BackSpace
+		keycode 22 = BackSpace
+
+		*** Make sure the keycode above matches the physical
+		    Backspace key on your machine!! (use xev) ***
+
+	This will also fix the BackSpace problem with Motif applications,
+	such as ``why doesn't Backspace work for Netscape?''
+
+	You now have a Backspace key that functions as described in the
+	previous question.
+
+	  1a - You may also want to fix the regular xterm if it doesn't
+	      generates the desired value for BackSpace
+
+		xterm*vt100.translations: #override \
+		<Key>BackSpace: string(\010) \n
+	    or
+		xterm*vt100.translations: #override \
+		<Key>BackSpace: string(\177) \n
+
+	   while you are at it, you may also want to have consistent
+	   values to Home/End/Delete
+
+		xterm*vt100.translations: #override \
+		<Key>Home:	string("\033[7~") \n\
+		<Key>End:	string("\033[8~") \n\
+		<Key>Delete:	string("\033[3~") \n
+
+	Finally, you can also remap the rxvt key-binding at run-time (next
+	question) but you'll lose the ability to have Ctrl/Shift-Backspace
+	work differently as well as losing the escape sequence toggling of
+	Backspace.
+
+-----
+
+    Q:	I don't like the key-bindings.  How do I change them?
+
+    A:	There are some compile-time selections available via configure.
+        Unless you have run "configure" with the "--disable-resources"
+	option you can use the `keysym' resource to alter the keystrings
+	associated with keysym 0xFF00 - 0xFFFF (function, cursor keys, etc).
+
+	Here's an example for a tn3270 session started using
+	`rxvt -name tn3270'
+
+		!#  ----- special uses ------:
+		! tn3270 login, remap function and arrow keys.
+		tn3270*font:	*clean-bold-*-*--15-*
+
+		! keysym - used by rxvt only
+		! Delete - ^D
+		tn3270*keysym.0xFFFF:	\004
+
+		! Home - ^A
+		tn3270*keysym.0xFF50:	\001
+		! Left - ^B
+		tn3270*keysym.0xFF51:	\002
+		! Up - ^P
+		tn3270*keysym.0xFF52:	\020
+		! Right - ^F
+		tn3270*keysym.0xFF53:	\006
+		! Down - ^N
+		tn3270*keysym.0xFF54:	\016
+		! End - ^E
+		tn3270*keysym.0xFF57:	\005
+
+		! F1 - F12
+		tn3270*keysym.0xFFBE:	\e1
+		tn3270*keysym.0xFFBF:	\e2
+		tn3270*keysym.0xFFC0:	\e3
+		tn3270*keysym.0xFFC1:	\e4
+		tn3270*keysym.0xFFC2:	\e5
+		tn3270*keysym.0xFFC3:	\e6
+		tn3270*keysym.0xFFC4:	\e7
+		tn3270*keysym.0xFFC5:	\e8
+		tn3270*keysym.0xFFC6:	\e9
+		tn3270*keysym.0xFFC7:	\e0
+		tn3270*keysym.0xFFC8:	\e-
+		tn3270*keysym.0xFFC9:	\e=
+
+		! map Prior/Next to F7/F8
+		tn3270*keysym.0xFF55:	\e7
+		tn3270*keysym.0xFF56:	\e8
+
+-----
+
+    Q:	I'm using keyboard model XXX that has extra Prior/Next/Insert keys.
+	How do I make use of them?  For example, the Sun Keyboard type 4
+	has the following mappings that rxvt doesn't recognize.
+
+		KP_Insert == Insert
+		F22 == Print
+		F27 == Home
+		F29 == Prior
+		F33 == End
+		F35 == Next
+
+    A:	Rather than have rxvt try to accomodate all the various possible
+	keyboard mappings, it is better to use `xmodmap' to remap the
+	keys as required for your particular machine.
+
+-----
+
+    Q:	How do I distinguish if I'm running rxvt or a regular xterm?
+	I need this to decide about setting colors etc.
+
+    A:	rxvt always exports the variable "COLORTERM", so you can check and
+	see if that is set.  Note that several programs, JED, slrn, Midnight
+	Commander automatically check this variable to decide whether or not
+	to use color.
+
+-----
+
+    Q:	How do I set the correct, full IP address for the DISPLAY variable?
+
+    A:	If you've compiled rxvt with DISPLAY_IS_IP then it is
+	possible to use the following shell script snippets to correctly set
+	the display.  If your version of rxvt wasn't also compiled with
+	ESCZ_ANSWER (as assumed in these snippets) then the COLORTERM
+	variable can be used to distinguish rxvt from a regular xterm.
+
+	Courtesy of Chuck Blake <cblake@BBN.COM> with the following shell
+	script snippets:
+
+	# Bourne/Korn/POSIX family of shells:
+	[ ${TERM:-foo} = foo ] && TERM=xterm # assume an xterm if we don't know
+	if [ ${TERM:-foo} = xterm ]; then
+	    stty -icanon -echo min 0 time 15 # see if enhanced rxvt or not
+	    echo -n '^[Z'
+	    read term_id
+	    stty icanon echo
+	    if [ ""${term_id} = '^[[?1;2C' -a ${DISPLAY:-foo} = foo ]; then
+	        echo -n '^[[7n'		# query the rxvt we are in for the DISPLAY string
+	        read DISPLAY		# set it in our local shell
+	    fi
+	fi
+
+	csh/tcsh family of shells:
+
+	if ( !(${?TERM}) ) then		# if term is unset, we are probably in an xterm
+	    TERM = xterm
+	endif
+	if ( ${TERM} =~ xterm ) then
+	    stty -icanon -echo min 0 time 15   # see if enhanced rxvt or not
+	    echo -n '^[Z'
+	    set term_id=$<
+	    stty icanon echo
+	    if ( ""${term_id} == "^[[?1;2C" && ${?DISPLAY} == 0 ) then
+	        echo -n '^[[7n'		# query the rxvt we're in for the DISPLAY string
+	        setenv DISPLAY "$<"	# set it in our local shell
+	    endif
+	endif
+--
+EOF
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/LSM.in work/main.d/rxvt-2.6.4/doc/LSM.in
--- tmp/rxvt-2.6.4/doc/LSM.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/LSM.in	2001-11-01 21:36:24.000000000 -0300
@@ -0,0 +1,51 @@
+Begin3
+Title:		rxvt
+Version:	@RXVT_VERSION@
+Entered-date:	@RXVT_LSMDATE@
+
+Description:	@RXVT_WEBPAGE@
+		Rxvt is an 8-bit clean, colour xterm replacement that uses
+		significantly less memory than a conventional xterm, mostly
+		since it doesn't support toolkit configurability or Tek
+		graphics, but also since features can be removed at
+		compile-time to reflect your needs.  Some rxvt features
+		(compilation dependent): ANSI-color, bold/blink attributes
+		modify foreground/background colours, scrollbars with arrow
+		buttons, kanji and greek support, printer-pipe, XPM
+		backgrounds with on-the-fly scaling, user-definable menus.
+
+		The distribution also includes rclock, the smaller/better
+		xclock replacement with appointment scheduling and xbiff
+		functionality.
+
+Keywords:	rxvt colour color kanji xterm X11 vt100 terminal-emulator
+		rclock xbiff xpm menu
+
+Author:		* John Bovey [Univ. Kent at Canterbury] was the creator of
+		  the original xvt.
+
+		* Rob Nation [Lockheed] re-wrote most of xvt to make a
+		  substantiallly enhanced version called rxvt (Rob's xvt)
+		  and also wrote rclock (Rob's clock).
+
+		* Mark Olesen [Queen's Univ. at Kingston] made various
+		  improvements and cleanups. 
+		  Coordinated development, versions 2.11 - 2.21
+
+		* Oezguer Kesim [FU Berlin] 
+		  Coordinated development, versions 2.21a - 2.4.5
+
+		* Geoff Wing rewrote much of the screen refreshing routines
+		  and mouse selection.
+		  Coordinated development, versions 2.4.6 - 
+
+Maintained-by:	@RXVT_MAINT@ @RXVT_MAINTEMAIL@ Project Coordinator
+
+Original-site:	@RXVT_FTPSITENAME@ @RXVT_FTPSITEDIR@
+		301k	rxvt-@RXVT_VERSION@.tar.gz
+
+Platforms:	requires X11 installed
+
+Copying-policy:	GPL
+
+End
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/Makefile work/main.d/rxvt-2.6.4/doc/Makefile
--- tmp/rxvt-2.6.4/doc/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/Makefile	2007-01-15 18:03:53.000000000 -0300
@@ -0,0 +1,178 @@
+# Generated automatically from Makefile.in by configure.
+# doc/Makefile.in	-*- Makefile -*-
+# $Id: Makefile.in,v 1.12.4.4 2000/04/15 08:59:44 gcw Exp $
+
+# autoconf/Make.common.in	 -*- Makefile -*-
+# release date (man), LSM date, version number/name, current maintainer
+DATE=02 NOVEMBER 2001
+LSMDATE=02NOV01
+VERSION=2.6.4
+VERNAME=rxvt-$(VERSION)#
+MAINT=Geoff Wing#
+MAINTEMAIL=<gcw@rxvt.org>#
+WEBMAINT=Oezguer Kesim#
+WEBMAINTEMAIL=<oec@rxvt.org>#
+WEBPAGE=<http://www.rxvt.org/>#
+FTPSITENAME=ftp.rxvt.org#
+FTPSITEDIR=/pub/rxvt#
+#-------------------------------------------------------------------------
+
+SHELL = /bin/sh
+
+# This variable makes it possible to move the installation root to another
+# directory. This is useful when you're creating a binary distribution
+# If empty, normal root will be used.
+# You can run eg. 'make install DESTDIR=/packages/rxvt-xx' to accomplish
+# that.
+# DESTDIR = /usr/local/X11/$(VERNAME)
+
+# Installation target directories & other installation stuff
+prefix = //usr
+exec_prefix = //usr
+binprefix =
+manprefix =
+bindir = //usr/bin
+mandir = //usr/share/man/man1
+manext = 1
+
+# Tools & program stuff
+CC = i586-castorbox-linux-gnu-gcc
+CPP = i586-castorbox-linux-gnu-cpp
+MV = //media/gar-castorbox/images/build/usr/bin/mv
+RM = //media/gar-castorbox/images/build/usr/bin/rm
+RMF = //media/gar-castorbox/images/build/usr/bin/rm -f
+CP = //media/gar-castorbox/images/build/usr/bin/cp
+SED = //media/gar-castorbox/images/build/usr/bin/sed
+AWK = //media/gar-castorbox/images/build/usr/bin/awk
+ECHO = //media/gar-castorbox/images/build/usr/bin/echo
+CMP = //media/gar-castorbox/images/build/usr/bin/cmp
+TBL = 
+INSTALL = //media/gar-castorbox/images/build/usr/bin/install -c
+INSTALL_PROGRAM = //media/gar-castorbox/images/build/usr/bin/install -c -s -m 755
+INSTALL_DATA = //media/gar-castorbox/images/build/usr/bin/install -c -m 644
+
+# Flags & libs
+# add -DBINDIR=\""$(bindir)/"\" to CPPFLAGS, if we need to spawn a program
+
+CFLAGS = -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32 
+CPPFLAGS =  
+LDFLAGS = 
+DEFS = -DHAVE_CONFIG_H
+LIBS = 
+DINCLUDE = 
+DLIB = 
+
+# X Include directory
+XINC =  -I/media/gar-castorbox/images/main//usr/include 
+
+# extra libraries needed by X on some systems, X library location
+XLIB =  -L/media/gar-castorbox/images/main//usr/lib  -lX11 
+
+# End of common section of the Makefile
+#-------------------------------------------------------------------------
+
+srcdir =	.
+.PATH:		.
+
+basedir = ..
+thisdir = doc
+
+first_rule: all
+dummy:
+
+#
+# Distribution variables
+#
+
+YODL_RXVT = yodl/rxvt-colours.yo yodl/rxvt-environment.yo\
+	    yodl/rxvt-files.yo yodl/rxvt-fonts.yo yodl/rxvt-login.yo\
+	    yodl/rxvt-mousereporting.yo yodl/rxvt-options.yo\
+	    yodl/rxvt-resources.yo yodl/rxvt-scrollbar.yo\
+	    yodl/rxvt-textselection.yo
+YODL_RREF = yodl/rxvtRef-csi.yo yodl/rxvtRef-definitions.yo\
+	    yodl/rxvtRef-graphics.yo yodl/rxvtRef-keycodes.yo\
+	    yodl/rxvtRef-menubar.yo yodl/rxvtRef-mouse.yo\
+	    yodl/rxvtRef-privatemodes.yo yodl/rxvtRef-sequences.yo\
+	    yodl/rxvtRef-values.yo yodl/rxvtRef-xpm.yo yodl/rxvtRef-xterm.yo
+
+DIST_ETC  = etc/rxvt.termcap etc/rxvt.terminfo etc/XTerm.ad
+DIST_YODL = yodl/masonyodl.yo yodl/versioninfo.yo yodl/versioninfo.yo.in\
+	    $(YODL_RXVT) yodl/rxvt.yo yodl/rxvt.yo.in $(YODL_RREF)\
+	    yodl/rxvtRef.yo.in
+DIST_MENU = menu/menu menu/example.menu menu/rxvt.menu menu/terminal.menu\
+	    menu/jedmenu.sl
+DIST	  = Makefile.in README.greek README.menu README.xvt BUGS FAQ TODO\
+	    changes.txt xterm.seq LSM.in rxvt.1 rxvt.tbl rxvtRef.txt\
+	    rxvtRef.html rxvtRef-frame.html rxvtRef-toc.html rxvt.html 
+
+#-------------------------------------------------------------------------
+
+all: rxvt.1
+
+rxvt.1: Makefile
+	@if test x$(TBL) = x; then : ; else echo "$(TBL) $(srcdir)/rxvt.tbl | grep -v '^.lf' > rxvt.1"; $(TBL) $(srcdir)/rxvt.tbl | grep -v '^.lf' > rxvt.1 ; fi
+
+SEDREPLACE = -e 's%@RXVT_VERSION@%$(VERSION)%g;'\
+	     -e 's%@RXVT_LSMDATE@%$(LSMDATE)%g;'\
+	     -e 's%@RXVT_DATE@%$(DATE)%g;'\
+	     -e 's%@RXVT_MAINTEMAIL@%$(MAINTEMAIL)%g;'\
+	     -e 's%@RXVT_MAINT@%$(MAINT)%g;'\
+	     -e 's%@RXVT_WEBPAGE@%$(WEBPAGE)%g;'\
+	     -e 's%@RXVT_WEBMAINTEMAIL@%$(WEBMAINTEMAIL)%g;'\
+	     -e 's%@RXVT_WEBMAINT@%$(WEBMAINT)%g;'\
+	     -e 's%@RXVT_FTPSITENAME@%$(FTPSITENAME)%g;'\
+	     -e 's%@RXVT_FTPSITEDIR@%$(FTPSITEDIR)%g;'
+
+tags allbin:
+
+alldoc:	$(basedir)/$(VERNAME).lsm rxvt.tbl rxvt.1 rxvt.html rxvtRef.html rxvtRef.txt
+
+yodl/versioninfo.yo: yodl/versioninfo.yo.in ../src/version.h
+	$(SED) $(SEDREPLACE) < $(srcdir)/yodl/versioninfo.yo.in > $@
+
+$(basedir)/$(VERNAME).lsm: LSM.in $(srcdir)/../autoconf/Make.common.in $(srcdir)/../src/version.h
+	$(SED) $(SEDREPLACE) < $(srcdir)/LSM.in > $@
+
+rxvt.tbl: yodl/rxvt.yo $(YODL_RXVT) yodl/versioninfo.yo yodl/masonyodl.yo
+	yodl2man -orxvt.tbl yodl/rxvt.yo
+
+rxvt.html: yodl/rxvt.yo $(YODL_RXVT) yodl/versioninfo.yo yodl/masonyodl.yo
+	yodl2html -o$@ yodl/rxvt.yo
+
+rxvtRef.html: $(YODL_RREF) yodl/rxvtRef.yo yodl/masonyodl.yo
+	yodl2html -o$@ yodl/rxvtRef.yo
+
+rxvtRef.txt: $(YODL_RREF) yodl/rxvtRef.yo yodl/masonyodl.yo
+	yodl2txt -o$@ yodl/rxvtRef.yo
+
+clean:
+	$(RMF) rxvt.man *~ yodl/*~
+
+realclean: clean
+	$(RMF) tags rxvt.1 rxvt.html rxvtRef.html rxvtRef.txt
+
+distclean:
+
+install:
+	$(INSTALL_DATA) rxvt.1 $(DESTDIR)$(mandir)/$(manprefix)rxvt.$(manext)
+
+uninstall:
+	-cd $(mandir); $(RMF) $(manprefix)rxvt.$(manext)
+
+distdirs:
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)/etc
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)/menu
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)/yodl
+
+distcopy: distdepend
+	$(CP) -p $(basedir)/$(VERNAME).lsm $(basedir)/../$(VERNAME);
+	$(CP) -p $(DIST)      $(basedir)/../$(VERNAME)/$(thisdir)
+	$(CP) -p $(DIST_ETC)  $(basedir)/../$(VERNAME)/$(thisdir)/etc
+	$(CP) -p $(DIST_MENU) $(basedir)/../$(VERNAME)/$(thisdir)/menu
+	$(CP) -p $(DIST_YODL) $(basedir)/../$(VERNAME)/$(thisdir)/yodl
+
+distdepend: alldoc
+
+# ------------------------------------------------------------------------
+# DO NOT DELETE: ugly dependency list follows
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/Makefile.in work/main.d/rxvt-2.6.4/doc/Makefile.in
--- tmp/rxvt-2.6.4/doc/Makefile.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/Makefile.in	2000-04-15 05:59:44.000000000 -0300
@@ -0,0 +1,110 @@
+# doc/Makefile.in	-*- Makefile -*-
+# $Id: Makefile.in,v 1.12.4.4 2000/04/15 08:59:44 gcw Exp $
+@MCOMMON@
+
+srcdir =	@srcdir@
+VPATH =		@srcdir@
+.PATH:		@srcdir@
+
+basedir = ..
+thisdir = doc
+
+first_rule: all
+dummy:
+
+#
+# Distribution variables
+#
+
+YODL_RXVT = yodl/rxvt-colours.yo yodl/rxvt-environment.yo\
+	    yodl/rxvt-files.yo yodl/rxvt-fonts.yo yodl/rxvt-login.yo\
+	    yodl/rxvt-mousereporting.yo yodl/rxvt-options.yo\
+	    yodl/rxvt-resources.yo yodl/rxvt-scrollbar.yo\
+	    yodl/rxvt-textselection.yo
+YODL_RREF = yodl/rxvtRef-csi.yo yodl/rxvtRef-definitions.yo\
+	    yodl/rxvtRef-graphics.yo yodl/rxvtRef-keycodes.yo\
+	    yodl/rxvtRef-menubar.yo yodl/rxvtRef-mouse.yo\
+	    yodl/rxvtRef-privatemodes.yo yodl/rxvtRef-sequences.yo\
+	    yodl/rxvtRef-values.yo yodl/rxvtRef-xpm.yo yodl/rxvtRef-xterm.yo
+
+DIST_ETC  = etc/rxvt.termcap etc/rxvt.terminfo etc/XTerm.ad
+DIST_YODL = yodl/masonyodl.yo yodl/versioninfo.yo yodl/versioninfo.yo.in\
+	    $(YODL_RXVT) yodl/rxvt.yo yodl/rxvt.yo.in $(YODL_RREF)\
+	    yodl/rxvtRef.yo.in
+DIST_MENU = menu/menu menu/example.menu menu/rxvt.menu menu/terminal.menu\
+	    menu/jedmenu.sl
+DIST	  = Makefile.in README.greek README.menu README.xvt BUGS FAQ TODO\
+	    changes.txt xterm.seq LSM.in rxvt.1 rxvt.tbl rxvtRef.txt\
+	    rxvtRef.html rxvtRef-frame.html rxvtRef-toc.html rxvt.html 
+
+#-------------------------------------------------------------------------
+
+all: rxvt.1
+
+rxvt.1: Makefile
+	@if test x$(TBL) = x; then : ; else echo "$(TBL) $(srcdir)/rxvt.tbl | grep -v '^.lf' > rxvt.1"; $(TBL) $(srcdir)/rxvt.tbl | grep -v '^.lf' > rxvt.1 ; fi
+
+SEDREPLACE = -e 's%@RXVT_VERSION@%$(VERSION)%g;'\
+	     -e 's%@RXVT_LSMDATE@%$(LSMDATE)%g;'\
+	     -e 's%@RXVT_DATE@%$(DATE)%g;'\
+	     -e 's%@RXVT_MAINTEMAIL@%$(MAINTEMAIL)%g;'\
+	     -e 's%@RXVT_MAINT@%$(MAINT)%g;'\
+	     -e 's%@RXVT_WEBPAGE@%$(WEBPAGE)%g;'\
+	     -e 's%@RXVT_WEBMAINTEMAIL@%$(WEBMAINTEMAIL)%g;'\
+	     -e 's%@RXVT_WEBMAINT@%$(WEBMAINT)%g;'\
+	     -e 's%@RXVT_FTPSITENAME@%$(FTPSITENAME)%g;'\
+	     -e 's%@RXVT_FTPSITEDIR@%$(FTPSITEDIR)%g;'
+
+tags allbin:
+
+alldoc:	$(basedir)/$(VERNAME).lsm rxvt.tbl rxvt.1 rxvt.html rxvtRef.html rxvtRef.txt
+
+yodl/versioninfo.yo: yodl/versioninfo.yo.in ../src/version.h
+	$(SED) $(SEDREPLACE) < $(srcdir)/yodl/versioninfo.yo.in > $@
+
+$(basedir)/$(VERNAME).lsm: LSM.in $(srcdir)/../autoconf/Make.common.in $(srcdir)/../src/version.h
+	$(SED) $(SEDREPLACE) < $(srcdir)/LSM.in > $@
+
+rxvt.tbl: yodl/rxvt.yo $(YODL_RXVT) yodl/versioninfo.yo yodl/masonyodl.yo
+	yodl2man -orxvt.tbl yodl/rxvt.yo
+
+rxvt.html: yodl/rxvt.yo $(YODL_RXVT) yodl/versioninfo.yo yodl/masonyodl.yo
+	yodl2html -o$@ yodl/rxvt.yo
+
+rxvtRef.html: $(YODL_RREF) yodl/rxvtRef.yo yodl/masonyodl.yo
+	yodl2html -o$@ yodl/rxvtRef.yo
+
+rxvtRef.txt: $(YODL_RREF) yodl/rxvtRef.yo yodl/masonyodl.yo
+	yodl2txt -o$@ yodl/rxvtRef.yo
+
+clean:
+	$(RMF) rxvt.man *~ yodl/*~
+
+realclean: clean
+	$(RMF) tags rxvt.1 rxvt.html rxvtRef.html rxvtRef.txt
+
+distclean:
+
+install:
+	$(INSTALL_DATA) rxvt.1 $(DESTDIR)$(mandir)/$(manprefix)rxvt.$(manext)
+
+uninstall:
+	-cd $(mandir); $(RMF) $(manprefix)rxvt.$(manext)
+
+distdirs:
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)/etc
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)/menu
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)/yodl
+
+distcopy: distdepend
+	$(CP) -p $(basedir)/$(VERNAME).lsm $(basedir)/../$(VERNAME);
+	$(CP) -p $(DIST)      $(basedir)/../$(VERNAME)/$(thisdir)
+	$(CP) -p $(DIST_ETC)  $(basedir)/../$(VERNAME)/$(thisdir)/etc
+	$(CP) -p $(DIST_MENU) $(basedir)/../$(VERNAME)/$(thisdir)/menu
+	$(CP) -p $(DIST_YODL) $(basedir)/../$(VERNAME)/$(thisdir)/yodl
+
+distdepend: alldoc
+
+# ------------------------------------------------------------------------
+# DO NOT DELETE: ugly dependency list follows
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/menu/example.menu work/main.d/rxvt-2.6.4/doc/menu/example.menu
--- tmp/rxvt-2.6.4/doc/menu/example.menu	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/menu/example.menu	1998-04-20 04:30:37.000000000 -0300
@@ -0,0 +1,95 @@
+This example illustrates how several menus could be combined together
+
+command = "[read:example]"
+
+	read the file starting at "[menu]" or "[menu:???]"
+	and continue until it "[done]"
+
+command = "[read:example;pico]" or "[read:example;shell]"
+
+	read the file starting at "[menu:pico]" or "[menu:shell]",
+	respectively and continue until "[done:pico]" or [done:shell]",
+	respectively.
+
+#-------------------------------------------------------------------------
+
+[menu:pico]
+[clear]
+[title:Pico (%n-%v)]
+
+# a menu for the pico editor
+# mostly a demonstration, I don't know why anyone would need it
+
+# Prior/Next & Home/End are messed up
+<l>^A<r>^E<u>^Y<d>^V
+
+/File/*
+{Insert File}{^R}
+{Save As}{^O}
+{-}
+{Suspend}{^Z}
+{Exit}{^X}
+
+/Edit/*
+{Find}{^W}
+{-}
+{Del Char}{^D}
+{Mark}{^^}
+{Kill Line}{^K}
+{Paste}{^U}
+
+/Basics/*
+{Forward}{^F}
+{Backward}{^B}
+{-}
+{Prev}{^P}
+{Next}{^N}
+{-}
+{Beg-of-Line}{^A}
+{End-of-Line}{^E}
+{-}
+{Prev Page}{^Y}
+{Next Page}{^V}
+
+/Buffer/*
+{Reformat}{^J}
+{Position}{^C}
+{Refresh}{^L}
+{Spell}{^T}
+
+[read:terminal]
+
+/?/*
+{Help}{^G}
+
+[show]
+[done:pico]
+
+#-------------------------------------------------------------------------
+
+[menu:shell]
+[clear]
+[title:shell]
+# [pixmap:name]
+
+# not necessarily useful, but an example of using the rxvt menuBar
+
+# assuming we have ksh with Emacs bindings
+<u>^P<d>^N<r>^F<l>^B
+
+/Programs/*
+{Edit}		${EDITOR:-vi}\r
+{Mail}		Mail\r
+{News}		slrn\r
+{Rxvt-News}	rxvt -e slrn&
+{Commander}	mc\r
+
+/Shell/{finger} finger\r
+{.name}	invisible label!
+/
+
+[read:terminal]
+[show]
+[done:shell]
+
+#--------------------------------------------------------------------- eof
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/menu/jedmenu.sl work/main.d/rxvt-2.6.4/doc/menu/jedmenu.sl
--- tmp/rxvt-2.6.4/doc/menu/jedmenu.sl	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/menu/jedmenu.sl	1998-04-20 04:30:38.000000000 -0300
@@ -0,0 +1,136 @@
+%--------------------------------*-SLang-*--------------------------------
+% An example of using the rxvt menuBar for the JED editor
+#if$TERM xterm*
+%!% provide a hook to imitated the S-Lang> prompt
+%!% use ESC[m to shadow the ESC[M used by mouse reporting
+define menuFn ()
+{
+   variable ch, cmd;
+
+   cmd = Null_String;
+   forever
+     {
+	ch = getkey ();
+	if (ch == '\r') break;
+	cmd = strcat (cmd, char (ch));
+     }
+   eval (cmd);
+}
+local_setkey ("menuFn", "\e[m");	% menu
+
+%!% allow the user to bind their owm commands
+define menucmd (str) { tt_send (Sprintf ("\e]10;%s\a", str, 1)); }
+%-------------------------------------------------------------------------
+% integrate these with any existing suspend/resume/exit hooks
+% the suspend hook works best if there was already a menu defined
+% before invoking JED
+
+define suspend_hook () { menucmd ("[prev]"); }
+define resume_hook () { menucmd ("[next]"); }
+define exit_hook () { menucmd ("[rm]"); exit_jed (); }
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+menucmd ("[read:jedmenu.sl]");		% read this file
+
+% format _jed_version xyyzz into x.yy-zz
+menucmd (Sprintf ("[:[title:Jed%d.%d-%d (%%n-%%v)]:]",
+		  (_jed_version/10000),
+		  ((_jed_version mod 10000)/100),
+		  (_jed_version mod 100),
+		  3));
+
+% get rid off pixmap stuff
+if (strcmp (getenv ("COLORTERM"), "rxvt-xpm"))
+{
+   menucmd ("[menu][:-/Terminal/Pixmap:][show]");
+}
+#endif	% xterm*
+%%%%%%%%%%%%%%%%%%%%%%%%%%% end-of-file (SLang) %%%%%%%%%%%%%%%%%%%%%%%%%%
+% rxvt menu database
+#iffalse
+% An example of using the rxvt menuBar for the JED editor
+% possibly useful things for the JED editor -- assuming Emacs bindings
+
+[menu:jed]
+
+[title:Jed menu (%n-%v)]
+% some convenient arrows
+<b>\E[m<l>bskip_word<u>backward_paragraph<d>forward_paragraph<r>skip_word<e>\r
+
+/File/*
+{Open}{^X^F}
+{Save}{^X^W}
+{Save Buffers}{^Xs}
+{Insert File}{^Xi}
+{-}
+{Shell Cmd}{M-!}
+{-}
+{Exit}{^X^C}
+
+/Edit/*
+{Undo}{^_}
+{-}
+{Cut}{^W}
+{Copy}{M-W}
+{Paste}{^Y}
+
+/Search/*
+{Forward}{^S}
+{Backward}{^R}
+{Replace}{M-%}
+{-}
+./Regexp/*
+{Forward}{M-^S}
+{Backward}{M-^R}
+{Replace}	\E[mquery_replace_match\r
+
+/Buffers/*
+{Kill}{^Xk}
+{List}{^X^B}
+{Switch}{^Xb}
+{-}
+./Modes/*
+{C}		\E[mc_mode\r
+{SLang}	\E[mslang_mode\r
+{None}		\E[mno_mode\r
+{LaTeX}	\E[mlatex_mode\r
+{Text}		\E[mtext_mode\r
+{Fortran}	\E[mfortran_mode\r
+
+/Window/*
+{Delete}{^X0}
+{One}{^X1}
+{Split}{^X2}
+{Other}{^Xo}
+{-}
+{Recenter}{^L}
+{-}
+./Color Schemes/*
+{White-on-Black}	\E[mset_color_scheme("15;0")\r
+{Black-on-White}	\E[mset_color_scheme("0;15")\r
+{White-on-default-Black}\E[mset_color_scheme("15;default;0")\r
+{Black-on-default-White}\E[mset_color_scheme("0;default;15")\r
+
+/Utils/*
+{Bufed}	\E[mbufed\r
+{Dired}	\E[mdired\r
+{Mail}	\E[mmail\r
+{Rmail}	\E[mrmail\r
+{-}
+{EvalBuffer}	\E[mevalbuffer\r
+{Trim-Buffer}	\E[mtrim_buffer\r
+
+[read:terminal]
+
+/?/*
+{Info}{^X?i}
+{Man}{^X?m}
+{-}
+{Apropos}{^X?a}
+{Show Key}{^X?k}
+{Where Is}{^X?w}
+
+[show]
+[done]
+#endif
+%%%%%%%%%%%%%%%%%%%%%%%%%%% end-of-file (SLang) %%%%%%%%%%%%%%%%%%%%%%%%%%
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/menu/menu work/main.d/rxvt-2.6.4/doc/menu/menu
--- tmp/rxvt-2.6.4/doc/menu/menu	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/menu/menu	1998-04-20 04:30:39.000000000 -0300
@@ -0,0 +1,83 @@
+#!/bin/sh --
+# shell wrapper to avoid typing Menu escape sequences
+if test $# -eq 0; then
+echo "\
+usage: `basename $0` cmd
+where the most common commands are
+	[menu] [menu:name]
+	[read:file] [read:file;name]
+	[title:string]
+	+/path/menu
+	+/path/menu/*
+	+/menu/path/{-}
+	+/menu/path/{item}{rtext} action
+
+	-/*
+	-/path/menu
+	-/path/menu/*
+	-/path/{-}
+	-/path/{item}
+
+	<b>Begin<r>Right<l>Left<u>Up<d>Down<e>End
+	[done]
+
+	[rm] [rm:] [rm*] [rm:*] [rm:name]
+	[swap] [prev] [next]
+	[clear] [show] [hide]
+	[pixmap:file]
+	[dump]
+NB: commands may need to be quoted to avoid shell expansion
+"
+exit
+fi
+Echo="echo -n"
+# some systems/shells don't like `echo -n'
+case `/bin/uname` in
+    SunOS) Echo="echo";;
+esac
+while [ $# -gt 0 ]
+do
+    case $1 in
+	+* | -* | '<'* | '['*)		# send raw commands
+	$Echo "]10;$1"
+	;;
+
+	*)					# read in menu files
+	if test $1 = "default";
+	then
+	    $Echo "]10;[read:$0]"
+	else
+	    $Echo "]10;[read:$1]"
+	fi
+	if test "$COLORTERM" != "rxvt-xpm";	# remove pixmap stuff
+	then
+	    $Echo "]10;[menu][:-/Terminal/Pixmap:][show]"
+	fi
+	;;
+    esac
+    shift
+done
+exit	# stop shell here!
+#-------------------------------------------------------------------------
+# since everything before a [menu] tag is ignored, we can put a default
+# menu here
+#-------------------------------------------------------------------------
+[menu:default]
+
+/Programs/*
+{Edit}		${EDITOR:-vi}\r
+{Top}		top\r
+{Dir}		ls -la|${PAGER:-more}\r
+{Dir-Time}	ls -lat|${PAGER:-more}\r
+{Space Left}	df\r
+{-}
+{Exit}		exit\r
+
+/Shell/*
+{check mail}	checkmail\r
+{Background}	^Z bg\r
+{Kill}		^C\r
+
+[show]
+[done]
+#--------------------------------------------------------------------- eof
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/menu/rxvt.menu work/main.d/rxvt-2.6.4/doc/menu/rxvt.menu
--- tmp/rxvt-2.6.4/doc/menu/rxvt.menu	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/menu/rxvt.menu	1998-04-20 04:30:40.000000000 -0300
@@ -0,0 +1,119 @@
+#!/bin/sh --
+# an example of having different menus (even different pixmaps)
+# show up depending on the machine you are rlogin/telnet connecting to
+
+menu="$0"	# or any convenient database
+exe="../../src/rxvt"	# default program to execute
+# exe="/usr/local/bin/rxvt-2.21"	# default program to execute
+
+if test $# -gt 0; then
+    # if first argument contains "rxvt" use that instead
+    case $1 in *rxvt*) exe="$1" shift;; esac
+fi
+
+while [ $# -gt 0 ]
+do
+    case $1 in
+	-h)		# give usage
+	echo "
+Usage:	`basename $0` [rxvt-prgm] [options]
+
+	start rxvt
+	and load a menu corresponding to \"machine\" if the option
+	    -e {rlogin|telnet|tn3270} Machine.Domain ...
+	was used"
+	exit
+	;;	# don't bother if we've already set it
+
+	-menu) break;;	# don't bother if we've already set it
+
+	-e)
+	if test $# -ge 3;
+	then
+	    case $2 in
+		# try to find menu for these cases
+		*rlogin | *telnet | *tn3270)
+		# strip domain & convert case
+		mach=`echo $3 | sed -e 's/\..*$//' | tr [A-Z] [a-z]`
+		if test ! -z "$mach";
+		then
+		    found=`egrep "^\[menu:$mach\]" $menu`
+		    if test ! -z "$found";
+		    then
+			mach="$menu;$mach"
+			exe="$exe -menu $mach"
+		    fi
+ 		fi
+		;;
+	    esac
+	fi
+	break
+	;;
+
+	*)
+	exe="$exe $1"
+	;;
+    esac
+    shift
+done
+
+# echo "$exe $@"
+$exe $@ &
+exit	# stop shell here!
+#-------------------------------------------------------------------------
+[menu:weber]
+#[menu:machine1]
+[clear]
+# [pixmap:machine1.xpm]
+
+/Programs/*
+{Edit}		${EDITOR:-vi}\r
+{Mail}		Mail\r
+{News}		News\r
+{-}
+{Exit}		exit\r
+
+/Jobs/*
+{Top}		top\r
+{Ps u}		ps aux|egrep ^$USER
+{Ps aux}	ps aux|egrep -v "(root|ps)"
+# who's REALLY logged on (even with utmp logging turned off)
+{Who}		ps aux|egrep "\-bash"|egrep -v "grep"
+{-}
+{Background}	^Z bg\r
+{Kill}		^C\r
+
+/Misc/*
+{Dir}		ls -la|${PAGER:-more}\r
+{Dir-Time}	ls -lat|${PAGER:-more}\r
+{Space Left}	df\r
+
+[read:terminal]
+[show]
+#[done:machine1]
+[done:weber]
+
+#-------------------------------------------------------------------------
+[menu:conn]
+#[menu:machine2]
+[clear]
+# [pixmap:machine2.xpm]
+
+/Programs/*
+{Edit}		${EDITOR:-vi}\r
+{Checkmail}	checkmail\r
+{Dir}		ls -la|${PAGER:-more}\r
+{Dir-Time}	ls -lat|${PAGER:-more}\r
+{Space Left}	df\r
+{-}
+{Exit}		exit\r
+
+/Jobs/*
+{Background}	^Z bg\r
+{Kill}		^C\r
+
+[read:terminal]
+[show]
+#[done:machine2]
+[done:conn]
+#--------------------------------------------------------------------- eof
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/menu/terminal.menu work/main.d/rxvt-2.6.4/doc/menu/terminal.menu
--- tmp/rxvt-2.6.4/doc/menu/terminal.menu	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/menu/terminal.menu	1998-04-20 04:30:40.000000000 -0300
@@ -0,0 +1,59 @@
+# standard settings for a `terminal' control menu
+# only attach to an existing menubar
+[menu]
+
+/Terminal/*
+./Font/*
+{Normal}	^@\E]50;#
+{Larger}	^@\E]50;#+
+{Smaller}	^@\E]50;#-
+{-}
+{Font 1}	^@\E]50;#1
+{Font 2}	^@\E]50;#2
+{Font 3}	^@\E]50;#3
+{Font 4}	^@\E]50;#4
+../Screen/*
+{ReverseVideo}	^@\E[?5t
+{Toggle Width}	^@\E[?3t
+{Cursor}	^@\E[?25t
+{Switch}	^@\E[?47t
+{-}
+{menuBar}	^@\E[?10t
+{refresh menu}	^@\E[?10h
+{scrollBar}	^@\E[?30t
+{-}
+{Toggle scroll-on-TTY}	^@\E[?1010t
+{Toggle scroll-on-Key}	^@\E[?1011t
+../Keys/*
+{XTerm}	^@\E[?35t
+{Backspace}	^@\E[?67t
+{Cursor}	^@\E[?1t
+{KeyPad}	^@\E[?66t
+../
+{-}
+./Pixmap/*
+{None}		^@\E[m\E]20;\a
+{-}
+# load .xpm files (assuming Rxvt*path: has been properly set)
+# notice there are 2 ways to do this task
+{background5}	^@\E]20;background5
+{Mona}		^@\E]10;[pixmap:monalisa;100]
+{-}
+./Attrib/*
+{Full}		^@\E]20;;100x100+50+50;?
+{Tiled}		^@\E]20;;0
+{Centre}	^@\E]20;;=+50+50;?
+{-}
+# set `quick arrow' keys
+{Zoom}{200/50%}	^@\E]10;[:<b>\^@\\E]20;;<r>200x0<l>50x0<u>0x200<d>0x50<e>;?:]
+{Pos}{5%}	^@\E]10;[:<b>\^@\\E]20;;<r>+5+0<l>-5+0<u>+0-5<d>+0+5<e>;?:]
+../
+../
+{-}
+{Version}	^@\E[8n
+/
+
+# make sure the change gets updated
+[show]
+[done]
+#--------------------------------------------------------------------- eof
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/README.greek work/main.d/rxvt-2.6.4/doc/README.greek
--- tmp/rxvt-2.6.4/doc/README.greek	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/README.greek	1998-04-20 04:30:31.000000000 -0300
@@ -0,0 +1,131 @@
+		-------------------------------
+		rxvt support for greek keyboard
+		-------------------------------
+
+		A. Haritsis <ah@doc.ic.ac.uk>
+
+rxvt supports both ELOT-928 (ISO-8859-7 standard) and IBM-437 keyboard
+translations for greek character entry. It is possible to start rxvt windows
+in any of the two translations, making it possible to use both translations
+modes simultanesuly on the same screen! No need to convert your files back
+and forth if you don't want to.
+
+When in greek mode, type ; or : twice to emit the respective symbol.
+No need to switch language mode back and forth!
+
+rxvt ISO-8859-7 includes mappings for the following (usually forgotten):
+anw teleia =  ;.
+<<	   =  ;<
+>>	   =  ;>
+  Also:
+Copyright  =  ;c
+Section    =  ;s
+
+For Greek Elot-928 or IBM-437 keyboard for rxvt & X greek entry support
+you will need to:
+
+1) compile rxvt with an ANSI C compiler (eg gcc) as follows:
+
+   Use the  --enable-greek  option in  configure , or edit config.h and
+   define GREEK_SUPPORT
+
+   Then your rxvt executable with greek support should be created.  Install
+   it as you would do for the normal rxvt.  There is no need to change its
+   name.  It works fully as a normal rxvt but if you press the 'toggle'
+   keysym (see below) it will switch into greek translation mode.  The extra
+   memory it takes in less than 4 kBytes.
+
+2) install greek elot & ibm437 fonts(s) for X-windows
+   eg.
+	cp a_greek_font.pcf.Z /usr/lib/X11/misc/
+
+   and ammend the fonts.dir and fonts.alias in /usr/lib/X11/misc/. Greek
+   fonts are available as a separate file which you can download from
+   sunsite (/pub/Linux/X11/misc/greek-xfont-pack.tgz).  A new release of a
+   FULL set of fixed (and proportional and Type1 for use by netscape etc)
+   can be found in the HCR archive - see at end).  I might upload them at
+   sunsite et all as well.
+
+3) include the following in your X resources:
+	rxvt.font: grfixed	(or the name of your preferred greek font)
+	rxvt.bits: 8				(default)
+	rxvt.greektoggle_key: Mode_switch	(default)
+
+   where grfixed is an alias for one of the elot-928 font in the pack.
+
+   Remember that the default keyboard translation is ELOT928.  If you need
+   to start rxvt with suppport for IBM437, use the command line of rxvt to
+   set mode & font (command line option -grk4 can do this).  Remember to use
+   an Elot font with the Elot translation mode and a 437 font with the
+   IBM437 mode.
+
+   You can choose any keysym you wish as the "toggler" greek_switch_keysym.
+   Choosing `VoidSymbol' will effectively _disable_ the greek keyboard.  
+   The default is keysym `Mode_switch'.
+
+   For XFree86 this is defined in the /usr/lib/X11/Xmodmap.* files as:
+	keycode 113 = Mode_switch  (it is the Right Alt key or ALtGr)
+   You may define it to be something else with a command like:
+
+	xmodmap -e "keycode ... = Mode_switch"
+
+   or changing your ~/.Xmodmap file (see xmodmap(1) and X(1) about this).  
+   I personally prefer the AltGr key on PC X terminals since it allows fast
+   switching. Of course this might not be liked by left-handed people.  You
+   can redefine it to whtever you like under X, but I would NOT recommend
+   keycodes that have other uses.
+
+5) Not all programs are 8-bit clean -- ie, they sometimes strip the top bit
+   of a character which is essential for the greek fonts.
+
+   Unfortunately bash is one of these programs (at least I couldn't figure
+   out how to make it to work). Use tcsh instead: it is 8-bit clean.
+
+   You will generally need to include in your ...rc files:
+
+   For sh/bash:
+	LC_CTYPE=iso_8859_1; export LC_CTYPE
+	LESSCHARSET=latin1; export LESSCHARSET
+	
+   For bash to be 8-bit clean, add the following lines to ~/.inputrc:
+	set meta-flag on
+	set convert-meta off
+	set output-meta on
+
+   For csh/tcsh:
+	setenv LC_CTYPE iso_8859_1
+	setenv LESSCHARSET latin1
+
+Still some applications will have problems.  Emacs has its own support for
+greek characters achieved with the .el script written by sarantos@csd.uch.gr
+(for 19.20 +).  It might be possible to have greek support via emacs
+invocations with the -nw argument (with this version of rxvt) but I have not
+tried it.  Elvis (vi clone) works fine.  I highly recommend vim version 3.15
+and later.  I have added support for making native languge vi'ing very easy
+(see langmap option). It's by far the most powerful vi (or maybe editor :-)
+I have ever seen.
+
+If some (terminal-based) applications do not work, please direct complaints
+to their authors stating that you would like them to be 8-bit clean.
+
+I will soon release a linux version of an 8-bit clean curses lib and
+versions of some useful programs that work with it (eg ytalk).  Watch the
+HCR archive.
+
+Do not expect programs that are not running within an rxvt window to have greek
+keyboard support. For this, it will be needed to change the Xlib so that it
+supports 4-state FSMs (rather than only 2 - I do not count shift keys or caps
+lock) for keyboard entry (required for greek keyboards).
+
+And something amusing and (maybe) useful: some filesystems (including SunOS
+and Linux filesystems -- haven't checked others) allow names with 8-bit
+characters; so you can create files or directories with names containing
+greek characters!
+
+Enjoy,
+
+Angelo Haritsis <ah@doc.ic.ac.uk>
+
+For more greek related tools/fonts etc, have a look at the
+HELLENIC RESOURCES ARCHIVE (HCR) : ftp://dolphin.doc.ic.ac.uk/pub/greek/
+maintained by the above author.
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/README.menu work/main.d/rxvt-2.6.4/doc/README.menu
--- tmp/rxvt-2.6.4/doc/README.menu	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/README.menu	1998-04-20 04:30:31.000000000 -0300
@@ -0,0 +1,55 @@
+A few examples of constructing menubars for rxvt.  Used in conjuction
+with the reference material (rxvtRef.html/txt), it should be possible to
+piece together some useful menus without too much time.
+
+C-shell users be warned.
+Some of the menu items contain bsh/ksh constructs like ${EDITOR:-vi}\r
+which will cause your shell to gag.
+----------------------------------------------------------------------
+
+example.menu:
+	simple menus for Pico and the Shell
+
+jedmenu.sl:
+	(almost) self-contained SLang code for loading up a menubar
+	for the Jed editor.  It doesn't need terminal.menu,
+	but looks a bit better with it.
+
+	Note for JED users:
+	    since rxvt provides an escape sequence to override the
+	    normal XTerm interpretation of Shift-Insert/Prev/Next,
+	    "wmark.sl" (MS-windows-style shift marking) works really
+	    well and is a nice bonus for those forced to switch
+	    to/from MS-windows
+
+terminal.menu
+	common rxvt terminal functions used by the other menus
+
+menu:
+	a small shell script to reduce the pain of typing
+	echo "ESC]10; ... BEL" for every menubar command.
+	It also contains a sample "default" menu at the bottom.
+
+rxvt.menu:
+	A nice script that allows a convenient way to have different
+	menubars used for rlogin|telnet to a machine.
+	Of course to get it to work, you'll need to add your own
+	machine names (and remove mine).
+
+	The script is set up so that "rxvt" will be called if the first
+	argument to the script does not contain "rxvt".
+	So
+		rxvt.menu [options]
+	is the same as
+		rxvt.menu rxvt [options]
+
+	To always have this script act as the front-end for rxvt:
+	  1) install the rxvt binary somewhere not in your path
+	  2) set the `exe' in menu.script to point to this binary
+	     eg,
+		exe="/usr/local/X11/rxvt-2.21/rxvt"
+		# default program to execute
+	  3) have rxvt.menu linked somewhere in your path as `rxvt'
+	  4) add all the various machines/menus combinations to
+	     rxvt.menu, or else make a separate database and change
+	     the `menu' variable in rxvt.menu to suit.
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/README.xvt work/main.d/rxvt-2.6.4/doc/README.xvt
--- tmp/rxvt-2.6.4/doc/README.xvt	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/README.xvt	1998-04-20 04:30:31.000000000 -0300
@@ -0,0 +1,171 @@
+-------------------------------------------------------------------------
+Rxvt is a heavily modified version of xvt, many modifications were made by
+Rob Nation <nation@rocket.sanders.lockheed.com> to make it a little more
+compact and to add a few simple features.
+
+This is the README that came with xvt-2.0. It is included mainly to give
+the original author credit for his work.
+
+		   README file for xvt 2.0
+		   -----------------------
+
+Xvt is an X terminal-emulator that is designed to be more or less
+compatible with xterm while using much less swap space.  It is mainly
+intended for use at sites which use large numbers of X terminals but
+may also be useful on single workstations that are short of memory.  On
+a SPARCstation running SunOS4, an initially invoked xvt uses about 1/3
+megabyte of swap while xterm uses about 1.3 megabytes (obtained by
+running pstat rather than ps which seems to give unreliable size
+figures on SPARCs).  The main way that xvt achieves its small size is
+by avoiding the use of the X toolkit.
+
+The current version of xvt is our default X terminal emulator and has
+been used for eight months by students, computing support staff and
+service users and so is fairly well tested.
+
+Supported architectures
+-----------------------
+
+One of the major changes between xvt-1.0 and 2.0 is that xvt-2.0 is
+much more portable.  The released version should build and run on all
+the architectures I have access to, namely: SunOS4, SunOS5, HP-UX 8.0,
+HP-UX 9.0, DEC OSF/1 V1.2 and ULTRIX 3.?.  In addition, the teletype
+initialisation code has been completely restructured to make it more
+portable.  Almost all the system dependent code is in the single source
+file, ttyinit.c.
+
+Xterm features not supported
+----------------------------
+
+ - Tektronix 4014 emulation
+
+ - Session logging
+
+ - Pop-up menus.  The only one of xterm's popup menu commands that is
+   provided in xvt is displaying and hiding of the scrollbar and this
+   is done simply by pressing any mouse key in the window with the
+   CONTROL key held down.
+
+ - Toolkit style configurability.  In particular, xvt does not allow
+   the user to remap the mouse or keyboard keys.
+
+Major xterm features that are supported
+---------------------------------------
+
+ - VT100 emulation.  Most of the main escape sequences are supported -
+   certainly all those used by the standard screen based UNIX
+   applications.
+
+ - Lines that scroll off the top of the window are saved can be
+   scrolled back with a scrollbar.
+
+ - Text selection and insertion including double and triple click for
+   words and lines.
+
+Differences between xvt2.0 and xvt1.0
+-------------------------------------
+
+ - xvt2.0 is eight bit clean and will generate and display eight bit
+   characters.  The META key can be used to generate characters with
+   the eighth bit set (in eight bit mode) or prefix by escape (in seven
+   bit mode).
+
+ - The teletype setup code has been rewritten to make it much more
+   portable.  See the comments at the head of ttyinit.c.
+
+ - Exposure handling has been made much more efficient so that xvt should
+   now be useable with window managers that provide opaque window movement.
+
+ - VT100 graphics characters are supported for fonts that include them.
+
+ - There is now a -ls option to enable the use of a login shell.
+
+ - Colored text cursors are now supported.
+
+ - There is support for the -C (console window) option but only on
+   SunOS 4.
+
+ - Bold characters are generated by overstriking if no bold font is
+   specified.
+
+ - Function keys generate escape sequences as in xterm.
+
+ - A number of bugs have been fixed:
+
+   - Setting the title without a terminating ^G no longer locks up.
+
+   - Paste followed by a keystroke will always insert in the correct
+     order.
+
+   - Pasting an uninitialised string will not cause a crash.
+
+Other differences between xvt and xterm
+---------------------------------------
+
+ - Xvt has a couple of additional enquiry escape sequences:
+
+   ESC[7n - causes xvt to respond with the name of its X display in a
+	    form that can be used to initialise the DISPLAY environment
+	    variable.  If this is done in a user's .cshrc file it
+	    provides a way to automatically update DISPLAY after an
+	    rlogin.  Something like the following should work if the
+	    initial ^[ in the echo command is an ESC character:
+
+	    if(!($?DISPLAY)) then
+		if($?term) then
+		    if($term =~ xterm*) then
+			stty -echo >/dev/tty
+			echo -n '^[[7n' >/dev/tty
+			setenv DISPLAY `line </dev/tty`
+			stty echo >/dev/tty
+		    endif
+		endif
+	    endif
+
+   ESC[8n - causes xvt to respond with a hex encoded copy of the server's
+	    magic cookie which can be used to update a user's .Xauthority
+	    file.  We have a program to do this which could be made available
+	    if anyone is interested.
+
+Known Bugs
+----------
+
+ - xvt does not know about transferring selections in installments and so
+   making large selections or trying to insert large selections will
+   fail.  The maximum selection size supported is server dependent but
+   seems to be a little under 64k on all our servers.
+
+ - xvt does not look in all the approved places for its X resources.
+   It does, however, work correctly with resources that have been
+   loaded into the server using xrdb
+
+Building and installing xvt
+---------------------------
+
+Xvt does not use imake but does come with a simple Makefile
+configuration scheme that provides some help with getting the Makefile
+right.  If you want to build xvt on one of the supported architectures
+then you should uncomment the appropriate definition at the start of
+the Makefile and then run `make config', which will modify other
+Makefile comments to bring them into line with the chosen
+architecture.
+
+To install xvt, you should edit the MANDIR and BIN pathnames in the
+Makefile and then type 'make install' as root.  When installed for
+general use, xvt needs to belong to root and have the setuid flag set
+so that it can make entries in the /etc/utmp file.
+
+Thanks to all the people who have mailed bug reports, patches and
+local improvements.  Some requested additions have gone into V2.0,
+others perhaps should have, but were left out due to lack of time.
+
+Please send bug reports and WIBNIs to:
+
+John Bovey
+Computing Laboratory
+University of Kent at Canterbury
+Canterbury
+Kent
+UK
+
+email: jdb@ukc.ac.uk
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/rxvt.1 work/main.d/rxvt-2.6.4/doc/rxvt.1
--- tmp/rxvt-2.6.4/doc/rxvt.1	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/rxvt.1	2001-11-01 21:31:49.000000000 -0300
@@ -0,0 +1,1248 @@
+.if !\n(.g .ab GNU tbl requires GNU troff.
+.if !dTS .ds TS
+.if !dTE .ds TE
+.TH "1" "RXVT" "02 NOVEMBER 2001" "X Version 11" "X Tools" 
+.SH "NAME" 
+rxvt (ouR XVT) \- a VT102 emulator for the X window system
+.PP 
+.SH "SYNOPSIS" 
+.PP 
+\fBrxvt\fP [options] [-e command [ args ]]
+.PP 
+.SH "DESCRIPTION" 
+.PP 
+\fBrxvt\fP, version \fB2\&.6\&.4\fP, is a colour vt102 terminal emulator
+intended as an \fIxterm\fP(1) replacement for users who do not require
+features such as Tektronix 4014 emulation and toolkit-style configurability\&.
+As a result, \fBrxvt\fP uses much less swap space -- a significant
+advantage on a machine serving many X sessions\&.
+.PP 
+.PP 
+.SH "OPTIONS" 
+.PP 
+The \fBrxvt\fP options (mostly a subset of \fIxterm\fP\'s) are listed below\&.
+In keeping with the smaller-is-better philosophy, options may be eliminated
+or default values chosen at compile-time, so options and defaults listed
+may not accurately reflect the version installed on your system\&.  
+`rxvt -h\' gives a list of major compile-time options on the usage line\&.
+Option descriptions may be prefixed with which compile option each is
+dependent upon\&.  e\&.g\&. `Compile \fIXIM\fP:\' requires \fIXIM\fP on the usage line\&.
+Note: `rxvt -help\' gives a list of all options compiled into your version\&.
+.PP 
+Note that \fBrxvt\fP permits the resource name to be used as a long-option
+(--/++ option) so the potential command-line options are far greater than
+those listed\&.
+For example: `rxvt --loginShell --color1 Orange\'\&.
+.PP 
+.IP "\fB-help\fP, \fB--help\fP" 
+Print out a message describing available options\&.
+.IP "\fB-display\fP \fIdisplayname\fP" 
+Attempt to open a window on the named X display (\fB-d\fP still
+respected)\&.  In the absence of this option, the display specified
+by the \fBDISPLAY\fP environment variable is used\&.
+.IP "\fB-geometry\fP \fIgeom\fP" 
+Window geometry (\fB-g\fP still respected);
+resource \fBgeometry\fP\&.
+.IP "\fB-rv\fP|\fB+rv\fP" 
+Turn on/off simulated reverse video;
+resource \fBreverseVideo\fP\&.
+.IP "\fB-ip\fP|\fB+ip\fP" 
+Turn on/off inheriting parent window\'s pixmap\&.  Alternative form
+is \fB-tr\fP;
+resource \fBinheritPixmap\fP\&.
+.IP "\fB-bg\fP \fIcolour\fP" 
+Window background colour;
+resource \fBbackground\fP\&.
+.IP "\fB-fg\fP \fIcolour\fP" 
+Window foreground colour;
+resource \fBforeground\fP\&.
+.IP "\fB-pixmap:\fP \fIfile[;geom]\fP" 
+Compile \fIXPM\fP: Specify XPM file for the background and also
+optionally specify its scaling with a geometry string\&.  Note you
+may need to add quotes to avoid special shell interpretation of
+the `;\' in the command-line;
+resource \fBbackgroundPixmap\fP\&.
+.IP "\fB-cr\fP \fIcolour\fP" 
+The cursor colour;
+resource \fBcursorColor\fP\&.
+.IP "\fB-pr\fP \fIcolour\fP" 
+The mouse pointer colour;
+resource \fBpointerColor\fP\&.
+.IP "\fB-bd\fP \fIcolour\fP" 
+The colour of the border between the xterm scrollbar and the text;
+resource \fBborderColor\fP\&.
+.IP "\fB-fn\fP \fIfontname\fP" 
+Main normal text font;
+resource \fBfont\fP\&.
+.IP "\fB-fb\fP \fIfontname\fP" 
+Main bold text font;
+resource \fBboldFont\fP\&.
+.IP "\fB-fm\fP \fIfontname\fP" 
+Main multicharacter font;
+resource \fBmfont\fP\&.
+.IP "\fB-km\fP \fImode\fP" 
+Multiple-character font-set encoding mode;
+\fBeucj\fP: EUC Japanese encoding\&.
+\fBsjis\fP: Shift JIS encoding;
+resource \fBmultichar_encoding\fP\&.
+.IP "\fB-grk\fP \fImode\fP" 
+Greek keyboard translation;
+\fBiso\fP: ISO-8859 mapping\&.
+\fBibm\fP: IBM-437 mapping;
+resource \fBgreek_keyboard\fP\&.
+.IP "\fB-name\fP \fIname\fP" 
+Specify the application name under which resources
+are to be obtained, rather than the default executable file name\&.
+Name should not contain `\&.\' or `*\' characters\&.
+Also sets the icon and title name\&.
+.IP "\fB-ls\fP|\fB+ls\fP" 
+Start as a login-shell/sub-shell;
+resource \fBloginShell\fP\&.
+.IP "\fB-ut\fP|\fB+ut\fP" 
+Compile \fIutmp\fP: Inhibit/enable writing a utmp entry;
+resource \fButmpInhibit\fP\&.
+.IP "\fB-vb\fP|\fB+vb\fP" 
+Turn on/off visual bell on receipt of a bell character;
+resource \fBvisualBell\fP\&.
+.IP "\fB-sb\fP|\fB+sb\fP" 
+Turn on/off scrollbar;
+resource \fBscrollBar\fP\&.
+.IP "\fB-si\fP|\fB+si\fP" 
+Turn on/off scroll-to-bottom on TTY output inhibit;
+resource \fBscrollTtyOutput\fP has opposite effect\&.
+.IP "\fB-sk\fP|\fB+sk\fP" 
+Turn on/off scroll-to-bottom on keypress;
+resource \fBscrollTtyKeypress\fP\&.
+.IP "\fB-sr\fP|\fB+sr\fP" 
+Put scrollbar on right/left;
+resource \fBscrollBar_right\fP\&.
+.IP "\fB-st\fP|\fB+st\fP" 
+Display normal (non XTerm/NeXT) scrollbar without/with a trough;
+resource \fBscrollBar_floating\fP\&.
+.IP "\fB-iconic\fP" 
+Start iconified, if the window manager supports that option\&.
+Alternative form is \fB-ic\fP\&.
+.IP "\fB-sl\fP \fInumber\fP" 
+Save \fInumber\fP lines in the scrollback buffer;
+resource \fBsaveLines\fP\&.
+.IP "\fB-tn\fP \fItermname\fP" 
+This option specifies the name of the terminal type to be set in the
+\fBTERM\fP environment variable\&. This terminal type must exist in the
+\fItermcap(5)\fP database and should have \fIli#\fP and \fIco#\fP entries;
+resource \fBtermName\fP\&.
+.IP "\fB-e\fP \fIcommand [arguments]\fP" 
+Run the command with its command-line arguments in the \fBrxvt\fP
+window; also sets the window title and icon name to be the basename
+of the program being executed if neither \fI-title\fP (\fI-T\fP) nor
+\fI-n\fP are given on the command line\&.  If this option is used, it
+must be the last on the command-line\&.  If there is no \fB-e\fP option
+then the default is to run the program specified by the \fBSHELL\fP
+environment variable or, failing that, \fIsh(1)\fP\&.
+.IP "\fB-title\fP \fItext\fP" 
+Window title (\fB-T\fP still respected); the default title is the
+basename of the program specified after the \fB-e\fP option, if
+any, otherwise the application name;
+resource \fBtitle\fP\&.
+.IP "\fB-n\fP \fItext\fP" 
+Icon name; the default name is the basename of the program specified
+after the \fB-e\fP option, if any, otherwise the application name;
+resource \fBiconName\fP\&.
+.IP "\fB-C\fP" 
+Capture system console messages\&.
+.IP "\fB-pt\fP \fIstyle\fP" 
+Compile \fIXIM\fP: input style for input method;
+\fBOverTheSpot\fP, \fBOffTheSpot\fP, \fBRoot\fP;
+resource \fBpreeditType\fP\&.
+.IP "\fB-im\fP \fItext\fP" 
+Compile \fIXIM\fP: input method name\&.
+resource \fBinputMethod\fP\&.
+.IP "\fB-mod\fP \fImodifier\fP" 
+Override detection of Meta modifier with specified key:
+\fBalt\fP, \fBmeta\fP, \fBhyper\fP, \fBsuper\fP, \fBmod1\fP, \fBmod2\fP, \fBmod3\fP,
+\fBmod4\fP, \fBmod5\fP;
+resource \fImodifier\fP\&.
+.IP "\fB-xrm\fP \fIresourcestring\fP" 
+No effect on rxvt\&.  Simply passes through an argument to be made
+available in the instance\'s argument list\&.  Appears in \fIWM_COMMAND\fP
+in some window managers\&.
+.SH "RESOURCES (available also as long-options)" 
+.PP 
+Note: `rxvt --help\' gives a list of all resources (long options) compiled
+into your version\&.
+If compiled with internal Xresources support (i\&.e\&. \fBrxvt -h\fP lists 
+\fB\&.Xdefaults\fP) then \fBrxvt\fP accepts application defaults set in
+XAPPLOADDIR/Rxvt (compile-time defined: usually
+\fB/usr/lib/X11/app-defaults/Rxvt\fP) and resources set in \fB~/\&.Xdefaults\fP,
+or \fB~/\&.Xresources\fP if \fB~/\&.Xdefaults\fP does not exist\&.  Note that when
+reading X resources, \fBrxvt\fP recognizes two class names: \fBXTerm\fP and
+\fBRxvt\fP\&.  The class name \fBXTerm\fP allows resources common to both
+\fBrxvt\fP and \fIxterm\fP to be easily configured, while the class name
+\fBRxvt\fP allows resources unique to \fBrxvt\fP, notably colours and
+key-handling, to be shared between different \fBrxvt\fP configurations\&. 
+If no resources are specified, suitable defaults will be used\&. 
+Command-line arguments can be used to override resource settings\&.  The
+following resources are allowed:
+.PP 
+.IP "\fBgeometry:\fP \fIgeom\fP" 
+Create the window with the specified X window geometry [default
+80x24];
+option \fB-geometry\fP\&.
+.IP "\fBbackground:\fP \fIcolour\fP" 
+Use the specified colour as the window\'s background colour [default
+White];
+option \fB-bg\fP\&.
+.IP "\fBforeground:\fP \fIcolour\fP" 
+Use the specified colour as the window\'s foreground colour [default
+Black];
+option \fB-fg\fP\&.
+.IP "\fBcolor\fP\fIn\fP\fB:\fP \fIcolour\fP" 
+Use the specified colour for the colour value \fIn\fP, where 0-7
+corresponds to low-intensity (normal) colours and 8-15 corresponds to
+high-intensity (bold = bright foreground, blink = bright
+background) colours\&.  The canonical names are as follows:
+0=black, 1=red, 2=green, 3=yellow, 4=blue, 5=magenta, 6=cyan, 7=white,
+but the actual colour names used are listed in the
+\fBCOLORS AND GRAPHICS\fP section\&.
+.IP "\fBcolorBD:\fP \fIcolour\fP" 
+Use the specified colour to display bold characters when the
+foreground colour is the default\&.
+.IP "\fBcolorUL:\fP \fIcolour\fP" 
+Use the specified colour to display underlined characters when the
+foreground colour is the default\&.
+.IP "\fBcursorColor:\fP \fIcolour\fP" 
+Use the specified colour for the cursor\&.  The default is to use the
+foreground colour;
+option \fB-cr\fP\&.
+.IP "\fBcursorColor2:\fP \fIcolour\fP" 
+Use the specified colour for the colour of the cursor text\&.  For this
+to take effect, \fBcursorColor\fP must also be specified\&.  The default
+is to use the background colour\&.
+.IP "\fBreverseVideo:\fP \fIboolean\fP" 
+\fBTrue\fP: simulate reverse video by foreground and background colours;
+option \fB-rv\fP,
+\fBFalse\fP: regular screen colours [default];
+option \fB+rv\fP\&.
+See note in \fBCOLORS AND GRAPHICS\fP section\&.
+.IP "\fBinheritPixmap:\fP \fIboolean\fP" 
+\fBTrue\fP: make the background inherit the parent windows\' pixmap,
+giving artificial transparency\&.
+\fBFalse\fP: do not inherit the parent windows\' pixmap\&.
+.IP "\fBscrollColor:\fP \fIcolour\fP" 
+Use the specified colour for the scrollbar [default #B2B2B2]\&.
+.IP "\fBtroughColor:\fP \fIcolour\fP" 
+Use the specified colour for the scrollbar\'s trough area [default
+#969696]\&.  Only relevant for normal (non XTerm/NeXT) scrollbar\&.
+.IP "\fBbackgroundPixmap:\fP \fIfile[;geom]\fP" 
+Use the specified XPM file (note the `\&.xpm\' extension is optional)
+for the background and also optionally specify its scaling with a
+geometry string \fBWxH+X+Y\fP, in which \fB"W" / "H"\fP specify the
+horizontal/vertical scale (percent) and \fB"X" / "Y"\fP locate the
+image centre (percent)\&.  A scale of 0 displays the image with tiling\&.
+A scale of 1 displays the image without any scaling\&.  A scale of 2 to
+9 specifies an integer number of images in that direction\&.  No image
+will be magnified beyond 10 times its original size\&.  The maximum
+permitted scale is 1000\&.  [default 0x0+50+50]
+.IP "\fBmenu:\fP \fIfile[;tag]\fP" 
+Read in the specified menu file (note the `\&.menu\' extension is
+optional) and also optionally specify a starting tag to find\&.  See
+the reference documentation for details on the syntax for the menuBar\&.
+.IP "\fBpath:\fP \fIpath\fP" 
+Specify the colon-delimited search path for finding files (XPM and
+menus), in addition to the paths specified by the \fBRXVTPATH\fP and
+\fBPATH\fP environment variables\&.
+.IP "\fBfont:\fP \fIfontname\fP" 
+Select the main text font used [default 7x14];
+option \fB-fn\fP\&.
+.IP "\fBfont\fP\fIn\fP\fB:\fP \fIfontname\fP" 
+Specify the alternative font \fIn\fP\&.  The default font values: 
+.br 
+.RS 
+.IP 
+.TS 
+.if '\*(.T'html' \X(table-start(
+.nr 3c \n(.C
+.cp 0
+.nr 3lps \n[.s]
+.nr 3cent \n[.ce]
+.de 3init
+.ft \n[.f]
+.ps \n[.s]
+.vs \n[.v]u
+.in \n[.i]u
+.ll \n[.l]u
+.ls \n[.L]
+.ad \n[.j]
+.ie \n[.u] .fi
+.el .nf
+.ce \n[.ce]
+..
+.nr 3ind \n[.i]
+.nr 3fnt \n[.f]
+.nr 3sz \n[.s]
+.nr 3fll \n[.u]
+.nr T. 0
+.nr 3crow 0-1
+.nr 3passed 0-1
+.nr 3sflag 0
+.ds 3trans
+.ds 3quote
+.nr 3brule 1
+.nr 3supbot 0
+.eo
+.de 3rmk
+.mk \$1
+.if !'\n(.z'' \!.3rmk "\$1"
+..
+.de 3rvpt
+.vpt \$1
+.if !'\n(.z'' \!.3rvpt "\$1"
+..
+.de 3keep
+.if '\n[.z]'' \{.ds 3quote \\
+.ds 3trans \!
+.di 3section
+.nr 3sflag 1
+.in 0
+.\}
+..
+.de 3release
+.if \n[3sflag] \{.di
+.in \n[3ind]u
+.nr 3dn \n[dn]
+.ds 3quote
+.ds 3trans
+.nr 3sflag 0
+.if \n[.t]<=\n[dn] \{.nr T. 1
+.T#
+.nr 3supbot 1
+.sp \n[.t]u
+.nr 3supbot 0
+.mk #T
+.\}
+.if \n[.t]<=\n[3dn] .tm warning: page \n%: table text block will not fit on one page
+.nf
+.ls 1
+.3section
+.ls
+.rm 3section
+.\}
+..
+.nr 3tflag 0
+.de 3tkeep
+.if '\n[.z]'' \{.di 3table
+.nr 3tflag 1
+.\}
+..
+.de 3trelease
+.if \n[3tflag] \{.br
+.di
+.nr 3dn \n[dn]
+.ne \n[dn]u+\n[.V]u
+.ie \n[.t]<=\n[3dn] .tm error: page \n%: table will not fit on one page; use .TS H/.TH with a supporting macro package
+.el \{.in 0
+.ls 1
+.nf
+.3table
+.\}
+.rm 3table
+.\}
+..
+.ec
+.ce 0
+.nf
+.nr 3sep 1n
+.nr 3w0 \n(.H
+.nr 3aw0 0
+.nr 3lnw0 0
+.nr 3rnw0 0
+.nr 3w1 \n(.H
+.nr 3aw1 0
+.nr 3lnw1 0
+.nr 3rnw1 0
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBfont\fP: \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ 7x14 \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBfont1\fP: \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ 6x10 \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBfont2\fP: \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ 6x13 \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBfont3\fP: \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ 8x13 \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBfont4\fP: \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ 9x15 \[tbl]
+.nr 3w0 \n[3w0]>?(\n[3lnw0]+\n[3rnw0])
+.if \n[3aw0] .nr 3w0 \n[3w0]>?(\n[3aw0]+2n)
+.nr 3w1 \n[3w1]>?(\n[3lnw1]+\n[3rnw1])
+.if \n[3aw1] .nr 3w1 \n[3w1]>?(\n[3aw1]+2n)
+.nr 3cd0 0
+.nr 3cl0 0*\n[3sep]
+.nr 3ce0 \n[3cl0]+\n[3w0]
+.nr 3cl1 \n[3ce0]+(3*\n[3sep])
+.nr 3cd1 \n[3ce0]+\n[3cl1]/2
+.nr 3ce1 \n[3cl1]+\n[3w1]
+.nr 3cd2 \n[3ce1]+(0*\n[3sep])
+.nr TW \n[3cd2]
+.if \n[3cent] \{.in +(u;\n[.l]-\n[.i]-\n[TW]/2)
+.nr 3ind \n[.i]
+.\}
+.eo
+.de T#
+.if !\n[3supbot] \{.3rvpt 0
+.mk 3vert
+.ls 1
+.ls
+.nr 3passed \n[3crow]
+.sp |\n[3vert]u
+.3rvpt 1
+.\}
+..
+.ec
+.fc 
+.3keep
+.3rmk 3rt0
+\*[3trans].nr 3crow 0
+.3keep
+.mk 3rs0
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u
+\&\h'|\n[3cl0]u'\fBfont\fP: \h'|\n[3cl1]u'\ 7x14 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs0]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt1
+\*[3trans].nr 3crow 1
+.3keep
+.mk 3rs1
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u
+\&\h'|\n[3cl0]u'\fBfont1\fP: \h'|\n[3cl1]u'\ 6x10 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs1]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt2
+\*[3trans].nr 3crow 2
+.3keep
+.mk 3rs2
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u
+\&\h'|\n[3cl0]u'\fBfont2\fP: \h'|\n[3cl1]u'\ 6x13 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs2]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt3
+\*[3trans].nr 3crow 3
+.3keep
+.mk 3rs3
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u
+\&\h'|\n[3cl0]u'\fBfont3\fP: \h'|\n[3cl1]u'\ 8x13 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs3]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt4
+\*[3trans].nr 3crow 4
+.3keep
+.mk 3rs4
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u
+\&\h'|\n[3cl0]u'\fBfont4\fP: \h'|\n[3cl1]u'\ 9x15 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs4]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.mk 3rt5
+.nr 3brule 1
+.nr T. 1
+.T#
+.3init
+.fc
+.cp \n(3c
+.if '\*(.T'html' \X(table-end(
+.TE 
+.RE 
+.IP 
+.IP "\fBboldFont:\fP \fIfontname\fP" 
+Specify the name of the bold font to use if \fBcolorBD\fP has not been
+specified and it is not possible to map the default foreground colour
+to colour 8-15 [default NONE]\&.  This font must be the same height and
+width as the normal font;
+option \fB-fb\fP\&.
+.IP "\fBmfont:\fP \fIfontname\fP" 
+Select the main multiple-character text font used [default k14];
+option \fB-fk\fP\&.
+.IP "\fBmfont\fP\fIn\fP\fB:\fP \fIfontname\fP" 
+Specify the alternative multiple-character font \fIn\fP\&.  If compiled
+for multiple-character fonts, the Roman and multiple-character font
+sizes should match\&.
+.IP "\fBmultichar_encoding:\fP \fImode\fP" 
+Set the encoding mode to be used when multicharacter encoding is
+received;
+\fBeucj\fP: EUC Japanese encoding [default for Kanji]\&.
+\fBsjis\fP: Shift JIS encoding\&.
+\fBbig5\fP: BIG5 encoding\&.
+\fBgb\fP: GB encoding;
+option \fB-km\fP\&.
+.IP "\fBgreek_keyboard:\fP \fImode\fP" 
+Set the Greek keyboard translation mode to be used;
+\fBiso\fP: ISO-8859 mapping (elot-928) [default]\&.
+\fBibm\fP: IBM-437 mapping (DOS codepage 737);
+option \fB-grk\fP\&.
+Use \fBMode_switch\fP to toggle keyboard input\&.  For more details,
+see the distributed file \fBREADME\&.greek\fP\&.
+.IP "\fBselectstyle:\fP \fItext\fP" 
+Set mouse selection style to \fBold\fP which is 2\&.20, \fBoldword\fP which
+is xterm style with 2\&.20 old word selection, or anything else which
+gives xterm style selection\&.
+.IP "\fBtitle:\fP \fItext\fP" 
+Set window title string, the default title is the command-line
+specified after the \fB-e\fP option, if any, otherwise the application
+name;
+option \fB-title\fP\&.
+.IP "\fBiconName:\fP \fItext\fP" 
+Set the name used to label the window\'s icon or displayed in an icon
+manager window, it also sets the window\'s title unless it is
+explicitly set;
+option \fB-n\fP\&.
+.IP "\fBmapAlert:\fP \fIboolean\fP" 
+\fBTrue\fP: de-iconify (map) on receipt of a bell character\&.
+\fBFalse\fP: no de-iconify (map) on receipt of a bell character
+[default]\&.
+.IP "\fBvisualBell:\fP \fIboolean\fP" 
+\fBTrue\fP: use visual bell on receipt of a bell character;
+option \fB-vb\fP\&.
+\fBFalse\fP: no visual bell [default];
+option \fB+vb\fP\&.
+.IP "\fBloginShell:\fP \fIboolean\fP" 
+\fBTrue\fP: start as a login shell by prepending a `-\' to \fBargv[0]\fP
+of the shell;
+option \fB-ls\fP\&.
+\fBFalse\fP: start as a normal sub-shell [default];
+option \fB+ls\fP\&.
+.IP "\fButmpInhibit:\fP \fIboolean\fP" 
+\fBTrue\fP: inhibit writing record into the system log file \fButmp\fP;
+option \fB-ut\fP\&.
+\fBFalse\fP: write record into the system log file \fButmp\fP [default];
+option \fB+ut\fP\&.
+.IP "\fBprint-pipe:\fP \fIstring\fP" 
+Specify a command pipe for vt100 printer [default \fIlpr(1)\fP]\&.  Use
+\fBPrint\fP to initiate a screen dump to the printer and \fBCtrl-Print\fP
+or \fBShift-Print\fP to include the scrollback as well\&.
+.IP "\fBscrollBar:\fP \fIboolean\fP" 
+\fBTrue\fP: enable the scrollbar [default];
+option \fB-sb\fP\&.
+\fBFalse\fP: disable the scrollbar;
+option \fB+sb\fP\&.
+.IP "\fBscrollBar_right:\fP \fIboolean\fP" 
+\fBTrue\fP: place the scrollbar on the right of the window;
+option \fB-sr\fP\&.
+\fBFalse\fP: place the scrollbar on the left of the window;
+option \fB+sr\fP\&.
+.IP "\fBscrollBar_floating:\fP \fIboolean\fP" 
+\fBTrue\fP: display an rxvt scrollbar without a trough;
+option \fB-st\fP\&.
+\fBFalse\fP: display an rxvt scrollbar with a trough;
+option \fB+st\fP\&.
+.IP "\fBscrollTtyOutput:\fP \fIboolean\fP" 
+\fBTrue\fP: scroll to bottom when tty receives output;
+option(+si)\&.
+\fBFalse\fP: do not scroll to bottom when tty receives output;
+option(-si)\&.
+.IP "\fBscrollTtyKeypress:\fP \fIboolean\fP" 
+\fBTrue\fP: scroll to bottom when a non-special key is pressed\&.
+Special keys are those which are intercepted by rxvt for special
+handling and are not passed onto the shell;
+option(-sk)\&.
+\fBFalse\fP: do not scroll to bottom when a non-special key is pressed;
+option(+sk)\&.
+.IP "\fBsmallfont_key:\fP \fIkeysym\fP" 
+If enabled, use \fBAlt-\fP\fIkeysym\fP to toggle to a smaller font
+[default \fBAlt-<\fP]
+.IP "\fBbigfont_key:\fP \fIkeysym\fP" 
+If enabled, use \fBAlt-\fP\fIkeysym\fP to toggle to a bigger font
+[default \fBAlt->\fP]
+.IP "\fBsaveLines:\fP \fInumber\fP" 
+Save \fInumber\fP lines in the scrollback buffer [default 64];
+option \fB-sl\fP\&.
+.IP "\fBtermName:\fP \fItermname\fP" 
+Specifies the terminal type name to be set in the \fBTERM\fP
+environment variable;
+option \fB-tn\fP\&.
+.IP "\fBmeta8:\fP \fIboolean\fP" 
+\fBTrue\fP: handle Meta (Alt) + keypress to set the 8th bit\&.
+\fBFalse\fP: handle Meta (Alt) + keypress as an escape prefix [default]\&.
+.IP "\fBbackspacekey:\fP \fIstring\fP" 
+The string to send when the backspace key is pressed\&.  If set to
+\fBDEC\fP or unset it will send \fBDelete\fP (code 127) or, if shifted,
+\fBBackspace\fP (code 8) - which can be reversed with the appropriate
+DEC private mode escape sequence\&.
+.IP "\fBdeletekey:\fP \fIstring\fP" 
+The string to send when the delete key (not the keypad delete key) is
+pressed\&.  If unset it will send the sequence traditionally associated
+with the \fBExecute\fP key\&.
+.IP "\fBcutchars:\fP \fIstring\fP" 
+The characters used as delimiters for double-click word selection\&. 
+The built-in default: 
+.br 
+\fBBACKSLASH `"\'&()*,;<=>?@[]{|}\fP
+.IP "\fBpreeditType:\fP \fIstyle\fP" 
+\fBOverTheSpot\fP, \fBOffTheSpot\fP, \fBRoot\fP;
+option \fB-pt\fP\&.
+.IP "\fBinputMethod:\fP \fIname\fP" 
+\fIname\fP of inputMethod to use;
+option \fB-im\fP\&.
+.IP "\fBmodifier:\fP \fImodifier\fP" 
+Set the key to be interpreted as the Meta key to:
+\fBalt\fP, \fBmeta\fP, \fBhyper\fP, \fBsuper\fP, \fBmod1\fP, \fBmod2\fP, \fBmod3\fP,
+\fBmod4\fP, \fBmod5\fP;
+option \fB-mod\fP\&.
+.IP "\fBkeysym\&.\fP\fIsym\fP: \fIstring\fP" 
+Associate \fIstring\fP with keysym \fIsym\fP (\fB0xFF00 - 0xFFFF\fP)\&.  It
+may contain escape values (\ea: bell, \eb: backspace, \ee, \eE: escape,
+\en: newline, \er: return, \et: tab, \e000: octal number) or control
+characters (^?: delete, ^@: null, ^A \&.\&.\&.) and may enclosed with
+double quotes so that it can start or end with whitespace\&.  The
+intervening resource name \fBkeysym\&.\fP cannot be omitted\&.  This
+resource is only available when compiled with KEYSYM_RESOURCE\&.
+.SH "THE SCROLLBAR" 
+.PP 
+Lines of text that scroll off the top of the \fBrxvt\fP window (resource:
+\fBsaveLines\fP) and can be scrolled back using the scrollbar or by keystrokes\&. 
+The normal \fBrxvt\fP scrollbar has arrows and its behaviour is fairly
+intuitive\&.  The \fBxterm-scrollbar\fP is without arrows and its behaviour
+mimics that of \fIxterm\fP
+.PP 
+Scroll down with \fBButton1\fP (\fBxterm-scrollbar\fP) or \fBShift-Next\fP\&.
+Scroll up with \fBButton3\fP (\fBxterm-scrollbar\fP) or \fBShift-Prior\fP\&.
+Continuous scroll with \fBButton2\fP\&.
+.SH "MOUSE REPORTING" 
+.PP 
+To temporarily override mouse reporting, for either the scrollbar or the
+normal text selection/insertion, hold either the Shift or the Meta (Alt) key
+while performing the desired mouse action\&.
+.PP 
+If mouse reporting mode is active, the normal scrollbar actions are disabled
+-- on the assumption that we are using a fullscreen application\&.
+Instead, pressing Button1 and Button3 sends
+\fBESC[6~\fP (Next) and \fBESC[5~\fP (Prior), respectively\&.
+Similarly, clicking on the up and down arrows sends \fBESC[A\fP (Up) and
+\fBESC[B\fP (Down), respectively\&.
+.SH "TEXT SELECTION AND INSERTION" 
+.PP 
+The behaviour of text selection and insertion mechanism is similar to
+\fIxterm\fP(1)\&.
+.PP 
+.IP "\fBSelection\fP:" 
+Left click at the beginning of the region, drag to the end of the
+region and release; Right click to extend the marked region;
+Left double-click to select a word; Left triple-click to select
+the entire line\&.
+.IP 
+.IP "\fBInsertion\fP:" 
+Pressing and releasing the Middle mouse button (or \fBShift-Insert\fP)
+in an \fBrxvt\fP window causes the current text selection to be inserted
+as if it had been typed on the keyboard\&.
+.SH "CHANGING FONTS" 
+.PP 
+You can change fonts on-the-fly, which is to say cycle through the default
+font and others of various sizes, by using \fBShift-KP_Add\fP and
+\fBShift-KP_Subtract\fP\&.  Or, alternatively (if enabled) with
+\fBAlt->\fP and \fBAlt-<\fP, where the actual key
+can be selected using resources \fBsmallfont_key\fP/\fBbigfont_key\fP\&.
+.SH "LOGIN STAMP" 
+.PP 
+\fBrxvt\fP tries to write an entry into the \fIutmp\fP(5) file so that it can be
+seen via the \fIwho(1)\fP command, and can accept messages\&.  To allow this
+feature, \fBrxvt\fP must be installed setuid root on some systems\&.
+.SH "COLORS AND GRAPHICS" 
+.PP 
+If graphics support was enabled at compile-time, \fBrxvt\fP can be queried
+with ANSI escape sequences and can address individual pixels instead of
+text characters\&.  Note the graphics support is still considered beta code\&.
+.PP 
+In addition to the default foreground and background colours, \fBrxvt\fP
+can display up to 16 colours (8 ANSI colours plus high-intensity bold/blink
+versions of the same)\&.
+Here is a list of the colours with their \fBrgb\&.txt\fP names\&.
+.PP 
+.TS 
+.if '\*(.T'html' \X(table-start(
+.nr 3c \n(.C
+.cp 0
+.nr 3lps \n[.s]
+.nr 3cent \n[.ce]
+.de 3init
+.ft \n[.f]
+.ps \n[.s]
+.vs \n[.v]u
+.in \n[.i]u
+.ll \n[.l]u
+.ls \n[.L]
+.ad \n[.j]
+.ie \n[.u] .fi
+.el .nf
+.ce \n[.ce]
+..
+.nr 3ind \n[.i]
+.nr 3fnt \n[.f]
+.nr 3sz \n[.s]
+.nr 3fll \n[.u]
+.nr T. 0
+.nr 3crow 0-1
+.nr 3passed 0-1
+.nr 3sflag 0
+.ds 3trans
+.ds 3quote
+.nr 3brule 1
+.nr 3supbot 0
+.eo
+.de 3rmk
+.mk \$1
+.if !'\n(.z'' \!.3rmk "\$1"
+..
+.de 3rvpt
+.vpt \$1
+.if !'\n(.z'' \!.3rvpt "\$1"
+..
+.de 3keep
+.if '\n[.z]'' \{.ds 3quote \\
+.ds 3trans \!
+.di 3section
+.nr 3sflag 1
+.in 0
+.\}
+..
+.de 3release
+.if \n[3sflag] \{.di
+.in \n[3ind]u
+.nr 3dn \n[dn]
+.ds 3quote
+.ds 3trans
+.nr 3sflag 0
+.if \n[.t]<=\n[dn] \{.nr T. 1
+.T#
+.nr 3supbot 1
+.sp \n[.t]u
+.nr 3supbot 0
+.mk #T
+.\}
+.if \n[.t]<=\n[3dn] .tm warning: page \n%: table text block will not fit on one page
+.nf
+.ls 1
+.3section
+.ls
+.rm 3section
+.\}
+..
+.nr 3tflag 0
+.de 3tkeep
+.if '\n[.z]'' \{.di 3table
+.nr 3tflag 1
+.\}
+..
+.de 3trelease
+.if \n[3tflag] \{.br
+.di
+.nr 3dn \n[dn]
+.ne \n[dn]u+\n[.V]u
+.ie \n[.t]<=\n[3dn] .tm error: page \n%: table will not fit on one page; use .TS H/.TH with a supporting macro package
+.el \{.in 0
+.ls 1
+.nf
+.3table
+.\}
+.rm 3table
+.\}
+..
+.ec
+.ce 0
+.nf
+.nr 3sep 1n
+.nr 3w0 \n(.H
+.nr 3aw0 0
+.nr 3lnw0 0
+.nr 3rnw0 0
+.nr 3w1 \n(.H
+.nr 3aw1 0
+.nr 3lnw1 0
+.nr 3rnw1 0
+.nr 3w2 \n(.H
+.nr 3aw2 0
+.nr 3lnw2 0
+.nr 3rnw2 0
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor0\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (black) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Black \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor1\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (red) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Red3 \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor2\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (green) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Green3 \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor3\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (yellow) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Yellow3 \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor4\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (blue) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Blue3 \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor5\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (magenta) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Magenta3 \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor6\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (cyan) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Cyan3 \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor7\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (white) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = AntiqueWhite \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor8\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (bright black) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Grey25 \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor9\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (bright red) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Red \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor10\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (bright green) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Green \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor11\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (bright yellow) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Yellow \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor12\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (bright blue) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Blue \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor13\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (bright magenta) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Magenta \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor14\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (bright cyan) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Cyan \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBcolor15\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\ (bright white) \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = White \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBforeground\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\  \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = Black \[tbl]
+.nr 3w0 \n[3w0]>?\w\[tbl]\fBbackground\fP \[tbl]
+.nr 3w1 \n[3w1]>?\w\[tbl]\  \[tbl]
+.nr 3w2 \n[3w2]>?\w\[tbl]\ = White \[tbl]
+.nr 3w0 \n[3w0]>?(\n[3lnw0]+\n[3rnw0])
+.if \n[3aw0] .nr 3w0 \n[3w0]>?(\n[3aw0]+2n)
+.nr 3w1 \n[3w1]>?(\n[3lnw1]+\n[3rnw1])
+.if \n[3aw1] .nr 3w1 \n[3w1]>?(\n[3aw1]+2n)
+.nr 3w2 \n[3w2]>?(\n[3lnw2]+\n[3rnw2])
+.if \n[3aw2] .nr 3w2 \n[3w2]>?(\n[3aw2]+2n)
+.nr 3cd0 0
+.nr 3cl0 0*\n[3sep]
+.nr 3ce0 \n[3cl0]+\n[3w0]
+.nr 3cl1 \n[3ce0]+(3*\n[3sep])
+.nr 3cd1 \n[3ce0]+\n[3cl1]/2
+.nr 3ce1 \n[3cl1]+\n[3w1]
+.nr 3cl2 \n[3ce1]+(3*\n[3sep])
+.nr 3cd2 \n[3ce1]+\n[3cl2]/2
+.nr 3ce2 \n[3cl2]+\n[3w2]
+.nr 3cd3 \n[3ce2]+(0*\n[3sep])
+.nr TW \n[3cd3]
+.if \n[3cent] \{.in +(u;\n[.l]-\n[.i]-\n[TW]/2)
+.nr 3ind \n[.i]
+.\}
+.eo
+.de T#
+.if !\n[3supbot] \{.3rvpt 0
+.mk 3vert
+.ls 1
+.ls
+.nr 3passed \n[3crow]
+.sp |\n[3vert]u
+.3rvpt 1
+.\}
+..
+.ec
+.fc 
+.3keep
+.3rmk 3rt0
+\*[3trans].nr 3crow 0
+.3keep
+.mk 3rs0
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor0\fP \h'|\n[3cl1]u'\ (black) \h'|\n[3cl2]u'\ = Black 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs0]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt1
+\*[3trans].nr 3crow 1
+.3keep
+.mk 3rs1
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor1\fP \h'|\n[3cl1]u'\ (red) \h'|\n[3cl2]u'\ = Red3 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs1]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt2
+\*[3trans].nr 3crow 2
+.3keep
+.mk 3rs2
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor2\fP \h'|\n[3cl1]u'\ (green) \h'|\n[3cl2]u'\ = Green3 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs2]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt3
+\*[3trans].nr 3crow 3
+.3keep
+.mk 3rs3
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor3\fP \h'|\n[3cl1]u'\ (yellow) \h'|\n[3cl2]u'\ = Yellow3 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs3]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt4
+\*[3trans].nr 3crow 4
+.3keep
+.mk 3rs4
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor4\fP \h'|\n[3cl1]u'\ (blue) \h'|\n[3cl2]u'\ = Blue3 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs4]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt5
+\*[3trans].nr 3crow 5
+.3keep
+.mk 3rs5
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor5\fP \h'|\n[3cl1]u'\ (magenta) \h'|\n[3cl2]u'\ = Magenta3 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs5]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt6
+\*[3trans].nr 3crow 6
+.3keep
+.mk 3rs6
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor6\fP \h'|\n[3cl1]u'\ (cyan) \h'|\n[3cl2]u'\ = Cyan3 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs6]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt7
+\*[3trans].nr 3crow 7
+.3keep
+.mk 3rs7
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor7\fP \h'|\n[3cl1]u'\ (white) \h'|\n[3cl2]u'\ = AntiqueWhite 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs7]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt8
+\*[3trans].nr 3crow 8
+.3keep
+.mk 3rs8
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor8\fP \h'|\n[3cl1]u'\ (bright black) \h'|\n[3cl2]u'\ = Grey25 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs8]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt9
+\*[3trans].nr 3crow 9
+.3keep
+.mk 3rs9
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor9\fP \h'|\n[3cl1]u'\ (bright red) \h'|\n[3cl2]u'\ = Red 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs9]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt10
+\*[3trans].nr 3crow 10
+.3keep
+.mk 3rs10
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor10\fP \h'|\n[3cl1]u'\ (bright green) \h'|\n[3cl2]u'\ = Green 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs10]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt11
+\*[3trans].nr 3crow 11
+.3keep
+.mk 3rs11
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor11\fP \h'|\n[3cl1]u'\ (bright yellow) \h'|\n[3cl2]u'\ = Yellow 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs11]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt12
+\*[3trans].nr 3crow 12
+.3keep
+.mk 3rs12
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor12\fP \h'|\n[3cl1]u'\ (bright blue) \h'|\n[3cl2]u'\ = Blue 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs12]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt13
+\*[3trans].nr 3crow 13
+.3keep
+.mk 3rs13
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor13\fP \h'|\n[3cl1]u'\ (bright magenta) \h'|\n[3cl2]u'\ = Magenta 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs13]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt14
+\*[3trans].nr 3crow 14
+.3keep
+.mk 3rs14
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor14\fP \h'|\n[3cl1]u'\ (bright cyan) \h'|\n[3cl2]u'\ = Cyan 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs14]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt15
+\*[3trans].nr 3crow 15
+.3keep
+.mk 3rs15
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBcolor15\fP \h'|\n[3cl1]u'\ (bright white) \h'|\n[3cl2]u'\ = White 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs15]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt16
+\*[3trans].nr 3crow 16
+.3keep
+.mk 3rs16
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBforeground\fP \h'|\n[3cl1]u'\  \h'|\n[3cl2]u'\ = Black 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs16]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.3keep
+.3rmk 3rt17
+\*[3trans].nr 3crow 17
+.3keep
+.mk 3rs17
+.mk 3bot
+.3rvpt 0
+.ta \n[3ce0]u \n[3ce1]u \n[3ce2]u
+\&\h'|\n[3cl0]u'\fBbackground\fP \h'|\n[3cl1]u'\  \h'|\n[3cl2]u'\ = White 
+.nr 3bot \n[3bot]>?\n[.d]
+.sp |\n[3rs17]u
+.3rvpt 1
+.sp |\n[3bot]u
+\*[3trans].nr 3brule 1
+.3release
+.mk 3rt18
+.nr 3brule 1
+.nr T. 1
+.T#
+.3init
+.fc
+.cp \n(3c
+.if '\*(.T'html' \X(table-end(
+.TE 
+.PP 
+It is also possible to specify the colour values of \fBforeground\fP,
+\fBbackground\fP, \fBcursorColor\fP, \fBcursorColor2\fP, \fBcolorBD\fP, \fBcolorUL\fP
+as a number 0-15, as a convenient shorthand to reference the colour name of
+color0-color15\&.
+.PP 
+Note that \fB-rv\fP (\fB"reverseVideo: True"\fP) simulates reverse video by
+always swapping the foreground/background colours\&.  This is in contrast to
+\fIxterm\fP(1) where the colours are only swapped if they have not otherwise been
+specified\&.
+For example,
+.PP 
+.IP "\fBrxvt -fg Black -bg White -rv\fP" 
+would yield White on Black, while on \fIxterm\fP(1) it would yield
+Black on White\&.
+.SH "ENVIRONMENT" 
+.PP 
+\fBrxvt\fP sets the environment variables \fBTERM\fP, \fBCOLORTERM\fP and
+\fBCOLORFGBG\fP\&.  The environment variable \fBWINDOWID\fP is set to the X window
+id number of the \fBrxvt\fP window and it also uses and sets the environment
+variable \fBDISPLAY\fP to specify which display terminal to use\&.  \fBrxvt\fP uses
+the environment variables \fBRXVTPATH\fP and \fBPATH\fP to find XPM files\&.
+.SH "FILES" 
+.PP 
+.IP "\fB/etc/utmp\fP" 
+System file for login records\&.
+.IP "\fB/usr/lib/X11/rgb\&.txt\fP" 
+Color names\&.
+.PP 
+.SH "SEE ALSO" 
+.PP 
+\fIxterm\fP(1), \fIsh\fP(1), \fIresize\fP(1), \fIX\fP(1), \fIpty\fP(4), \fItty\fP(4),
+\fIutmp\fP(5)
+.PP 
+See rxvtRef\&.html rxvtRef\&.txt for detailed information on recognized escape
+sequences and menuBar syntax, etc\&.
+.PP 
+.SH "BUGS" 
+.PP 
+Check the BUGS file for an up-to-date list\&.
+.PP 
+Cursor change support is not yet implemented\&.
+.PP 
+Click-and-drag doesn\'t work with X11 mouse report overriding\&.
+.PP 
+Graphics support is fairly crude\&.
+.PP 
+.SH "FTP LOCATION" 
+.PP 
+rxvt-2\&.6\&.4\&.tar\&.gz can be found at the following ftp sites
+ftp://ftp\&.rxvt\&.org/pub/rxvt
+.PP 
+.SH "CURRENT PROJECT COORDINATOR" 
+.PP 
+.IP "Project Coordinator" 
+Geoff Wing <gcw@rxvt\&.org>
+.br 
+.IP "Web page maintainter" 
+Oezguer Kesim <oec@rxvt\&.org>
+.br 
+<http://www\&.rxvt\&.org/>
+.br 
+.IP "Mailing list" 
+The Rxvt Workers <rxvt-workers@rxvt\&.org>
+mailing list has also been established for rxvt development, to
+subscribe, email to 
+<rxvt-workers-subscribe@rxvt\&.org>\&.
+There is also a mailing list for announcements of new releases of
+rxvt\&. To subscribe, email to
+<rxvt-announce-subscribe@rxvt\&.org>\&.
+.PP 
+.SH "AUTHORS" 
+.PP 
+.IP "John Bovey" 
+University of Kent, 1992, wrote the original Xvt\&.
+.IP "Rob Nation <nation@rocket\&.sanders\&.lockheed\&.com>" 
+very heavily modified Xvt and came up with Rxvt
+.IP "Angelo Haritsis <ah@doc\&.ic\&.ac\&.uk>" 
+wrote the Greek Keyboard Input
+.IP "mj olesen <olesen@me\&.QueensU\&.CA>" 
+Wrote the menu system\&. 
+.br 
+Project Coordinator (changes\&.txt 2\&.11 to 2\&.21)
+.IP "Oezguer Kesim <kesim@math\&.fu-berlin\&.de>" 
+Project Coordinator (changes\&.txt 2\&.21a to 2\&.4\&.5)
+.IP "Geoff Wing <gcw@pobox\&.com>" 
+Rewrote screen display and text selection routines\&. 
+.br 
+Project Coordinator (changes\&.txt 2\&.4\&.6 - )
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/rxvt.html work/main.d/rxvt-2.6.4/doc/rxvt.html
--- tmp/rxvt-2.6.4/doc/rxvt.html	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/rxvt.html	2001-11-01 21:32:03.000000000 -0300
@@ -0,0 +1,771 @@
+
+
+
+
+<a name="versioninfo.yo"></a>
+    
+
+
+
+
+
+
+
+
+
+
+<a name="masonyodl.yo"></a>
+    
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+<html><head><title>1</title>
+
+<link rev="made" href="mailto:gcw@pobox.com">
+</head>
+<body>
+
+<hr>
+
+<h1>1</h1>
+<h2>X Version 11</h2>
+<h2>02 NOVEMBER 2001</h2>
+
+
+    
+<h2>NAME</h2>
+    rxvt (ouR XVT) - a VT102 emulator for the X window system
+<p>
+<h2>SYNOPSIS</h2>
+    
+<p><strong>rxvt</strong> [options] [-e command [ args ]]
+<p>
+<h2>DESCRIPTION</h2>
+    
+<p><strong>rxvt</strong>, version <strong>2.6.4</strong>, is a colour vt102 terminal emulator
+intended as an <em>xterm</em>(1) replacement for users who do not require
+features such as Tektronix 4014 emulation and toolkit-style configurability.
+As a result, <strong>rxvt</strong> uses much less swap space -- a significant
+advantage on a machine serving many X sessions.
+<p>
+<p><a name="rxvt-options.yo"></a>
+    
+
+<h2>OPTIONS</h2>
+    
+<p>The <strong>rxvt</strong> options (mostly a subset of <em>xterm</em>'s) are listed below.
+In keeping with the smaller-is-better philosophy, options may be eliminated
+or default values chosen at compile-time, so options and defaults listed
+may not accurately reflect the version installed on your system.  
+`rxvt -h' gives a list of major compile-time options on the usage line.
+Option descriptions may be prefixed with which compile option each is
+dependent upon.  e.g. `Compile <em>XIM</em>:' requires <em>XIM</em> on the usage line.
+Note: `rxvt -help' gives a list of all options compiled into your version.
+<p>Note that <strong>rxvt</strong> permits the resource name to be used as a long-option
+(--/++ option) so the potential command-line options are far greater than
+those listed.
+For example: `rxvt --loginShell --color1 Orange'.
+<p><dl>
+    <p></p><dt><strong><strong>-help</strong>, <strong>--help</strong></strong><dd>
+	Print out a message describing available options.
+    <p></p><dt><strong><strong>-display</strong> <em>displayname</em></strong><dd>
+	Attempt to open a window on the named X display (<strong>-d</strong> still
+	respected).  In the absence of this option, the display specified
+	by the <strong>DISPLAY</strong> environment variable is used.
+    <p></p><dt><strong><strong>-geometry</strong> <em>geom</em></strong><dd>
+	Window geometry (<strong>-g</strong> still respected);
+        resource <strong>geometry</strong>.
+    <p></p><dt><strong><strong>-rv</strong>|<strong>+rv</strong></strong><dd>
+	Turn on/off simulated reverse video;
+        resource <strong>reverseVideo</strong>.
+    <p></p><dt><strong><strong>-ip</strong>|<strong>+ip</strong></strong><dd>
+	Turn on/off inheriting parent window's pixmap.  Alternative form
+	is <strong>-tr</strong>;
+	resource <strong>inheritPixmap</strong>.
+    <p></p><dt><strong><strong>-bg</strong> <em>colour</em></strong><dd>
+	Window background colour;
+        resource <strong>background</strong>.
+    <p></p><dt><strong><strong>-fg</strong> <em>colour</em></strong><dd>
+	Window foreground colour;
+	resource <strong>foreground</strong>.
+    <p></p><dt><strong><strong>-pixmap:</strong> <em>file[;geom]</em></strong><dd>
+	Compile <em>XPM</em>: Specify XPM file for the background and also
+	optionally specify its scaling with a geometry string.  Note you
+	may need to add quotes to avoid special shell interpretation of
+	the `;' in the command-line;
+	resource <strong>backgroundPixmap</strong>.
+    <p></p><dt><strong><strong>-cr</strong> <em>colour</em></strong><dd>
+	The cursor colour;
+	resource <strong>cursorColor</strong>.
+    <p></p><dt><strong><strong>-pr</strong> <em>colour</em></strong><dd>
+	The mouse pointer colour;
+	resource <strong>pointerColor</strong>.
+    <p></p><dt><strong><strong>-bd</strong> <em>colour</em></strong><dd>
+	The colour of the border between the xterm scrollbar and the text;
+	resource <strong>borderColor</strong>.
+    <p></p><dt><strong><strong>-fn</strong> <em>fontname</em></strong><dd>
+	Main normal text font;
+	resource <strong>font</strong>.
+    <p></p><dt><strong><strong>-fb</strong> <em>fontname</em></strong><dd>
+	Main bold text font;
+	resource <strong>boldFont</strong>.
+    <p></p><dt><strong><strong>-fm</strong> <em>fontname</em></strong><dd>
+	Main multicharacter font;
+	resource <strong>mfont</strong>.
+    <p></p><dt><strong><strong>-km</strong> <em>mode</em></strong><dd>
+	Multiple-character font-set encoding mode;
+	<strong>eucj</strong>: EUC Japanese encoding.
+	<strong>sjis</strong>: Shift JIS encoding;
+	resource <strong>multichar_encoding</strong>.
+    <p></p><dt><strong><strong>-grk</strong> <em>mode</em></strong><dd>
+	Greek keyboard translation;
+	<strong>iso</strong>: ISO-8859 mapping.
+	<strong>ibm</strong>: IBM-437 mapping;
+	resource <strong>greek_keyboard</strong>.
+    <p></p><dt><strong><strong>-name</strong> <em>name</em></strong><dd>
+	Specify the application name under which resources
+	are to be obtained, rather than the default executable file name.
+	Name should not contain `.' or `*' characters.
+	Also sets the icon and title name.
+    <p></p><dt><strong><strong>-ls</strong>|<strong>+ls</strong></strong><dd>
+	Start as a login-shell/sub-shell;
+	resource <strong>loginShell</strong>.
+    <p></p><dt><strong><strong>-ut</strong>|<strong>+ut</strong></strong><dd>
+	Compile <em>utmp</em>: Inhibit/enable writing a utmp entry;
+	resource <strong>utmpInhibit</strong>.
+    <p></p><dt><strong><strong>-vb</strong>|<strong>+vb</strong></strong><dd>
+	Turn on/off visual bell on receipt of a bell character;
+	resource <strong>visualBell</strong>.
+    <p></p><dt><strong><strong>-sb</strong>|<strong>+sb</strong></strong><dd>
+	Turn on/off scrollbar;
+	resource <strong>scrollBar</strong>.
+    <p></p><dt><strong><strong>-si</strong>|<strong>+si</strong></strong><dd>
+	Turn on/off scroll-to-bottom on TTY output inhibit;
+	resource <strong>scrollTtyOutput</strong> has opposite effect.
+    <p></p><dt><strong><strong>-sk</strong>|<strong>+sk</strong></strong><dd>
+	Turn on/off scroll-to-bottom on keypress;
+	resource <strong>scrollTtyKeypress</strong>.
+    <p></p><dt><strong><strong>-sr</strong>|<strong>+sr</strong></strong><dd> 
+	Put scrollbar on right/left;
+	resource <strong>scrollBar_right</strong>.
+    <p></p><dt><strong><strong>-st</strong>|<strong>+st</strong></strong><dd> 
+	Display normal (non XTerm/NeXT) scrollbar without/with a trough;
+	resource <strong>scrollBar_floating</strong>.
+    <p></p><dt><strong><strong>-iconic</strong></strong><dd> 
+	Start iconified, if the window manager supports that option.
+	Alternative form is <strong>-ic</strong>.
+    <p></p><dt><strong><strong>-sl</strong> <em>number</em></strong><dd>
+	Save <em>number</em> lines in the scrollback buffer;
+	resource <strong>saveLines</strong>.
+    <p></p><dt><strong><strong>-tn</strong> <em>termname</em></strong><dd> 
+	This option specifies the name of the terminal type to be set in the
+	<strong>TERM</strong> environment variable. This terminal type must exist in the
+	<em>termcap(5)</em> database and should have <em>li#</em> and <em>co#</em> entries;
+	resource <strong>termName</strong>.
+    <p></p><dt><strong><strong>-e</strong> <em>command [arguments]</em></strong><dd>
+	Run the command with its command-line arguments in the <strong>rxvt</strong>
+	window; also sets the window title and icon name to be the basename
+	of the program being executed if neither <em>-title</em> (<em>-T</em>) nor
+	<em>-n</em> are given on the command line.  If this option is used, it
+	must be the last on the command-line.  If there is no <strong>-e</strong> option
+	then the default is to run the program specified by the <strong>SHELL</strong>
+	environment variable or, failing that, <em>sh(1)</em>.
+    <p></p><dt><strong><strong>-title</strong> <em>text</em></strong><dd>
+	Window title (<strong>-T</strong> still respected); the default title is the
+	basename of the program specified after the <strong>-e</strong> option, if
+	any, otherwise the application name;
+	resource <strong>title</strong>.
+    <p></p><dt><strong><strong>-n</strong> <em>text</em></strong><dd>
+	Icon name; the default name is the basename of the program specified
+	after the <strong>-e</strong> option, if any, otherwise the application name;
+	resource <strong>iconName</strong>.
+    <p></p><dt><strong><strong>-C</strong></strong><dd>
+	Capture system console messages.
+    <p></p><dt><strong><strong>-pt</strong> <em>style</em></strong><dd>
+	Compile <em>XIM</em>: input style for input method;
+	<strong>OverTheSpot</strong>, <strong>OffTheSpot</strong>, <strong>Root</strong>;
+	resource <strong>preeditType</strong>.
+    <p></p><dt><strong><strong>-im</strong> <em>text</em></strong><dd>
+	Compile <em>XIM</em>: input method name.
+	resource <strong>inputMethod</strong>.
+    <p></p><dt><strong><strong>-mod</strong> <em>modifier</em></strong><dd>
+	Override detection of Meta modifier with specified key:
+	<strong>alt</strong>, <strong>meta</strong>, <strong>hyper</strong>, <strong>super</strong>, <strong>mod1</strong>, <strong>mod2</strong>, <strong>mod3</strong>,
+	<strong>mod4</strong>, <strong>mod5</strong>;
+	resource <em>modifier</em>.
+    <p></p><dt><strong><strong>-xrm</strong> <em>resourcestring</em></strong><dd>
+	No effect on rxvt.  Simply passes through an argument to be made
+	available in the instance's argument list.  Appears in <em>WM_COMMAND</em>
+	in some window managers.
+</dl>
+
+<a name="rxvt-resources.yo"></a>
+    
+
+<h2>RESOURCES (available also as long-options)</h2>
+    
+<p>Note: `rxvt --help' gives a list of all resources (long options) compiled
+into your version.
+If compiled with internal Xresources support (i.e. <strong>rxvt -h</strong> lists 
+<strong>.Xdefaults</strong>) then <strong>rxvt</strong> accepts application defaults set in
+XAPPLOADDIR/Rxvt (compile-time defined: usually
+<strong>/usr/lib/X11/app-defaults/Rxvt</strong>) and resources set in <strong>~/.Xdefaults</strong>,
+or <strong>~/.Xresources</strong> if <strong>~/.Xdefaults</strong> does not exist.  Note that when
+reading X resources, <strong>rxvt</strong> recognizes two class names: <strong>XTerm</strong> and
+<strong>Rxvt</strong>.  The class name <strong>XTerm</strong> allows resources common to both
+<strong>rxvt</strong> and <em>xterm</em> to be easily configured, while the class name
+<strong>Rxvt</strong> allows resources unique to <strong>rxvt</strong>, notably colours and
+key-handling, to be shared between different <strong>rxvt</strong> configurations. 
+If no resources are specified, suitable defaults will be used. 
+Command-line arguments can be used to override resource settings.  The
+following resources are allowed:
+<p><dl>
+    <p></p><dt><strong><strong>geometry:</strong> <em>geom</em></strong><dd>
+	Create the window with the specified X window geometry [default
+	80x24];
+	option <strong>-geometry</strong>.
+    <p></p><dt><strong><strong>background:</strong> <em>colour</em></strong><dd>
+	Use the specified colour as the window's background colour [default
+	White];
+	option <strong>-bg</strong>.
+    <p></p><dt><strong><strong>foreground:</strong> <em>colour</em></strong><dd>
+	Use the specified colour as the window's foreground colour [default
+	Black];
+	option <strong>-fg</strong>.
+    <p></p><dt><strong><strong>color</strong><em>n</em><strong>:</strong> <em>colour</em></strong><dd>
+	Use the specified colour for the colour value <em>n</em>, where 0-7
+	corresponds to low-intensity (normal) colours and 8-15 corresponds to
+	high-intensity (bold = bright foreground, blink = bright
+	background) colours.  The canonical names are as follows:
+	0=black, 1=red, 2=green, 3=yellow, 4=blue, 5=magenta, 6=cyan, 7=white,
+	but the actual colour names used are listed in the
+	<strong>COLORS AND GRAPHICS</strong> section.
+    <p></p><dt><strong><strong>colorBD:</strong> <em>colour</em></strong><dd>
+	Use the specified colour to display bold characters when the
+	foreground colour is the default.
+    <p></p><dt><strong><strong>colorUL:</strong> <em>colour</em></strong><dd>
+	Use the specified colour to display underlined characters when the
+	foreground colour is the default.
+    <p></p><dt><strong><strong>cursorColor:</strong> <em>colour</em></strong><dd>
+	Use the specified colour for the cursor.  The default is to use the
+	foreground colour;
+	option <strong>-cr</strong>.
+    <p></p><dt><strong><strong>cursorColor2:</strong> <em>colour</em></strong><dd>
+	Use the specified colour for the colour of the cursor text.  For this
+	to take effect, <strong>cursorColor</strong> must also be specified.  The default
+	is to use the background colour.
+    <p></p><dt><strong><strong>reverseVideo:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: simulate reverse video by foreground and background colours;
+	option <strong>-rv</strong>,
+	<strong>False</strong>: regular screen colours [default];
+	option <strong>+rv</strong>.
+	See note in <strong>COLORS AND GRAPHICS</strong> section.
+    <p></p><dt><strong><strong>inheritPixmap:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: make the background inherit the parent windows' pixmap,
+	giving artificial transparency.
+	<strong>False</strong>: do not inherit the parent windows' pixmap.
+    <p></p><dt><strong><strong>scrollColor:</strong> <em>colour</em></strong><dd>
+	Use the specified colour for the scrollbar [default #B2B2B2].
+    <p></p><dt><strong><strong>troughColor:</strong> <em>colour</em></strong><dd>
+	Use the specified colour for the scrollbar's trough area [default
+	#969696].  Only relevant for normal (non XTerm/NeXT) scrollbar.
+    <p></p><dt><strong><strong>backgroundPixmap:</strong> <em>file[;geom]</em></strong><dd>
+	Use the specified XPM file (note the `.xpm' extension is optional)
+	for the background and also optionally specify its scaling with a
+	geometry string <strong>WxH+X+Y</strong>, in which <strong>"W" / "H"</strong> specify the
+	horizontal/vertical scale (percent) and <strong>"X" / "Y"</strong> locate the
+	image centre (percent).  A scale of 0 displays the image with tiling.
+	A scale of 1 displays the image without any scaling.  A scale of 2 to
+	9 specifies an integer number of images in that direction.  No image
+	will be magnified beyond 10 times its original size.  The maximum
+	permitted scale is 1000.  [default 0x0+50+50]
+    <p></p><dt><strong><strong>menu:</strong> <em>file[;tag]</em></strong><dd>
+	Read in the specified menu file (note the `.menu' extension is
+	optional) and also optionally specify a starting tag to find.  See
+	the reference documentation for details on the syntax for the menuBar.
+    <p></p><dt><strong><strong>path:</strong> <em>path</em></strong><dd>
+	Specify the colon-delimited search path for finding files (XPM and
+	menus), in addition to the paths specified by the <strong>RXVTPATH</strong> and
+	<strong>PATH</strong> environment variables.
+    <p></p><dt><strong><strong>font:</strong> <em>fontname</em></strong><dd>
+	Select the main text font used [default 7x14];
+	option <strong>-fn</strong>.
+    <p></p><dt><strong><strong>font</strong><em>n</em><strong>:</strong> <em>fontname</em></strong><dd>
+	Specify the alternative font <em>n</em>.  The default font values: <br><ul><table>
+<tr> 
+<td> <strong>font</strong>: </td> 
+<td> 7x14 <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>font1</strong>: </td> 
+<td> 6x10 <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>font2</strong>: </td> 
+<td> 6x13 <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>font3</strong>: </td> 
+<td> 8x13 <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>font4</strong>: </td> 
+<td> 9x15 <br></td> 
+ 
+</tr>
+</table>   </ul>
+<p><p></p><dt><strong><strong>boldFont:</strong> <em>fontname</em></strong><dd>
+	Specify the name of the bold font to use if <strong>colorBD</strong> has not been
+	specified and it is not possible to map the default foreground colour
+	to colour 8-15 [default NONE].  This font must be the same height and
+	width as the normal font;
+	option <strong>-fb</strong>.
+    <p></p><dt><strong><strong>mfont:</strong> <em>fontname</em></strong><dd>
+	Select the main multiple-character text font used [default k14];
+	option <strong>-fk</strong>.
+    <p></p><dt><strong><strong>mfont</strong><em>n</em><strong>:</strong> <em>fontname</em></strong><dd>
+	Specify the alternative multiple-character font <em>n</em>.  If compiled
+	for multiple-character fonts, the Roman and multiple-character font
+	sizes should match.
+    <p></p><dt><strong><strong>multichar_encoding:</strong> <em>mode</em></strong><dd>
+	Set the encoding mode to be used when multicharacter encoding is
+	received;
+	<strong>eucj</strong>: EUC Japanese encoding [default for Kanji].
+	<strong>sjis</strong>: Shift JIS encoding.
+	<strong>big5</strong>: BIG5 encoding.
+	<strong>gb</strong>: GB encoding;
+	option <strong>-km</strong>.
+    <p></p><dt><strong><strong>greek_keyboard:</strong> <em>mode</em></strong><dd>
+	Set the Greek keyboard translation mode to be used;
+	<strong>iso</strong>: ISO-8859 mapping (elot-928) [default].
+	<strong>ibm</strong>: IBM-437 mapping (DOS codepage 737);
+	option <strong>-grk</strong>.
+	Use <strong>Mode_switch</strong> to toggle keyboard input.  For more details,
+	see the distributed file <strong>README.greek</strong>.
+    <p></p><dt><strong><strong>selectstyle:</strong> <em>text</em></strong><dd>
+	Set mouse selection style to <strong>old</strong> which is 2.20, <strong>oldword</strong> which
+	is xterm style with 2.20 old word selection, or anything else which
+	gives xterm style selection.
+    <p></p><dt><strong><strong>title:</strong> <em>text</em></strong><dd>
+	Set window title string, the default title is the command-line
+	specified after the <strong>-e</strong> option, if any, otherwise the application
+	name;
+	option <strong>-title</strong>.
+    <p></p><dt><strong><strong>iconName:</strong> <em>text</em></strong><dd>
+	Set the name used to label the window's icon or displayed in an icon
+	manager window, it also sets the window's title unless it is
+	explicitly set;
+	option <strong>-n</strong>.
+    <p></p><dt><strong><strong>mapAlert:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: de-iconify (map) on receipt of a bell character.
+	<strong>False</strong>: no de-iconify (map) on receipt of a bell character
+	[default].
+    <p></p><dt><strong><strong>visualBell:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: use visual bell on receipt of a bell character;
+	option <strong>-vb</strong>.
+	<strong>False</strong>: no visual bell [default];
+	option <strong>+vb</strong>.
+    <p></p><dt><strong><strong>loginShell:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: start as a login shell by prepending a `-' to <strong>argv[0]</strong>
+	of the shell;
+	option <strong>-ls</strong>.
+	<strong>False</strong>: start as a normal sub-shell [default];
+	option <strong>+ls</strong>.
+    <p></p><dt><strong><strong>utmpInhibit:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: inhibit writing record into the system log file <strong>utmp</strong>;
+	option <strong>-ut</strong>.
+	<strong>False</strong>: write record into the system log file <strong>utmp</strong> [default];
+	option <strong>+ut</strong>.
+    <p></p><dt><strong><strong>print-pipe:</strong> <em>string</em></strong><dd>
+	Specify a command pipe for vt100 printer [default <em>lpr(1)</em>].  Use
+	<strong>Print</strong> to initiate a screen dump to the printer and <strong>Ctrl-Print</strong>
+	or <strong>Shift-Print</strong> to include the scrollback as well.
+    <p></p><dt><strong><strong>scrollBar:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: enable the scrollbar [default];
+	option <strong>-sb</strong>.
+	<strong>False</strong>: disable the scrollbar;
+	option <strong>+sb</strong>.
+    <p></p><dt><strong><strong>scrollBar_right:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: place the scrollbar on the right of the window;
+	option <strong>-sr</strong>.
+	<strong>False</strong>: place the scrollbar on the left of the window;
+	option <strong>+sr</strong>.
+    <p></p><dt><strong><strong>scrollBar_floating:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: display an rxvt scrollbar without a trough;
+	option <strong>-st</strong>.
+	<strong>False</strong>: display an rxvt scrollbar with a trough;
+	option <strong>+st</strong>.
+    <p></p><dt><strong><strong>scrollTtyOutput:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: scroll to bottom when tty receives output;
+	option(+si).
+	<strong>False</strong>: do not scroll to bottom when tty receives output;
+	option(-si).
+    <p></p><dt><strong><strong>scrollTtyKeypress:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: scroll to bottom when a non-special key is pressed.
+	Special keys are those which are intercepted by rxvt for special
+	handling and are not passed onto the shell;
+	option(-sk).
+	<strong>False</strong>: do not scroll to bottom when a non-special key is pressed;
+	option(+sk).
+    <p></p><dt><strong><strong>smallfont_key:</strong> <em>keysym</em></strong><dd>
+	If enabled, use <strong>Alt-</strong><em>keysym</em> to toggle to a smaller font
+	[default <strong>Alt-&lt;</strong>]
+    <p></p><dt><strong><strong>bigfont_key:</strong> <em>keysym</em></strong><dd>
+	If enabled, use <strong>Alt-</strong><em>keysym</em> to toggle to a bigger font
+	[default <strong>Alt-&gt;</strong>]
+    <p></p><dt><strong><strong>saveLines:</strong> <em>number</em></strong><dd>
+	Save <em>number</em> lines in the scrollback buffer [default 64];
+	option <strong>-sl</strong>.
+    <p></p><dt><strong><strong>termName:</strong> <em>termname</em></strong><dd>
+	Specifies the terminal type name to be set in the <strong>TERM</strong>
+	environment variable;
+	option <strong>-tn</strong>.
+    <p></p><dt><strong><strong>meta8:</strong> <em>boolean</em></strong><dd>
+	<strong>True</strong>: handle Meta (Alt) + keypress to set the 8th bit.
+	<strong>False</strong>: handle Meta (Alt) + keypress as an escape prefix [default].
+    <p></p><dt><strong><strong>backspacekey:</strong> <em>string</em></strong><dd>
+	The string to send when the backspace key is pressed.  If set to
+	<strong>DEC</strong> or unset it will send <strong>Delete</strong> (code 127) or, if shifted,
+	<strong>Backspace</strong> (code 8) - which can be reversed with the appropriate
+	DEC private mode escape sequence.
+    <p></p><dt><strong><strong>deletekey:</strong> <em>string</em></strong><dd>
+	The string to send when the delete key (not the keypad delete key) is
+	pressed.  If unset it will send the sequence traditionally associated
+	with the <strong>Execute</strong> key.
+    <p></p><dt><strong><strong>cutchars:</strong> <em>string</em></strong><dd>
+	The characters used as delimiters for double-click word selection. 
+	The built-in default: <br><strong>BACKSLASH `"'&amp;()*,;&lt;=&gt;?@[]{|}</strong>
+    <p></p><dt><strong><strong>preeditType:</strong> <em>style</em></strong><dd>
+	<strong>OverTheSpot</strong>, <strong>OffTheSpot</strong>, <strong>Root</strong>;
+	option <strong>-pt</strong>.
+    <p></p><dt><strong><strong>inputMethod:</strong> <em>name</em></strong><dd>
+	<em>name</em> of inputMethod to use;
+	option <strong>-im</strong>.
+    <p></p><dt><strong><strong>modifier:</strong> <em>modifier</em></strong><dd>
+	Set the key to be interpreted as the Meta key to:
+	<strong>alt</strong>, <strong>meta</strong>, <strong>hyper</strong>, <strong>super</strong>, <strong>mod1</strong>, <strong>mod2</strong>, <strong>mod3</strong>,
+	<strong>mod4</strong>, <strong>mod5</strong>;
+	option <strong>-mod</strong>.
+    <p></p><dt><strong><strong>keysym.</strong><em>sym</em>: <em>string</em></strong><dd>
+	Associate <em>string</em> with keysym <em>sym</em> (<strong>0xFF00 - 0xFFFF</strong>).  It
+	may contain escape values (\a: bell, \b: backspace, \e, \E: escape,
+	\n: newline, \r: return, \t: tab, \000: octal number) or control
+	characters (^?: delete, ^@: null, ^A ...) and may enclosed with
+	double quotes so that it can start or end with whitespace.  The
+	intervening resource name <strong>keysym.</strong> cannot be omitted.  This
+	resource is only available when compiled with KEYSYM_RESOURCE.
+</dl>
+
+<a name="rxvt-scrollbar.yo"></a>
+    
+
+<h2>THE SCROLLBAR</h2>
+    
+<p>Lines of text that scroll off the top of the <strong>rxvt</strong> window (resource:
+<strong>saveLines</strong>) and can be scrolled back using the scrollbar or by keystrokes. 
+The normal <strong>rxvt</strong> scrollbar has arrows and its behaviour is fairly
+intuitive.  The <strong>xterm-scrollbar</strong> is without arrows and its behaviour
+mimics that of <em>xterm</em>
+<p>Scroll down with <strong>Button1</strong> (<strong>xterm-scrollbar</strong>) or <strong>Shift-Next</strong>.
+Scroll up with <strong>Button3</strong> (<strong>xterm-scrollbar</strong>) or <strong>Shift-Prior</strong>.
+Continuous scroll with <strong>Button2</strong>.
+
+<a name="rxvt-mousereporting.yo"></a>
+    
+
+<h2>MOUSE REPORTING</h2>
+    
+<p>To temporarily override mouse reporting, for either the scrollbar or the
+normal text selection/insertion, hold either the Shift or the Meta (Alt) key
+while performing the desired mouse action.
+<p>If mouse reporting mode is active, the normal scrollbar actions are disabled
+-- on the assumption that we are using a fullscreen application.
+Instead, pressing Button1 and Button3 sends
+<strong>ESC[6~</strong> (Next) and <strong>ESC[5~</strong> (Prior), respectively.
+Similarly, clicking on the up and down arrows sends <strong>ESC[A</strong> (Up) and
+<strong>ESC[B</strong> (Down), respectively.
+
+<a name="rxvt-textselection.yo"></a>
+    
+
+<h2>TEXT SELECTION AND INSERTION</h2>
+    
+<p>The behaviour of text selection and insertion mechanism is similar to
+<em>xterm</em>(1).
+<p><dl>
+    <p></p><dt><strong><strong>Selection</strong>:</strong><dd>
+	Left click at the beginning of the region, drag to the end of the
+	region and release; Right click to extend the marked region;
+	Left double-click to select a word; Left triple-click to select
+	the entire line.
+<p><p></p><dt><strong><strong>Insertion</strong>:</strong><dd>
+	Pressing and releasing the Middle mouse button (or <strong>Shift-Insert</strong>)
+	in an <strong>rxvt</strong> window causes the current text selection to be inserted
+	as if it had been typed on the keyboard.
+</dl>
+
+<a name="rxvt-fonts.yo"></a>
+    
+
+<h2>CHANGING FONTS</h2>
+    
+<p>You can change fonts on-the-fly, which is to say cycle through the default
+font and others of various sizes, by using <strong>Shift-KP_Add</strong> and
+<strong>Shift-KP_Subtract</strong>.  Or, alternatively (if enabled) with
+<strong>Alt-&gt;</strong> and <strong>Alt-&lt;</strong>, where the actual key
+can be selected using resources <strong>smallfont_key</strong>/<strong>bigfont_key</strong>.
+
+<a name="rxvt-login.yo"></a>
+    
+
+<h2>LOGIN STAMP</h2>
+    
+<p><strong>rxvt</strong> tries to write an entry into the <em>utmp</em>(5) file so that it can be
+seen via the <em>who(1)</em> command, and can accept messages.  To allow this
+feature, <strong>rxvt</strong> must be installed setuid root on some systems.
+
+<a name="rxvt-colours.yo"></a>
+    
+
+<h2>COLORS AND GRAPHICS</h2>
+    
+<p>If graphics support was enabled at compile-time, <strong>rxvt</strong> can be queried
+with ANSI escape sequences and can address individual pixels instead of
+text characters.  Note the graphics support is still considered beta code.
+<p>In addition to the default foreground and background colours, <strong>rxvt</strong>
+can display up to 16 colours (8 ANSI colours plus high-intensity bold/blink
+versions of the same).
+Here is a list of the colours with their <strong>rgb.txt</strong> names.
+<p><table>
+<tr> 
+<td> <strong>color0</strong> </td> 
+<td> (black) </td> 
+<td> = Black <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color1</strong> </td> 
+<td> (red) </td> 
+<td> = Red3 <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color2</strong> </td> 
+<td> (green) </td> 
+<td> = Green3 <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color3</strong> </td> 
+<td> (yellow) </td> 
+<td> = Yellow3 <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color4</strong> </td> 
+<td> (blue) </td> 
+<td> = Blue3 <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color5</strong> </td> 
+<td> (magenta) </td> 
+<td> = Magenta3 <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color6</strong> </td> 
+<td> (cyan) </td> 
+<td> = Cyan3 <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color7</strong> </td> 
+<td> (white) </td> 
+<td> = AntiqueWhite <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color8</strong> </td> 
+<td> (bright black) </td> 
+<td> = Grey25 <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color9</strong> </td> 
+<td> (bright red) </td> 
+<td> = Red <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color10</strong> </td> 
+<td> (bright green) </td> 
+<td> = Green <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color11</strong> </td> 
+<td> (bright yellow) </td> 
+<td> = Yellow <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color12</strong> </td> 
+<td> (bright blue) </td> 
+<td> = Blue <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color13</strong> </td> 
+<td> (bright magenta) </td> 
+<td> = Magenta <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color14</strong> </td> 
+<td> (bright cyan) </td> 
+<td> = Cyan <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>color15</strong> </td> 
+<td> (bright white) </td> 
+<td> = White <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>foreground</strong> </td> 
+<td>  </td> 
+<td> = Black <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong>background</strong> </td> 
+<td>  </td> 
+<td> = White <br></td> 
+ 
+</tr>
+</table>   
+<p>It is also possible to specify the colour values of <strong>foreground</strong>,
+<strong>background</strong>, <strong>cursorColor</strong>, <strong>cursorColor2</strong>, <strong>colorBD</strong>, <strong>colorUL</strong>
+as a number 0-15, as a convenient shorthand to reference the colour name of
+color0-color15.
+<p>Note that <strong>-rv</strong> (<strong>"reverseVideo: True"</strong>) simulates reverse video by
+always swapping the foreground/background colours.  This is in contrast to
+<em>xterm</em>(1) where the colours are only swapped if they have not otherwise been
+specified.
+For example,
+<p><dl>
+   <p></p><dt><strong><strong>rxvt -fg Black -bg White -rv</strong></strong><dd>
+	would yield White on Black, while on <em>xterm</em>(1) it would yield
+	Black on White.
+</dl>
+
+<a name="rxvt-environment.yo"></a>
+    
+
+<h2>ENVIRONMENT</h2>
+    
+<p><strong>rxvt</strong> sets the environment variables <strong>TERM</strong>, <strong>COLORTERM</strong> and
+<strong>COLORFGBG</strong>.  The environment variable <strong>WINDOWID</strong> is set to the X window
+id number of the <strong>rxvt</strong> window and it also uses and sets the environment
+variable <strong>DISPLAY</strong> to specify which display terminal to use.  <strong>rxvt</strong> uses
+the environment variables <strong>RXVTPATH</strong> and <strong>PATH</strong> to find XPM files.
+
+<a name="rxvt-files.yo"></a>
+    
+
+<h2>FILES</h2>
+    
+<p><dl>
+    <p></p><dt><strong><strong>/etc/utmp</strong></strong><dd> System file for login records.
+    <p></p><dt><strong><strong>/usr/lib/X11/rgb.txt</strong></strong><dd> Color names.
+</dl>
+
+<p>
+<h2>SEE ALSO</h2>
+    
+<p><em>xterm</em>(1), <em>sh</em>(1), <em>resize</em>(1), <em>X</em>(1), <em>pty</em>(4), <em>tty</em>(4),
+<em>utmp</em>(5)
+<p>See rxvtRef.html rxvtRef.txt for detailed information on recognized escape
+sequences and menuBar syntax, etc.
+<p>
+<h2>BUGS</h2>
+    
+<p>Check the BUGS file for an up-to-date list.
+<p>Cursor change support is not yet implemented.
+<p>Click-and-drag doesn't work with X11 mouse report overriding.
+<p>Graphics support is fairly crude.
+<p>
+<h2>FTP LOCATION</h2>
+    
+<p>rxvt-2.6.4.tar.gz can be found at the following ftp sites
+<a href="RXVTFTPSITE()">ftp://ftp.rxvt.org/pub/rxvt</a>
+<p>
+<h2>CURRENT PROJECT COORDINATOR</h2>
+    
+<p><dl>
+    <p></p><dt><strong>Project Coordinator</strong><dd>
+	Geoff Wing <a href="mailto:RXVTMAINTEMAIL()"><em>&lt;gcw@rxvt.org&gt;</em></a><br><p></p><dt><strong>Web page maintainter</strong><dd>
+	Oezguer Kesim <a href="mailto:RXVTWEBMAINTEMAIL()"><em>&lt;oec@rxvt.org&gt;</em></a><br><a href="RXVTWEBPAGE()">&lt;http://www.rxvt.org/&gt;</a><br><p></p><dt><strong>Mailing list</strong><dd>
+	The Rxvt Workers <a href="mailto:<rxvt-workers@rxvt.org>"><em>&lt;rxvt-workers@rxvt.org&gt;</em></a>
+	mailing list has also been established for rxvt development, to
+	subscribe, email to 
+	<a href="mailto:<rxvt-workers-subscribe@rxvt.org>"><em>&lt;rxvt-workers-subscribe@rxvt.org&gt;</em></a>.
+	There is also a mailing list for announcements of new releases of
+	rxvt. To subscribe, email to
+	<a href="mailto:<rxvt-announce-subscribe@rxvt.org>"><em>&lt;rxvt-announce-subscribe@rxvt.org&gt;</em></a>.
+</dl>
+<p>
+<h2>AUTHORS</h2>
+    
+<p><dl>
+    <p></p><dt><strong>John Bovey</strong><dd>
+	University of Kent, 1992, wrote the original Xvt.
+    <p></p><dt><strong>Rob Nation <a href="mailto:<nation@rocket.sanders.lockheed.com>"><em>&lt;nation@rocket.sanders.lockheed.com&gt;</em></a></strong><dd>
+	very heavily modified Xvt and came up with Rxvt
+    <p></p><dt><strong>Angelo Haritsis <a href="mailto:<ah@doc.ic.ac.uk>"><em>&lt;ah@doc.ic.ac.uk&gt;</em></a></strong><dd>
+	wrote the Greek Keyboard Input
+    <p></p><dt><strong>mj olesen <a href="mailto:<olesen@me.QueensU.CA>"><em>&lt;olesen@me.QueensU.CA&gt;</em></a></strong><dd>
+	Wrote the menu system. <br>Project Coordinator (changes.txt 2.11 to 2.21)
+    <p></p><dt><strong>Oezguer Kesim <a href="mailto:<kesim@math.fu-berlin.de>"><em>&lt;kesim@math.fu-berlin.de&gt;</em></a></strong><dd>
+	Project Coordinator (changes.txt 2.21a to 2.4.5)
+    <p></p><dt><strong>Geoff Wing <a href="mailto:<gcw@pobox.com>"><em>&lt;gcw@pobox.com&gt;</em></a></strong><dd>
+	Rewrote screen display and text selection routines. <br>Project Coordinator (changes.txt 2.4.6 - )
+</dl>
+</body>
+</html>
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/rxvtRef-frame.html work/main.d/rxvt-2.6.4/doc/rxvtRef-frame.html
--- tmp/rxvt-2.6.4/doc/rxvtRef-frame.html	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/rxvtRef-frame.html	1998-04-20 04:30:32.000000000 -0300
@@ -0,0 +1,10 @@
+<HTML>
+<HEAD>
+<TITLE>Rxvt Technical Reference</TITLE>
+</HEAD>
+<FRAMESET COLS="20%,*">
+	<FRAME NAME="toc" SRC="rxvtRef-toc.html" >
+	<FRAME NAME="main" SRC="rxvtRef.html" >
+</FRAMESET>
+<NOFRAME><BODY>Your browser needs frames</BODY></NOFRAME>
+</HTML>
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/rxvtRef.html work/main.d/rxvt-2.6.4/doc/rxvtRef.html
--- tmp/rxvt-2.6.4/doc/rxvtRef.html	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/rxvtRef.html	2001-11-01 21:32:39.000000000 -0300
@@ -0,0 +1,1460 @@
+
+
+
+
+
+
+
+
+<html><head><title>Rxvt Technical Reference</title>
+
+<link rev="made" href="mailto:gcw@pobox.com">
+</head>
+<body BGCOLOR="#FFFFFF">
+
+<hr>
+
+<h1>Rxvt Technical Reference</h1>
+<h2>Geoff Wing (gcw@pobox.com)</h2>
+<h2>18 April 1998</h2>
+
+
+<a name="toc"></a>
+
+
+
+
+<a name="masonyodl.yo"></a>
+    
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+<p><dl>
+    <li ><a href="rxvtRef.html#Definitions">Definitions</a>
+    <li ><a href="rxvtRef.html#Values">Values</a>
+    <li ><a href="rxvtRef.html#Sequences">Escape Sequences</a>
+    <li ><a href="rxvtRef.html#CSI">CSI (Code Sequence Introducer) Sequences</a>
+    <li ><a href="rxvtRef.html#PrivateModes">DEC Private Modes</a>
+    <li ><a href="rxvtRef.html#XTerm">XTerm Escape Sequences</a>
+    <li ><a href="rxvtRef.html#menuBar">menuBar</a>
+    <li ><a href="rxvtRef.html#XPM">XPM</a>
+    <li ><a href="rxvtRef.html#Mouse">Mouse Reporting</a>
+    <li ><a href="rxvtRef.html#Graphics">Special Graphics Mode</a>
+    <li ><a href="rxvtRef.html#KeyCodes">Key Codes</a>
+</dl>
+<p>Reworked from XTerm documentation and other sources
+<a name="rxvtRef-definitions.yo"></a>
+    
+<a name="Definitions"></a>
+<h2>Definitions</h2>
+    
+<p><dl>
+    <dt><strong><code>c</code></strong></dt><dd>The literal character c.</dd>
+<p><dt><strong><code>C</code></strong></dt><dd>A single (required) character.</dd>
+<p><dt><strong><code>Ps</code></strong></dt><dd>A single (usually optional) numeric parameter, composed of one or
+	more digits.</dd>
+<p><dt><strong><code>Pm</code></strong></dt><dd>A multiple numeric parameter composed of any number of single numeric
+	parameters, separated by ; character(s).</dd>
+<p><dt><strong><code>Pt</code></strong></dt><dd>A text parameter composed of printable characters.</dd>
+</dl>
+
+<a href="rxvtRef.html#toc">Top</a>
+<p><hr><p><br>
+<a name="rxvtRef-values.yo"></a>
+    
+<a name="Values"></a>
+<h2>Values</h2>
+    
+<p><dl>
+    <dt><strong><code>ENQ</code></strong></dt><dd>Enquiry (Ctrl-E) = Send Device Attributes (DA) <br>request attributes from terminal == <a href="rxvtRef.html#ESCOBPsc">ESC[Psc</a></dd>
+<p><dt><strong><code>BEL</code></strong></dt><dd>Bell (Ctrl-G)</dd>
+<p><dt><strong><code>BS</code></strong></dt><dd>Backspace (Ctrl-H)</dd>
+<p><dt><strong><code>TAB</code></strong></dt><dd>Horizontal Tab (HT) (Ctrl-I)</dd>
+<p><dt><strong><code>LF</code></strong></dt><dd>Line Feed or New Line (NL) (Ctrl-J)</dd>
+<p><dt><strong><code>VT</code></strong></dt><dd>Vertical Tab (Ctrl-K) same as <strong><code>LF</code></strong></dd>
+<p><dt><strong><code>FF</code></strong></dt><dd>Form Feed or New Page (NP) (Ctrl-L) same as <strong><code>LF</code></strong></dd>
+<p><dt><strong><code>CR</code></strong></dt><dd>Carriage Return (Ctrl-M)</dd>
+<p><dt><strong><code>SO</code></strong></dt><dd>Shift Out (Ctrl-N), invokes the G1 character set. <br>Switch to Alternate Character Set</dd>
+<p><dt><strong><code>SI</code></strong></dt><dd>Shift In (Ctrl-O), invokes the G0 character set (the default) <br>Switch to Standard Character Set</dd>
+<p><dt><strong><code>SPC</code></strong></dt><dd>Space Character</dd>
+</dl>
+
+<a href="rxvtRef.html#toc">Top</a>
+<p><hr><p><br>
+<a name="rxvtRef-sequences.yo"></a>
+    
+<a name="Sequences"></a>
+<h2>Escape Sequences</h2>
+    
+<p><dl>
+    <dt><strong><code>ESC # 8</code></strong></dt><dd>DEC Screen Alignment Test (DECALN)</dd>
+<p><dt><strong><code>ESC 7</code><br><code>ESC 8</code></strong></dt><dd>Save Cursor (SC)<br>Restore Cursor</dd><p><a name="ESCequals"></a>
+    <dt><strong><code>ESC =</code><br><code>ESC &gt;</code></strong></dt><dd>Application Keypad (SMKX) == <a href="rxvtRef.html#Priv66"><code>ESC[?66h</code></a><br>Normal Keypad (RMKX) == <a href="rxvtRef.html#Priv66"><code>ESC[?66l</code></a></dd><br><strong>Note:</strong> If the numeric keypad is activated, eg, <strong>Num_Lock</strong> has been
+    pressed, numbers or control functions are generated by the numeric keypad
+    (see <a href="rxvtRef.html#KeyCodes">Key Codes</a>)
+<p><dt><strong><code>ESC D</code></strong></dt><dd>Index (IND)</dd>
+<p><dt><strong><code>ESC E</code></strong></dt><dd>Next Line (NEL)</dd>
+<p><dt><strong><code>ESC H</code></strong></dt><dd>Tab Set (HTS)</dd>
+<p><dt><strong><code>ESC M</code></strong></dt><dd>Reverse Index (RI)</dd>
+<p><dt><strong><code>ESC N</code></strong></dt><dd>Single Shift Select of G2 Character Set (SS2): affects next character
+	only <em>unimplemented</em></dd>
+<p><dt><strong><code>ESC O</code></strong></dt><dd>Single Shift Select of G3 Character Set (SS3): affects next character
+	only <em>unimplemented</em></dd>
+<p><dt><strong><code>ESC Z</code></strong></dt><dd>Obsolete form of <a href="rxvtRef.html#ESCOBPsc"><code>ESC[c</code></a> <br>returns: <strong><code>ESC[?1;2C</code></strong> <em>rxvt compile-time option</em></dd>
+<p><dt><strong><code>ESC c</code></strong></dt><dd>Full reset (RIS)</dd>
+<p><dt><strong><code>ESC n</code></strong></dt><dd>Invoke the G2 Character Set (LS2)</dd>
+<p><dt><strong><code>ESC o</code></strong></dt><dd>Invoke the G3 Character Set (LS3)</dd>
+<p><dt><strong><code>ESC </code>(<code> C</code><br><code>ESC </code>)<code> C</code><br><code>ESC * C</code><br><code>ESC + C</code><br><code>ESC $ C</code></strong></dt><dd>Designate G0 Character Set (ISO 2022)<br>Designate G1 Character Set (ISO 2022)<br>Designate G2 Character Set (ISO 2022)<br>Designate G3 Character Set (ISO 2022)<br>Designate Kanji Character Set <br><em>where</em> <strong><code>C</code></strong> is <br><table>
+<tr> 
+<td> <strong><code>C = 0</code></strong> </td> 
+<td> DEC Special Character and Line Drawing Set <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>C = A</code></strong> </td> 
+<td> United Kingdom (UK) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>C = B</code></strong> </td> 
+<td> United States (USASCII) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>C = &lt;</code></strong> </td> 
+<td> Multinational character set <em>unimplemented</em> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>C = 5</code></strong> </td> 
+<td> Finnish character set <em>unimplemented</em> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>C = C</code></strong> </td> 
+<td> Finnish character set <em>unimplemented</em> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>C = K</code></strong> </td> 
+<td> German character set <em>unimplemented</em> <br></td> 
+ 
+</tr>
+</table>   </dd>
+</dl>
+
+<a href="rxvtRef.html#toc">Top</a>
+<p><hr><p><br>
+<a name="rxvtRef-csi.yo"></a>
+    
+<a name="CSI"></a>
+<h2>CSI (Code Sequence Introducer) Sequences</h2>
+    
+<p><dl>
+    <dt><strong><code>ESC [ Ps @</code></strong></dt><dd>Insert <strong><code>Ps</code></strong> (Blank) Character(s) [default: 1] (ICH)</dd><p><a name="ESCOBPsA"></a>
+    <dt><strong><code>ESC [ Ps A</code></strong></dt><dd>Cursor Up <strong><code>Ps</code></strong> Times [default: 1] (CUU)</dd>
+<p><dt><strong><code>ESC [ Ps B</code></strong></dt><dd>Cursor Down <strong><code>Ps</code></strong> Times [default: 1] (CUD)</dd><a name="ESCOBPsC"></a>
+    <dt><strong><code>ESC [ Ps C</code></strong></dt><dd>Cursor Forward <strong><code>Ps</code></strong> Times [default: 1] (CUF)</dd>
+<p><dt><strong><code>ESC [ Ps D</code></strong></dt><dd>Cursor Backward <strong><code>Ps</code></strong> Times [default: 1] (CUB)</dd>
+<p><dt><strong><code>ESC [ Ps E</code></strong></dt><dd>Cursor Down <strong><code>Ps</code></strong> Times [default: 1] and to first column</dd>
+<p><dt><strong><code>ESC [ Ps F</code></strong></dt><dd>Cursor Up <strong><code>Ps</code></strong> Times [default: 1] and to first column</dd><p><a name="ESCOBPsG"></a>
+    <dt><strong><code>ESC [ Ps G</code></strong></dt><dd>Cursor to Column <strong><code>Ps</code></strong> (HPA)</dd>
+<p><dt><strong><code>ESC [ Ps;Ps H</code></strong></dt><dd>Cursor Position [row;column] [default: 1;1] (CUP)</dd>
+<p><dt><strong><code>ESC [ Ps I</code></strong></dt><dd>Move forward <strong><code>Ps</code></strong> tab stops [default: 1]</dd>
+<p><dt><strong><code>ESC [ Ps J</code></strong></dt><dd>Erase in Display (ED) <br><table>
+<tr> 
+<td> <strong><code>Ps = 0</code></strong> </td> 
+<td> Clear Below (default) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 1</code></strong> </td> 
+<td> Clear Above <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 2</code></strong> </td> 
+<td> Clear All <br></td> 
+ 
+</tr>
+</table>   </dd>
+    <dt><strong><code>ESC [ Ps K</code></strong></dt><dd>Erase in Line (EL) <br><table>
+<tr> 
+<td> <strong><code>Ps = 0</code></strong> </td> 
+<td> Clear to Right (default) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 1</code></strong> </td> 
+<td> Clear to Left <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 2</code></strong> </td> 
+<td> Clear All <br></td> 
+ 
+</tr>
+</table>   </dd>
+    <dt><strong><code>ESC [ Ps L</code></strong></dt><dd>Insert <strong><code>Ps</code></strong> Line(s) [default: 1] (IL)</dd>
+<p><dt><strong><code>ESC [ Ps M</code></strong></dt><dd>Delete <strong><code>Ps</code></strong> Line(s) [default: 1] (DL)</dd>
+<p><dt><strong><code>ESC [ Ps P</code></strong></dt><dd>Delete <strong><code>Ps</code></strong> Character(s) [default: 1] (DCH)</dd>
+<p><dt><strong><code>ESC [ Ps;Ps;Ps;Ps;Ps T</code></strong></dt><dd>Initiate <a href="rxvtRef.html#Mouse">hilite mouse tracking</a>.  <em>unimplemented</em>
+	Parameters are [func;startx;starty;firstrow;lastrow].</dd>
+<p><dt><strong><code>ESC [ Ps W</code></strong></dt><dd>Tabulator functions <br><table>
+<tr> 
+<td> <strong><code>Ps = 0</code></strong> </td> 
+<td> Tab Set (HTS) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 2</code></strong> </td> 
+<td> Tab Clear (TBC), Clear Current Column (default) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 5</code></strong> </td> 
+<td> Tab Clear (TBC), Clear All <br></td> 
+ 
+</tr>
+</table>   </dd>
+    <dt><strong><code>ESC [ Ps X</code></strong></dt><dd>Erase <strong><code>Ps</code></strong> Character(s) [default: 1] (ECH)</dd>
+<p><dt><strong><code>ESC [ Ps Z</code></strong></dt><dd>Move backward <strong><code>Ps</code></strong> [default: 1] tab stops</dd>
+<p><dt><strong><code>ESC [ Ps '</code></strong></dt><dd>== <a href="rxvtRef.html#ESCOBPsG"><code>ESC [ Ps G</code></a></dd>
+<p><dt><strong><code>ESC [ Ps a</code></strong></dt><dd>== <a href="rxvtRef.html#ESCOBPsC"><code>ESC [ Ps C</code></a></dd><p><a name="ESCOBPsc"></a>
+    <dt><strong><code>ESC [ Ps c</code></strong></dt><dd>Send Device Attributes (DA)<br><strong><code>Ps = 0</code></strong> (or omitted) : request attributes from terminal <br>returns: <strong><code>ESC[?1;2c</code></strong> (``I am a VT100 with Advanced Video
+	Option'')</dd>
+<p><dt><strong><code>ESC [ Ps d</code></strong></dt><dd>Cursor to Line <strong><code>Ps</code></strong> (VPA)</dd>
+<p><dt><strong><code>ESC [ Ps e</code></strong></dt><dd>== <a href="rxvtRef.html#ESCOBPsA">ESC [ Ps A</a></dd>
+<p><dt><strong><code>ESC [ Ps;Ps f</code></strong></dt><dd>Horizontal and Vertical Position [row;column] (HVP) [default: 1;1]</dd>
+<p><dt><strong><code>ESC [ Ps g</code></strong></dt><dd>Tab Clear (TBC) <br><table>
+<tr> 
+<td> <strong><code>Ps = 0</code></strong> </td> 
+<td> Clear Current Column (default) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 3</code></strong> </td> 
+<td> Clear All (TBC) <br></td> 
+ 
+</tr>
+</table>   </dd>
+    <dt><strong><code>ESC [ Ps i</code></strong></dt><dd>Printing <br><table>
+<tr> 
+<td> <strong><code>Ps = 4</code></strong> </td> 
+<td> disable transparent print mode (MC4) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 5</code></strong> </td> 
+<td> enable transparent print mode (MC5) <em>unimplemented</em> <br></td> 
+ 
+</tr>
+</table>   </dd>
+    <dt><strong><code>ESC [ Pm h</code><br><code>ESC [ Pm l</code></strong></dt><dd>Set Mode (SM) <br>Reset Mode (RM)<dl>
+	    <dt><strong><code>Ps = 4</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Insert Mode (SMIR) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Replace Mode (RMIR) <br></td> 
+ 
+</tr>
+</table>   </dd>
+	    <dt><strong><code>Ps = 20</code></strong> <em>unimplemented</em></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Automatic Newline (LNM) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Normal Linefeed (LNM) <br></td> 
+ 
+</tr>
+</table>   </dd>
+	</dl></dd>
+    <dt><strong><code>ESC [ Pm m</code></strong></dt><dd>Character Attributes (SGR) <br><table>
+<tr> 
+<td> <strong><code>Ps = 0</code></strong> </td> 
+<td> Normal (default) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 1 / 22</code></strong> </td> 
+<td> On / Off Bold (bright fg) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 4 / 24</code></strong> </td> 
+<td> On / Off Underline <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 5 / 25</code></strong> </td> 
+<td> On / Off Blink (bright bg) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 7 / 27</code></strong> </td> 
+<td> On / Off Inverse <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 30 / 40</code></strong> </td> 
+<td> fg/bg Black <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 31 / 41</code></strong> </td> 
+<td> fg/bg Red <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 32 / 42</code></strong> </td> 
+<td> fg/bg Green <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 33 / 43</code></strong> </td> 
+<td> fg/bg Yellow <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 34 / 44</code></strong> </td> 
+<td> fg/bg Blue <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 35 / 45</code></strong> </td> 
+<td> fg/bg Magenta <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 36 / 46</code></strong> </td> 
+<td> fg/bg Cyan <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 37 / 47</code></strong> </td> 
+<td> fg/bg White <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 39 / 49</code></strong> </td> 
+<td> fg/bg Default <br></td> 
+ 
+</tr>
+</table>   </dd>
+    <dt><strong><code>ESC [ Ps n</code></strong></dt><dd>Device Status Report (DSR) <br><table>
+<tr> 
+<td> <strong><code>Ps = 5</code></strong> </td> 
+<td> Status Report <strong><code>ESC [ 0 n</code></strong> (``OK'') <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 6</code></strong> </td> 
+<td> Report Cursor Position (CPR) [row;column] as <strong><code>ESC [ r ; c R</code></strong> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 7</code></strong> </td> 
+<td> Request Display Name <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 8</code></strong> </td> 
+<td> Request Version Number (place in window title) <br></td> 
+ 
+</tr>
+</table>   </dd>
+    <dt><strong><code>ESC [ Ps;Ps r</code></strong></dt><dd>Set Scrolling Region [top;bottom] <br>[default: full size of window] (CSR)</dd>
+<p><dt><strong><code>ESC [ Ps x</code></strong></dt><dd>Request Terminal Parameters (DECREQTPARM)</dd>
+</dl>
+
+<a href="rxvtRef.html#toc">Top</a>
+<p><hr><p><br>
+<a name="rxvtRef-privatemodes.yo"></a>
+    
+<a name="PrivateModes"></a>
+<h2>DEC Private Modes</h2>
+    
+<p><dl>
+    <dt><strong><code>ESC [ ? Pm h</code></strong></dt><dd>DEC Private Mode Set (DECSET)</dd>
+<p><dt><strong><code>ESC [ ? Pm l</code></strong></dt><dd>DEC Private Mode Reset (DECRST)</dd>
+<p><dt><strong><code>ESC [ ? Pm r</code></strong></dt><dd>Restore previously saved DEC Private Mode Values.</dd>
+<p><dt><strong><code>ESC [ ? Pm s</code></strong></dt><dd>Save DEC Private Mode Values.</dd>
+<p><dt><strong><code>ESC [ ? Pm t</code></strong></dt><dd>Toggle DEC Private Mode Values (rxvt extension).</dd>
+    <em>where</em> <br><dl>
+        <dt><strong><code>Ps = 1</code></strong> (DECCKM)</dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Application Cursor Keys <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Normal Cursor Keys <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 2</code></strong> <em>unimplemented</em></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Designate USASCII for character sets G0-G3. <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 3</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> 132 Column Mode (DECCOLM) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> 80 Column Mode (DECCOLM) <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 4</code></strong> <em>unimplemented</em></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Smooth (Slow) Scroll (DECSCLM) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Jump (Fast) Scroll (DECSCLM) <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 5</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Reverse Video (DECSCNM) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Normal Video (DECSCNM) <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 6</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Origin Mode (DECOM) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Normal Cursor Mode (DECOM) <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 7</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Wraparound Mode (DECAWM) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> No Wraparound Mode (DECAWM) <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 8</code></strong> <em>unimplemented</em></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Auto-repeat Keys (DECARM) <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> No Auto-repeat Keys (DECARM) <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 9</code></strong> X10 XTerm <a href="rxvtRef.html#Mouse">mouse reporting</a></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Send Mouse X &amp; Y on button press. <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> No mouse reporting. <br></td> 
+ 
+</tr>
+</table>   </dd><a name="Priv10"></a>
+        <dt><strong><code>Ps = 10</code></strong> (<strong>rxvt</strong>)</dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> <a href="rxvtRef.html#menuBar">menuBar</a> visible <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> <a href="rxvtRef.html#menuBar">menuBar</a> invisible <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 25</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Visible cursor {cnorm/cvvis} <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Invisible cursor {civis} <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 30</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> scrollBar visisble <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> scrollBar invisisble <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 35</code></strong> (<strong>rxvt</strong>)</dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Allow XTerm Shift+key sequences <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Disallow XTerm Shift+key sequences <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 38</code></strong> <em>unimplemented</em></dt><dd>Enter Tektronix Mode (DECTEK)</dd>
+        <dt><strong><code>Ps = 40</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Allow 80/132 Mode <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Disallow 80/132 Mode <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 44</code></strong> <em>unimplemented</em></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Turn On Margin Bell <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Turn Off Margin Bell <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 45</code></strong> <em>unimplemented</em></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Reverse-wraparound Mode <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> No Reverse-wraparound Mode <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 46</code></strong> <em>unimplemented</em></dt><dd></dd>
+<p><dt><strong><code>Ps = 47</code></strong> <em>unimplemented</em></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Use Alternate Screen Buffer <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Use Normal Screen Buffer <br></td> 
+ 
+</tr>
+</table>   </dd><a name="Priv66"></a>   
+        <dt><strong><code>Ps = 66</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Application Keypad (DECPAM) == <a href="rxvtRef.html#ESCequals"><code>ESC =</code></a> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Normal Keypad (DECPNM) == <a href="rxvtRef.html#ESCequals"><code>ESC &gt;</code></a> <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 67</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Backspace key sends <strong><code>BS</code> (DECBKM)</strong> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Backspace key sends <strong><code>DEL</code></strong> <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 1000</code></strong> (X11 XTerm <a href="rxvtRef.html#Mouse">mouse reporting</a>)</dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Send Mouse X &amp; Y on button press and release. <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> No mouse reporting. <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 1001</code></strong> (X11 XTerm <a href="rxvtRef.html#Mouse">mouse tracking</a>) <em>unimplemented</em></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Use Hilite Mouse Tracking. <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> No mouse reporting. <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 1010</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Don't scroll to bottom on TTY output <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Scroll to bottom on TTY output <br></td> 
+ 
+</tr>
+</table>   </dd>
+        <dt><strong><code>Ps = 1011</code></strong></dt><dd><table>
+<tr> 
+<td> <strong><code>h</code></strong> </td> 
+<td> Scroll to bottom when a key is pressed <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>l</code></strong> </td> 
+<td> Don't scroll to bottom when a key is pressed <br></td> 
+ 
+</tr>
+</table>   </dd>
+   </dl>
+</dl>
+<p>
+<a href="rxvtRef.html#toc">Top</a>
+<p><hr><p><br>
+<a name="rxvtRef-xterm.yo"></a>
+    
+<a name="XTerm"></a>
+<h2>XTerm Escape Sequences</h2>
+    
+<p><dl>
+    <dt><strong><code>ESC ] Ps;Pt BEL</code></strong></dt><dd>Set XTerm Parameters <br><table>
+<tr> 
+<td> <strong><code>Ps = 0</code></strong> </td> 
+<td> Change Icon Name and Window Title to <strong><code>Pt</code></strong> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 1</code></strong> </td> 
+<td> Change Icon Name to <strong><code>Pt</code></strong> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 2</code></strong> </td> 
+<td> Change Window Title to <strong><code>Pt</code></strong> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 10</code></strong> </td> 
+<td> <a href="rxvtRef.html#menuBar">menuBar</a> command <strong><code>Pt</code></strong> <em>rxvt compile-time option</em> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 20</code></strong> </td> 
+<td> Change default background <a href="rxvtRef.html#XPM">pixmap</a> to <strong><code>Pt</code></strong> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 39</code></strong> </td> 
+<td> Change default foreground colour to <strong><code>Pt</code></strong> <em>rxvt compile-time option</em> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 46</code></strong> </td> 
+<td> Change Log File to <strong><code>Pt</code></strong> <em>unimplemented</em> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 49</code></strong> </td> 
+<td> Change default background colour to <strong><code>Pt</code></strong> <em>rxvt compile-time option</em> <br></td> 
+ 
+</tr>
+<tr> 
+<td> <strong><code>Ps = 50</code></strong> </td> 
+<td> Set Font to <strong><code>Pt</code></strong>, with the following special values of <strong><code>Pt</code></strong> (<strong>rxvt</strong>) <br><strong><code>#+n</code></strong> change up <strong><code>n</code></strong> font(s) <br><strong><code>#-n</code></strong> change down <strong><code>n</code></strong> font(s) <br>if <strong><code>n</code></strong> is missing of 0, a value of 1 is used <br><em>empty</em> change to font0 <br><strong><code>n</code></strong> change to font <strong><code>n</code></strong> <br></td> 
+ 
+</tr>
+</table>   </dd>
+</dl>
+
+<a href="rxvtRef.html#toc">Top</a>
+<p><hr><p><br>
+<a name="rxvtRef-menubar.yo"></a>
+    
+<a name="menuBar"></a>
+<h2>menuBar</h2>
+    
+<p><strong>The exact syntax used is <em>almost</em> solidified.</strong> <br>In the menus, <strong>DON'T</strong> try to use menuBar commands that add or remove a
+menuBar.
+<p>Note that in all of the commands, the <strong><em>/path/</em></strong> <em>cannot</em> be omitted:
+use <strong>./</strong> to specify a menu relative to the current menu.
+<p><h3>Overview of menuBar operation</h3><p>
+<p>For the menuBar XTerm escape sequence <code>ESC ] 10; Pt BEL</code>, the
+syntax of <code>Pt</code> can be used for a variety of tasks:
+<dl>
+    <li ><a href="rxvtRef.html#menuBarCommands">Commands</a>
+    <li ><a href="rxvtRef.html#menuBarAdd">Adding and accessing menus</a>
+    <li ><a href="rxvtRef.html#menuBarRemove">Removing menus</a>
+    <li ><a href="rxvtRef.html#menuBarArrows">Quick Arrows</a>
+    <li ><a href="rxvtRef.html#menuBarSummary">Command Summary</a>
+</dl>
+<p>At the top level is the current menuBar which is a member of a circular
+linked-list of other such menuBars.
+<p>The menuBar acts as a parent for the various drop-down menus, which in turn,
+may have labels, separator lines, menuItems and subMenus.
+<p>The menuItems are the useful bits: you can use them to mimic keyboard input
+or even to send text or escape sequences back to rxvt.
+<p>The menuBar syntax is intended to provide a simple yet robust method of
+constructing and manipulating menus and navigating through the menuBars.
+<p>The first step is to use the tag <strong>[menu:<em>name</em>]</strong> which creates the
+menuBar called <em>name</em> and allows access.
+You may now <a href="rxvtRef.html#menuBarAdd">add</a> or <a href="rxvtRef.html#menuBarRemove">remove</a> menus,
+subMenus, and menuItems. Finally, use the tag <strong>[done]</strong> to set the menuBar
+access as <strong>readonly</strong> to prevent accidental corruption of the menus.
+To re-access the current menuBar for alterations, use the tag <strong>[menu]</strong>,
+make the alterations and then use <strong>[done]</strong>
+<p><a name="menuBarCommands"></a>
+<h3>Commands</h3><p>
+<p><dl>
+    <dt><strong>[menu:<em>name</em>]</strong></dt><dd>access the named menuBar for creation or alteration. If a new menuBar
+	is created, it is called <em>name</em> (max of 15 chars) and the current
+	menuBar is pushed onto the stack</dd>
+<p><dt><strong>[menu]</strong></dt><dd>access the current menuBar for alteration</dd>
+<p><dt><strong>[title:<em>string</em>]</strong></dt><dd>set the current menuBar's title to <em>string</em>, which may contain the
+	following format specifiers: <br><strong>%%</strong> : literal <strong>%</strong> character <br><strong>%n</strong> : rxvt name (as per the <strong>-name</strong> command-line option) <br><strong>%v</strong> : rxvt version</dd>
+<p><dt><strong>[done]</strong></dt><dd>set menuBar access as <strong>readonly</strong>. <br>End-of-file tag for <strong>[read:<em>file</em>]</strong> operations.</dd>
+<p><dt><strong>[read:<em>file</em>]</strong></dt><dd>read menu commands directly from <em>file</em> (extension ".menu" will be
+	appended if required.) Start reading at a line with <strong>[menu]</strong> or
+	<strong>[menu:<em>name</em></strong> and continuing until <strong>[done]</strong> is encountered.
+<p>Blank and comment lines (starting with <strong>#</strong>) are ignored.
+	Actually, since any invalid menu commands are also ignored, almost
+	anything could be construed as a comment line, but this may be
+	tightened up in the future ... so don't count on it!.</dd>
+<p><dt><strong>[read:<em>file</em>;<em>name</em>]</strong></dt><dd>The same as <strong>[read:<em>file</em>]</strong>, but start reading at a line with
+	<strong>[menu:<em>name</em>]</strong> and continuing until <strong>[done:<em>name</em>]</strong> or
+	<strong>[done]</strong> is encountered.</dd>
+<p><dt><strong>[dump]</strong></dt><dd>dump all menuBars to the file <strong>/tmp/rxvt-PID</strong> in a format suitable
+	for later rereading.</dd>
+<p><dt><strong>[rm:name]<br>[rm] [rm:]<br>[rm*] [rm:*]</strong></dt><dd>remove the named menuBar <br>remove the current menuBar <br>remove all menuBars</dd>
+<p><dt><strong>[swap]</strong></dt><dd>swap the top two menuBars</dd>
+<p><dt><strong>[prev]<br>[next]</strong></dt><dd>access the previous or next menuBar</dd>
+<p><dt><strong>[show]<br>[hide]</strong></dt><dd>control display of the menuBar ... just like
+	<a href="rxvtRef.html#Priv10">ESC[?10 h/l</a></dd>
+<p><dt><strong>[pixmap:<em>name</em>]<br>[pixmap:<em>name</em>;<em>scaling</em>]</strong></dt><dd>set the background pixmap globally ... just like
+	<a href="rxvtRef.html#XPM">ESC]20; Pt BEL</a>
+<p><strong>A Future implementation <em>may</em> make this local to the menubar</strong></dd>
+<p><dt><strong>[:<em>command</em>:]</strong></dt><dd>ignore the menu readonly status and issue a <em>command</em> to
+	<a href="rxvtRef.html#menuBarAdd">Add/Modify</a> or <a href="rxvtRef.html#menuBarRemove">Remove</a> a menu or
+	menuitem or change the <a href="rxvtRef.html#menuBarArrows">Quick Arrows</a>; a useful
+	shortcut for setting the quick arrows from a menuBar.</dd>
+</dl>
+<p><a name="menuBarAdd"></a>
+<h3>Adding and accessing menus</h3><p>
+<p>The following commands may also be <strong>+</strong> prefixed.
+<dl>
+    <dt><strong>/<br>./<br>../<br>../../</strong></dt><dd>access menuBar top level <br>access current menu level <br>access parent menu (1 level up) <br>access parent menu (multiple levels up)</dd>
+    <dt><strong><em>/path/</em>menu</strong></dt><dd>add/access menu</dd>
+    <dt><strong><em>/path/</em>menu/*</strong></dt><dd>add/access menu and clear it if it exists</dd>
+    <dt><strong><em>/path/</em>{-}</strong></dt><dd>add separator</dd>
+    <dt><strong><em>/path/</em>{item}</strong></dt><dd>add <strong>item</strong> as a label</dd>
+    <dt><strong><em>/path/</em>{item} action</strong></dt><dd>add/alter <em>menuitem</em> with an associated <em>action</em></dd>
+    <dt><strong><em>/path/</em>{item}{right-text}</strong></dt><dd>add/alter <em>menuitem</em> with <strong>right-text</strong> as the right-justified
+	text and as the associated <em>action</em></dd>
+    <dt><strong><em>/path/</em>{item}{rtext} action</strong></dt><dd>add/alter <em>menuitem</em> with an associated <em>action</em> and with
+	<strong>rtext</strong> as the right-justified text.</dd>
+</dl>
+<dl>
+    <dt>Special characters in <em>action</em> must be backslash-escaped:</dt><dd><strong>\a \b \E \e \n \r \t \octal</strong></dd>
+    <dt>or in control-character notation:</dt><dd><strong>^@, ^A .. ^Z .. ^_, ^?</strong></dd>
+</dl>
+<p>To send a string starting with a <strong>NUL</strong> (<strong>^@</strong>) character to the program,
+start <em>action</em> with a pair of <strong>NUL</strong> characters (<strong>^@^@</strong>), the first of
+which will be stripped off and the balance directed to the program.
+Otherwise if <em>action</em> begins with <strong>NUL</strong> followed by non-<strong>NUL</strong>
+characters, the leading <strong>NUL</strong> is stripped off and the balance is sent back
+to rxvt.
+<p>As a convenience for the many Emacs-type editors, <em>action</em> may start
+with <strong>M-</strong> (eg, <strong>M-$</strong> is equivalent to <strong>\E$</strong>) and a <strong>CR</strong> will be
+appended if missed from <strong>M-x</strong> commands.
+<p>As a convenience for issuing XTerm <strong>ESC]</strong> sequences from a menubar
+(or quick arrow), a <strong>BEL</strong> (<strong>^G</strong>) will be appended if needed.
+<p><dl>
+    <dt>For example,</dt><dd><strong>M-xapropos</strong> is equivalent to <strong>\Exapropos\r</strong></dd>
+    <dt>and</dt><dd><strong>\E]10;mona;100</strong> is equivalent to <strong>\E]10;mona;100\a</strong></dd>
+</dl>
+<p>The option <strong>{<em>right-rtext</em>}</strong> will be right-justified.  In the absence of
+a specified action, this text will be used as the <em>action</em> as well.
+<p><dl>
+    <dt>For example,</dt><dd><strong>/File/{Open}{^X^F}</strong> is equivalent to <strong>/File/{Open}{^X^F} ^X^F</strong></dd>
+</dl>
+<p>The left label <em>is</em> necessary, since it's used for matching,
+but implicitly hiding the left label (by using same name for both left
+and right labels), or explicitly hiding the left label (by preceeding
+it with a dot), makes it possible to have right-justified text only.
+<dl>
+    <dt>For example,</dt><dd><strong>/File/{Open}{Open} Open-File-Action</strong></dd>
+    <dt>or hiding it</dt><dd><strong>/File/{.anylabel}{Open} Open-File-Action</strong></dd>
+</dl>
+<p><a name="menuBarRemove"></a>
+<h3>Removing menus</h3><p>
+<p><dl>
+    <dt><strong>-/*<br>-<em>/path</em>menu<br>-<em>/path</em>{item}<br>-<em>/path</em>{-}</strong></dt><dd>remove all menus from the menuBar, the same as <strong>[clear]</strong><br>remove menu <br>remove item <br>remove separator</dd>
+    <dt><strong>-/path/menu/*</strong></dt><dd>remove all items, separators and submenus from menu</dd>
+</dl>
+<p><a name="menuBarArrows"></a>
+<h3>Quick Arrows</h3><p>
+<p>The menus also provide a hook for <em>quick arrows</em> to provide easier user
+access. If nothing has been explicitly set, the default is to emulate the
+curror keys. The syntax permits each arrow to be altered individually or
+all four at once without re-entering their common beginning/end text. For
+example, to explicitly associate cursor actions with the arrows, any of
+the following forms could be used:
+<p><dl>
+    <dt><strong>&lt;r&gt;<em>Right</em><br>&lt;l&gt;<em>Left</em><br>&lt;u&gt;<em>Up</em><br>&lt;d&gt;<em>Down</em></strong></dt><dd>Define actions for the respective arrow buttons</dd>
+    <dt><strong>&lt;b&gt;<em>Begin</em><br>&lt;e&gt;<em>End</em></strong></dt><dd>Define common beginning/end parts for <em>quick arrows</em> which used
+	in conjunction with the above &lt;r&gt; &lt;l&gt; &lt;u&gt; &lt;d&gt; constructs</dd>
+</dl>
+<p><dl>
+    <dt>For example, define arrows individually,</dt><dd><strong>&lt;u&gt;\E[A <br>&lt;d&gt;\E[B <br>&lt;r&gt;\E[C <br>&lt;l&gt;\E[D</strong></dd>
+    <dt>or all at once</dt><dd><strong>&lt;u&gt;\E[A&lt;d&gt;\E[B&lt;r&gt;\E[C&lt;l&gt;\E[D</strong></dd>
+    <dt>or more compactly (factoring out common parts)</dt><dd><strong>&lt;b&gt;\E[&lt;u&gt;A&lt;d&gt;B&lt;r&gt;C&lt;l&gt;D</strong></dd>
+</dl>
+<p><a name="menuBarSummary"></a>
+<h3>Command Summary</h3><p>
+<p>A short summary of the most <em>common</em> commands:
+<p><dl>
+    <dt>[menu:name]</dt><dd>use an existing named menuBar or start a new one</dd>
+    <dt>[menu]</dt><dd>use the current menuBar</dd>
+    <dt>[title:string]</dt><dd>set menuBar title</dd>
+    <dt>[done]</dt><dd>set menu access to readonly and, if reading from a file, signal EOF</dd>
+    <dt>[done:name]</dt><dd>if reading from a file using [read:file;name] signal EOF</dd>
+    <dt>[rm:name]<br>[rm] [rm:]<br>[rm*] [rm:*]</dt><dd>remove named, current, or all menuBar(s)</dd>
+    <dt>[swap]</dt><dd>swap top two menuBars</dd>
+    <dt>[prev]<br>[next]</dt><dd>access the previous/next menuBar</dd>
+    <dt>[show]<br>[hide]</dt><dd>map/unmap menuBar</dd>
+    <dt>[pixmap;file]<br>[pixmap;file;scaling]</dt><dd>set a background pixmap</dd>
+    <dt>[read:file]<br>[read:file;name]</dt><dd>read in a menu from a file</dd>
+    <dt>[dump]</dt><dd>dump out all menuBars to /tmp/rxvt-PID</dd>
+    <dt>/</dt><dd>access menuBar top level</dd>
+    <dt>./<br>../<br>../../</dt><dd>access current or parent menu level</dd>
+    <dt>/path/menu</dt><dd>add/access menu</dd>
+    <dt>/path/{-}</dt><dd>add separator</dd>
+    <dt>/path/{item}{rtext} action</dt><dd>add/alter menu item<br>({rtext} and/or action, may be omitted)</dd>
+    <dt>-/*</dt><dd>remove all menus from the menuBar</dd>
+    <dt>-/path/menu</dt><dd>remove menu items, separators and submenus from menu</dd>
+    <dt>-/path/menu</dt><dd>remove menu</dd>
+    <dt>-/path/{item}</dt><dd>remove item</dd>
+    <dt>-/path/{-}</dt><dd>remove separator</dd>
+    <dt>&lt;b&gt;Begin&lt;r&gt;Right&lt;l&gt;Left&lt;u&gt;Up&lt;d&gt;Down&lt;e&gt;End</dt><dd>menu quick arrows</dd>
+</dl>
+
+<a href="rxvtRef.html#toc">Top</a>
+<p><hr><p><br>
+<a name="rxvtRef-xpm.yo"></a>
+    
+<a name="XPM"></a>
+<h2>XPM</h2>
+    
+<p>For the XPM XTerm escape sequence <strong><code>ESC ] 20; Pt BEL</code></strong> then value of
+<strong><code>Pt</code></strong> can be the name of the background pixmap followed by a sequence of
+scaling/positioning commands separated by semi-colons. The scaling/positioning
+commands are as follows:
+<p><dl>
+    <dt>query scale/position</dt><dd><strong>?</strong></dd>
+<p><dt>change scale and position</dt><dd><strong>WxH+X+Y</strong><br><strong>WxH+X</strong> (== <strong>WxH+X+X</strong>)<br><strong>WxH</strong> (same as <strong>WxH+50+50</strong>)<br><strong>W+X+Y</strong> (same as <strong>WxW+X+Y</strong>)<br><strong>W+X</strong> (same as <strong>WxW+X+X</strong>)<br><strong>W</strong> (same as <strong>WxW+50+50</strong>)</dd>
+<p><dt>change position (absolute)</dt><dd><strong>=+X+Y</strong><br><strong>=+X</strong> (same as <strong>=+X+Y</strong>)</dd>
+<p><dt>change position (relative)</dt><dd><strong>+X+Y</strong><br><strong>+X</strong> (same as <strong>+X+Y</strong>)</dd>
+<p><dt>rescale (relative)</dt><dd><strong>Wx0</strong> -&gt; <strong>W *= (W/100)</strong><br><strong>0xH</strong> -&gt; <strong>H *= (H/100)</strong></dd>
+</dl>
+<p>For example:
+<p><dl>
+    <dt><strong>\E]20;funky\a</strong></dt><dd>load <strong>funky.xpm</strong> as a tiled image</dd>
+<p><dt><strong>\E]20;mona;100\a</strong></dt><dd>load <strong>mona.xpm</strong> with a scaling of 100%</dd>
+<p><dt><strong>\E]20;;200;?\a</strong></dt><dd>rescale the current pixmap to 200% and display the image geometry in the title</dd>
+</dl>
+
+<a href="rxvtRef.html#toc">Top</a>
+<p><hr><p><br>
+<a name="rxvtRef-mouse.yo"></a>
+    
+<a name="Mouse"></a>
+<h2>Mouse Reporting</h2>
+    
+<p><dl>
+    <dt><strong><code>ESC [ M &lt;b&gt; &lt;x&gt; &lt;y&gt;</code></strong></dt><dd>report mouse position</dd>
+</dl>
+The lower 2 bits of <strong><code>&lt;b&gt;</code></strong> indicate the button:
+<dl>
+    <dt>Button = <strong><code>(&lt;b&gt; - SPACE) &amp; 3</code></strong></dt><dd>0 = Button1 pressed <br>1 = Button2 pressed <br>2 = Button3 pressed <br>3 = button released (X11 mouse report)</dd>
+</dl>
+<p>The upper bits of <strong><code>&lt;b&gt;</code></strong> indicate the modifiers when the button was
+pressed and are added together (X11 mouse report only):
+<p><dl>
+    <dt>State = <strong><code>(&lt;b&gt; - SPACE) &amp; 60</code></strong></dt><dd>4 = Shift <br>8 = Meta <br>16 = Control <br>32 = Double Click <em>(Rxvt extension)</em> <br>Col = <strong><code>&lt;x&gt; - SPACE</code></strong> <br>Row = <strong><code>&lt;y&gt; - SPACE</code></strong></dd>
+</dl>
+
+<a href="rxvtRef.html#toc">Top</a>
+<p><hr><p><br>
+<a name="rxvtRef-graphics.yo"></a>
+    
+<a name="Graphics"></a>
+<h2>Special Graphics Mode</h2>
+    
+<p>Add more documentation here, <em>if anyone actually cares.</em>
+<p><dl>
+    <dt><strong><code>ESC G Q</code></strong></dt><dd>query if graphics are available <br>returns: <strong><code>ESC G 0</code></strong> no graphics available <br>returns: <strong><code>ESC G 1</code></strong> graphics available (colour only)</dd>
+<p><dt><strong><code>ESC G W &lt;;x&gt;;&lt;y&gt;;&lt;w&gt;;&lt;h&gt;:</code></strong></dt><dd>create window</dd>
+<p><dt><strong><code>ESC G C &lt;id&gt;</code></strong></dt><dd>clear window</dd>
+<p><dt><strong><code>ESC G G &lt;it&gt;:</code></strong></dt><dd>query window <br>returns: <strong><code>ESC G &lt;id&gt; &lt;x&gt; &lt;y&gt; &lt;w&gt; &lt;h&gt; &lt;fw&gt; &lt;fh&gt; &lt;nw&gt; &lt;nh&gt;</code></strong></dd>
+<p><dt><strong><code>ESC G L &lt;id&gt;</code><br><code>ESC G P &lt;id&gt;</code><br><code>ESC G F &lt;id&gt;</code></strong></dt><dd>start point <br>start line <br>start fill</dd>
+<p><dt><strong><code>;&lt;x&gt;;&lt;y&gt;</code></strong></dt><dd>extend point/line/fill</dd>
+<p><dt><strong><code>ESC G T &lt;id&gt;;&lt;x&gt;;&lt;y&gt;;&lt;mode&gt;;&lt;len&gt;:&lt;text&gt;</code></strong></dt><dd>place text</dd>
+</dl>
+
+<a href="rxvtRef.html#toc">Top</a>
+<p><hr><p><br>
+<a name="rxvtRef-keycodes.yo"></a>
+    
+<a name="KeyCodes"></a>
+<h2>Key Codes</h2>
+    
+<p>Note: <strong>Shift</strong> + <strong>F1</strong>-<strong>F10</strong> generates <strong>F11</strong>-<strong>F20</strong>
+<p>For the keypad, use <strong>Shift</strong> to temporarily override Application-Keypad
+setting use <strong>Num_Lock</strong> to toggle Application-Keypad setting if <strong>Num_Lock</strong>
+is off, <a href="rxvtRef.html#ESCequals">escape sequences</a> toggle Application-Keypad setting.
+Also note that values of <strong>Home</strong>, <strong>End</strong>, <strong>Delete</strong> may have been compiled
+differently on your system.
+<p>
+<table border=1>
+<tr> 
+<td>                 </td> 
+<td> <strong>Normal</strong>      </td> 
+<td> <strong>Shift</strong>       </td> 
+<td> <strong>Control</strong>     </td> 
+<td> <strong>Ctrl+Shift</strong> <br></td> 
+ 
+</tr>
+<tr> 
+<td> Tab             </td> 
+<td> ^I          </td> 
+<td> ESC [ Z     </td> 
+<td> ^I          </td> 
+<td> ESC [ Z <br></td> 
+ 
+</tr>
+<tr> 
+<td> BackSpace       </td> 
+<td> ^H          </td> 
+<td> ^?          </td> 
+<td> ^?          </td> 
+<td> ^? <br></td> 
+ 
+</tr>
+<tr> 
+<td> Find            </td> 
+<td> ESC [ 1 ~   </td> 
+<td> ESC [ 1 $   </td> 
+<td> ESC [ 1 ^   </td> 
+<td> ESC [ 1 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> Insert          </td> 
+<td> ESC [ 2 ~   </td> 
+<td> <em>paste</em>       </td> 
+<td> ESC [ 2 ^   </td> 
+<td> ESC [ 2 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> Execute         </td> 
+<td> ESC [ 3 ~   </td> 
+<td> ESC [ 3 $   </td> 
+<td> ESC [ 3 ^   </td> 
+<td> ESC [ 3 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> Select          </td> 
+<td> ESC [ 4 ~   </td> 
+<td> ESC [ 4 $   </td> 
+<td> ESC [ 4 ^   </td> 
+<td> ESC [ 4 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> Prior           </td> 
+<td> ESC [ 5 ~   </td> 
+<td> <em>scroll-up</em>   </td> 
+<td> ESC [ 5 ^   </td> 
+<td> ESC [ 5 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> Next            </td> 
+<td> ESC [ 6 ~   </td> 
+<td> <em>scroll-down</em> </td> 
+<td> ESC [ 6 ^   </td> 
+<td> ESC [ 6 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> Home            </td> 
+<td> ESC [ 7 ~   </td> 
+<td> ESC [ 7 $   </td> 
+<td> ESC [ 7 ^   </td> 
+<td> ESC [ 7 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> End             </td> 
+<td> ESC [ 8 ~   </td> 
+<td> ESC [ 8 $   </td> 
+<td> ESC [ 8 ^   </td> 
+<td> ESC [ 8 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> Delete          </td> 
+<td> ESC [ 3 ~   </td> 
+<td> ESC [ 3 $   </td> 
+<td> ESC [ 3 ^   </td> 
+<td> ESC [ 3 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F1              </td> 
+<td> ESC [ 11 ~  </td> 
+<td> ESC [ 23 ~  </td> 
+<td> ESC [ 11 ^  </td> 
+<td> ESC [ 23 ^ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F2              </td> 
+<td> ESC [ 12 ~  </td> 
+<td> ESC [ 24 ~  </td> 
+<td> ESC [ 12 ^  </td> 
+<td> ESC [ 24 ^ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F3              </td> 
+<td> ESC [ 13 ~  </td> 
+<td> ESC [ 25 ~  </td> 
+<td> ESC [ 13 ^  </td> 
+<td> ESC [ 25 ^ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F4              </td> 
+<td> ESC [ 14 ~  </td> 
+<td> ESC [ 26 ~  </td> 
+<td> ESC [ 14 ^  </td> 
+<td> ESC [ 26 ^ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F5              </td> 
+<td> ESC [ 15 ~  </td> 
+<td> ESC [ 28 ~  </td> 
+<td> ESC [ 15 ^  </td> 
+<td> ESC [ 28 ^ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F6              </td> 
+<td> ESC [ 17 ~  </td> 
+<td> ESC [ 29 ~  </td> 
+<td> ESC [ 17 ^  </td> 
+<td> ESC [ 29 ^ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F7              </td> 
+<td> ESC [ 18 ~  </td> 
+<td> ESC [ 31 ~  </td> 
+<td> ESC [ 18 ^  </td> 
+<td> ESC [ 31 ^ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F8              </td> 
+<td> ESC [ 19 ~  </td> 
+<td> ESC [ 32 ~  </td> 
+<td> ESC [ 19 ^  </td> 
+<td> ESC [ 32 ^ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F9              </td> 
+<td> ESC [ 20 ~  </td> 
+<td> ESC [ 33 ~  </td> 
+<td> ESC [ 20 ^  </td> 
+<td> ESC [ 33 ^ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F10             </td> 
+<td> ESC [ 21 ~  </td> 
+<td> ESC [ 34 ~  </td> 
+<td> ESC [ 21 ^  </td> 
+<td> ESC [ 34 ^ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F11             </td> 
+<td> ESC [ 23 ~  </td> 
+<td> ESC [ 23 $  </td> 
+<td> ESC [ 23 ^  </td> 
+<td> ESC [ 23 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F12             </td> 
+<td> ESC [ 24 ~  </td> 
+<td> ESC [ 24 $  </td> 
+<td> ESC [ 24 ^  </td> 
+<td> ESC [ 24 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F13             </td> 
+<td> ESC [ 25 ~  </td> 
+<td> ESC [ 25 $  </td> 
+<td> ESC [ 25 ^  </td> 
+<td> ESC [ 25 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F14             </td> 
+<td> ESC [ 26 ~  </td> 
+<td> ESC [ 26 $  </td> 
+<td> ESC [ 26 ^  </td> 
+<td> ESC [ 26 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F15 (Help)      </td> 
+<td> ESC [ 28 ~  </td> 
+<td> ESC [ 28 $  </td> 
+<td> ESC [ 28 ^  </td> 
+<td> ESC [ 28 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F16 (Menu)      </td> 
+<td> ESC [ 29 ~  </td> 
+<td> ESC [ 29 $  </td> 
+<td> ESC [ 29 ^  </td> 
+<td> ESC [ 29 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F17             </td> 
+<td> ESC [ 31 ~  </td> 
+<td> ESC [ 31 $  </td> 
+<td> ESC [ 31 ^  </td> 
+<td> ESC [ 31 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F18             </td> 
+<td> ESC [ 32 ~  </td> 
+<td> ESC [ 32 $  </td> 
+<td> ESC [ 32 ^  </td> 
+<td> ESC [ 32 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F19             </td> 
+<td> ESC [ 33 ~  </td> 
+<td> ESC [ 33 $  </td> 
+<td> ESC [ 33 ^  </td> 
+<td> ESC [ 33 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td> F20             </td> 
+<td> ESC [ 34 ~  </td> 
+<td> ESC [ 34 $  </td> 
+<td> ESC [ 34 ^  </td> 
+<td> ESC [ 34 @ <br></td> 
+ 
+</tr>
+<tr> 
+<td>                 </td> 
+<td>             </td> 
+<td>             </td> 
+<td>             </td> 
+<td> <strong>Application</strong> <br></td> 
+ 
+</tr>
+<tr> 
+<td> Up              </td> 
+<td> ESC [ A     </td> 
+<td> ESC [ a     </td> 
+<td> ESC O a     </td> 
+<td> ESC O A <br></td> 
+ 
+</tr>
+<tr> 
+<td> Down            </td> 
+<td> ESC [ B     </td> 
+<td> ESC [ b     </td> 
+<td> ESC O b     </td> 
+<td> ESC O B <br></td> 
+ 
+</tr>
+<tr> 
+<td> Right           </td> 
+<td> ESC [ C     </td> 
+<td> ESC [ c     </td> 
+<td> ESC O c     </td> 
+<td> ESC O C <br></td> 
+ 
+</tr>
+<tr> 
+<td> Left            </td> 
+<td> ESC [ D     </td> 
+<td> ESC [ d     </td> 
+<td> ESC O d     </td> 
+<td> ESC O D <br></td> 
+ 
+</tr>
+<tr> 
+<td> KP_Enter        </td> 
+<td> ^M          </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O M <br></td> 
+ 
+</tr>
+<tr> 
+<td> KP_F1           </td> 
+<td> ESC O P     </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O P <br></td> 
+ 
+</tr>
+<tr> 
+<td> KP_F2           </td> 
+<td> ESC O Q     </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O Q <br></td> 
+ 
+</tr>
+<tr> 
+<td> KP_F3           </td> 
+<td> ESC O R     </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O R <br></td> 
+ 
+</tr>
+<tr> 
+<td> KP_F4           </td> 
+<td> ESC O S     </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O S <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_Multiply  </td> 
+<td> *           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O j <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_Add       </td> 
+<td> +           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O k <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_Separator </td> 
+<td> ,           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O l <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_Subtract  </td> 
+<td> -           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O m <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_Decimal   </td> 
+<td> .           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O n <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_Divide    </td> 
+<td> /           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O o <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_0         </td> 
+<td> 0           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O p <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_1         </td> 
+<td> 1           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O q <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_2         </td> 
+<td> 2           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O r <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_3         </td> 
+<td> 3           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O s <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_4         </td> 
+<td> 4           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O t <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_5         </td> 
+<td> 5           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O u <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_6         </td> 
+<td> 6           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O v <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_7         </td> 
+<td> 7           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O w <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_8         </td> 
+<td> 8           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O x <br></td> 
+ 
+</tr>
+<tr> 
+<td> XK_KP_9         </td> 
+<td> 9           </td> 
+<td>             </td> 
+<td>             </td> 
+<td> ESC O y <br></td> 
+ 
+</tr>
+</table>   
+
+<a href="rxvtRef.html#toc">Top</a>
+</body>
+</html>
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/rxvtRef-toc.html work/main.d/rxvt-2.6.4/doc/rxvtRef-toc.html
--- tmp/rxvt-2.6.4/doc/rxvtRef-toc.html	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/rxvtRef-toc.html	2000-07-20 23:03:33.000000000 -0300
@@ -0,0 +1,33 @@
+<HTML>
+<HEAD>
+<TITLE>rxvtRef TOC</TITLE>
+</HEAD>
+<BASE TARGET="main">
+<BODY BGCOLOR="#FFFFFF">
+<CENTER>
+<HR>
+<STRONG>
+<A HREF="rxvt.html">Man Page</A></B>
+<HR>
+<A HREF="rxvtRef.html#Top">Reference</A>
+</STRONG>
+<A HREF="rxvtRef.html#Definitions">Definitions</A><BR>
+<A HREF="rxvtRef.html#Values">Values</A><BR>
+<A HREF="rxvtRef.html#Sequences">Escape</A><BR>
+<A HREF="rxvtRef.html#CSI">CSI</A><BR>
+<A HREF="rxvtRef.html#PrivateModes">DEC</A><BR>
+<A HREF="rxvtRef.html#XTerm">XTerm</A><BR>
+<A HREF="rxvtRef.html#menuBar">menuBar</A><BR>
+<A HREF="rxvtRef.html#XPM">XPM</A><BR>
+<A HREF="rxvtRef.html#Mouse">Mouse</A><BR>
+<A HREF="rxvtRef.html#Graphics">Graphics</A><BR>
+<A HREF="rxvtRef.html#KeyCodes">KeyCodes</A><BR>
+<HR>
+<STRONG>
+<A HREF="http://www.rxvt.org/">Rxvt Home</A><BR>
+<A HREF="http://www.rxvt.org/screenshots.html">Screenshots</A>
+</STRONG>
+<HR>
+</CENTER>
+</BODY>
+</HTML>
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/rxvtRef.txt work/main.d/rxvt-2.6.4/doc/rxvtRef.txt
--- tmp/rxvt-2.6.4/doc/rxvtRef.txt	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/rxvtRef.txt	2001-11-01 21:33:21.000000000 -0300
@@ -0,0 +1,890 @@
+
+TITLE INFORMATION: Rxvt Technical Reference 
+AUTHOR INFORMATION: Geoff Wing (gcw@pobox.com) 
+DATE INFORMATION: 18 April 1998 
+
+    o Definitions
+    o Values
+    o Escape Sequences
+    o CSI (Code Sequence Introducer) Sequences
+    o DEC Private Modes
+    o XTerm Escape Sequences
+    o menuBar
+    o XPM
+    o Mouse Reporting
+    o Special Graphics Mode
+    o Key Codes
+
+Reworked from XTerm documentation and other sources
+
+Definitions
+
+    o c
+        The literal character c.
+
+    o C
+        A single (required) character.
+
+    o Ps
+        A single (usually optional) numeric parameter, composed of one or
+	more digits.
+
+    o Pm
+        A multiple numeric parameter composed of any number of single numeric
+	parameters, separated by ; character(s).
+
+    o Pt
+        A text parameter composed of printable characters.
+
+Top
+
+Values
+
+    o ENQ
+        Enquiry (Ctrl-E) = Send Device Attributes (DA) 
+        request attributes from terminal == ESC[Psc
+
+    o BEL
+        Bell (Ctrl-G)
+
+    o BS
+        Backspace (Ctrl-H)
+
+    o TAB
+        Horizontal Tab (HT) (Ctrl-I)
+
+    o LF
+        Line Feed or New Line (NL) (Ctrl-J)
+
+    o VT
+        Vertical Tab (Ctrl-K) same as LF
+
+    o FF
+        Form Feed or New Page (NP) (Ctrl-L) same as LF
+
+    o CR
+        Carriage Return (Ctrl-M)
+
+    o SO
+        Shift Out (Ctrl-N), invokes the G1 character set. 
+        Switch to Alternate Character Set
+
+    o SI
+        Shift In (Ctrl-O), invokes the G0 character set (the default) 
+        Switch to Standard Character Set
+
+    o SPC
+        Space Character
+
+Top
+
+Escape Sequences
+
+    o ESC # 8
+        DEC Screen Alignment Test (DECALN)
+
+    o ESC 7
+      ESC 8
+        Save Cursor (SC)
+        Restore Cursor
+
+    o ESC =
+      ESC >
+        Application Keypad (SMKX) == ESC[?66h
+        Normal Keypad (RMKX) == ESC[?66l
+    Note: If the numeric keypad is activated, eg, Num_Lock has been
+    pressed, numbers or control functions are generated by the numeric keypad
+    (see Key Codes)
+
+    o ESC D
+        Index (IND)
+
+    o ESC E
+        Next Line (NEL)
+
+    o ESC H
+        Tab Set (HTS)
+
+    o ESC M
+        Reverse Index (RI)
+
+    o ESC N
+        Single Shift Select of G2 Character Set (SS2): affects next character
+	only unimplemented
+
+    o ESC O
+        Single Shift Select of G3 Character Set (SS3): affects next character
+	only unimplemented
+
+    o ESC Z
+        Obsolete form of ESC[c 
+        returns: ESC[?1;2C rxvt compile-time option
+
+    o ESC c
+        Full reset (RIS)
+
+    o ESC n
+        Invoke the G2 Character Set (LS2)
+
+    o ESC o
+        Invoke the G3 Character Set (LS3)
+
+    o ESC ( C
+      ESC ) C
+      ESC * C
+      ESC + C
+      ESC $ C
+        Designate G0 Character Set (ISO 2022)
+        Designate G1 Character Set (ISO 2022)
+        Designate G2 Character Set (ISO 2022)
+        Designate G3 Character Set (ISO 2022)
+        Designate Kanji Character Set 
+        where C is 
+         C = 0  DEC Special Character and Line Drawing Set 
+         C = A  United Kingdom (UK) 
+         C = B  United States (USASCII) 
+         C = <  Multinational character set unimplemented 
+         C = 5  Finnish character set unimplemented 
+         C = C  Finnish character set unimplemented 
+         C = K  German character set unimplemented 
+
+Top
+
+CSI (Code Sequence Introducer) Sequences
+
+    o ESC [ Ps @
+        Insert Ps (Blank) Character(s) [default: 1] (ICH)
+
+    o ESC [ Ps A
+        Cursor Up Ps Times [default: 1] (CUU)
+
+    o ESC [ Ps B
+        Cursor Down Ps Times [default: 1] (CUD)
+    o ESC [ Ps C
+        Cursor Forward Ps Times [default: 1] (CUF)
+
+    o ESC [ Ps D
+        Cursor Backward Ps Times [default: 1] (CUB)
+
+    o ESC [ Ps E
+        Cursor Down Ps Times [default: 1] and to first column
+
+    o ESC [ Ps F
+        Cursor Up Ps Times [default: 1] and to first column
+
+    o ESC [ Ps G
+        Cursor to Column Ps (HPA)
+
+    o ESC [ Ps;Ps H
+        Cursor Position [row;column] [default: 1;1] (CUP)
+
+    o ESC [ Ps I
+        Move forward Ps tab stops [default: 1]
+
+    o ESC [ Ps J
+        Erase in Display (ED) 
+         Ps = 0  Clear Below (default) 
+         Ps = 1  Clear Above 
+         Ps = 2  Clear All 
+
+    o ESC [ Ps K
+        Erase in Line (EL) 
+         Ps = 0  Clear to Right (default) 
+         Ps = 1  Clear to Left 
+         Ps = 2  Clear All 
+
+    o ESC [ Ps L
+        Insert Ps Line(s) [default: 1] (IL)
+
+    o ESC [ Ps M
+        Delete Ps Line(s) [default: 1] (DL)
+
+    o ESC [ Ps P
+        Delete Ps Character(s) [default: 1] (DCH)
+
+    o ESC [ Ps;Ps;Ps;Ps;Ps T
+        Initiate hilite mouse tracking.  unimplemented
+	Parameters are [func;startx;starty;firstrow;lastrow].
+
+    o ESC [ Ps W
+        Tabulator functions 
+         Ps = 0  Tab Set (HTS) 
+         Ps = 2  Tab Clear (TBC), Clear Current Column (default) 
+         Ps = 5  Tab Clear (TBC), Clear All 
+
+    o ESC [ Ps X
+        Erase Ps Character(s) [default: 1] (ECH)
+
+    o ESC [ Ps Z
+        Move backward Ps [default: 1] tab stops
+
+    o ESC [ Ps '
+        == ESC [ Ps G
+
+    o ESC [ Ps a
+        == ESC [ Ps C
+
+    o ESC [ Ps c
+        Send Device Attributes (DA)
+        Ps = 0 (or omitted) : request attributes from terminal 
+        returns: ESC[?1;2c (``I am a VT100 with Advanced Video
+	Option'')
+
+    o ESC [ Ps d
+        Cursor to Line Ps (VPA)
+
+    o ESC [ Ps e
+        == ESC [ Ps A
+
+    o ESC [ Ps;Ps f
+        Horizontal and Vertical Position [row;column] (HVP) [default: 1;1]
+
+    o ESC [ Ps g
+        Tab Clear (TBC) 
+         Ps = 0  Clear Current Column (default) 
+         Ps = 3  Clear All (TBC) 
+
+    o ESC [ Ps i
+        Printing 
+         Ps = 4  disable transparent print mode (MC4) 
+         Ps = 5  enable transparent print mode (MC5) unimplemented 
+
+    o ESC [ Pm h
+      ESC [ Pm l
+        Set Mode (SM) 
+        Reset Mode (RM)
+	    o Ps = 4
+                 h  Insert Mode (SMIR) 
+                 l  Replace Mode (RMIR) 
+
+	    o Ps = 20 unimplemented
+                 h  Automatic Newline (LNM) 
+                 h  Normal Linefeed (LNM) 
+
+    o ESC [ Pm m
+        Character Attributes (SGR) 
+         Ps = 0  Normal (default) 
+         Ps = 1 / 22  On / Off Bold (bright fg) 
+         Ps = 4 / 24  On / Off Underline 
+         Ps = 5 / 25  On / Off Blink (bright bg) 
+         Ps = 7 / 27  On / Off Inverse 
+         Ps = 30 / 40  fg/bg Black 
+         Ps = 31 / 41  fg/bg Red 
+         Ps = 32 / 42  fg/bg Green 
+         Ps = 33 / 43  fg/bg Yellow 
+         Ps = 34 / 44  fg/bg Blue 
+         Ps = 35 / 45  fg/bg Magenta 
+         Ps = 36 / 46  fg/bg Cyan 
+         Ps = 37 / 47  fg/bg White 
+         Ps = 39 / 49  fg/bg Default 
+
+    o ESC [ Ps n
+        Device Status Report (DSR) 
+         Ps = 5  Status Report ESC [ 0 n (``OK'') 
+         Ps = 6  Report Cursor Position (CPR) [row;column] as ESC [ r ; c R 
+         Ps = 7  Request Display Name 
+         Ps = 8  Request Version Number (place in window title) 
+
+    o ESC [ Ps;Ps r
+        Set Scrolling Region [top;bottom] 
+        [default: full size of window] (CSR)
+
+    o ESC [ Ps x
+        Request Terminal Parameters (DECREQTPARM)
+
+Top
+
+DEC Private Modes
+
+    o ESC [ ? Pm h
+        DEC Private Mode Set (DECSET)
+
+    o ESC [ ? Pm l
+        DEC Private Mode Reset (DECRST)
+
+    o ESC [ ? Pm r
+        Restore previously saved DEC Private Mode Values.
+
+    o ESC [ ? Pm s
+        Save DEC Private Mode Values.
+
+    o ESC [ ? Pm t
+        Toggle DEC Private Mode Values (rxvt extension).
+    where 
+
+        o Ps = 1 (DECCKM)
+             h  Application Cursor Keys 
+             l  Normal Cursor Keys 
+
+        o Ps = 2 unimplemented
+             h  Designate USASCII for character sets G0-G3. 
+
+        o Ps = 3
+             h  132 Column Mode (DECCOLM) 
+             l  80 Column Mode (DECCOLM) 
+
+        o Ps = 4 unimplemented
+             h  Smooth (Slow) Scroll (DECSCLM) 
+             l  Jump (Fast) Scroll (DECSCLM) 
+
+        o Ps = 5
+             h  Reverse Video (DECSCNM) 
+             l  Normal Video (DECSCNM) 
+
+        o Ps = 6
+             h  Origin Mode (DECOM) 
+             l  Normal Cursor Mode (DECOM) 
+
+        o Ps = 7
+             h  Wraparound Mode (DECAWM) 
+             l  No Wraparound Mode (DECAWM) 
+
+        o Ps = 8 unimplemented
+             h  Auto-repeat Keys (DECARM) 
+             l  No Auto-repeat Keys (DECARM) 
+
+        o Ps = 9 X10 XTerm mouse reporting
+             h  Send Mouse X & Y on button press. 
+             l  No mouse reporting. 
+
+        o Ps = 10 (rxvt)
+             h  menuBar visible 
+             l  menuBar invisible 
+
+        o Ps = 25
+             h  Visible cursor {cnorm/cvvis} 
+             l  Invisible cursor {civis} 
+
+        o Ps = 30
+             h  scrollBar visisble 
+             l  scrollBar invisisble 
+
+        o Ps = 35 (rxvt)
+             h  Allow XTerm Shift+key sequences 
+             l  Disallow XTerm Shift+key sequences 
+
+        o Ps = 38 unimplemented
+            Enter Tektronix Mode (DECTEK)
+        o Ps = 40
+             h  Allow 80/132 Mode 
+             l  Disallow 80/132 Mode 
+
+        o Ps = 44 unimplemented
+             h  Turn On Margin Bell 
+             l  Turn Off Margin Bell 
+
+        o Ps = 45 unimplemented
+             h  Reverse-wraparound Mode 
+             l  No Reverse-wraparound Mode 
+
+        o Ps = 46 unimplemented
+
+        o Ps = 47 unimplemented
+             h  Use Alternate Screen Buffer 
+             l  Use Normal Screen Buffer 
+
+        o Ps = 66
+             h  Application Keypad (DECPAM) == ESC = 
+             l  Normal Keypad (DECPNM) == ESC > 
+
+        o Ps = 67
+             h  Backspace key sends BS (DECBKM) 
+             l  Backspace key sends DEL 
+
+        o Ps = 1000 (X11 XTerm mouse reporting)
+             h  Send Mouse X & Y on button press and release. 
+             l  No mouse reporting. 
+
+        o Ps = 1001 (X11 XTerm mouse tracking) unimplemented
+             h  Use Hilite Mouse Tracking. 
+             l  No mouse reporting. 
+
+        o Ps = 1010
+             h  Don't scroll to bottom on TTY output 
+             l  Scroll to bottom on TTY output 
+
+        o Ps = 1011
+             h  Scroll to bottom when a key is pressed 
+             l  Don't scroll to bottom when a key is pressed 
+
+Top
+
+XTerm Escape Sequences
+
+    o ESC ] Ps;Pt BEL
+        Set XTerm Parameters 
+         Ps = 0  Change Icon Name and Window Title to Pt 
+         Ps = 1  Change Icon Name to Pt 
+         Ps = 2  Change Window Title to Pt 
+         Ps = 10  menuBar command Pt rxvt compile-time option 
+         Ps = 20  Change default background pixmap to Pt 
+         Ps = 39  Change default foreground colour to Pt rxvt compile-time option 
+         Ps = 46  Change Log File to Pt unimplemented 
+         Ps = 49  Change default background colour to Pt rxvt compile-time option 
+         Ps = 50  Set Font to Pt, with the following special values of Pt (rxvt) 
+        #+n change up n font(s) 
+        #-n change down n font(s) 
+        if n is missing of 0, a value of 1 is used 
+        empty change to font0 
+        n change to font n 
+
+Top
+
+menuBar
+
+The exact syntax used is almost solidified. 
+In the menus, DON'T try to use menuBar commands that add or remove a
+menuBar.
+
+Note that in all of the commands, the /path/ cannot be omitted:
+use ./ to specify a menu relative to the current menu.
+
+Overview of menuBar operation
+
+For the menuBar XTerm escape sequence ESC ] 10; Pt BEL, the
+syntax of Pt can be used for a variety of tasks:
+
+    o Commands
+    o Adding and accessing menus
+    o Removing menus
+    o Quick Arrows
+    o Command Summary
+
+At the top level is the current menuBar which is a member of a circular
+linked-list of other such menuBars.
+
+The menuBar acts as a parent for the various drop-down menus, which in turn,
+may have labels, separator lines, menuItems and subMenus.
+
+The menuItems are the useful bits: you can use them to mimic keyboard input
+or even to send text or escape sequences back to rxvt.
+
+The menuBar syntax is intended to provide a simple yet robust method of
+constructing and manipulating menus and navigating through the menuBars.
+
+The first step is to use the tag [menu:name] which creates the
+menuBar called name and allows access.
+You may now add or remove menus,
+subMenus, and menuItems. Finally, use the tag [done] to set the menuBar
+access as readonly to prevent accidental corruption of the menus.
+To re-access the current menuBar for alterations, use the tag [menu],
+make the alterations and then use [done]
+
+Commands
+
+    o [menu:name]
+        access the named menuBar for creation or alteration. If a new menuBar
+	is created, it is called name (max of 15 chars) and the current
+	menuBar is pushed onto the stack
+
+    o [menu]
+        access the current menuBar for alteration
+
+    o [title:string]
+        set the current menuBar's title to string, which may contain the
+	following format specifiers: 
+        %% : literal % character 
+        %n : rxvt name (as per the -name command-line option) 
+        %v : rxvt version
+
+    o [done]
+        set menuBar access as readonly. 
+        End-of-file tag for [read:file] operations.
+
+    o [read:file]
+        read menu commands directly from file (extension ".menu" will be
+	appended if required.) Start reading at a line with [menu] or
+	[menu:name and continuing until [done] is encountered.
+
+	Blank and comment lines (starting with #) are ignored.
+	Actually, since any invalid menu commands are also ignored, almost
+	anything could be construed as a comment line, but this may be
+	tightened up in the future ... so don't count on it!.
+
+    o [read:file;name]
+        The same as [read:file], but start reading at a line with
+	[menu:name] and continuing until [done:name] or
+	[done] is encountered.
+
+    o [dump]
+        dump all menuBars to the file /tmp/rxvt-PID in a format suitable
+	for later rereading.
+
+    o [rm:name]
+      [rm] [rm:]
+      [rm*] [rm:*]
+        remove the named menuBar 
+        remove the current menuBar 
+        remove all menuBars
+
+    o [swap]
+        swap the top two menuBars
+
+    o [prev]
+      [next]
+        access the previous or next menuBar
+
+    o [show]
+      [hide]
+        control display of the menuBar ... just like
+	ESC[?10 h/l
+
+    o [pixmap:name]
+      [pixmap:name;scaling]
+        set the background pixmap globally ... just like
+	ESC]20; Pt BEL
+
+	A Future implementation may make this local to the menubar
+
+    o [:command:]
+        ignore the menu readonly status and issue a command to
+	Add/Modify or Remove a menu or
+	menuitem or change the Quick Arrows; a useful
+	shortcut for setting the quick arrows from a menuBar.
+
+Adding and accessing menus
+
+The following commands may also be + prefixed.
+
+    o /
+      ./
+      ../
+      ../../
+        access menuBar top level 
+        access current menu level 
+        access parent menu (1 level up) 
+        access parent menu (multiple levels up)
+    o /path/menu
+        add/access menu
+    o /path/menu/*
+        add/access menu and clear it if it exists
+    o /path/{-}
+        add separator
+    o /path/{item}
+        add item as a label
+    o /path/{item} action
+        add/alter menuitem with an associated action
+    o /path/{item}{right-text}
+        add/alter menuitem with right-text as the right-justified
+	text and as the associated action
+    o /path/{item}{rtext} action
+        add/alter menuitem with an associated action and with
+	rtext as the right-justified text.
+
+    o Special characters in action must be backslash-escaped:
+        \a \b \E \e \n \r \t \octal
+    o or in control-character notation:
+        ^@, ^A .. ^Z .. ^_, ^?
+
+To send a string starting with a NUL (^@) character to the program,
+start action with a pair of NUL characters (^@^@), the first of
+which will be stripped off and the balance directed to the program.
+Otherwise if action begins with NUL followed by non-NUL
+characters, the leading NUL is stripped off and the balance is sent back
+to rxvt.
+
+As a convenience for the many Emacs-type editors, action may start
+with M- (eg, M-$ is equivalent to \E$) and a CR will be
+appended if missed from M-x commands.
+
+As a convenience for issuing XTerm ESC] sequences from a menubar
+(or quick arrow), a BEL (^G) will be appended if needed.
+
+    o For example,
+        M-xapropos is equivalent to \Exapropos\r
+    o and
+        \E]10;mona;100 is equivalent to \E]10;mona;100\a
+
+The option {right-rtext} will be right-justified.  In the absence of
+a specified action, this text will be used as the action as well.
+
+    o For example,
+        /File/{Open}{^X^F} is equivalent to /File/{Open}{^X^F} ^X^F
+
+The left label is necessary, since it's used for matching,
+but implicitly hiding the left label (by using same name for both left
+and right labels), or explicitly hiding the left label (by preceeding
+it with a dot), makes it possible to have right-justified text only.
+
+    o For example,
+        /File/{Open}{Open} Open-File-Action
+    o or hiding it
+        /File/{.anylabel}{Open} Open-File-Action
+
+Removing menus
+
+    o -/*
+      -/pathmenu
+      -/path{item}
+      -/path{-}
+        remove all menus from the menuBar, the same as [clear]
+        remove menu 
+        remove item 
+        remove separator
+    o -/path/menu/*
+        remove all items, separators and submenus from menu
+
+Quick Arrows
+
+The menus also provide a hook for quick arrows to provide easier user
+access. If nothing has been explicitly set, the default is to emulate the
+curror keys. The syntax permits each arrow to be altered individually or
+all four at once without re-entering their common beginning/end text. For
+example, to explicitly associate cursor actions with the arrows, any of
+the following forms could be used:
+
+    o <r>Right
+      <l>Left
+      <u>Up
+      <d>Down
+        Define actions for the respective arrow buttons
+    o <b>Begin
+      <e>End
+        Define common beginning/end parts for quick arrows which used
+	in conjunction with the above <r> <l> <u> <d> constructs
+
+    o For example, define arrows individually,
+        <u>\E[A 
+        <d>\E[B 
+        <r>\E[C 
+        <l>\E[D
+    o or all at once
+        <u>\E[A<d>\E[B<r>\E[C<l>\E[D
+    o or more compactly (factoring out common parts)
+        <b>\E[<u>A<d>B<r>C<l>D
+
+Command Summary
+
+A short summary of the most common commands:
+
+    o [menu:name]
+        use an existing named menuBar or start a new one
+    o [menu]
+        use the current menuBar
+    o [title:string]
+        set menuBar title
+    o [done]
+        set menu access to readonly and, if reading from a file, signal EOF
+    o [done:name]
+        if reading from a file using [read:file;name] signal EOF
+    o [rm:name]
+      [rm] [rm:]
+      [rm*] [rm:*]
+        remove named, current, or all menuBar(s)
+    o [swap]
+        swap top two menuBars
+    o [prev]
+      [next]
+        access the previous/next menuBar
+    o [show]
+      [hide]
+        map/unmap menuBar
+    o [pixmap;file]
+      [pixmap;file;scaling]
+        set a background pixmap
+    o [read:file]
+      [read:file;name]
+        read in a menu from a file
+    o [dump]
+        dump out all menuBars to /tmp/rxvt-PID
+    o /
+        access menuBar top level
+    o ./
+      ../
+      ../../
+        access current or parent menu level
+    o /path/menu
+        add/access menu
+    o /path/{-}
+        add separator
+    o /path/{item}{rtext} action
+        add/alter menu item
+        ({rtext} and/or action, may be omitted)
+    o -/*
+        remove all menus from the menuBar
+    o -/path/menu
+        remove menu items, separators and submenus from menu
+    o -/path/menu
+        remove menu
+    o -/path/{item}
+        remove item
+    o -/path/{-}
+        remove separator
+    o <b>Begin<r>Right<l>Left<u>Up<d>Down<e>End
+        menu quick arrows
+
+Top
+
+XPM
+
+For the XPM XTerm escape sequence ESC ] 20; Pt BEL then value of
+Pt can be the name of the background pixmap followed by a sequence of
+scaling/positioning commands separated by semi-colons. The scaling/positioning
+commands are as follows:
+
+    o query scale/position
+        ?
+
+    o change scale and position
+        WxH+X+Y
+        WxH+X (== WxH+X+X)
+        WxH (same as WxH+50+50)
+        W+X+Y (same as WxW+X+Y)
+        W+X (same as WxW+X+X)
+        W (same as WxW+50+50)
+
+    o change position (absolute)
+        =+X+Y
+        =+X (same as =+X+Y)
+
+    o change position (relative)
+        +X+Y
+        +X (same as +X+Y)
+
+    o rescale (relative)
+        Wx0 -> W *= (W/100)
+        0xH -> H *= (H/100)
+
+For example:
+
+    o \E]20;funky\a
+        load funky.xpm as a tiled image
+
+    o \E]20;mona;100\a
+        load mona.xpm with a scaling of 100%
+
+    o \E]20;;200;?\a
+        rescale the current pixmap to 200% and display the image geometry in the title
+
+Top
+
+Mouse Reporting
+
+    o ESC [ M <b> <x> <y>
+        report mouse position
+
+The lower 2 bits of <b> indicate the button:
+
+    o Button = (<b> - SPACE) & 3
+        0 = Button1 pressed 
+        1 = Button2 pressed 
+        2 = Button3 pressed 
+        3 = button released (X11 mouse report)
+
+The upper bits of <b> indicate the modifiers when the button was
+pressed and are added together (X11 mouse report only):
+
+    o State = (<b> - SPACE) & 60
+        4 = Shift 
+        8 = Meta 
+        16 = Control 
+        32 = Double Click (Rxvt extension) 
+        Col = <x> - SPACE 
+        Row = <y> - SPACE
+
+Top
+
+Special Graphics Mode
+
+Add more documentation here, if anyone actually cares.
+
+    o ESC G Q
+        query if graphics are available 
+        returns: ESC G 0 no graphics available 
+        returns: ESC G 1 graphics available (colour only)
+
+    o ESC G W <;x>;<y>;<w>;<h>:
+        create window
+
+    o ESC G C <id>
+        clear window
+
+    o ESC G G <it>:
+        query window 
+        returns: ESC G <id> <x> <y> <w> <h> <fw> <fh> <nw> <nh>
+
+    o ESC G L <id>
+      ESC G P <id>
+      ESC G F <id>
+        start point 
+        start line 
+        start fill
+
+    o ;<x>;<y>
+        extend point/line/fill
+
+    o ESC G T <id>;<x>;<y>;<mode>;<len>:<text>
+        place text
+
+Top
+
+Key Codes
+
+Note: Shift + F1-F10 generates F11-F20
+
+For the keypad, use Shift to temporarily override Application-Keypad
+setting use Num_Lock to toggle Application-Keypad setting if Num_Lock
+is off, escape sequences toggle Application-Keypad setting.
+Also note that values of Home, End, Delete may have been compiled
+differently on your system.
+
+                  Normal       Shift        Control      Ctrl+Shift 
+ Tab              ^I           ESC [ Z      ^I           ESC [ Z 
+ BackSpace        ^H           ^?           ^?           ^? 
+ Find             ESC [ 1 ~    ESC [ 1 $    ESC [ 1 ^    ESC [ 1 @ 
+ Insert           ESC [ 2 ~    paste        ESC [ 2 ^    ESC [ 2 @ 
+ Execute          ESC [ 3 ~    ESC [ 3 $    ESC [ 3 ^    ESC [ 3 @ 
+ Select           ESC [ 4 ~    ESC [ 4 $    ESC [ 4 ^    ESC [ 4 @ 
+ Prior            ESC [ 5 ~    scroll-up    ESC [ 5 ^    ESC [ 5 @ 
+ Next             ESC [ 6 ~    scroll-down  ESC [ 6 ^    ESC [ 6 @ 
+ Home             ESC [ 7 ~    ESC [ 7 $    ESC [ 7 ^    ESC [ 7 @ 
+ End              ESC [ 8 ~    ESC [ 8 $    ESC [ 8 ^    ESC [ 8 @ 
+ Delete           ESC [ 3 ~    ESC [ 3 $    ESC [ 3 ^    ESC [ 3 @ 
+ F1               ESC [ 11 ~   ESC [ 23 ~   ESC [ 11 ^   ESC [ 23 ^ 
+ F2               ESC [ 12 ~   ESC [ 24 ~   ESC [ 12 ^   ESC [ 24 ^ 
+ F3               ESC [ 13 ~   ESC [ 25 ~   ESC [ 13 ^   ESC [ 25 ^ 
+ F4               ESC [ 14 ~   ESC [ 26 ~   ESC [ 14 ^   ESC [ 26 ^ 
+ F5               ESC [ 15 ~   ESC [ 28 ~   ESC [ 15 ^   ESC [ 28 ^ 
+ F6               ESC [ 17 ~   ESC [ 29 ~   ESC [ 17 ^   ESC [ 29 ^ 
+ F7               ESC [ 18 ~   ESC [ 31 ~   ESC [ 18 ^   ESC [ 31 ^ 
+ F8               ESC [ 19 ~   ESC [ 32 ~   ESC [ 19 ^   ESC [ 32 ^ 
+ F9               ESC [ 20 ~   ESC [ 33 ~   ESC [ 20 ^   ESC [ 33 ^ 
+ F10              ESC [ 21 ~   ESC [ 34 ~   ESC [ 21 ^   ESC [ 34 ^ 
+ F11              ESC [ 23 ~   ESC [ 23 $   ESC [ 23 ^   ESC [ 23 @ 
+ F12              ESC [ 24 ~   ESC [ 24 $   ESC [ 24 ^   ESC [ 24 @ 
+ F13              ESC [ 25 ~   ESC [ 25 $   ESC [ 25 ^   ESC [ 25 @ 
+ F14              ESC [ 26 ~   ESC [ 26 $   ESC [ 26 ^   ESC [ 26 @ 
+ F15 (Help)       ESC [ 28 ~   ESC [ 28 $   ESC [ 28 ^   ESC [ 28 @ 
+ F16 (Menu)       ESC [ 29 ~   ESC [ 29 $   ESC [ 29 ^   ESC [ 29 @ 
+ F17              ESC [ 31 ~   ESC [ 31 $   ESC [ 31 ^   ESC [ 31 @ 
+ F18              ESC [ 32 ~   ESC [ 32 $   ESC [ 32 ^   ESC [ 32 @ 
+ F19              ESC [ 33 ~   ESC [ 33 $   ESC [ 33 ^   ESC [ 33 @ 
+ F20              ESC [ 34 ~   ESC [ 34 $   ESC [ 34 ^   ESC [ 34 @ 
+                                                         Application 
+ Up               ESC [ A      ESC [ a      ESC O a      ESC O A 
+ Down             ESC [ B      ESC [ b      ESC O b      ESC O B 
+ Right            ESC [ C      ESC [ c      ESC O c      ESC O C 
+ Left             ESC [ D      ESC [ d      ESC O d      ESC O D 
+ KP_Enter         ^M                                     ESC O M 
+ KP_F1            ESC O P                                ESC O P 
+ KP_F2            ESC O Q                                ESC O Q 
+ KP_F3            ESC O R                                ESC O R 
+ KP_F4            ESC O S                                ESC O S 
+ XK_KP_Multiply   *                                      ESC O j 
+ XK_KP_Add        +                                      ESC O k 
+ XK_KP_Separator  ,                                      ESC O l 
+ XK_KP_Subtract   -                                      ESC O m 
+ XK_KP_Decimal    .                                      ESC O n 
+ XK_KP_Divide     /                                      ESC O o 
+ XK_KP_0          0                                      ESC O p 
+ XK_KP_1          1                                      ESC O q 
+ XK_KP_2          2                                      ESC O r 
+ XK_KP_3          3                                      ESC O s 
+ XK_KP_4          4                                      ESC O t 
+ XK_KP_5          5                                      ESC O u 
+ XK_KP_6          6                                      ESC O v 
+ XK_KP_7          7                                      ESC O w 
+ XK_KP_8          8                                      ESC O x 
+ XK_KP_9          9                                      ESC O y 
+
+Top
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/rxvt.tbl work/main.d/rxvt-2.6.4/doc/rxvt.tbl
--- tmp/rxvt-2.6.4/doc/rxvt.tbl	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/rxvt.tbl	2001-11-01 21:31:49.000000000 -0300
@@ -0,0 +1,582 @@
+.TH "1" "RXVT" "02 NOVEMBER 2001" "X Version 11" "X Tools" 
+.SH "NAME" 
+rxvt (ouR XVT) \- a VT102 emulator for the X window system
+.PP 
+.SH "SYNOPSIS" 
+.PP 
+\fBrxvt\fP [options] [-e command [ args ]]
+.PP 
+.SH "DESCRIPTION" 
+.PP 
+\fBrxvt\fP, version \fB2\&.6\&.4\fP, is a colour vt102 terminal emulator
+intended as an \fIxterm\fP(1) replacement for users who do not require
+features such as Tektronix 4014 emulation and toolkit-style configurability\&.
+As a result, \fBrxvt\fP uses much less swap space -- a significant
+advantage on a machine serving many X sessions\&.
+.PP 
+.PP 
+.SH "OPTIONS" 
+.PP 
+The \fBrxvt\fP options (mostly a subset of \fIxterm\fP\'s) are listed below\&.
+In keeping with the smaller-is-better philosophy, options may be eliminated
+or default values chosen at compile-time, so options and defaults listed
+may not accurately reflect the version installed on your system\&.  
+`rxvt -h\' gives a list of major compile-time options on the usage line\&.
+Option descriptions may be prefixed with which compile option each is
+dependent upon\&.  e\&.g\&. `Compile \fIXIM\fP:\' requires \fIXIM\fP on the usage line\&.
+Note: `rxvt -help\' gives a list of all options compiled into your version\&.
+.PP 
+Note that \fBrxvt\fP permits the resource name to be used as a long-option
+(--/++ option) so the potential command-line options are far greater than
+those listed\&.
+For example: `rxvt --loginShell --color1 Orange\'\&.
+.PP 
+.IP "\fB-help\fP, \fB--help\fP" 
+Print out a message describing available options\&.
+.IP "\fB-display\fP \fIdisplayname\fP" 
+Attempt to open a window on the named X display (\fB-d\fP still
+respected)\&.  In the absence of this option, the display specified
+by the \fBDISPLAY\fP environment variable is used\&.
+.IP "\fB-geometry\fP \fIgeom\fP" 
+Window geometry (\fB-g\fP still respected);
+resource \fBgeometry\fP\&.
+.IP "\fB-rv\fP|\fB+rv\fP" 
+Turn on/off simulated reverse video;
+resource \fBreverseVideo\fP\&.
+.IP "\fB-ip\fP|\fB+ip\fP" 
+Turn on/off inheriting parent window\'s pixmap\&.  Alternative form
+is \fB-tr\fP;
+resource \fBinheritPixmap\fP\&.
+.IP "\fB-bg\fP \fIcolour\fP" 
+Window background colour;
+resource \fBbackground\fP\&.
+.IP "\fB-fg\fP \fIcolour\fP" 
+Window foreground colour;
+resource \fBforeground\fP\&.
+.IP "\fB-pixmap:\fP \fIfile[;geom]\fP" 
+Compile \fIXPM\fP: Specify XPM file for the background and also
+optionally specify its scaling with a geometry string\&.  Note you
+may need to add quotes to avoid special shell interpretation of
+the `;\' in the command-line;
+resource \fBbackgroundPixmap\fP\&.
+.IP "\fB-cr\fP \fIcolour\fP" 
+The cursor colour;
+resource \fBcursorColor\fP\&.
+.IP "\fB-pr\fP \fIcolour\fP" 
+The mouse pointer colour;
+resource \fBpointerColor\fP\&.
+.IP "\fB-bd\fP \fIcolour\fP" 
+The colour of the border between the xterm scrollbar and the text;
+resource \fBborderColor\fP\&.
+.IP "\fB-fn\fP \fIfontname\fP" 
+Main normal text font;
+resource \fBfont\fP\&.
+.IP "\fB-fb\fP \fIfontname\fP" 
+Main bold text font;
+resource \fBboldFont\fP\&.
+.IP "\fB-fm\fP \fIfontname\fP" 
+Main multicharacter font;
+resource \fBmfont\fP\&.
+.IP "\fB-km\fP \fImode\fP" 
+Multiple-character font-set encoding mode;
+\fBeucj\fP: EUC Japanese encoding\&.
+\fBsjis\fP: Shift JIS encoding;
+resource \fBmultichar_encoding\fP\&.
+.IP "\fB-grk\fP \fImode\fP" 
+Greek keyboard translation;
+\fBiso\fP: ISO-8859 mapping\&.
+\fBibm\fP: IBM-437 mapping;
+resource \fBgreek_keyboard\fP\&.
+.IP "\fB-name\fP \fIname\fP" 
+Specify the application name under which resources
+are to be obtained, rather than the default executable file name\&.
+Name should not contain `\&.\' or `*\' characters\&.
+Also sets the icon and title name\&.
+.IP "\fB-ls\fP|\fB+ls\fP" 
+Start as a login-shell/sub-shell;
+resource \fBloginShell\fP\&.
+.IP "\fB-ut\fP|\fB+ut\fP" 
+Compile \fIutmp\fP: Inhibit/enable writing a utmp entry;
+resource \fButmpInhibit\fP\&.
+.IP "\fB-vb\fP|\fB+vb\fP" 
+Turn on/off visual bell on receipt of a bell character;
+resource \fBvisualBell\fP\&.
+.IP "\fB-sb\fP|\fB+sb\fP" 
+Turn on/off scrollbar;
+resource \fBscrollBar\fP\&.
+.IP "\fB-si\fP|\fB+si\fP" 
+Turn on/off scroll-to-bottom on TTY output inhibit;
+resource \fBscrollTtyOutput\fP has opposite effect\&.
+.IP "\fB-sk\fP|\fB+sk\fP" 
+Turn on/off scroll-to-bottom on keypress;
+resource \fBscrollTtyKeypress\fP\&.
+.IP "\fB-sr\fP|\fB+sr\fP" 
+Put scrollbar on right/left;
+resource \fBscrollBar_right\fP\&.
+.IP "\fB-st\fP|\fB+st\fP" 
+Display normal (non XTerm/NeXT) scrollbar without/with a trough;
+resource \fBscrollBar_floating\fP\&.
+.IP "\fB-iconic\fP" 
+Start iconified, if the window manager supports that option\&.
+Alternative form is \fB-ic\fP\&.
+.IP "\fB-sl\fP \fInumber\fP" 
+Save \fInumber\fP lines in the scrollback buffer;
+resource \fBsaveLines\fP\&.
+.IP "\fB-tn\fP \fItermname\fP" 
+This option specifies the name of the terminal type to be set in the
+\fBTERM\fP environment variable\&. This terminal type must exist in the
+\fItermcap(5)\fP database and should have \fIli#\fP and \fIco#\fP entries;
+resource \fBtermName\fP\&.
+.IP "\fB-e\fP \fIcommand [arguments]\fP" 
+Run the command with its command-line arguments in the \fBrxvt\fP
+window; also sets the window title and icon name to be the basename
+of the program being executed if neither \fI-title\fP (\fI-T\fP) nor
+\fI-n\fP are given on the command line\&.  If this option is used, it
+must be the last on the command-line\&.  If there is no \fB-e\fP option
+then the default is to run the program specified by the \fBSHELL\fP
+environment variable or, failing that, \fIsh(1)\fP\&.
+.IP "\fB-title\fP \fItext\fP" 
+Window title (\fB-T\fP still respected); the default title is the
+basename of the program specified after the \fB-e\fP option, if
+any, otherwise the application name;
+resource \fBtitle\fP\&.
+.IP "\fB-n\fP \fItext\fP" 
+Icon name; the default name is the basename of the program specified
+after the \fB-e\fP option, if any, otherwise the application name;
+resource \fBiconName\fP\&.
+.IP "\fB-C\fP" 
+Capture system console messages\&.
+.IP "\fB-pt\fP \fIstyle\fP" 
+Compile \fIXIM\fP: input style for input method;
+\fBOverTheSpot\fP, \fBOffTheSpot\fP, \fBRoot\fP;
+resource \fBpreeditType\fP\&.
+.IP "\fB-im\fP \fItext\fP" 
+Compile \fIXIM\fP: input method name\&.
+resource \fBinputMethod\fP\&.
+.IP "\fB-mod\fP \fImodifier\fP" 
+Override detection of Meta modifier with specified key:
+\fBalt\fP, \fBmeta\fP, \fBhyper\fP, \fBsuper\fP, \fBmod1\fP, \fBmod2\fP, \fBmod3\fP,
+\fBmod4\fP, \fBmod5\fP;
+resource \fImodifier\fP\&.
+.IP "\fB-xrm\fP \fIresourcestring\fP" 
+No effect on rxvt\&.  Simply passes through an argument to be made
+available in the instance\'s argument list\&.  Appears in \fIWM_COMMAND\fP
+in some window managers\&.
+.SH "RESOURCES (available also as long-options)" 
+.PP 
+Note: `rxvt --help\' gives a list of all resources (long options) compiled
+into your version\&.
+If compiled with internal Xresources support (i\&.e\&. \fBrxvt -h\fP lists 
+\fB\&.Xdefaults\fP) then \fBrxvt\fP accepts application defaults set in
+XAPPLOADDIR/Rxvt (compile-time defined: usually
+\fB/usr/lib/X11/app-defaults/Rxvt\fP) and resources set in \fB~/\&.Xdefaults\fP,
+or \fB~/\&.Xresources\fP if \fB~/\&.Xdefaults\fP does not exist\&.  Note that when
+reading X resources, \fBrxvt\fP recognizes two class names: \fBXTerm\fP and
+\fBRxvt\fP\&.  The class name \fBXTerm\fP allows resources common to both
+\fBrxvt\fP and \fIxterm\fP to be easily configured, while the class name
+\fBRxvt\fP allows resources unique to \fBrxvt\fP, notably colours and
+key-handling, to be shared between different \fBrxvt\fP configurations\&. 
+If no resources are specified, suitable defaults will be used\&. 
+Command-line arguments can be used to override resource settings\&.  The
+following resources are allowed:
+.PP 
+.IP "\fBgeometry:\fP \fIgeom\fP" 
+Create the window with the specified X window geometry [default
+80x24];
+option \fB-geometry\fP\&.
+.IP "\fBbackground:\fP \fIcolour\fP" 
+Use the specified colour as the window\'s background colour [default
+White];
+option \fB-bg\fP\&.
+.IP "\fBforeground:\fP \fIcolour\fP" 
+Use the specified colour as the window\'s foreground colour [default
+Black];
+option \fB-fg\fP\&.
+.IP "\fBcolor\fP\fIn\fP\fB:\fP \fIcolour\fP" 
+Use the specified colour for the colour value \fIn\fP, where 0-7
+corresponds to low-intensity (normal) colours and 8-15 corresponds to
+high-intensity (bold = bright foreground, blink = bright
+background) colours\&.  The canonical names are as follows:
+0=black, 1=red, 2=green, 3=yellow, 4=blue, 5=magenta, 6=cyan, 7=white,
+but the actual colour names used are listed in the
+\fBCOLORS AND GRAPHICS\fP section\&.
+.IP "\fBcolorBD:\fP \fIcolour\fP" 
+Use the specified colour to display bold characters when the
+foreground colour is the default\&.
+.IP "\fBcolorUL:\fP \fIcolour\fP" 
+Use the specified colour to display underlined characters when the
+foreground colour is the default\&.
+.IP "\fBcursorColor:\fP \fIcolour\fP" 
+Use the specified colour for the cursor\&.  The default is to use the
+foreground colour;
+option \fB-cr\fP\&.
+.IP "\fBcursorColor2:\fP \fIcolour\fP" 
+Use the specified colour for the colour of the cursor text\&.  For this
+to take effect, \fBcursorColor\fP must also be specified\&.  The default
+is to use the background colour\&.
+.IP "\fBreverseVideo:\fP \fIboolean\fP" 
+\fBTrue\fP: simulate reverse video by foreground and background colours;
+option \fB-rv\fP,
+\fBFalse\fP: regular screen colours [default];
+option \fB+rv\fP\&.
+See note in \fBCOLORS AND GRAPHICS\fP section\&.
+.IP "\fBinheritPixmap:\fP \fIboolean\fP" 
+\fBTrue\fP: make the background inherit the parent windows\' pixmap,
+giving artificial transparency\&.
+\fBFalse\fP: do not inherit the parent windows\' pixmap\&.
+.IP "\fBscrollColor:\fP \fIcolour\fP" 
+Use the specified colour for the scrollbar [default #B2B2B2]\&.
+.IP "\fBtroughColor:\fP \fIcolour\fP" 
+Use the specified colour for the scrollbar\'s trough area [default
+#969696]\&.  Only relevant for normal (non XTerm/NeXT) scrollbar\&.
+.IP "\fBbackgroundPixmap:\fP \fIfile[;geom]\fP" 
+Use the specified XPM file (note the `\&.xpm\' extension is optional)
+for the background and also optionally specify its scaling with a
+geometry string \fBWxH+X+Y\fP, in which \fB"W" / "H"\fP specify the
+horizontal/vertical scale (percent) and \fB"X" / "Y"\fP locate the
+image centre (percent)\&.  A scale of 0 displays the image with tiling\&.
+A scale of 1 displays the image without any scaling\&.  A scale of 2 to
+9 specifies an integer number of images in that direction\&.  No image
+will be magnified beyond 10 times its original size\&.  The maximum
+permitted scale is 1000\&.  [default 0x0+50+50]
+.IP "\fBmenu:\fP \fIfile[;tag]\fP" 
+Read in the specified menu file (note the `\&.menu\' extension is
+optional) and also optionally specify a starting tag to find\&.  See
+the reference documentation for details on the syntax for the menuBar\&.
+.IP "\fBpath:\fP \fIpath\fP" 
+Specify the colon-delimited search path for finding files (XPM and
+menus), in addition to the paths specified by the \fBRXVTPATH\fP and
+\fBPATH\fP environment variables\&.
+.IP "\fBfont:\fP \fIfontname\fP" 
+Select the main text font used [default 7x14];
+option \fB-fn\fP\&.
+.IP "\fBfont\fP\fIn\fP\fB:\fP \fIfontname\fP" 
+Specify the alternative font \fIn\fP\&.  The default font values: 
+.br 
+.RS 
+.IP 
+.TS 
+tab(`); 
+l l .
+\fBfont\fP: `\ 7x14 
+\fBfont1\fP: `\ 6x10 
+\fBfont2\fP: `\ 6x13 
+\fBfont3\fP: `\ 8x13 
+\fBfont4\fP: `\ 9x15 
+.TE 
+.RE 
+.IP 
+.IP "\fBboldFont:\fP \fIfontname\fP" 
+Specify the name of the bold font to use if \fBcolorBD\fP has not been
+specified and it is not possible to map the default foreground colour
+to colour 8-15 [default NONE]\&.  This font must be the same height and
+width as the normal font;
+option \fB-fb\fP\&.
+.IP "\fBmfont:\fP \fIfontname\fP" 
+Select the main multiple-character text font used [default k14];
+option \fB-fk\fP\&.
+.IP "\fBmfont\fP\fIn\fP\fB:\fP \fIfontname\fP" 
+Specify the alternative multiple-character font \fIn\fP\&.  If compiled
+for multiple-character fonts, the Roman and multiple-character font
+sizes should match\&.
+.IP "\fBmultichar_encoding:\fP \fImode\fP" 
+Set the encoding mode to be used when multicharacter encoding is
+received;
+\fBeucj\fP: EUC Japanese encoding [default for Kanji]\&.
+\fBsjis\fP: Shift JIS encoding\&.
+\fBbig5\fP: BIG5 encoding\&.
+\fBgb\fP: GB encoding;
+option \fB-km\fP\&.
+.IP "\fBgreek_keyboard:\fP \fImode\fP" 
+Set the Greek keyboard translation mode to be used;
+\fBiso\fP: ISO-8859 mapping (elot-928) [default]\&.
+\fBibm\fP: IBM-437 mapping (DOS codepage 737);
+option \fB-grk\fP\&.
+Use \fBMode_switch\fP to toggle keyboard input\&.  For more details,
+see the distributed file \fBREADME\&.greek\fP\&.
+.IP "\fBselectstyle:\fP \fItext\fP" 
+Set mouse selection style to \fBold\fP which is 2\&.20, \fBoldword\fP which
+is xterm style with 2\&.20 old word selection, or anything else which
+gives xterm style selection\&.
+.IP "\fBtitle:\fP \fItext\fP" 
+Set window title string, the default title is the command-line
+specified after the \fB-e\fP option, if any, otherwise the application
+name;
+option \fB-title\fP\&.
+.IP "\fBiconName:\fP \fItext\fP" 
+Set the name used to label the window\'s icon or displayed in an icon
+manager window, it also sets the window\'s title unless it is
+explicitly set;
+option \fB-n\fP\&.
+.IP "\fBmapAlert:\fP \fIboolean\fP" 
+\fBTrue\fP: de-iconify (map) on receipt of a bell character\&.
+\fBFalse\fP: no de-iconify (map) on receipt of a bell character
+[default]\&.
+.IP "\fBvisualBell:\fP \fIboolean\fP" 
+\fBTrue\fP: use visual bell on receipt of a bell character;
+option \fB-vb\fP\&.
+\fBFalse\fP: no visual bell [default];
+option \fB+vb\fP\&.
+.IP "\fBloginShell:\fP \fIboolean\fP" 
+\fBTrue\fP: start as a login shell by prepending a `-\' to \fBargv[0]\fP
+of the shell;
+option \fB-ls\fP\&.
+\fBFalse\fP: start as a normal sub-shell [default];
+option \fB+ls\fP\&.
+.IP "\fButmpInhibit:\fP \fIboolean\fP" 
+\fBTrue\fP: inhibit writing record into the system log file \fButmp\fP;
+option \fB-ut\fP\&.
+\fBFalse\fP: write record into the system log file \fButmp\fP [default];
+option \fB+ut\fP\&.
+.IP "\fBprint-pipe:\fP \fIstring\fP" 
+Specify a command pipe for vt100 printer [default \fIlpr(1)\fP]\&.  Use
+\fBPrint\fP to initiate a screen dump to the printer and \fBCtrl-Print\fP
+or \fBShift-Print\fP to include the scrollback as well\&.
+.IP "\fBscrollBar:\fP \fIboolean\fP" 
+\fBTrue\fP: enable the scrollbar [default];
+option \fB-sb\fP\&.
+\fBFalse\fP: disable the scrollbar;
+option \fB+sb\fP\&.
+.IP "\fBscrollBar_right:\fP \fIboolean\fP" 
+\fBTrue\fP: place the scrollbar on the right of the window;
+option \fB-sr\fP\&.
+\fBFalse\fP: place the scrollbar on the left of the window;
+option \fB+sr\fP\&.
+.IP "\fBscrollBar_floating:\fP \fIboolean\fP" 
+\fBTrue\fP: display an rxvt scrollbar without a trough;
+option \fB-st\fP\&.
+\fBFalse\fP: display an rxvt scrollbar with a trough;
+option \fB+st\fP\&.
+.IP "\fBscrollTtyOutput:\fP \fIboolean\fP" 
+\fBTrue\fP: scroll to bottom when tty receives output;
+option(+si)\&.
+\fBFalse\fP: do not scroll to bottom when tty receives output;
+option(-si)\&.
+.IP "\fBscrollTtyKeypress:\fP \fIboolean\fP" 
+\fBTrue\fP: scroll to bottom when a non-special key is pressed\&.
+Special keys are those which are intercepted by rxvt for special
+handling and are not passed onto the shell;
+option(-sk)\&.
+\fBFalse\fP: do not scroll to bottom when a non-special key is pressed;
+option(+sk)\&.
+.IP "\fBsmallfont_key:\fP \fIkeysym\fP" 
+If enabled, use \fBAlt-\fP\fIkeysym\fP to toggle to a smaller font
+[default \fBAlt-<\fP]
+.IP "\fBbigfont_key:\fP \fIkeysym\fP" 
+If enabled, use \fBAlt-\fP\fIkeysym\fP to toggle to a bigger font
+[default \fBAlt->\fP]
+.IP "\fBsaveLines:\fP \fInumber\fP" 
+Save \fInumber\fP lines in the scrollback buffer [default 64];
+option \fB-sl\fP\&.
+.IP "\fBtermName:\fP \fItermname\fP" 
+Specifies the terminal type name to be set in the \fBTERM\fP
+environment variable;
+option \fB-tn\fP\&.
+.IP "\fBmeta8:\fP \fIboolean\fP" 
+\fBTrue\fP: handle Meta (Alt) + keypress to set the 8th bit\&.
+\fBFalse\fP: handle Meta (Alt) + keypress as an escape prefix [default]\&.
+.IP "\fBbackspacekey:\fP \fIstring\fP" 
+The string to send when the backspace key is pressed\&.  If set to
+\fBDEC\fP or unset it will send \fBDelete\fP (code 127) or, if shifted,
+\fBBackspace\fP (code 8) - which can be reversed with the appropriate
+DEC private mode escape sequence\&.
+.IP "\fBdeletekey:\fP \fIstring\fP" 
+The string to send when the delete key (not the keypad delete key) is
+pressed\&.  If unset it will send the sequence traditionally associated
+with the \fBExecute\fP key\&.
+.IP "\fBcutchars:\fP \fIstring\fP" 
+The characters used as delimiters for double-click word selection\&. 
+The built-in default: 
+.br 
+\fBBACKSLASH `"\'&()*,;<=>?@[]{|}\fP
+.IP "\fBpreeditType:\fP \fIstyle\fP" 
+\fBOverTheSpot\fP, \fBOffTheSpot\fP, \fBRoot\fP;
+option \fB-pt\fP\&.
+.IP "\fBinputMethod:\fP \fIname\fP" 
+\fIname\fP of inputMethod to use;
+option \fB-im\fP\&.
+.IP "\fBmodifier:\fP \fImodifier\fP" 
+Set the key to be interpreted as the Meta key to:
+\fBalt\fP, \fBmeta\fP, \fBhyper\fP, \fBsuper\fP, \fBmod1\fP, \fBmod2\fP, \fBmod3\fP,
+\fBmod4\fP, \fBmod5\fP;
+option \fB-mod\fP\&.
+.IP "\fBkeysym\&.\fP\fIsym\fP: \fIstring\fP" 
+Associate \fIstring\fP with keysym \fIsym\fP (\fB0xFF00 - 0xFFFF\fP)\&.  It
+may contain escape values (\ea: bell, \eb: backspace, \ee, \eE: escape,
+\en: newline, \er: return, \et: tab, \e000: octal number) or control
+characters (^?: delete, ^@: null, ^A \&.\&.\&.) and may enclosed with
+double quotes so that it can start or end with whitespace\&.  The
+intervening resource name \fBkeysym\&.\fP cannot be omitted\&.  This
+resource is only available when compiled with KEYSYM_RESOURCE\&.
+.SH "THE SCROLLBAR" 
+.PP 
+Lines of text that scroll off the top of the \fBrxvt\fP window (resource:
+\fBsaveLines\fP) and can be scrolled back using the scrollbar or by keystrokes\&. 
+The normal \fBrxvt\fP scrollbar has arrows and its behaviour is fairly
+intuitive\&.  The \fBxterm-scrollbar\fP is without arrows and its behaviour
+mimics that of \fIxterm\fP
+.PP 
+Scroll down with \fBButton1\fP (\fBxterm-scrollbar\fP) or \fBShift-Next\fP\&.
+Scroll up with \fBButton3\fP (\fBxterm-scrollbar\fP) or \fBShift-Prior\fP\&.
+Continuous scroll with \fBButton2\fP\&.
+.SH "MOUSE REPORTING" 
+.PP 
+To temporarily override mouse reporting, for either the scrollbar or the
+normal text selection/insertion, hold either the Shift or the Meta (Alt) key
+while performing the desired mouse action\&.
+.PP 
+If mouse reporting mode is active, the normal scrollbar actions are disabled
+-- on the assumption that we are using a fullscreen application\&.
+Instead, pressing Button1 and Button3 sends
+\fBESC[6~\fP (Next) and \fBESC[5~\fP (Prior), respectively\&.
+Similarly, clicking on the up and down arrows sends \fBESC[A\fP (Up) and
+\fBESC[B\fP (Down), respectively\&.
+.SH "TEXT SELECTION AND INSERTION" 
+.PP 
+The behaviour of text selection and insertion mechanism is similar to
+\fIxterm\fP(1)\&.
+.PP 
+.IP "\fBSelection\fP:" 
+Left click at the beginning of the region, drag to the end of the
+region and release; Right click to extend the marked region;
+Left double-click to select a word; Left triple-click to select
+the entire line\&.
+.IP 
+.IP "\fBInsertion\fP:" 
+Pressing and releasing the Middle mouse button (or \fBShift-Insert\fP)
+in an \fBrxvt\fP window causes the current text selection to be inserted
+as if it had been typed on the keyboard\&.
+.SH "CHANGING FONTS" 
+.PP 
+You can change fonts on-the-fly, which is to say cycle through the default
+font and others of various sizes, by using \fBShift-KP_Add\fP and
+\fBShift-KP_Subtract\fP\&.  Or, alternatively (if enabled) with
+\fBAlt->\fP and \fBAlt-<\fP, where the actual key
+can be selected using resources \fBsmallfont_key\fP/\fBbigfont_key\fP\&.
+.SH "LOGIN STAMP" 
+.PP 
+\fBrxvt\fP tries to write an entry into the \fIutmp\fP(5) file so that it can be
+seen via the \fIwho(1)\fP command, and can accept messages\&.  To allow this
+feature, \fBrxvt\fP must be installed setuid root on some systems\&.
+.SH "COLORS AND GRAPHICS" 
+.PP 
+If graphics support was enabled at compile-time, \fBrxvt\fP can be queried
+with ANSI escape sequences and can address individual pixels instead of
+text characters\&.  Note the graphics support is still considered beta code\&.
+.PP 
+In addition to the default foreground and background colours, \fBrxvt\fP
+can display up to 16 colours (8 ANSI colours plus high-intensity bold/blink
+versions of the same)\&.
+Here is a list of the colours with their \fBrgb\&.txt\fP names\&.
+.PP 
+.TS 
+tab(`); 
+l l l .
+\fBcolor0\fP `\ (black) `\ = Black 
+\fBcolor1\fP `\ (red) `\ = Red3 
+\fBcolor2\fP `\ (green) `\ = Green3 
+\fBcolor3\fP `\ (yellow) `\ = Yellow3 
+\fBcolor4\fP `\ (blue) `\ = Blue3 
+\fBcolor5\fP `\ (magenta) `\ = Magenta3 
+\fBcolor6\fP `\ (cyan) `\ = Cyan3 
+\fBcolor7\fP `\ (white) `\ = AntiqueWhite 
+\fBcolor8\fP `\ (bright black) `\ = Grey25 
+\fBcolor9\fP `\ (bright red) `\ = Red 
+\fBcolor10\fP `\ (bright green) `\ = Green 
+\fBcolor11\fP `\ (bright yellow) `\ = Yellow 
+\fBcolor12\fP `\ (bright blue) `\ = Blue 
+\fBcolor13\fP `\ (bright magenta) `\ = Magenta 
+\fBcolor14\fP `\ (bright cyan) `\ = Cyan 
+\fBcolor15\fP `\ (bright white) `\ = White 
+\fBforeground\fP `\  `\ = Black 
+\fBbackground\fP `\  `\ = White 
+.TE 
+.PP 
+It is also possible to specify the colour values of \fBforeground\fP,
+\fBbackground\fP, \fBcursorColor\fP, \fBcursorColor2\fP, \fBcolorBD\fP, \fBcolorUL\fP
+as a number 0-15, as a convenient shorthand to reference the colour name of
+color0-color15\&.
+.PP 
+Note that \fB-rv\fP (\fB"reverseVideo: True"\fP) simulates reverse video by
+always swapping the foreground/background colours\&.  This is in contrast to
+\fIxterm\fP(1) where the colours are only swapped if they have not otherwise been
+specified\&.
+For example,
+.PP 
+.IP "\fBrxvt -fg Black -bg White -rv\fP" 
+would yield White on Black, while on \fIxterm\fP(1) it would yield
+Black on White\&.
+.SH "ENVIRONMENT" 
+.PP 
+\fBrxvt\fP sets the environment variables \fBTERM\fP, \fBCOLORTERM\fP and
+\fBCOLORFGBG\fP\&.  The environment variable \fBWINDOWID\fP is set to the X window
+id number of the \fBrxvt\fP window and it also uses and sets the environment
+variable \fBDISPLAY\fP to specify which display terminal to use\&.  \fBrxvt\fP uses
+the environment variables \fBRXVTPATH\fP and \fBPATH\fP to find XPM files\&.
+.SH "FILES" 
+.PP 
+.IP "\fB/etc/utmp\fP" 
+System file for login records\&.
+.IP "\fB/usr/lib/X11/rgb\&.txt\fP" 
+Color names\&.
+.PP 
+.SH "SEE ALSO" 
+.PP 
+\fIxterm\fP(1), \fIsh\fP(1), \fIresize\fP(1), \fIX\fP(1), \fIpty\fP(4), \fItty\fP(4),
+\fIutmp\fP(5)
+.PP 
+See rxvtRef\&.html rxvtRef\&.txt for detailed information on recognized escape
+sequences and menuBar syntax, etc\&.
+.PP 
+.SH "BUGS" 
+.PP 
+Check the BUGS file for an up-to-date list\&.
+.PP 
+Cursor change support is not yet implemented\&.
+.PP 
+Click-and-drag doesn\'t work with X11 mouse report overriding\&.
+.PP 
+Graphics support is fairly crude\&.
+.PP 
+.SH "FTP LOCATION" 
+.PP 
+rxvt-2\&.6\&.4\&.tar\&.gz can be found at the following ftp sites
+ftp://ftp\&.rxvt\&.org/pub/rxvt
+.PP 
+.SH "CURRENT PROJECT COORDINATOR" 
+.PP 
+.IP "Project Coordinator" 
+Geoff Wing <gcw@rxvt\&.org>
+.br 
+.IP "Web page maintainter" 
+Oezguer Kesim <oec@rxvt\&.org>
+.br 
+<http://www\&.rxvt\&.org/>
+.br 
+.IP "Mailing list" 
+The Rxvt Workers <rxvt-workers@rxvt\&.org>
+mailing list has also been established for rxvt development, to
+subscribe, email to 
+<rxvt-workers-subscribe@rxvt\&.org>\&.
+There is also a mailing list for announcements of new releases of
+rxvt\&. To subscribe, email to
+<rxvt-announce-subscribe@rxvt\&.org>\&.
+.PP 
+.SH "AUTHORS" 
+.PP 
+.IP "John Bovey" 
+University of Kent, 1992, wrote the original Xvt\&.
+.IP "Rob Nation <nation@rocket\&.sanders\&.lockheed\&.com>" 
+very heavily modified Xvt and came up with Rxvt
+.IP "Angelo Haritsis <ah@doc\&.ic\&.ac\&.uk>" 
+wrote the Greek Keyboard Input
+.IP "mj olesen <olesen@me\&.QueensU\&.CA>" 
+Wrote the menu system\&. 
+.br 
+Project Coordinator (changes\&.txt 2\&.11 to 2\&.21)
+.IP "Oezguer Kesim <kesim@math\&.fu-berlin\&.de>" 
+Project Coordinator (changes\&.txt 2\&.21a to 2\&.4\&.5)
+.IP "Geoff Wing <gcw@pobox\&.com>" 
+Rewrote screen display and text selection routines\&. 
+.br 
+Project Coordinator (changes\&.txt 2\&.4\&.6 - )
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/TODO work/main.d/rxvt-2.6.4/doc/TODO
--- tmp/rxvt-2.6.4/doc/TODO	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/TODO	1999-05-05 19:06:28.000000000 -0300
@@ -0,0 +1,15 @@
+- Convert checks for char/short/int/long to Xmd.h defines?
+
+- Improve Documentation...
+
+- Multichar font (eg. Kanji) bold-overstrike pixel dropping support
+
+- Need font-check for multichar fonts (eg. Kanji).
+
+- Add Unicode support
+
+- Extend menu language / facility
+
+In progress:
+- Rewrite event-queue handling
+- Rewrite window creation/resizing routines
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/xterm.seq work/main.d/rxvt-2.6.4/doc/xterm.seq
--- tmp/rxvt-2.6.4/doc/xterm.seq	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/xterm.seq	1998-04-20 04:30:33.000000000 -0300
@@ -0,0 +1,305 @@
+                          Xterm Control Sequences
+
+                                 Edward Moy
+
+                     University of California, Berkeley
+
+                                 Revised by
+
+                               Stephen Gildea
+
+                                X Consortium
+
+Definitions
+
+c    The literal character c.
+
+C    A single (required) character.
+
+Ps   A single (usually optional) numeric parameter, composed of one of  more
+     digits.
+
+Pm   A multiple numeric parameter composed of any number of  single  numeric
+     parameters, separated by ;  character(s).
+
+Pt   A text parameter composed of printable characters.
+
+VT100 Mode
+
+	Most of these control sequences are standard VT102  control  sequences,  but
+	there  are  some  sequences  here  from  later DEC VT terminals, too.  VT102
+	features not supported are smooth scrolling, double size characters,  blink-
+	ing  characters,  and  VT52 mode.  There are additional control sequences to
+	provide xterm-dependent functions, like the scrollbar or window size.  Where
+	the  function  is  specified  by DEC or ISO 6429, the code assigned to it is
+	given in parentheses.  The escape codes to designate  and  invoke  character
+	sets  are specified by ISO 2022; see that document for a discussion of char-
+	acter sets.
+	BEL            Bell (Ctrl-G)
+	BS             Backspace (Ctrl-H)
+	TAB            Horizontal Tab (HT) (Ctrl-I)
+	LF             Line Feed or New Line (NL) (Ctrl-J)
+	VT             Vertical Tab (Ctrl-K) same as LF
+	FF             Form Feed or New Page (NP) (Ctrl-L) same as LF
+	CR             Carriage Return (Ctrl-M)
+	SO             Shift Out (Ctrl-N) ->  Switch  to  Alternate  Character  Set:
+	               invokes the G1 character set.
+	SI             Shift In  (Ctrl-O)  ->  Switch  to  Standard  Character  Set:
+	               invokes the G0 character set (the default).
+	ESC # 8        DEC Screen Alignment Test (DECALN)
+	ESC ( C        Designate G0 Character Set (ISO 2022)
+	                 C = 0  -> DEC Special Character and Line Drawing Set
+	                 C = A  -> United Kingdom (UK)
+	                 C = B  -> United States (USASCII)
+	ESC ) C        Designate G1 Character Set (ISO 2022)
+	                 C = 0  -> DEC Special Character and Line Drawing Set
+	                 C = A  -> United Kingdom (UK)
+	                 C = B  -> United States (USASCII)
+	ESC * C        Designate G2 Character Set (ISO 2022)
+	                 C = 0  -> DEC Special Character and Line Drawing Set
+	                 C = A  -> United Kingdom (UK)
+	                 C = B  -> United States (USASCII)
+	ESC + C        Designate G3 Character Set (ISO 2022)
+	                 C = 0  -> DEC Special Character and Line Drawing Set
+	                 C = A  -> United Kingdom (UK)
+	                 C = B  -> United States (USASCII)
+	ESC 7          Save Cursor (DECSC)
+	ESC 8          Restore Cursor (DECRC)
+	ESC =          Application Keypad (DECPAM)
+	ESC >          Normal Keypad (DECPNM)
+	ESC D          Index (IND)
+	ESC E          Next Line (NEL)
+	ESC F          Cursor to lower left corner of  screen  (if  enabled  by  the
+	               hpLowerleftBugCompat resource).
+	ESC H          Tab Set (HTS)
+	ESC M          Reverse Index (RI)
+	ESC N          Single Shift Select of G2 Character Set (SS2):  affects  next
+	               character only
+	ESC O          Single Shift Select of G3 Character Set (SS3):  affects  next
+	               character only
+	ESC P Pt ESC \ Device Control String (DCS)
+	                 xterm implements no DCS functions; Pt is ignored.  Pt  need
+	               not be printable characters.
+	ESC Z          Return Terminal ID (DECID).  Obsolete form of ESC [ c  (DA).
+	ESC [ Ps @     Insert Ps (Blank) Character(s) (default = 1) (ICH)
+	ESC [ Ps A     Cursor Up Ps Times (default = 1) (CUU)
+	ESC [ Ps B     Cursor Down Ps Times (default = 1) (CUD)
+	ESC [ Ps C     Cursor Forward Ps Times (default = 1) (CUF)
+	ESC [ Ps D     Cursor Backward Ps Times (default = 1) (CUB)
+	ESC [ Ps ; Ps H Cursor Position [row;column] (default = [1,1]) (CUP)
+	ESC [ Ps J     Erase in Display (ED)
+	                 Ps = 0  -> Clear Below (default)
+	                 Ps = 1  -> Clear Above
+	                 Ps = 2  -> Clear All
+	ESC [ Ps K     Erase in Line (EL)
+	                 Ps = 0  -> Clear to Right (default)
+	                 Ps = 1  -> Clear to Left
+	                 Ps = 2  -> Clear All
+	ESC [ Ps L     Insert Ps Line(s) (default = 1) (IL)
+	ESC [ Ps M     Delete Ps Line(s) (default = 1) (DL)
+	ESC [ Ps P     Delete Ps Character(s) (default = 1) (DCH)
+	ESC [ Ps ; Ps ; Ps ; Ps ; Ps T
+	               Initiate   hilite    mouse    tracking.     Parameters    are
+	               [func;startx;starty;firstrow;lastrow].  See the section Mouse
+	               Tracking.
+	ESC [ Ps c     Send Device Attributes (DA)
+	                 Ps = 0  or omitted -> request attributes from terminal
+	                 -> ESC [ ? 1 ; 2 c  (``I am a  VT100  with  Advanced  Video
+	               Option.'')
+	ESC [ Ps ; Ps f Horizontal and Vertical  Position  [row;column]  (default  =
+	               [1,1]) (HVP)
+	ESC [ Ps g     Tab Clear (TBC)
+	                 Ps = 0  -> Clear Current Column (default)
+	                 Ps = 3  -> Clear All
+	ESC [ Pm h     Set Mode (SM)
+	                 Ps = 4  -> Insert Mode (IRM)
+	                 Ps = 2 0  -> Automatic Newline (LNM)
+	ESC [ Pm l     Reset Mode (RM)
+	                 Ps = 4  -> Replace Mode (IRM)
+	                 Ps = 2 0  -> Normal Linefeed (LNM)
+	ESC [ Pm m     Character Attributes (SGR)
+	                 Ps = 0  -> Normal (default)
+	                 Ps = 1  -> Bold
+	                 Ps = 4  -> Underscore
+	                 Ps = 5  -> Blink (appears as Bold)
+	                 Ps = 7  -> Inverse
+	ESC [ Ps n     Device Status Report (DSR)
+	                 Ps = 5  -> Status Report ESC [ 0 n  (``OK'')
+	                 Ps = 6  -> Report Cursor Position (CPR) [row;column] as ESC
+	               [ r ; c R
+	ESC [ Ps ; Ps r Set Scrolling Region [top;bottom] (default =  full  size  of
+	               window) (DECSTBM)
+	ESC [ Ps x     Request Terminal Parameters (DECREQTPARM)
+	ESC [ ? Pm h   DEC Private Mode Set (DECSET)
+	                 Ps = 1  -> Application Cursor Keys (DECCKM)
+	                 Ps = 2  -> Designate USASCII for character sets G0-G3.  (In
+	               the  VT102,  this  selects  VT52  mode  (DECANM), which xterm
+	               doesn't support.)
+	                 Ps = 3  -> 132 Column Mode (DECCOLM)
+	                 Ps = 4  -> Smooth (Slow) Scroll (DECSCLM)
+	                 Ps = 5  -> Reverse Video (DECSCNM)
+	                 Ps = 6  -> Origin Mode (DECOM)
+	                 Ps = 7  -> Wraparound Mode (DECAWM)
+	                 Ps = 8  -> Auto-repeat Keys (DECARM)
+	                 Ps = 9  -> Send Mouse X & Y on button press.  See the  sec-
+	               tion Mouse Tracking.
+	                 Ps = 3 8  -> Enter Tektronix Mode (DECTEK)
+	                 Ps = 4 0  -> Allow 80 <--> 132 Mode
+	                 Ps = 4 1  -> more(1) fix (see curses resource)
+	                 Ps = 4 4  -> Turn On Margin Bell
+	                 Ps = 4 5  -> Reverse-wraparound Mode
+	                 Ps =  4  6   ->  Start  Logging  (normally  disabled  by  a
+	               compile-time option)
+	                 Ps = 4 7  -> Use Alternate Screen Buffer  (unless  disabled
+	               by the titeInhibit resource)
+	                 Ps = 1 0 0 0  -> Send Mouse X  &  Y  on  button  press  and
+	               release.  See the section Mouse Tracking.
+	                 Ps = 1 0 0 1  -> Use Hilite Mouse Tracking.  See  the  sec-
+	               tion Mouse Tracking.
+	ESC [ ? Pm l   DEC Private Mode Reset (DECRST)
+	                 Ps = 1  -> Normal Cursor Keys (DECCKM)
+	                 Ps = 3  -> 80 Column Mode (DECCOLM)
+	                 Ps = 4  -> Jump (Fast) Scroll (DECSCLM)
+	                 Ps = 5  -> Normal Video (DECSCNM)
+	                 Ps = 6  -> Normal Cursor Mode (DECOM)
+	                 Ps = 7  -> No Wraparound Mode (DECAWM)
+	                 Ps = 8  -> No Auto-repeat Keys (DECARM)
+	                 Ps = 9  -> Don't Send Mouse X & Y on button press
+	                 Ps = 4 0  -> Disallow 80 <--> 132 Mode
+	                 Ps = 4 1  -> No more(1) fix (see curses resource)
+	                 Ps = 4 4  -> Turn Off Margin Bell
+	                 Ps = 4 5  -> No Reverse-wraparound Mode
+	                 Ps = 4 6  -> Stop Logging (normally disabled by a  compile-
+	               time option)
+	                 Ps = 4 7  -> Use Normal Screen Buffer
+	                 Ps = 1 0 0 0  -> Don't Send Mouse X & Y on button press and
+	               release
+	                 Ps = 1 0 0 1  -> Don't Use Hilite Mouse Tracking
+	ESC [ ? Pm r   Restore DEC Private Mode Values.  The value of Ps  previously
+	               saved is restored.  Ps values are the same as for DECSET.
+	ESC [ ? Pm s   Save DEC Private Mode Values.  Ps values are the same as  for
+	               DECSET.
+	ESC ] Ps ; Pt BEL
+	               Set Text Parameters
+	                 Ps = 0  -> Change Icon Name and Window Title to Pt
+	                 Ps = 1  -> Change Icon Name to Pt
+	                 Ps = 2  -> Change Window Title to Pt
+	                 Ps = 4 6  -> Change Log File to Pt (normally disabled by  a
+	               compile-time option)
+	                 Ps = 5 0  -> Set Font to Pt
+	ESC ^ Pt ESC \ Privacy Message (PM)
+	                 xterm implements no PM functions; Pt is ignored.   Pt  need
+	               not be printable characters.
+	ESC _ Pt ESC \ Application Program Command (APC)
+	                 xterm implements no APC functions; Pt is ignored.  Pt  need
+	               not be printable characters.
+	ESC c          Full Reset (RIS)
+	ESC l          Memory Lock (per HP terminals).  Locks memory above the  cur-
+	               sor.
+	ESC m          Memory Unlock (per HP terminals)
+	ESC n          Invoke the G2 Character Set (LS2)
+	ESC o          Invoke the G3 Character Set (LS3)
+	ESC |          Invoke the G3 Character Set as GR  (LS3R).   Has  no  visible
+	               effect in xterm.
+	ESC }          Invoke the G2 Character Set as GR  (LS2R).   Has  no  visible
+	               effect in xterm.
+	ESC ~          Invoke the G1 Character Set as GR  (LS1R).   Has  no  visible
+	               effect in xterm.
+
+Mouse Tracking
+	The VT widget can be set to send the mouse position and other information on
+button  presses.   These modes are typically used by editors and other full-
+screen applications that want to make use of the mouse.
+	There are three mutually exclusive modes, each enabled (or  disabled)  by  a
+different  parameter  in the DECSET (or DECRST) escape sequence.  Parameters
+for all mouse tracking escape sequences generated by  xterm  encode  numeric
+parameters  in  a single character as value+040.  For example, !  is 1.  The
+screen coodinate system is 1-based.
+	X10 compatibility mode sends an escape sequence on button press encoding the
+location  and the mouse button pressed.  It is enabled by specifying parame-
+ter 9 to DECSET.  On button press, xterm sends ESC [  M  CbCxCy  (6  charac-
+ters).   Cb is button-1.  Cx and Cy are the x and y coordinates of the mouse
+when the button was pressed.
+	Normal tracking mode sends an escape  sequence  on  both  button  press  and
+release.   Modifier  information  is also sent.  It is enabled by specifying
+parameter 1000 to DECSET.  On button press or release, xterm sends ESC  [  M
+CbCxCy.   The  low two bits of Cb encode button information:  0=MB1 pressed,
+1=MB2 pressed, 2=MB3 pressed, 3=release.  The upper bits encode what  modif-
+iers were down when the button was pressed and are added together.  4=Shift,
+8=Meta, 16=Control.  Cx and Cy are the x and  y  coordinates  of  the  mouse
+event.  The upper left corner is (1,1).
+	Mouse hilite tracking notifies a program of a button press, receives a range
+of lines from the program, highlights the region covered by the mouse within
+that range until button release, and then  sends  the  program  the  release
+coordinates.   It  is enabled by specifying parameter 1001 to DECSET.  Warn-
+ing: use of this mode requires a cooperating program or it will hang  xterm.
+On  button  press, the same information as for normal tracking is generated;
+xterm then waits for the program to send mouse tracking information.  All  X
+events  are  ignored  until  the proper escape sequence is received from the
+pty:  ESC [ Ps ; Ps ; Ps ; Ps ; Ps T .  The  parameters  are  func,  startx,
+starty, firstrow, and lastrow.  func is non-zero to initiate hilite tracking
+and zero to abort.  startx and starty give the starting x and y location for
+the  highlighted  region.   The  ending  location tracks the mouse, but will
+never be above row firstrow and will always be above row lastrow.  (The  top
+of  the  screen  is  row 1.)  When the button is released, xterm reports the
+ending position one of two ways: if the start and end coordinates are  valid
+text  locations:  ESC [ t CxCy.  If either coordinate is past the end of the
+line:  ESC [ T CxCyCxCyCxCy.  The parameters are startx, starty, endx, endy,
+mousex,  and  mousey.   startx, starty, endx, and endy give the starting and
+ending character positions of the region.  mousex and mousey give the  loca-
+tion of the mouse at button up, which may not be over a character.
+
+Tektronix 4014 Mode
+	Most of these sequences  are  standard  Tektronix  4014  control  sequences.
+Graph  mode supports the 12-bit addressing of the Tektronix 4014.  The major
+features missing are the write-thru and defocused modes.  This document does
+not  describe  the commands used in the various Tektronix plotting modes but
+does describe the commands to switch modes.
+
+	BEL            Bell (Ctrl-G)
+	BS             Backspace (Ctrl-H)
+	TAB            Horizontal Tab (Ctrl-I)
+	LF             Line Feed or New Line (Ctrl-J)
+	VT             Cursor up (Ctrl-K)
+	FF             Form Feed or New Page (Ctrl-L)
+	CR             Carriage Return (Ctrl-M)
+	ESC ETX        Switch to VT100 Mode (ESC Ctrl-C)
+	ESC ENQ        Return Terminal Status (ESC Ctrl-E)
+	ESC FF         PAGE (Clear Screen) (ESC Ctrl-L)
+	ESC SO         Begin 4015 APL mode (ignored by xterm) (ESC Ctrl-N)
+	ESC SI         End 4015 APL mode (ignored by xterm) (ESC Ctrl-O)
+	ESC ETB        COPY (Save Tektronix  Codes  to  file  COPYyy-mm-dd.hh:mm:ss)
+	               (ESC Ctrl-W)
+	ESC CAN        Bypass Condition (ESC Ctrl-X)
+	ESC SUB        GIN mode (ESC Ctrl-Z)
+	ESC FS         Special Point Plot Mode (ESC Ctrl-\)
+	ESC 8          Select Large Character Set
+	ESC 9          Select #2 Character Set
+	ESC :          Select #3 Character Set
+	ESC ;          Select Small Character Set
+	ESC ] Ps ; Pt BEL
+	               Set Text Parameters of VT window
+	                 Ps = 0  -> Change Icon Name and Window Title to Pt
+	                 Ps = 1  -> Change Icon Name to Pt
+	                 Ps = 2  -> Change Window Title to Pt
+	                 Ps = 4 6  -> Change Log File to Pt (normally disabled by  a
+	               compile-time option)
+	ESC `          Normal Z Axis and Normal (solid) Vectors
+	ESC a          Normal Z Axis and Dotted Line Vectors
+	ESC b          Normal Z Axis and Dot-Dashed Vectors
+	ESC c          Normal Z Axis and Short-Dashed Vectors
+	ESC d          Normal Z Axis and Long-Dashed Vectors
+	ESC h          Defocused Z Axis and Normal (solid) Vectors
+	ESC i          Defocused Z Axis and Dotted Line Vectors
+	ESC j          Defocused Z Axis and Dot-Dashed Vectors
+	ESC k          Defocused Z Axis and Short-Dashed Vectors
+	ESC l          Defocused Z Axis and Long-Dashed Vectors
+	ESC p          Write-Thru Mode and Normal (solid) Vectors
+	ESC q          Write-Thru Mode and Dotted Line Vectors
+	ESC r          Write-Thru Mode and Dot-Dashed Vectors
+	ESC s          Write-Thru Mode and Short-Dashed Vectors
+	ESC t          Write-Thru Mode and Long-Dashed Vectors
+	FS             Point Plot Mode (Ctrl-\)
+	GS             Graph Mode (Ctrl-])
+	RS             Incremental Plot Mode (Ctrl-^)
+	US             Alpha Mode (Ctrl-_)
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/masonyodl.yo work/main.d/rxvt-2.6.4/doc/yodl/masonyodl.yo
--- tmp/rxvt-2.6.4/doc/yodl/masonyodl.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/masonyodl.yo	1998-04-20 04:24:20.000000000 -0300
@@ -0,0 +1,125 @@
+COMMENT(-- $Id: masonyodl.yo,v 1.2 1998/04/20 07:24:20 mason Exp $ --)
+COMMENT(-----------------------------------------------------------------------
+-- We want more functionality and some better layout
+-- proto changes:
+--     starttable(nColumns)(Alignment)(borderwidth)
+------------------------------------------------------------------------------)
+NEWCOUNTER(RRindentlevel)
+NEWCOUNTER(RRnl)
+SETCOUNTER(RRindentlevel)(0)
+\
+DEFINEMACRO(nltxt)(0)(\
+    IFZERO(RRnl)()( ADDTOCOUNTER(RRnl)(-1)nltxt()))
+\
+UNDEFINEMACRO(XXnl)
+DEFINEMACRO(XXnl)(0)(\
+    NOTRANS(
+)\
+    whentxt(SETCOUNTER(RRnl)(RRindentlevel)nltxt()))
+\
+DEFINEMACRO(P)(0)(\
+    SETCOUNTER(RRnl)(0)\
+    whenhtml(SETCOUNTER(RRnl)(1)htmlcommand(<p>))\
+    IFZERO(RRnl)(nl())())
+\
+UNDEFINEMACRO(starttable)
+DEFINEMACRO(starttable)(3)(\
+    SETCOUNTER(XXtablewidth)(ARG1)\
+    whenhtml(IFZERO(ARG3)(htmlcommand(<table>))\
+			 (htmlcommand(<table border=ARG3>))XXnl())\
+    whenlatex(latexcommand(\begin{tabular}{)ARG2+latexcommand(}))\
+    whenman(roffcmd(.TS)()()())\
+    whenman(IFZERO(ARG3)(roffcmd(tab(`);)()()())\
+			(roffcmd(allbox,tab(`);)()()()))\
+    whenman(ARG2 NOTRANS(.
+))\
+    whenms(roffcmd(.TS)()()())\
+    whenms(IFZERO(ARG3)(roffcmd(tab(`);)()()())\
+		       (roffcmd(allbox,tab(`);)()()()))\
+    whenms(ARG2+mscommand(.))\
+    SETCOUNTER(XXtablewidth)(ARG1)\
+    SETCOUNTER(XXparcounter)(0))
+COMMENT(        For HTML, we'll need <table>, for
+        LaTeX we'll need \begin{tabular}{alignment}. Also, we don't want
+        paragraph delimiters.)
+\
+UNDEFINEMACRO(cell)
+DEFINEMACRO(cell)(1)(\
+    ADDTOCOUNTER(XXtableline)(1)\
+    whenhtml(htmlcommand(<td>) ARG1 \
+             IFZERO(XXcellcounter)\
+                (htmlcommand(<br>))\
+                ()\
+             htmlcommand(</td>) XXnl())\
+    whenlatex(ARG1 \
+              IFZERO(XXcellcounter)\
+                ()(latexcommand( & )))\
+    whentxt( ARG1 )\
+    whenms( ARG1 )\
+             IFZERO(XXcellcounter)\
+                ()\
+                (mscommand(`\))\
+    whenman( ARG1 )\
+             IFZERO(XXcellcounter)\
+                ()\
+                (mancommand(`\))\
+    ADDTOCOUNTER(XXcellcounter)(-1))
+COMMENT(For HTML we need:
+<td> text </td>, so that's fairly easy. If we're already at the last
+cell, we need <td> text <br></td>.
+For LaTeX: we need text followed by &, unless
+        we're already at the last cell 'cuz in that case we need only text.
+        Also we need to decrement the cell counter..)
+\
+UNDEFINEMACRO(cells)
+DEFINEMACRO(cells)(2)(\
+    ADDTOCOUNTER(XXtableline)(ARG1)\
+    ADDTOCOUNTER(XXcellcounter)(-ARG1)\
+    ADDTOCOUNTER(XXcellcounter)(1)\
+    whenhtml(htmlcommand(<td colspan=ARG1 align=center>) ARG2 \
+             IFZERO(XXcellcounter)\
+                (htmlcommand(<br>))\
+                ()\
+             htmlcommand(</td>) XXnl())\
+    whenlatex(\
+    latexcommand(\multicolumn{)ARG1+latexcommand(}{c}{)ARG2+latexcommand(})\
+              IFZERO(XXcellcounter)\
+                ()(latexcommand( & )))\
+    whentxt( ARG1 )\
+    whenms( ARG1 )\
+             IFZERO(XXcellcounter)\
+                ()\
+                (mscommand(`\))\
+    whenman( ARG1 )\
+             IFZERO(XXcellcounter)\
+                ()\
+                (mancommand(`\))\
+    ADDTOCOUNTER(XXcellcounter)(-1))
+\
+DEFINEMACRO(indent)(1)(\
+    whenhtml(htmlcommand(<ul>)ARG1+htmlcommand(</ul>))\
+    whentxt(ADDTOCOUNTER(RRindentlevel)(4)ARG1+ADDTOCOUNTER(RRindentlevel)(-4))\
+    whenman(roffcmd(.RS)()()()roffcmd(.IP)()()()ARG1+roffcmd(.RE)()()())\
+    whenms())
+\
+DEFINEMACRO(startdl)(0)(\
+    whenhtml(htmlcommand(<dl>))\
+    whentxt(ADDTOCOUNTER(RRindentlevel)(4))\
+    whenman(startdit()))
+\
+DEFINEMACRO(enddl)(0)(\
+    whenhtml(htmlcommand(</dl>))\
+    whentxt(ADDTOCOUNTER(RRindentlevel)(-4))\
+    whenman(enddit()))
+\
+DEFINEMACRO(dl)(2)(\
+    whenhtml(htmlcommand(<dt>)ARG1+htmlcommand(</dt><dd>)\
+	     ARG2+htmlcommand(</dd>))\
+    whentxt(ADDTOCOUNTER(RRindentlevel)(2)dit(ARG1)\
+	    ADDTOCOUNTER(RRindentlevel)(2)nl()\
+	    ARG2+ADDTOCOUNTER(RRindentlevel)(-4))\
+    whenman(dit(ARG1)ARG2))
+\
+DEFINEMACRO(manpageauthors)(0)(\
+    manpagesection(AUTHORS)\
+    DEFINESYMBOL(XXmanpageAuthor))
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt-colours.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvt-colours.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvt-colours.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt-colours.yo	1998-04-20 04:24:21.000000000 -0300
@@ -0,0 +1,50 @@
+COMMENT(-- $Id: rxvt-colours.yo,v 1.2 1998/04/20 07:24:21 mason Exp $ --)
+COMMENT(----------------------------------------------------------------------)
+manpagesection(COLORS AND GRAPHICS)
+
+If graphics support was enabled at compile-time, bf(rxvt) can be queried
+with ANSI escape sequences and can address individual pixels instead of
+text characters.  Note the graphics support is still considered beta code.
+
+In addition to the default foreground and background colours, bf(rxvt)
+can display up to 16 colours (8 ANSI colours plus high-intensity bold/blink
+versions of the same).
+Here is a list of the colours with their bf(rgb.txt) names.
+
+starttable(3)(l l l)(0)\
+    row(cell(bf(color0))cell((black))cell(= Black))\
+    row(cell(bf(color1))cell((red))cell(= Red3))\
+    row(cell(bf(color2))cell((green))cell(= Green3))\
+    row(cell(bf(color3))cell((yellow))cell(= Yellow3))\
+    row(cell(bf(color4))cell((blue))cell(= Blue3))\
+    row(cell(bf(color5))cell((magenta))cell(= Magenta3))\
+    row(cell(bf(color6))cell((cyan))cell(= Cyan3))\
+    row(cell(bf(color7))cell((white))cell(= AntiqueWhite))\
+    row(cell(bf(color8))cell((bright black))cell(= Grey25))\
+    row(cell(bf(color9))cell((bright red))cell(= Red))\
+    row(cell(bf(color10))cell((bright green))cell(= Green))\
+    row(cell(bf(color11))cell((bright yellow))cell(= Yellow))\
+    row(cell(bf(color12))cell((bright blue))cell(= Blue))\
+    row(cell(bf(color13))cell((bright magenta))cell(= Magenta))\
+    row(cell(bf(color14))cell((bright cyan))cell(= Cyan))\
+    row(cell(bf(color15))cell((bright white))cell(= White))\
+    row(cell(bf(foreground))cell()cell(= Black))\
+    row(cell(bf(background))cell()cell(= White))\
+endtable()
+
+It is also possible to specify the colour values of bf(foreground),
+bf(background), bf(cursorColor), bf(cursorColor2), bf(colorBD), bf(colorUL)
+as a number 0-15, as a convenient shorthand to reference the colour name of
+color0-color15.
+
+Note that bf(-rv) (bf("reverseVideo: True")) simulates reverse video by
+always swapping the foreground/background colours.  This is in contrast to
+em(xterm)(1) where the colours are only swapped if they have not otherwise been
+specified.
+For example,
+
+startdit()
+   dit(bf(rxvt -fg Black -bg White -rv))
+	would yield White on Black, while on em(xterm)(1) it would yield
+	Black on White.
+enddit()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt-environment.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvt-environment.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvt-environment.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt-environment.yo	1998-04-20 04:24:21.000000000 -0300
@@ -0,0 +1,9 @@
+COMMENT(-- $Id: rxvt-environment.yo,v 1.2 1998/04/20 07:24:21 mason Exp $ --)
+COMMENT(----------------------------------------------------------------------)
+manpagesection(ENVIRONMENT)
+
+bf(rxvt) sets the environment variables bf(TERM), bf(COLORTERM) and
+bf(COLORFGBG).  The environment variable bf(WINDOWID) is set to the X window
+id number of the bf(rxvt) window and it also uses and sets the environment
+variable bf(DISPLAY) to specify which display terminal to use.  bf(rxvt) uses
+the environment variables bf(RXVTPATH) and bf(PATH) to find XPM files.
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt-files.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvt-files.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvt-files.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt-files.yo	1998-04-20 04:24:21.000000000 -0300
@@ -0,0 +1,8 @@
+COMMENT(-- $Id: rxvt-files.yo,v 1.2 1998/04/20 07:24:21 mason Exp $ --)
+COMMENT(----------------------------------------------------------------------)
+manpagesection(FILES)
+
+startdit()
+    dit(bf(/etc/utmp)) System file for login records.
+    dit(bf(/usr/lib/X11/rgb.txt)) Color names.
+enddit()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt-fonts.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvt-fonts.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvt-fonts.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt-fonts.yo	1998-04-20 04:24:21.000000000 -0300
@@ -0,0 +1,9 @@
+COMMENT(-- $Id: rxvt-fonts.yo,v 1.2 1998/04/20 07:24:21 mason Exp $ --)
+COMMENT(----------------------------------------------------------------------)
+manpagesection(CHANGING FONTS)
+
+You can change fonts on-the-fly, which is to say cycle through the default
+font and others of various sizes, by using bf(Shift-KP_Add) and
+bf(Shift-KP_Subtract).  Or, alternatively (if enabled) with
+bf(HOTKEY()-BIGFONT()) and bf(HOTKEY()-SMALLFONT()), where the actual key
+can be selected using resources bf(smallfont_key)/bf(bigfont_key).
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt-login.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvt-login.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvt-login.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt-login.yo	1998-04-20 04:24:22.000000000 -0300
@@ -0,0 +1,7 @@
+COMMENT(-- $Id: rxvt-login.yo,v 1.2 1998/04/20 07:24:22 mason Exp $ --)
+COMMENT(----------------------------------------------------------------------)
+manpagesection(LOGIN STAMP)
+
+bf(rxvt) tries to write an entry into the em(utmp)(5) file so that it can be
+seen via the em(who(1)) command, and can accept messages.  To allow this
+feature, bf(rxvt) must be installed setuid root on some systems.
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt-mousereporting.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvt-mousereporting.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvt-mousereporting.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt-mousereporting.yo	1998-04-20 04:24:22.000000000 -0300
@@ -0,0 +1,14 @@
+COMMENT(-- $Id: rxvt-mousereporting.yo,v 1.2 1998/04/20 07:24:22 mason Exp $ --)
+COMMENT(----------------------------------------------------------------------)
+manpagesection(MOUSE REPORTING)
+
+To temporarily override mouse reporting, for either the scrollbar or the
+normal text selection/insertion, hold either the Shift or the Meta (Alt) key
+while performing the desired mouse action.
+
+If mouse reporting mode is active, the normal scrollbar actions are disabled
+-- on the assumption that we are using a fullscreen application.
+Instead, pressing Button1 and Button3 sends
+bf(ESC[6~) (Next) and bf(ESC[5~) (Prior), respectively.
+Similarly, clicking on the up and down arrows sends bf(ESC[A) (Up) and
+bf(ESC[B) (Down), respectively.
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt-options.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvt-options.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvt-options.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt-options.yo	2000-07-05 05:04:14.000000000 -0300
@@ -0,0 +1,151 @@
+COMMENT(-- $Id: rxvt-options.yo,v 1.4.2.5 2000/07/05 08:04:14 gcw Exp $ --)
+COMMENT(----------------------------------------------------------------------)
+manpageoptions()
+
+The bf(rxvt) options (mostly a subset of em(xterm)'s) are listed below.
+In keeping with the smaller-is-better philosophy, options may be eliminated
+or default values chosen at compile-time, so options and defaults listed
+may not accurately reflect the version installed on your system.  
+`rxvt -h' gives a list of major compile-time options on the usage line.
+Option descriptions may be prefixed with which compile option each is
+dependent upon.  e.g. `Compile em(XIM):' requires em(XIM) on the usage line.
+Note: `rxvt -help' gives a list of all options compiled into your version.
+
+Note that bf(rxvt) permits the resource name to be used as a long-option
+(--/++ option) so the potential command-line options are far greater than
+those listed.
+For example: `rxvt --loginShell --color1 Orange'.
+
+startdit()
+    dit(bf(-help), bf(--help))
+	Print out a message describing available options.
+    dit(bf(-display) em(displayname))
+	Attempt to open a window on the named X display (bf(-d) still
+	respected).  In the absence of this option, the display specified
+	by the bf(DISPLAY) environment variable is used.
+    dit(bf(-geometry) em(geom))
+	Window geometry (bf(-g) still respected);
+        resource bf(geometry).
+    dit(bf(-rv)|bf(+rv))
+	Turn on/off simulated reverse video;
+        resource bf(reverseVideo).
+    dit(bf(-ip)|bf(+ip))
+	Turn on/off inheriting parent window's pixmap.  Alternative form
+	is bf(-tr);
+	resource bf(inheritPixmap).
+    dit(bf(-bg) em(colour))
+	Window background colour;
+        resource bf(background).
+    dit(bf(-fg) em(colour))
+	Window foreground colour;
+	resource bf(foreground).
+    dit(bf(-pixmap:) em(file[;geom]))
+	Compile em(XPM): Specify XPM file for the background and also
+	optionally specify its scaling with a geometry string.  Note you
+	may need to add quotes to avoid special shell interpretation of
+	the `;' in the command-line;
+	resource bf(backgroundPixmap).
+    dit(bf(-cr) em(colour))
+	The cursor colour;
+	resource bf(cursorColor).
+    dit(bf(-pr) em(colour))
+	The mouse pointer colour;
+	resource bf(pointerColor).
+    dit(bf(-bd) em(colour))
+	The colour of the border between the xterm scrollbar and the text;
+	resource bf(borderColor).
+    dit(bf(-fn) em(fontname))
+	Main normal text font;
+	resource bf(font).
+    dit(bf(-fb) em(fontname))
+	Main bold text font;
+	resource bf(boldFont).
+    dit(bf(-fm) em(fontname))
+	Main multicharacter font;
+	resource bf(mfont).
+    dit(bf(-km) em(mode))
+	Multiple-character font-set encoding mode;
+	bf(eucj): EUC Japanese encoding.
+	bf(sjis): Shift JIS encoding;
+	resource bf(multichar_encoding).
+    dit(bf(-grk) em(mode))
+	Greek keyboard translation;
+	bf(iso): ISO-8859 mapping.
+	bf(ibm): IBM-437 mapping;
+	resource bf(greek_keyboard).
+    dit(bf(-name) em(name))
+	Specify the application name under which resources
+	are to be obtained, rather than the default executable file name.
+	Name should not contain `.' or `*' characters.
+	Also sets the icon and title name.
+    dit(bf(-ls)|bf(+ls))
+	Start as a login-shell/sub-shell;
+	resource bf(loginShell).
+    dit(bf(-ut)|bf(+ut))
+	Compile em(utmp): Inhibit/enable writing a utmp entry;
+	resource bf(utmpInhibit).
+    dit(bf(-vb)|bf(+vb))
+	Turn on/off visual bell on receipt of a bell character;
+	resource bf(visualBell).
+    dit(bf(-sb)|bf(+sb))
+	Turn on/off scrollbar;
+	resource bf(scrollBar).
+    dit(bf(-si)|bf(+si))
+	Turn on/off scroll-to-bottom on TTY output inhibit;
+	resource bf(scrollTtyOutput) has opposite effect.
+    dit(bf(-sk)|bf(+sk))
+	Turn on/off scroll-to-bottom on keypress;
+	resource bf(scrollTtyKeypress).
+    dit(bf(-sr)|bf(+sr)) 
+	Put scrollbar on right/left;
+	resource bf(scrollBar_right).
+    dit(bf(-st)|bf(+st)) 
+	Display normal (non XTerm/NeXT) scrollbar without/with a trough;
+	resource bf(scrollBar_floating).
+    dit(bf(-iconic)) 
+	Start iconified, if the window manager supports that option.
+	Alternative form is bf(-ic).
+    dit(bf(-sl) em(number))
+	Save em(number) lines in the scrollback buffer;
+	resource bf(saveLines).
+    dit(bf(-tn) em(termname)) 
+	This option specifies the name of the terminal type to be set in the
+	bf(TERM) environment variable. This terminal type must exist in the
+	em(termcap(5)) database and should have em(li#) and em(co#) entries;
+	resource bf(termName).
+    dit(bf(-e) em(command [arguments]))
+	Run the command with its command-line arguments in the bf(rxvt)
+	window; also sets the window title and icon name to be the basename
+	of the program being executed if neither em(-title) (em(-T)) nor
+	em(-n) are given on the command line.  If this option is used, it
+	must be the last on the command-line.  If there is no bf(-e) option
+	then the default is to run the program specified by the bf(SHELL)
+	environment variable or, failing that, em(sh(1)).
+    dit(bf(-title) em(text))
+	Window title (bf(-T) still respected); the default title is the
+	basename of the program specified after the bf(-e) option, if
+	any, otherwise the application name;
+	resource bf(title).
+    dit(bf(-n) em(text))
+	Icon name; the default name is the basename of the program specified
+	after the bf(-e) option, if any, otherwise the application name;
+	resource bf(iconName).
+    dit(bf(-C))
+	Capture system console messages.
+    dit(bf(-pt) em(style))
+	Compile em(XIM): input style for input method;
+	bf(OverTheSpot), bf(OffTheSpot), bf(Root);
+	resource bf(preeditType).
+    dit(bf(-im) em(text))
+	Compile em(XIM): input method name.
+	resource bf(inputMethod).
+    dit(bf(-mod) em(modifier))
+	Override detection of Meta modifier with specified key:
+	bf(alt), bf(meta), bf(hyper), bf(super), bf(mod1), bf(mod2), bf(mod3),
+	bf(mod4), bf(mod5);
+	resource em(modifier).
+    dit(bf(-xrm) em(resourcestring))
+	No effect on rxvt.  Simply passes through an argument to be made
+	available in the instance's argument list.  Appears in em(WM_COMMAND)
+	in some window managers.
+enddit()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef-csi.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-csi.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef-csi.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-csi.yo	1998-04-20 04:24:23.000000000 -0300
@@ -0,0 +1,163 @@
+COMMENT(-- $Id: rxvtRef-csi.yo,v 1.2 1998/04/20 07:24:23 mason Exp $ --)
+label(CSI)
+nsect(CSI (Code Sequence Introducer) Sequences)
+
+startdl()
+    dl(bf(tt(ESC [ Ps @)))
+	(Insert bf(tt(Ps)) (Blank) Character(s) [default: 1] (ICH))\
+P()\
+label(ESCOBPsA)
+    dl(bf(tt(ESC [ Ps A)))
+	(Cursor Up bf(tt(Ps)) Times [default: 1] (CUU))
+P()\
+    dl(bf(tt(ESC [ Ps B)))
+	(Cursor Down bf(tt(Ps)) Times [default: 1] (CUD))\
+label(ESCOBPsC)
+    dl(bf(tt(ESC [ Ps C)))
+	(Cursor Forward bf(tt(Ps)) Times [default: 1] (CUF))
+P()\
+    dl(bf(tt(ESC [ Ps D)))
+	(Cursor Backward bf(tt(Ps)) Times [default: 1] (CUB))
+P()\
+    dl(bf(tt(ESC [ Ps E)))
+	(Cursor Down bf(tt(Ps)) Times [default: 1] and to first column)
+P()\
+    dl(bf(tt(ESC [ Ps F)))
+	(Cursor Up bf(tt(Ps)) Times [default: 1] and to first column)\
+P()\
+label(ESCOBPsG)
+    dl(bf(tt(ESC [ Ps G)))
+	(Cursor to Column bf(tt(Ps)) (HPA))
+P()\
+    dl(bf(tt(ESC [ Ps;Ps H)))
+	(Cursor Position [row;column] [default: 1;1] (CUP))
+P()\
+    dl(bf(tt(ESC [ Ps I)))
+	(Move forward bf(tt(Ps)) tab stops [default: 1])
+P()\
+    dl(bf(tt(ESC [ Ps J)))
+	(Erase in Display (ED) nl()\
+        starttable(2)(l l)(0)\
+	    row(cell(bf(tt(Ps = 0)))cell(Clear Below (default)))\
+	    row(cell(bf(tt(Ps = 1)))cell(Clear Above))\
+	    row(cell(bf(tt(Ps = 2)))cell(Clear All))\
+	endtable())
+    dl(bf(tt(ESC [ Ps K)))
+	(Erase in Line (EL) nl()\
+        starttable(2)(l l)(0)\
+	    row(cell(bf(tt(Ps = 0)))cell(Clear to Right (default)))\
+	    row(cell(bf(tt(Ps = 1)))cell(Clear to Left))\
+	    row(cell(bf(tt(Ps = 2)))cell(Clear All))\
+	endtable())
+    dl(bf(tt(ESC [ Ps L)))
+	(Insert bf(tt(Ps)) Line(s) [default: 1] (IL))
+P()\
+    dl(bf(tt(ESC [ Ps M)))
+	(Delete bf(tt(Ps)) Line(s) [default: 1] (DL))
+P()\
+    dl(bf(tt(ESC [ Ps P)))
+	(Delete bf(tt(Ps)) Character(s) [default: 1] (DCH))
+P()\
+    dl(bf(tt(ESC [ Ps;Ps;Ps;Ps;Ps T)))
+	(Initiate link(hilite mouse tracking)(Mouse).  em(unimplemented)
+	Parameters are [func;startx;starty;firstrow;lastrow].)
+P()\
+    dl(bf(tt(ESC [ Ps W)))
+	(Tabulator functions nl()\
+        starttable(2)(l l)(0)\
+	    row(cell(bf(tt(Ps = 0)))cell(Tab Set (HTS)))\
+	    row(cell(bf(tt(Ps = 2)))cell(Tab Clear (TBC), Clear Current \
+		Column (default)))\
+	    row(cell(bf(tt(Ps = 5)))cell(Tab Clear (TBC), Clear All))\
+	endtable())
+    dl(bf(tt(ESC [ Ps X)))
+	(Erase bf(tt(Ps)) Character(s) [default: 1] (ECH))
+P()\
+    dl(bf(tt(ESC [ Ps Z)))
+	(Move backward bf(tt(Ps)) [default: 1] tab stops)
+P()\
+    dl(bf(tt(ESC [ Ps ')))
+	(== link(tt(ESC [ Ps G))(ESCOBPsG))
+P()\
+    dl(bf(tt(ESC [ Ps a)))
+	(== link(tt(ESC [ Ps C))(ESCOBPsC))\
+P()\
+label(ESCOBPsc)
+    dl(bf(tt(ESC [ Ps c)))
+	(Send Device Attributes (DA)nl()\
+	bf(tt(Ps = 0)) (or omitted) : request attributes from terminal nl()\
+	returns: bf(tt(ESC[?1;2c)) (``I am a VT100 with Advanced Video
+	Option''))
+P()\
+    dl(bf(tt(ESC [ Ps d)))
+	(Cursor to Line bf(tt(Ps)) (VPA))
+P()\
+    dl(bf(tt(ESC [ Ps e)))
+	(== link(ESC [ Ps A)(ESCOBPsA))
+P()\
+    dl(bf(tt(ESC [ Ps;Ps f)))
+	(Horizontal and Vertical Position [row;column] (HVP) [default: 1;1])
+P()\
+    dl(bf(tt(ESC [ Ps g)))
+	(Tab Clear (TBC) nl()\
+        starttable(2)(l l)(0)\
+	    row(cell(bf(tt(Ps = 0)))cell(Clear Current Column (default)))\
+	    row(cell(bf(tt(Ps = 3)))cell(Clear All (TBC)))\
+	endtable())
+    dl(bf(tt(ESC [ Ps i)))
+	(Printing nl()\
+        starttable(2)(l l)(0)\
+	    row(cell(bf(tt(Ps = 4)))cell(disable transparent print mode (MC4)))\
+	    row(cell(bf(tt(Ps = 5)))cell(enable transparent print mode (MC5) \
+		em(unimplemented)))\
+	endtable())
+    dl(bf(tt(ESC [ Pm h)nl()tt(ESC [ Pm l)))
+	(Set Mode (SM) nl()Reset Mode (RM)\
+	startdl()
+	    dl(bf(tt(Ps = 4)))
+	        (starttable(2)(l l)(0)\
+		    row(cell(bf(tt(h)))cell(Insert Mode (SMIR)))\
+		    row(cell(bf(tt(l)))cell(Replace Mode (RMIR)))\
+	        endtable())
+	    dl(bf(tt(Ps = 20)) em(unimplemented))
+	        (starttable(2)(l l)(0)\
+		    row(cell(bf(tt(h)))cell(Automatic Newline (LNM)))\
+		    row(cell(bf(tt(h)))cell(Normal Linefeed (LNM)))\
+	        endtable())
+	enddl())
+    dl(bf(tt(ESC [ Pm m)))
+	(Character Attributes (SGR) nl()\
+	starttable(2)(l l)(0)\
+	    row(cell(bf(tt(Ps = 0)))cell(Normal (default)))\
+	    row(cell(bf(tt(Ps = 1 / 22)))cell(On / Off Bold (bright fg)))\
+	    row(cell(bf(tt(Ps = 4 / 24)))cell(On / Off Underline))\
+	    row(cell(bf(tt(Ps = 5 / 25)))cell(On / Off Blink (bright bg)))\
+	    row(cell(bf(tt(Ps = 7 / 27)))cell(On / Off Inverse))\
+	    row(cell(bf(tt(Ps = 30 / 40)))cell(fg/bg Black))\
+	    row(cell(bf(tt(Ps = 31 / 41)))cell(fg/bg Red))\
+	    row(cell(bf(tt(Ps = 32 / 42)))cell(fg/bg Green))\
+	    row(cell(bf(tt(Ps = 33 / 43)))cell(fg/bg Yellow))\
+	    row(cell(bf(tt(Ps = 34 / 44)))cell(fg/bg Blue))\
+	    row(cell(bf(tt(Ps = 35 / 45)))cell(fg/bg Magenta))\
+	    row(cell(bf(tt(Ps = 36 / 46)))cell(fg/bg Cyan))\
+	    row(cell(bf(tt(Ps = 37 / 47)))cell(fg/bg White))\
+	    row(cell(bf(tt(Ps = 39 / 49)))cell(fg/bg Default))\
+	endtable())
+    dl(bf(tt(ESC [ Ps n)))
+	(Device Status Report (DSR) nl()\
+	starttable(2)(l l)(0)\
+	    row(cell(bf(tt(Ps = 5)))cell(Status Report bf(tt(ESC [ 0 n)) \
+		(``OK'')))\
+	    row(cell(bf(tt(Ps = 6)))cell(Report Cursor Position (CPR) \
+		[row;column] as bf(tt(ESC [ r ; c R))))\
+	    row(cell(bf(tt(Ps = 7)))cell(Request Display Name))\
+	    row(cell(bf(tt(Ps = 8)))cell(Request Version Number (place in \
+		window title)))\
+	endtable())
+    dl(bf(tt(ESC [ Ps;Ps r)))
+	(Set Scrolling Region [top;bottom] nl()\
+	[default: full size of window] (CSR))
+P()\
+    dl(bf(tt(ESC [ Ps x)))
+	(Request Terminal Parameters (DECREQTPARM))
+enddl()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef-definitions.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-definitions.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef-definitions.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-definitions.yo	1998-04-20 04:24:24.000000000 -0300
@@ -0,0 +1,22 @@
+COMMENT(-- $Id: rxvtRef-definitions.yo,v 1.2 1998/04/20 07:24:24 mason Exp $ --)
+label(Definitions)
+nsect(Definitions)
+
+startdl()
+    dl(bf(tt(c)))
+	(The literal character c.)
+P()\
+    dl(bf(tt(C)))
+	(A single (required) character.)
+P()\
+    dl(bf(tt(Ps)))
+	(A single (usually optional) numeric parameter, composed of one or
+	more digits.)
+P()\
+    dl(bf(tt(Pm)))
+	(A multiple numeric parameter composed of any number of single numeric
+	parameters, separated by ; character(s).)
+P()\
+    dl(bf(tt(Pt)))
+	(A text parameter composed of printable characters.)
+enddl()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef-graphics.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-graphics.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef-graphics.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-graphics.yo	1998-04-20 04:24:24.000000000 -0300
@@ -0,0 +1,33 @@
+COMMENT(-- $Id: rxvtRef-graphics.yo,v 1.2 1998/04/20 07:24:24 mason Exp $ --)
+label(Graphics)
+nsect(Special Graphics Mode)
+
+Add more documentation here, em(if anyone actually cares.)
+
+startdl()
+    dl(bf(tt(ESC G Q)))
+	(query if graphics are available nl()\
+	returns: bf(tt(ESC G 0)) no graphics available nl()\
+	returns: bf(tt(ESC G 1)) graphics available (colour only))
+P()\
+    dl(bf(tt(ESC G W <;x>;<y>;<w>;<h>:)))
+	(create window)
+P()\
+    dl(bf(tt(ESC G C <id>)))
+	(clear window)
+P()\
+    dl(bf(tt(ESC G G <it>:)))
+	(query window nl()\
+	returns: bf(tt(ESC G <id> <x> <y> <w> <h> <fw> <fh> <nw> <nh>)))
+P()\
+    dl(bf(tt(ESC G L <id>)nl()tt(ESC G P <id>)nl()tt(ESC G F <id>)))
+	(start point nl()\
+	start line nl()\
+	start fill)
+P()\
+    dl(bf(tt(;<x>;<y>)))
+	(extend point/line/fill)
+P()\
+    dl(bf(tt(ESC G T <id>;<x>;<y>;<mode>;<len>:<text>)))
+	(place text)
+enddl()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef-keycodes.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-keycodes.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef-keycodes.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-keycodes.yo	1998-04-20 04:24:24.000000000 -0300
@@ -0,0 +1,73 @@
+COMMENT(-- $Id: rxvtRef-keycodes.yo,v 1.2 1998/04/20 07:24:24 mason Exp $ --)
+label(KeyCodes)
+nsect(Key Codes)
+
+Note: bf(Shift) + bf(F1)-bf(F10) generates bf(F11)-bf(F20)
+
+For the keypad, use bf(Shift) to temporarily override Application-Keypad
+setting use bf(Num_Lock) to toggle Application-Keypad setting if bf(Num_Lock)
+is off, link(escape sequences)(ESCequals) toggle Application-Keypad setting.
+Also note that values of bf(Home), bf(End), bf(Delete) may have been compiled
+differently on your system.
+
+COMMENT(-- Edited in a wide window --)
+starttable(5)(l l l l l)(1)\
+    row(cell(               )cell(bf(Normal)     )cell(bf(Shift)      )cell(bf(Control)    )cell(bf(Ctrl+Shift)))\
+    row(cell(Tab            )cell(^I         )cell(ESC [ Z    )cell(^I         )cell(ESC [ Z))\
+    row(cell(BackSpace      )cell(^H         )cell(^?         )cell(^?         )cell(^?))\
+    row(cell(Find           )cell(ESC [ 1 ~  )cell(ESC [ 1 $  )cell(ESC [ 1 ^  )cell(ESC [ 1 @))\
+    row(cell(Insert         )cell(ESC [ 2 ~  )cell(em(paste)      )cell(ESC [ 2 ^  )cell(ESC [ 2 @))\
+    row(cell(Execute        )cell(ESC [ 3 ~  )cell(ESC [ 3 $  )cell(ESC [ 3 ^  )cell(ESC [ 3 @))\
+    row(cell(Select         )cell(ESC [ 4 ~  )cell(ESC [ 4 $  )cell(ESC [ 4 ^  )cell(ESC [ 4 @))\
+    row(cell(Prior          )cell(ESC [ 5 ~  )cell(em(scroll-up)  )cell(ESC [ 5 ^  )cell(ESC [ 5 @))\
+    row(cell(Next           )cell(ESC [ 6 ~  )cell(em(scroll-down))cell(ESC [ 6 ^  )cell(ESC [ 6 @))\
+    row(cell(Home           )cell(ESC [ 7 ~  )cell(ESC [ 7 $  )cell(ESC [ 7 ^  )cell(ESC [ 7 @))\
+    row(cell(End            )cell(ESC [ 8 ~  )cell(ESC [ 8 $  )cell(ESC [ 8 ^  )cell(ESC [ 8 @))\
+    row(cell(Delete         )cell(ESC [ 3 ~  )cell(ESC [ 3 $  )cell(ESC [ 3 ^  )cell(ESC [ 3 @))\
+    row(cell(F1             )cell(ESC [ 11 ~ )cell(ESC [ 23 ~ )cell(ESC [ 11 ^ )cell(ESC [ 23 ^))\
+    row(cell(F2             )cell(ESC [ 12 ~ )cell(ESC [ 24 ~ )cell(ESC [ 12 ^ )cell(ESC [ 24 ^))\
+    row(cell(F3             )cell(ESC [ 13 ~ )cell(ESC [ 25 ~ )cell(ESC [ 13 ^ )cell(ESC [ 25 ^))\
+    row(cell(F4             )cell(ESC [ 14 ~ )cell(ESC [ 26 ~ )cell(ESC [ 14 ^ )cell(ESC [ 26 ^))\
+    row(cell(F5             )cell(ESC [ 15 ~ )cell(ESC [ 28 ~ )cell(ESC [ 15 ^ )cell(ESC [ 28 ^))\
+    row(cell(F6             )cell(ESC [ 17 ~ )cell(ESC [ 29 ~ )cell(ESC [ 17 ^ )cell(ESC [ 29 ^))\
+    row(cell(F7             )cell(ESC [ 18 ~ )cell(ESC [ 31 ~ )cell(ESC [ 18 ^ )cell(ESC [ 31 ^))\
+    row(cell(F8             )cell(ESC [ 19 ~ )cell(ESC [ 32 ~ )cell(ESC [ 19 ^ )cell(ESC [ 32 ^))\
+    row(cell(F9             )cell(ESC [ 20 ~ )cell(ESC [ 33 ~ )cell(ESC [ 20 ^ )cell(ESC [ 33 ^))\
+    row(cell(F10            )cell(ESC [ 21 ~ )cell(ESC [ 34 ~ )cell(ESC [ 21 ^ )cell(ESC [ 34 ^))\
+    row(cell(F11            )cell(ESC [ 23 ~ )cell(ESC [ 23 $ )cell(ESC [ 23 ^ )cell(ESC [ 23 @))\
+    row(cell(F12            )cell(ESC [ 24 ~ )cell(ESC [ 24 $ )cell(ESC [ 24 ^ )cell(ESC [ 24 @))\
+    row(cell(F13            )cell(ESC [ 25 ~ )cell(ESC [ 25 $ )cell(ESC [ 25 ^ )cell(ESC [ 25 @))\
+    row(cell(F14            )cell(ESC [ 26 ~ )cell(ESC [ 26 $ )cell(ESC [ 26 ^ )cell(ESC [ 26 @))\
+    row(cell(F15 (Help)     )cell(ESC [ 28 ~ )cell(ESC [ 28 $ )cell(ESC [ 28 ^ )cell(ESC [ 28 @))\
+    row(cell(F16 (Menu)     )cell(ESC [ 29 ~ )cell(ESC [ 29 $ )cell(ESC [ 29 ^ )cell(ESC [ 29 @))\
+    row(cell(F17            )cell(ESC [ 31 ~ )cell(ESC [ 31 $ )cell(ESC [ 31 ^ )cell(ESC [ 31 @))\
+    row(cell(F18            )cell(ESC [ 32 ~ )cell(ESC [ 32 $ )cell(ESC [ 32 ^ )cell(ESC [ 32 @))\
+    row(cell(F19            )cell(ESC [ 33 ~ )cell(ESC [ 33 $ )cell(ESC [ 33 ^ )cell(ESC [ 33 @))\
+    row(cell(F20            )cell(ESC [ 34 ~ )cell(ESC [ 34 $ )cell(ESC [ 34 ^ )cell(ESC [ 34 @))\
+    row(cell(               )cell(           )cell(           )cell(           )cell(bf(Application)))\
+    row(cell(Up             )cell(ESC [ A    )cell(ESC [ a    )cell(ESC O a    )cell(ESC O A))\
+    row(cell(Down           )cell(ESC [ B    )cell(ESC [ b    )cell(ESC O b    )cell(ESC O B))\
+    row(cell(Right          )cell(ESC [ C    )cell(ESC [ c    )cell(ESC O c    )cell(ESC O C))\
+    row(cell(Left           )cell(ESC [ D    )cell(ESC [ d    )cell(ESC O d    )cell(ESC O D))\
+    row(cell(KP_Enter       )cell(^M         )cell(           )cell(           )cell(ESC O M))\
+    row(cell(KP_F1          )cell(ESC O P    )cell(           )cell(           )cell(ESC O P))\
+    row(cell(KP_F2          )cell(ESC O Q    )cell(           )cell(           )cell(ESC O Q))\
+    row(cell(KP_F3          )cell(ESC O R    )cell(           )cell(           )cell(ESC O R))\
+    row(cell(KP_F4          )cell(ESC O S    )cell(           )cell(           )cell(ESC O S))\
+    row(cell(XK_KP_Multiply )cell(*          )cell(           )cell(           )cell(ESC O j))\
+    row(cell(XK_KP_Add      )cell(+          )cell(           )cell(           )cell(ESC O k))\
+    row(cell(XK_KP_Separator)cell(,          )cell(           )cell(           )cell(ESC O l))\
+    row(cell(XK_KP_Subtract )cell(-          )cell(           )cell(           )cell(ESC O m))\
+    row(cell(XK_KP_Decimal  )cell(.          )cell(           )cell(           )cell(ESC O n))\
+    row(cell(XK_KP_Divide   )cell(/          )cell(           )cell(           )cell(ESC O o))\
+    row(cell(XK_KP_0        )cell(0          )cell(           )cell(           )cell(ESC O p))\
+    row(cell(XK_KP_1        )cell(1          )cell(           )cell(           )cell(ESC O q))\
+    row(cell(XK_KP_2        )cell(2          )cell(           )cell(           )cell(ESC O r))\
+    row(cell(XK_KP_3        )cell(3          )cell(           )cell(           )cell(ESC O s))\
+    row(cell(XK_KP_4        )cell(4          )cell(           )cell(           )cell(ESC O t))\
+    row(cell(XK_KP_5        )cell(5          )cell(           )cell(           )cell(ESC O u))\
+    row(cell(XK_KP_6        )cell(6          )cell(           )cell(           )cell(ESC O v))\
+    row(cell(XK_KP_7        )cell(7          )cell(           )cell(           )cell(ESC O w))\
+    row(cell(XK_KP_8        )cell(8          )cell(           )cell(           )cell(ESC O x))\
+    row(cell(XK_KP_9        )cell(9          )cell(           )cell(           )cell(ESC O y))\
+endtable()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef-menubar.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-menubar.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef-menubar.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-menubar.yo	1998-07-20 08:11:59.000000000 -0300
@@ -0,0 +1,283 @@
+COMMENT(-- $Id: rxvtRef-menubar.yo,v 1.3 1998/07/20 11:11:59 mason Exp $ --)
+label(menuBar)
+nsect(menuBar)
+
+bf(The exact syntax used is em(almost) solidified.) nl()\
+In the menus, bf(DON'T) try to use menuBar commands that add or remove a
+menuBar.
+
+Note that in all of the commands, the bf(em(/path/)) em(cannot) be omitted:
+use bf(./) to specify a menu relative to the current menu.
+
+nsubsect(Overview of menuBar operation)
+
+For the menuBar XTerm escape sequence tt(ESC ] 10; Pt BEL), the
+syntax of tt(Pt) can be used for a variety of tasks:
+startit()
+    it()link(Commands)(menuBarCommands)
+    it()link(Adding and accessing menus)(menuBarAdd)
+    it()link(Removing menus)(menuBarRemove)
+    it()link(Quick Arrows)(menuBarArrows)
+    it()link(Command Summary)(menuBarSummary)
+endit()
+
+At the top level is the current menuBar which is a member of a circular
+linked-list of other such menuBars.
+
+The menuBar acts as a parent for the various drop-down menus, which in turn,
+may have labels, separator lines, menuItems and subMenus.
+
+The menuItems are the useful bits: you can use them to mimic keyboard input
+or even to send text or escape sequences back to rxvt.
+
+The menuBar syntax is intended to provide a simple yet robust method of
+constructing and manipulating menus and navigating through the menuBars.
+
+The first step is to use the tag bf([menu:em(name)]) which creates the
+menuBar called em(name) and allows access.
+You may now link(add)(menuBarAdd) or link(remove)(menuBarRemove) menus,
+subMenus, and menuItems. Finally, use the tag bf([done]) to set the menuBar
+access as bf(readonly) to prevent accidental corruption of the menus.
+To re-access the current menuBar for alterations, use the tag bf([menu]),
+make the alterations and then use bf([done])
+
+label(menuBarCommands)
+nsubsect(Commands)
+
+startdl()
+    dl(bf([menu:+em(name)]))
+	(access the named menuBar for creation or alteration. If a new menuBar
+	is created, it is called em(name) (max of 15 chars) and the current
+	menuBar is pushed onto the stack)
+P()\
+    dl(bf([menu]))
+	(access the current menuBar for alteration)
+P()\
+    dl(bf([title:+em(string)]))
+	(set the current menuBar's title to em(string), which may contain the
+	following format specifiers: nl()\
+	bf(%%) : literal bf(%) character nl()\
+	bf(%n) : rxvt name (as per the bf(-name) command-line option) nl()\
+	bf(%v) : rxvt version)
+P()\
+    dl(bf([done]))
+	(set menuBar access as bf(readonly). nl()\
+	End-of-file tag for bf([read:+em(file)]) operations.)
+P()\
+    dl(bf([read:+em(file)]))
+	(read menu commands directly from em(file) (extension ".menu" will be
+	appended if required.) Start reading at a line with bf([menu]) or
+	bf([menu:+em(name)) and continuing until bf([done]) is encountered.
+
+	Blank and comment lines (starting with bf(#)) are ignored.
+	Actually, since any invalid menu commands are also ignored, almost
+	anything could be construed as a comment line, but this may be
+	tightened up in the future ... so don't count on it!.)
+P()\
+    dl(bf([read:+em(file);+em(name)]))
+	(The same as bf([read:+em(file)]), but start reading at a line with
+	bf([menu:+em(name)]) and continuing until bf([done:+em(name)]) or
+	bf([done]) is encountered.)
+P()\
+    dl(bf([dump]))
+	(dump all menuBars to the file bf(/tmp/rxvt-PID) in a format suitable
+	for later rereading.)
+P()\
+    dl(bf([rm:name]nl()[rm] [rm:]nl()[rm*] [rm:*]))
+	(remove the named menuBar nl()\
+	remove the current menuBar nl()\
+	remove all menuBars)
+P()\
+    dl(bf([swap]))
+	(swap the top two menuBars)
+P()\
+    dl(bf([prev]nl()[next]))
+	(access the previous or next menuBar)
+P()\
+    dl(bf([show]nl()[hide]))
+	(control display of the menuBar ... just like
+	link(ESC[?10 h/l)(Priv10))
+P()\
+    dl(bf([pixmap:+em(name)]nl()[pixmap:+em(name);em(scaling)]))
+	(set the background pixmap globally ... just like
+	link(ESC]20; Pt BEL)(XPM)
+
+	bf(A Future implementation em(may) make this local to the menubar))
+P()\
+    dl(bf([:+em(command):]))
+	(ignore the menu readonly status and issue a em(command) to
+	link(Add/Modify)(menuBarAdd) or link(Remove)(menuBarRemove) a menu or
+	menuitem or change the link(Quick Arrows)(menuBarArrows); a useful
+	shortcut for setting the quick arrows from a menuBar.)
+enddl()
+
+label(menuBarAdd)
+nsubsect(Adding and accessing menus)
+
+The following commands may also be bf(+) prefixed.
+startdl()
+    dl(bf(/+nl()./+nl()../+nl()../../))
+	(access menuBar top level nl()\
+	access current menu level nl()\
+	access parent menu (1 level up) nl()\
+	access parent menu (multiple levels up))
+    dl(bf(em(/path/)menu))
+	(add/access menu)
+    dl(bf(em(/path/)menu/*))
+	(add/access menu and clear it if it exists)
+    dl(bf(em(/path/){-}))
+	(add separator)
+    dl(bf(em(/path/){item}))
+	(add bf(item) as a label)
+    dl(bf(em(/path/){item} action))
+	(add/alter em(menuitem) with an associated em(action))
+    dl(bf(em(/path/){item}{right-text}))
+	(add/alter em(menuitem) with bf(right-text) as the right-justified
+	text and as the associated em(action))
+    dl(bf(em(/path/){item}{rtext} action))
+	(add/alter em(menuitem) with an associated em(action) and with
+	bf(rtext) as the right-justified text.)
+enddl()
+startdl()
+    dl(Special characters in em(action) must be backslash-escaped:)
+	(bf(\a \b \E \e \n \r \t \octal))
+    dl(or in control-character notation:)
+	(bf(^@, ^A .. ^Z .. ^_, ^?))
+enddl()
+
+To send a string starting with a bf(NUL) (bf(^@)) character to the program,
+start em(action) with a pair of bf(NUL) characters (bf(^@^@)), the first of
+which will be stripped off and the balance directed to the program.
+Otherwise if em(action) begins with bf(NUL) followed by non-+bf(NUL)
+characters, the leading bf(NUL) is stripped off and the balance is sent back
+to rxvt.
+
+As a convenience for the many Emacs-type editors, em(action) may start
+with bf(M-) (eg, bf(M-$) is equivalent to bf(\E$)) and a bf(CR) will be
+appended if missed from bf(M-x) commands.
+
+As a convenience for issuing XTerm bf(ESC]) sequences from a menubar
+(or quick arrow), a bf(BEL) (bf(^G)) will be appended if needed.
+
+startdl()
+    dl(For example,)
+	(bf(M-xapropos) is equivalent to bf(\Exapropos\r))
+    dl(and)
+	(bf(\E]10;mona;100) is equivalent to bf(\E]10;mona;100\a))
+enddl()
+
+The option bf({em(right-rtext)}) will be right-justified.  In the absence of
+a specified action, this text will be used as the em(action) as well.
+
+startdl()
+    dl(For example,)
+    	(bf(/File/{Open}{^X^F}) is equivalent to bf(/File/{Open}{^X^F} ^X^F))
+enddl()
+
+The left label em(is) necessary, since it's used for matching,
+but implicitly hiding the left label (by using same name for both left
+and right labels), or explicitly hiding the left label (by preceeding
+it with a dot), makes it possible to have right-justified text only.
+startdl()
+    dl(For example,)
+	(bf(/File/{Open}{Open} Open-File-Action))
+    dl(or hiding it)
+	(bf(/File/{.anylabel}{Open} Open-File-Action))
+enddl()
+
+label(menuBarRemove)
+nsubsect(Removing menus)
+
+startdl()
+    dl(bf(-/*+nl()-+em(/path)menu+nl()-+em(/path){item}+nl()-+em(/path){-}))
+	(remove all menus from the menuBar, the same as bf([clear])nl()\
+	remove menu nl()\
+	remove item nl()\
+	remove separator)
+    dl(bf(-/path/menu/*))
+	(remove all items, separators and submenus from menu)
+enddl()
+
+label(menuBarArrows)
+nsubsect(Quick Arrows)
+
+The menus also provide a hook for em(quick arrows) to provide easier user
+access. If nothing has been explicitly set, the default is to emulate the
+curror keys. The syntax permits each arrow to be altered individually or
+all four at once without re-entering their common beginning/end text. For
+example, to explicitly associate cursor actions with the arrows, any of
+the following forms could be used:
+
+startdl()
+    dl(bf(<r>+em(Right)nl()<l>+em(Left)nl()<u>+em(Up)nl()<d>+em(Down)))
+	(Define actions for the respective arrow buttons)
+    dl(bf(<b>+em(Begin)nl()<e>+em(End)))
+	(Define common beginning/end parts for em(quick arrows) which used
+	in conjunction with the above <r> <l> <u> <d> constructs)
+enddl()
+
+startdl()
+    dl(For example, define arrows individually,)
+	(bf(<u>\E[A nl()\
+	<d>\E[B nl()\
+	<r>\E[C nl()\
+	<l>\E[D))
+    dl(or all at once)
+        (bf(<u>\E[A<d>\E[B<r>\E[C<l>\E[D))
+    dl(or more compactly (factoring out common parts))
+	(bf(<b>\E[<u>A<d>B<r>C<l>D))
+enddl()
+
+label(menuBarSummary)
+nsubsect(Command Summary)
+
+A short summary of the most em(common) commands:
+
+startdl()
+    dl([menu:name])
+	(use an existing named menuBar or start a new one)
+    dl([menu])
+	(use the current menuBar)
+    dl([title:string])
+	(set menuBar title)
+    dl([done])
+	(set menu access to readonly and, if reading from a file, signal EOF)
+    dl([done:name])
+	(if reading from a file using [read:file;name] signal EOF)
+    dl([rm:name]+nl()[rm] [rm:]+nl()[rm*] [rm:*])
+	(remove named, current, or all menuBar(s))
+    dl([swap])
+	(swap top two menuBars)
+    dl([prev]+nl()[next])
+	(access the previous/next menuBar)
+    dl([show]+nl()[hide])
+	(map/unmap menuBar)
+    dl([pixmap;file]+nl()[pixmap;file;scaling])
+	(set a background pixmap)
+    dl([read:file]+nl()[read:file;name])
+	(read in a menu from a file)
+    dl([dump])
+	(dump out all menuBars to /tmp/rxvt-PID)
+    dl(/)
+	(access menuBar top level)
+    dl(./+nl()../+nl()../../)
+	(access current or parent menu level)
+    dl(/path/menu)
+	(add/access menu)
+    dl(/path/{-})
+	(add separator)
+    dl(/path/{item}{rtext} action)
+	(add/alter menu item+nl()({rtext} and/or action, may be omitted))
+    dl(-/*)
+	(remove all menus from the menuBar)
+    dl(-/path/menu)
+	(remove menu items, separators and submenus from menu)
+    dl(-/path/menu)
+	(remove menu)
+    dl(-/path/{item})
+	(remove item)
+    dl(-/path/{-})
+	(remove separator)
+    dl(<b>Begin<r>Right<l>Left<u>Up<d>Down<e>End)
+	(menu quick arrows)
+enddl()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef-mouse.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-mouse.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef-mouse.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-mouse.yo	1998-04-20 04:24:25.000000000 -0300
@@ -0,0 +1,29 @@
+COMMENT(-- $Id: rxvtRef-mouse.yo,v 1.2 1998/04/20 07:24:25 mason Exp $ --)
+label(Mouse)
+nsect(Mouse Reporting)
+
+startdl()
+    dl(bf(tt(ESC [ M <b> <x> <y>)))
+	(report mouse position)
+enddl()
+The lower 2 bits of bf(tt(<b>)) indicate the button:
+startdl()
+    dl(Button = bf(tt((<b> - SPACE) & 3)))
+	(0 = Button1 pressed nl()\
+	1 = Button2 pressed nl()\
+	2 = Button3 pressed nl()\
+	3 = button released (X11 mouse report))
+enddl()
+
+The upper bits of bf(tt(<b>)) indicate the modifiers when the button was
+pressed and are added together (X11 mouse report only):
+
+startdl()
+    dl(State = bf(tt((<b> - SPACE) & 60)))
+        (4 = Shift nl()\
+	8 = Meta nl()\
+	16 = Control nl()\
+	32 = Double Click em((Rxvt extension)) nl()\
+	Col = bf(tt(<x> - SPACE)) nl()\
+	Row = bf(tt(<y> - SPACE)))
+enddl()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef-privatemodes.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-privatemodes.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef-privatemodes.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-privatemodes.yo	1998-04-20 04:24:25.000000000 -0300
@@ -0,0 +1,153 @@
+COMMENT(-- $Id: rxvtRef-privatemodes.yo,v 1.2 1998/04/20 07:24:25 mason Exp $ --)
+label(PrivateModes)
+nsect(DEC Private Modes)
+
+startdl()
+    dl(bf(tt(ESC [ ? Pm h)))
+        (DEC Private Mode Set (DECSET))
+P()\
+    dl(bf(tt(ESC [ ? Pm l)))
+        (DEC Private Mode Reset (DECRST))
+P()\
+    dl(bf(tt(ESC [ ? Pm r)))
+        (Restore previously saved DEC Private Mode Values.)
+P()\
+    dl(bf(tt(ESC [ ? Pm s)))
+        (Save DEC Private Mode Values.)
+P()\
+    dl(bf(tt(ESC [ ? Pm t)))
+        (Toggle DEC Private Mode Values (rxvt extension).)
+    em(where) nl()\
+startdl()
+        dl(bf(tt(Ps = 1)) (DECCKM))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Application Cursor Keys))\
+                row(cell(bf(tt(l)))cell(Normal Cursor Keys))\
+            endtable())
+        dl(bf(tt(Ps = 2)) em(unimplemented))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Designate USASCII for character sets \
+                    G0-G3.))\
+            endtable())
+        dl(bf(tt(Ps = 3)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(132 Column Mode (DECCOLM)))\
+                row(cell(bf(tt(l)))cell(80 Column Mode (DECCOLM)))\
+            endtable())
+        dl(bf(tt(Ps = 4)) em(unimplemented))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Smooth (Slow) Scroll (DECSCLM)))\
+                row(cell(bf(tt(l)))cell(Jump (Fast) Scroll (DECSCLM)))\
+            endtable())
+        dl(bf(tt(Ps = 5)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Reverse Video (DECSCNM)))\
+                row(cell(bf(tt(l)))cell(Normal Video (DECSCNM)))\
+            endtable())
+        dl(bf(tt(Ps = 6)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Origin Mode (DECOM)))\
+                row(cell(bf(tt(l)))cell(Normal Cursor Mode (DECOM)))\
+            endtable())
+        dl(bf(tt(Ps = 7)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Wraparound Mode (DECAWM)))\
+                row(cell(bf(tt(l)))cell(No Wraparound Mode (DECAWM)))\
+            endtable())
+        dl(bf(tt(Ps = 8)) em(unimplemented))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Auto-repeat Keys (DECARM)))\
+                row(cell(bf(tt(l)))cell(No Auto-repeat Keys (DECARM)))\
+            endtable())
+        dl(bf(tt(Ps = 9)) X10 XTerm link(mouse reporting)(Mouse))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Send Mouse X & Y on button press.))\
+                row(cell(bf(tt(l)))cell(No mouse reporting.))\
+            endtable())\
+label(Priv10)
+        dl(bf(tt(Ps = 10)) (bf(rxvt)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(link(menuBar)(menuBar) visible))\
+                row(cell(bf(tt(l)))cell(link(menuBar)(menuBar) invisible))\
+            endtable())
+        dl(bf(tt(Ps = 25)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Visible cursor {cnorm/cvvis}))\
+                row(cell(bf(tt(l)))cell(Invisible cursor {civis}))\
+            endtable())
+        dl(bf(tt(Ps = 30)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(scrollBar visisble))\
+                row(cell(bf(tt(l)))cell(scrollBar invisisble))\
+            endtable())
+        dl(bf(tt(Ps = 35)) (bf(rxvt)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Allow XTerm Shift+key sequences))\
+                row(cell(bf(tt(l)))cell(Disallow XTerm Shift+key sequences))\
+            endtable())
+        dl(bf(tt(Ps = 38)) em(unimplemented))
+            (Enter Tektronix Mode (DECTEK))
+        dl(bf(tt(Ps = 40)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Allow 80/132 Mode))\
+                row(cell(bf(tt(l)))cell(Disallow 80/132 Mode))\
+            endtable())
+        dl(bf(tt(Ps = 44)) em(unimplemented))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Turn On Margin Bell))\
+                row(cell(bf(tt(l)))cell(Turn Off Margin Bell))\
+            endtable())
+        dl(bf(tt(Ps = 45)) em(unimplemented))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Reverse-wraparound Mode))\
+                row(cell(bf(tt(l)))cell(No Reverse-wraparound Mode))\
+            endtable())
+        dl(bf(tt(Ps = 46)) em(unimplemented))
+            ()
+P()\
+        dl(bf(tt(Ps = 47)) em(unimplemented))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Use Alternate Screen Buffer))\
+                row(cell(bf(tt(l)))cell(Use Normal Screen Buffer))\
+            endtable())\
+label(Priv66)   
+        dl(bf(tt(Ps = 66)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Application Keypad (DECPAM) == \
+                    link(tt(ESC =))(ESCequals)))\
+                row(cell(bf(tt(l)))cell(Normal Keypad (DECPNM) == \
+                    link(tt(ESC >))(ESCequals)))\
+            endtable())
+        dl(bf(tt(Ps = 67)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Backspace key sends bf(tt(BS) \
+		    (DECBKM))))\
+                row(cell(bf(tt(l)))cell(Backspace key sends bf(tt(DEL))))\
+            endtable())
+        dl(bf(tt(Ps = 1000)) (X11 XTerm link(mouse reporting)(Mouse)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Send Mouse X & Y on button press and \
+                    release.))\
+                row(cell(bf(tt(l)))cell(No mouse reporting.))\
+            endtable())
+        dl(bf(tt(Ps = 1001)) (X11 XTerm link(mouse tracking)(Mouse)) \
+            em(unimplemented))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Use Hilite Mouse Tracking.))\
+                row(cell(bf(tt(l)))cell(No mouse reporting.))\
+            endtable())
+        dl(bf(tt(Ps = 1010)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Don't scroll to bottom on TTY output))\
+                row(cell(bf(tt(l)))cell(Scroll to bottom on TTY output))\
+            endtable())
+        dl(bf(tt(Ps = 1011)))
+            (starttable(2)(l l)(0)\
+                row(cell(bf(tt(h)))cell(Scroll to bottom when a key is \
+		    pressed))\
+                row(cell(bf(tt(l)))cell(Don't scroll to bottom when a key is \
+                    pressed))\
+            endtable())
+   enddl()
+enddl()
+    
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef-sequences.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-sequences.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef-sequences.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-sequences.yo	1998-04-20 04:24:25.000000000 -0300
@@ -0,0 +1,77 @@
+COMMENT(-- $Id: rxvtRef-sequences.yo,v 1.2 1998/04/20 07:24:25 mason Exp $ --)
+label(Sequences)
+nsect(Escape Sequences)
+
+startdl()
+    dl(bf(tt(ESC # 8)))
+	(DEC Screen Alignment Test (DECALN))
+P()\
+    dl(bf(tt(ESC 7)nl()tt(ESC 8)))
+	(Save Cursor (SC)nl()Restore Cursor)\
+P()\
+label(ESCequals)
+    dl(bf(tt(ESC =)nl()tt(ESC >)))
+	(Application Keypad (SMKX) == link(tt(ESC[?66h))(Priv66)nl()\
+	Normal Keypad (RMKX) == link(tt(ESC[?66l))(Priv66))nl()\
+bf(Note:) If the numeric keypad is activated, eg, bf(Num_Lock) has been
+    pressed, numbers or control functions are generated by the numeric keypad
+    (see link(Key Codes)(KeyCodes))
+P()\
+    dl(bf(tt(ESC D)))
+	(Index (IND))
+P()\
+    dl(bf(tt(ESC E)))
+	(Next Line (NEL))
+P()\
+    dl(bf(tt(ESC H)))
+	(Tab Set (HTS))
+P()\
+    dl(bf(tt(ESC M)))
+	(Reverse Index (RI))
+P()\
+    dl(bf(tt(ESC N)))
+	(Single Shift Select of G2 Character Set (SS2): affects next character
+	only em(unimplemented))
+P()\
+    dl(bf(tt(ESC O)))
+    	(Single Shift Select of G3 Character Set (SS3): affects next character
+	only em(unimplemented))
+P()\
+    dl(bf(tt(ESC Z)))
+	(Obsolete form of link(tt(ESC[c))(ESCOBPsc) nl()\
+	returns: bf(tt(ESC[?1;2C)) em(rxvt compile-time option))
+P()\
+    dl(bf(tt(ESC c)))
+	(Full reset (RIS))
+P()\
+    dl(bf(tt(ESC n)))
+	(Invoke the G2 Character Set (LS2))
+P()\
+    dl(bf(tt(ESC o)))
+	(Invoke the G3 Character Set (LS3))
+P()\
+    dl(bf(tt(ESC )CHAR(40)tt( C)nl()tt(ESC )CHAR(41)tt( C)nl()tt(ESC * C)nl()\
+	tt(ESC + C)nl()tt(ESC $ C)))
+	(Designate G0 Character Set (ISO 2022)nl()\
+	Designate G1 Character Set (ISO 2022)nl()\
+	Designate G2 Character Set (ISO 2022)nl()\
+	Designate G3 Character Set (ISO 2022)nl()\
+	Designate Kanji Character Set nl()\
+	em(where) bf(tt(C)) is nl()\
+	starttable(2)(l l)(0)\
+	    row(cell(bf(tt(C = 0)))\
+		cell(DEC Special Character and Line Drawing Set))\
+	    row(cell(bf(tt(C = A)))\
+	    	cell(United Kingdom (UK)))\
+	    row(cell(bf(tt(C = B)))\
+	    	cell(United States (USASCII)))\
+	    row(cell(bf(tt(C = <)))\
+	    	cell(Multinational character set em(unimplemented)))\
+	    row(cell(bf(tt(C = 5)))\
+	    	cell(Finnish character set em(unimplemented)))\
+	    row(cell(bf(tt(C = C)))\
+	    	cell(Finnish character set em(unimplemented)))\
+	    row(cell(bf(tt(C = K)))\
+	    	cell(German character set em(unimplemented)))\
+	endtable())
+enddl()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef-values.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-values.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef-values.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-values.yo	1998-04-20 04:24:26.000000000 -0300
@@ -0,0 +1,41 @@
+COMMENT(-- $Id: rxvtRef-values.yo,v 1.2 1998/04/20 07:24:26 mason Exp $ --)
+label(Values)
+nsect(Values)
+
+startdl()
+    dl(bf(tt(ENQ)))
+	(Enquiry (Ctrl-E) = Send Device Attributes (DA) nl()\
+	request attributes from terminal == link(ESC[Psc)(ESCOBPsc))
+P()\
+    dl(bf(tt(BEL)))
+	(Bell (Ctrl-G))
+P()\
+    dl(bf(tt(BS)))
+	(Backspace (Ctrl-H))
+P()\
+    dl(bf(tt(TAB)))
+	(Horizontal Tab (HT) (Ctrl-I))
+P()\
+    dl(bf(tt(LF)))
+	(Line Feed or New Line (NL) (Ctrl-J))
+P()\
+    dl(bf(tt(VT)))
+	(Vertical Tab (Ctrl-K) same as bf(tt(LF)))
+P()\
+    dl(bf(tt(FF)))
+	(Form Feed or New Page (NP) (Ctrl-L) same as bf(tt(LF)))
+P()\
+    dl(bf(tt(CR)))
+	(Carriage Return (Ctrl-M))
+P()\
+    dl(bf(tt(SO)))
+	(Shift Out (Ctrl-N), invokes the G1 character set. nl()\
+	Switch to Alternate Character Set)
+P()\
+    dl(bf(tt(SI)))
+	(Shift In (Ctrl-O), invokes the G0 character set (the default) nl()\
+	Switch to Standard Character Set)
+P()\
+    dl(bf(tt(SPC)))
+	(Space Character)
+enddl()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef-xpm.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-xpm.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef-xpm.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-xpm.yo	1998-10-28 11:04:26.000000000 -0300
@@ -0,0 +1,47 @@
+COMMENT(-- $Id: rxvtRef-xpm.yo,v 1.6 1998/10/28 14:04:26 mason Exp $ --)
+label(XPM)
+nsect(XPM)
+
+For the XPM XTerm escape sequence bf(tt(ESC ] 20; Pt BEL)) then value of
+bf(tt(Pt)) can be the name of the background pixmap followed by a sequence of
+scaling/positioning commands separated by semi-colons. The scaling/positioning
+commands are as follows:
+
+startdl()
+    dl(query scale/position)
+	(bf(?))
+P()\
+    dl(change scale and position)
+	(bf(WxH+X+Y)nl()\
+	 bf(WxH+X) (== bf(WxH+X+X))nl()\
+	 bf(WxH) (same as bf(WxH+50+50))nl()\
+	 bf(W+X+Y) (same as bf(WxW+X+Y))nl()\
+	 bf(W+X) (same as bf(WxW+X+X))nl()\
+	 bf(W) (same as bf(WxW+50+50)))
+P()\
+    dl(change position (absolute))
+	(bf(=+X+Y)nl()\
+	bf(=+X) (same as bf(=+X+Y)))
+P()\
+    dl(change position (relative))
+	(bf(+X+Y)nl()\
+	bf(+X) (same as bf(+X+Y)))
+P()\
+    dl(rescale (relative))
+	(bf(Wx0) -> bf(W *= (W/100))nl()\
+	bf(0xH) -> bf(H *= (H/100)))
+enddl()
+
+For example:
+
+startdl()
+    dl(bf(\E]20;funky\a))
+	(load bf(funky.xpm) as a tiled image)
+P()\
+    dl(bf(\E]20;mona;100\a))
+	(load bf(mona.xpm) with a scaling of 100%)
+P()\
+    dl(bf(\E]20;;200;?\a))
+	(rescale the current pixmap to 200% and display the image geometry in \
+	the title)
+enddl()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef-xterm.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-xterm.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef-xterm.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef-xterm.yo	1998-04-20 04:24:26.000000000 -0300
@@ -0,0 +1,40 @@
+COMMENT(-- $Id: rxvtRef-xterm.yo,v 1.2 1998/04/20 07:24:26 mason Exp $ --)
+label(XTerm)
+nsect(XTerm Escape Sequences)
+
+startdl()
+    dl(bf(tt(ESC ] Ps;Pt BEL)))
+	(Set XTerm Parameters nl()\
+	starttable(2)(l l)(0)\
+	    row(cell(bf(tt(Ps = 0)))\
+		cell(Change Icon Name and Window Title to bf(tt(Pt))))\
+	    row(cell(bf(tt(Ps = 1)))\
+		cell(Change Icon Name to bf(tt(Pt))))\
+	    row(cell(bf(tt(Ps = 2)))\
+		cell(Change Window Title to bf(tt(Pt))))\
+	    row(cell(bf(tt(Ps = 10)))\
+		cell(link(menuBar)(menuBar) command bf(tt(Pt)) \
+		    em(rxvt compile-time option)))\
+	    row(cell(bf(tt(Ps = 20)))\
+		cell(Change default background link(pixmap)(XPM) to \
+		    bf(tt(Pt))))\
+	    row(cell(bf(tt(Ps = 39)))\
+		cell(Change default foreground colour to bf(tt(Pt)) \
+		    em(rxvt compile-time option)))\
+	    row(cell(bf(tt(Ps = 46)))\
+		cell(Change Log File to bf(tt(Pt)) \
+		    em(unimplemented)))\
+	    row(cell(bf(tt(Ps = 49)))\
+		cell(Change default background colour to bf(tt(Pt)) \
+		    em(rxvt compile-time option)))\
+	    row(cell(bf(tt(Ps = 50)))\
+		cell(Set Font to bf(tt(Pt)), with the following special \
+		    values of \
+		    bf(tt(Pt)) (bf(rxvt)) nl()\
+		    bf(tt(#+n)) change up bf(tt(n)) font(s) nl()\
+		    bf(tt(#-n)) change down bf(tt(n)) font(s) nl()\
+		    if bf(tt(n)) is missing of 0, a value of 1 is used nl()\
+		    em(empty) change to font0 nl()\
+		    bf(tt(n)) change to font bf(tt(n))))\
+	endtable())
+enddl()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef.yo	2007-01-15 18:03:53.000000000 -0300
@@ -0,0 +1,67 @@
+COMMENT(-- $Id: rxvtRef.yo.in,v 1.2 1998/10/22 02:47:05 mason Exp $ --)
+mailto(gcw@pobox.com)
+htmlbodyopt(BGCOLOR)(#FFFFFF)
+notableofcontents()
+article(Rxvt Technical Reference)
+       (Geoff Wing (gcw@pobox.com))
+       (18 April 1998)
+label(toc)
+COMMENT(-----------------------------------------------------------------------
+-- Originally written: Mark Olesen, Fri Feb 14 14:16:00 1997
+-- Converted to yodl: Geoff Wing
+------------------------------------------------------------------------------)
+COMMENT(---
+  <meta name="Author" content="mj olesen <olesen@me.queensu.ca>">
+  <meta name="Description" content="Documentation of VT, XTerm, and other escape sequences used by rxvt.">
+---)
+CHDIR(yodl)
+CHDIR(.)
+includefile(masonyodl.yo)
+
+startit()
+    it()link(Definitions)(Definitions)
+    it()link(Values)(Values)
+    it()link(Escape Sequences)(Sequences)
+    it()link(CSI (Code Sequence Introducer) Sequences)(CSI)
+    it()link(DEC Private Modes)(PrivateModes)
+    it()link(XTerm Escape Sequences)(XTerm)
+    it()link(menuBar)(menuBar)
+    it()link(XPM)(XPM)
+    it()link(Mouse Reporting)(Mouse)
+    it()link(Special Graphics Mode)(Graphics)
+    it()link(Key Codes)(KeyCodes)
+endit()
+
+Reworked from XTerm documentation and other sources
+includefile(rxvtRef-definitions.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-values.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-sequences.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-csi.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-privatemodes.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-xterm.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-menubar.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-xpm.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-mouse.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-graphics.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-keycodes.yo)
+link(Top)(toc)
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvtRef.yo.in work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef.yo.in
--- tmp/rxvt-2.6.4/doc/yodl/rxvtRef.yo.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvtRef.yo.in	1998-10-21 23:47:05.000000000 -0300
@@ -0,0 +1,67 @@
+COMMENT(-- $Id: rxvtRef.yo.in,v 1.2 1998/10/22 02:47:05 mason Exp $ --)
+mailto(gcw@pobox.com)
+htmlbodyopt(BGCOLOR)(#FFFFFF)
+notableofcontents()
+article(Rxvt Technical Reference)
+       (Geoff Wing (gcw@pobox.com))
+       (18 April 1998)
+label(toc)
+COMMENT(-----------------------------------------------------------------------
+-- Originally written: Mark Olesen, Fri Feb 14 14:16:00 1997
+-- Converted to yodl: Geoff Wing
+------------------------------------------------------------------------------)
+COMMENT(---
+  <meta name="Author" content="mj olesen <olesen@me.queensu.ca>">
+  <meta name="Description" content="Documentation of VT, XTerm, and other escape sequences used by rxvt.">
+---)
+CHDIR(yodl)
+CHDIR(@srcdir@)
+includefile(masonyodl.yo)
+
+startit()
+    it()link(Definitions)(Definitions)
+    it()link(Values)(Values)
+    it()link(Escape Sequences)(Sequences)
+    it()link(CSI (Code Sequence Introducer) Sequences)(CSI)
+    it()link(DEC Private Modes)(PrivateModes)
+    it()link(XTerm Escape Sequences)(XTerm)
+    it()link(menuBar)(menuBar)
+    it()link(XPM)(XPM)
+    it()link(Mouse Reporting)(Mouse)
+    it()link(Special Graphics Mode)(Graphics)
+    it()link(Key Codes)(KeyCodes)
+endit()
+
+Reworked from XTerm documentation and other sources
+includefile(rxvtRef-definitions.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-values.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-sequences.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-csi.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-privatemodes.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-xterm.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-menubar.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-xpm.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-mouse.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-graphics.yo)
+link(Top)(toc)
+clearpage()
+includefile(rxvtRef-keycodes.yo)
+link(Top)(toc)
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt-resources.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvt-resources.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvt-resources.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt-resources.yo	2000-07-05 05:04:14.000000000 -0300
@@ -0,0 +1,244 @@
+COMMENT(-- $Id: rxvt-resources.yo,v 1.14.2.3 2000/07/05 08:04:14 gcw Exp $ --)
+COMMENT(----------------------------------------------------------------------)
+manpagesection(RESOURCES (available also as long-options))
+
+Note: `rxvt --help' gives a list of all resources (long options) compiled
+into your version.
+If compiled with internal Xresources support (i.e. bf(rxvt -h) lists 
+bf(.Xdefaults)) then bf(rxvt) accepts application defaults set in
+XAPPLOADDIR/Rxvt (compile-time defined: usually
+bf(/usr/lib/X11/app-defaults/Rxvt)) and resources set in bf(~/.Xdefaults),
+or bf(~/.Xresources) if bf(~/.Xdefaults) does not exist.  Note that when
+reading X resources, bf(rxvt) recognizes two class names: bf(XTerm) and
+bf(Rxvt).  The class name bf(XTerm) allows resources common to both
+bf(rxvt) and em(xterm) to be easily configured, while the class name
+bf(Rxvt) allows resources unique to bf(rxvt), notably colours and
+key-handling, to be shared between different bf(rxvt) configurations. 
+If no resources are specified, suitable defaults will be used. 
+Command-line arguments can be used to override resource settings.  The
+following resources are allowed:
+
+startdit()
+    dit(bf(geometry:) em(geom))
+	Create the window with the specified X window geometry [default
+	80x24];
+	option bf(-geometry).
+    dit(bf(background:) em(colour))
+	Use the specified colour as the window's background colour [default
+	White];
+	option bf(-bg).
+    dit(bf(foreground:) em(colour))
+	Use the specified colour as the window's foreground colour [default
+	Black];
+	option bf(-fg).
+    dit(bf(color)em(n)bf(:) em(colour))
+	Use the specified colour for the colour value em(n), where 0-7
+	corresponds to low-intensity (normal) colours and 8-15 corresponds to
+	high-intensity (bold = bright foreground, blink = bright
+	background) colours.  The canonical names are as follows:
+	0=black, 1=red, 2=green, 3=yellow, 4=blue, 5=magenta, 6=cyan, 7=white,
+	but the actual colour names used are listed in the
+	bf(COLORS AND GRAPHICS) section.
+    dit(bf(colorBD:) em(colour))
+	Use the specified colour to display bold characters when the
+	foreground colour is the default.
+    dit(bf(colorUL:) em(colour))
+	Use the specified colour to display underlined characters when the
+	foreground colour is the default.
+    dit(bf(cursorColor:) em(colour))
+	Use the specified colour for the cursor.  The default is to use the
+	foreground colour;
+	option bf(-cr).
+    dit(bf(cursorColor2:) em(colour))
+	Use the specified colour for the colour of the cursor text.  For this
+	to take effect, bf(cursorColor) must also be specified.  The default
+	is to use the background colour.
+    dit(bf(reverseVideo:) em(boolean))
+	bf(True): simulate reverse video by foreground and background colours;
+	option bf(-rv),
+	bf(False): regular screen colours [default];
+	option bf(+rv).
+	See note in bf(COLORS AND GRAPHICS) section.
+    dit(bf(inheritPixmap:) em(boolean))
+	bf(True): make the background inherit the parent windows' pixmap,
+	giving artificial transparency.
+	bf(False): do not inherit the parent windows' pixmap.
+    dit(bf(scrollColor:) em(colour))
+	Use the specified colour for the scrollbar [default #B2B2B2].
+    dit(bf(troughColor:) em(colour))
+	Use the specified colour for the scrollbar's trough area [default
+	#969696].  Only relevant for normal (non XTerm/NeXT) scrollbar.
+    dit(bf(backgroundPixmap:) em(file[;geom]))
+	Use the specified XPM file (note the `.xpm' extension is optional)
+	for the background and also optionally specify its scaling with a
+	geometry string bf(WxH+X+Y), in which bf("W" / "H") specify the
+	horizontal/vertical scale (percent) and bf("X" / "Y") locate the
+	image centre (percent).  A scale of 0 displays the image with tiling.
+	A scale of 1 displays the image without any scaling.  A scale of 2 to
+	9 specifies an integer number of images in that direction.  No image
+	will be magnified beyond 10 times its original size.  The maximum
+	permitted scale is 1000.  [default 0x0+50+50]
+    dit(bf(menu:) em(file[;tag]))
+	Read in the specified menu file (note the `.menu' extension is
+	optional) and also optionally specify a starting tag to find.  See
+	the reference documentation for details on the syntax for the menuBar.
+    dit(bf(path:) em(path))
+	Specify the colon-delimited search path for finding files (XPM and
+	menus), in addition to the paths specified by the bf(RXVTPATH) and
+	bf(PATH) environment variables.
+    dit(bf(font:) em(fontname))
+	Select the main text font used [default 7x14];
+	option bf(-fn).
+    dit(bf(font)em(n)bf(:) em(fontname))
+	Specify the alternative font em(n).  The default font values: nl()\
+	indent(\
+	    starttable(2)(l l)(0)\
+		row(cell(bf(font):)cell(7x14))\
+		row(cell(bf(font1):)cell(6x10))\
+		row(cell(bf(font2):)cell(6x13))\
+		row(cell(bf(font3):)cell(8x13))\
+		row(cell(bf(font4):)cell(9x15))\
+	    endtable())
+
+    dit(bf(boldFont:) em(fontname))
+	Specify the name of the bold font to use if bf(colorBD) has not been
+	specified and it is not possible to map the default foreground colour
+	to colour 8-15 [default NONE].  This font must be the same height and
+	width as the normal font;
+	option bf(-fb).
+    dit(bf(mfont:) em(fontname))
+	Select the main multiple-character text font used [default k14];
+	option bf(-fk).
+    dit(bf(mfont)em(n)bf(:) em(fontname))
+	Specify the alternative multiple-character font em(n).  If compiled
+	for multiple-character fonts, the Roman and multiple-character font
+	sizes should match.
+    dit(bf(multichar_encoding:) em(mode))
+	Set the encoding mode to be used when multicharacter encoding is
+	received;
+	bf(eucj): EUC Japanese encoding [default for Kanji].
+	bf(sjis): Shift JIS encoding.
+	bf(big5): BIG5 encoding.
+	bf(gb): GB encoding;
+	option bf(-km).
+    dit(bf(greek_keyboard:) em(mode))
+	Set the Greek keyboard translation mode to be used;
+	bf(iso): ISO-8859 mapping (elot-928) [default].
+	bf(ibm): IBM-437 mapping (DOS codepage 737);
+	option bf(-grk).
+	Use bf(Mode_switch) to toggle keyboard input.  For more details,
+	see the distributed file bf(README.greek).
+    dit(bf(selectstyle:) em(text))
+	Set mouse selection style to bf(old) which is 2.20, bf(oldword) which
+	is xterm style with 2.20 old word selection, or anything else which
+	gives xterm style selection.
+    dit(bf(title:) em(text))
+	Set window title string, the default title is the command-line
+	specified after the bf(-e) option, if any, otherwise the application
+	name;
+	option bf(-title).
+    dit(bf(iconName:) em(text))
+	Set the name used to label the window's icon or displayed in an icon
+	manager window, it also sets the window's title unless it is
+	explicitly set;
+	option bf(-n).
+    dit(bf(mapAlert:) em(boolean))
+	bf(True): de-iconify (map) on receipt of a bell character.
+	bf(False): no de-iconify (map) on receipt of a bell character
+	[default].
+    dit(bf(visualBell:) em(boolean))
+	bf(True): use visual bell on receipt of a bell character;
+	option bf(-vb).
+	bf(False): no visual bell [default];
+	option bf(+vb).
+    dit(bf(loginShell:) em(boolean))
+	bf(True): start as a login shell by prepending a `-' to bf(argv[0])
+	of the shell;
+	option bf(-ls).
+	bf(False): start as a normal sub-shell [default];
+	option bf(+ls).
+    dit(bf(utmpInhibit:) em(boolean))
+	bf(True): inhibit writing record into the system log file bf(utmp);
+	option bf(-ut).
+	bf(False): write record into the system log file bf(utmp) [default];
+	option bf(+ut).
+    dit(bf(print-pipe:) em(string))
+	Specify a command pipe for vt100 printer [default em(lpr(1))].  Use
+	bf(Print) to initiate a screen dump to the printer and bf(Ctrl-Print)
+	or bf(Shift-Print) to include the scrollback as well.
+    dit(bf(scrollBar:) em(boolean))
+	bf(True): enable the scrollbar [default];
+	option bf(-sb).
+	bf(False): disable the scrollbar;
+	option bf(+sb).
+    dit(bf(scrollBar_right:) em(boolean))
+	bf(True): place the scrollbar on the right of the window;
+	option bf(-sr).
+	bf(False): place the scrollbar on the left of the window;
+	option bf(+sr).
+    dit(bf(scrollBar_floating:) em(boolean))
+	bf(True): display an rxvt scrollbar without a trough;
+	option bf(-st).
+	bf(False): display an rxvt scrollbar with a trough;
+	option bf(+st).
+    dit(bf(scrollTtyOutput:) em(boolean))
+	bf(True): scroll to bottom when tty receives output;
+	option(+si).
+	bf(False): do not scroll to bottom when tty receives output;
+	option(-si).
+    dit(bf(scrollTtyKeypress:) em(boolean))
+	bf(True): scroll to bottom when a non-special key is pressed.
+	Special keys are those which are intercepted by rxvt for special
+	handling and are not passed onto the shell;
+	option(-sk).
+	bf(False): do not scroll to bottom when a non-special key is pressed;
+	option(+sk).
+    dit(bf(smallfont_key:) em(keysym))
+	If enabled, use bf(HOTKEY()-)em(keysym) to toggle to a smaller font
+	[default bf(HOTKEY()-SMALLFONT())]
+    dit(bf(bigfont_key:) em(keysym))
+	If enabled, use bf(HOTKEY()-)em(keysym) to toggle to a bigger font
+	[default bf(HOTKEY()-BIGFONT())]
+    dit(bf(saveLines:) em(number))
+	Save em(number) lines in the scrollback buffer [default 64];
+	option bf(-sl).
+    dit(bf(termName:) em(termname))
+	Specifies the terminal type name to be set in the bf(TERM)
+	environment variable;
+	option bf(-tn).
+    dit(bf(meta8:) em(boolean))
+	bf(True): handle Meta (Alt) + keypress to set the 8th bit.
+	bf(False): handle Meta (Alt) + keypress as an escape prefix [default].
+    dit(bf(backspacekey:) em(string))
+	The string to send when the backspace key is pressed.  If set to
+	bf(DEC) or unset it will send bf(Delete) (code 127) or, if shifted,
+	bf(Backspace) (code 8) - which can be reversed with the appropriate
+	DEC private mode escape sequence.
+    dit(bf(deletekey:) em(string))
+	The string to send when the delete key (not the keypad delete key) is
+	pressed.  If unset it will send the sequence traditionally associated
+	with the bf(Execute) key.
+    dit(bf(cutchars:) em(string))
+	The characters used as delimiters for double-click word selection. 
+	The built-in default: nl()\
+	bf(BACKSLASH `"'&()*,;<=>?@[]{|})
+    dit(bf(preeditType:) em(style))
+	bf(OverTheSpot), bf(OffTheSpot), bf(Root);
+	option bf(-pt).
+    dit(bf(inputMethod:) em(name))
+	em(name) of inputMethod to use;
+	option bf(-im).
+    dit(bf(modifier:) em(modifier))
+	Set the key to be interpreted as the Meta key to:
+	bf(alt), bf(meta), bf(hyper), bf(super), bf(mod1), bf(mod2), bf(mod3),
+	bf(mod4), bf(mod5);
+	option bf(-mod).
+    dit(bf(keysym.)em(sym): em(string))
+	Associate em(string) with keysym em(sym) (bf(0xFF00 - 0xFFFF)).  It
+	may contain escape values (\a: bell, \b: backspace, \e, \E: escape,
+	\n: newline, \r: return, \t: tab, \000: octal number) or control
+	characters (^?: delete, ^@: null, ^A ...) and may enclosed with
+	double quotes so that it can start or end with whitespace.  The
+	intervening resource name bf(keysym.) cannot be omitted.  This
+	resource is only available when compiled with KEYSYM_RESOURCE.
+enddit()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt-scrollbar.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvt-scrollbar.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvt-scrollbar.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt-scrollbar.yo	1998-04-20 04:24:23.000000000 -0300
@@ -0,0 +1,13 @@
+COMMENT(-- $Id: rxvt-scrollbar.yo,v 1.2 1998/04/20 07:24:23 mason Exp $ --)
+COMMENT(----------------------------------------------------------------------)
+manpagesection(THE SCROLLBAR)
+
+Lines of text that scroll off the top of the bf(rxvt) window (resource:
+bf(saveLines)) and can be scrolled back using the scrollbar or by keystrokes. 
+The normal bf(rxvt) scrollbar has arrows and its behaviour is fairly
+intuitive.  The bf(xterm-scrollbar) is without arrows and its behaviour
+mimics that of em(xterm)
+
+Scroll down with bf(Button1) (bf(xterm-scrollbar)) or bf(Shift-Next).
+Scroll up with bf(Button3) (bf(xterm-scrollbar)) or bf(Shift-Prior).
+Continuous scroll with bf(Button2).
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt-textselection.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvt-textselection.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvt-textselection.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt-textselection.yo	1998-04-20 04:24:23.000000000 -0300
@@ -0,0 +1,19 @@
+COMMENT(-- $Id: rxvt-textselection.yo,v 1.2 1998/04/20 07:24:23 mason Exp $ --)
+COMMENT(----------------------------------------------------------------------)
+manpagesection(TEXT SELECTION AND INSERTION)
+
+The behaviour of text selection and insertion mechanism is similar to
+em(xterm)(1).
+
+startdit()
+    dit(bf(Selection):)
+	Left click at the beginning of the region, drag to the end of the
+	region and release; Right click to extend the marked region;
+	Left double-click to select a word; Left triple-click to select
+	the entire line.
+
+    dit(bf(Insertion):)
+	Pressing and releasing the Middle mouse button (or bf(Shift-Insert))
+	in an bf(rxvt) window causes the current text selection to be inserted
+	as if it had been typed on the keyboard.
+enddit()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt.yo work/main.d/rxvt-2.6.4/doc/yodl/rxvt.yo
--- tmp/rxvt-2.6.4/doc/yodl/rxvt.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt.yo	2007-01-15 18:03:53.000000000 -0300
@@ -0,0 +1,119 @@
+COMMENT(-- $Id: rxvt.yo.in,v 1.2.4.1 2000/07/21 01:44:23 gcw Exp $ --)
+CHDIR(yodl)
+includefile(versioninfo.yo)
+CHDIR(.)
+includefile(masonyodl.yo)
+mailto(gcw@pobox.com)
+
+DEFINEMACRO(HOTKEY)(0)(Alt)
+DEFINEMACRO(BIGFONT)(0)(>)
+DEFINEMACRO(SMALLFONT)(0)(<)
+
+COMMENT(-----------------------------------------------------------------------
+-- We want the following macro's to be pre-defined
+--  RXVTDATE()
+--  RXVTVERSION()
+--  RXVTMAINT()
+--  RXVTMAINTEMAIL()
+--  RXVTWEBPAGE()
+--  RXVTWEBMAINT()
+--  RXVTWEBMAINTEMAIL()
+--  RXVTFTPSITE()
+------------------------------------------------------------------------------)
+
+COMMENT(----------------------------------------------------------------------)
+manpage(1)(RXVT)(RXVTDATE())(X Version 11)(X Tools)
+manpagename(rxvt (ouR XVT))(a VT102 emulator for the X window system)
+
+COMMENT(----------------------------------------------------------------------)
+manpagesynopsis()
+
+bf(rxvt) [options] [-e command [ args ]]
+
+COMMENT(----------------------------------------------------------------------)
+manpagedescription()
+
+bf(rxvt), version bf(RXVTVERSION()), is a colour vt102 terminal emulator
+intended as an em(xterm)(1) replacement for users who do not require
+features such as Tektronix 4014 emulation and toolkit-style configurability.
+As a result, bf(rxvt) uses much less swap space -- a significant
+advantage on a machine serving many X sessions.
+
+COMMENT(----------------------------------------------------------------------)
+
+includefile(rxvt-options.yo)
+includefile(rxvt-resources.yo)
+includefile(rxvt-scrollbar.yo)
+includefile(rxvt-mousereporting.yo)
+includefile(rxvt-textselection.yo)
+includefile(rxvt-fonts.yo)
+includefile(rxvt-login.yo)
+includefile(rxvt-colours.yo)
+includefile(rxvt-environment.yo)
+includefile(rxvt-files.yo)
+
+COMMENT(----------------------------------------------------------------------)
+manpageseealso()
+
+em(xterm)(1), em(sh)(1), em(resize)(1), em(X)(1), em(pty)(4), em(tty)(4),
+em(utmp)(5)
+
+See rxvtRef.html rxvtRef.txt for detailed information on recognized escape
+sequences and menuBar syntax, etc.
+
+COMMENT(----------------------------------------------------------------------)
+manpagebugs()
+
+Check the BUGS file for an up-to-date list.
+
+Cursor change support is not yet implemented.
+
+Click-and-drag doesn't work with X11 mouse report overriding.
+
+Graphics support is fairly crude.
+
+
+COMMENT(----------------------------------------------------------------------)
+manpagesection(FTP LOCATION)
+
+rxvt-+RXVTVERSION().tar.gz can be found at the following ftp sites
+url(RXVTFTPSITE())(RXVTFTPSITE())
+
+COMMENT(----------------------------------------------------------------------)
+manpagesection(CURRENT PROJECT COORDINATOR)
+
+startdit()
+    dit(Project Coordinator)
+	RXVTMAINT() email(RXVTMAINTEMAIL())nl()\
+    dit(Web page maintainter)
+	RXVTWEBMAINT() email(RXVTWEBMAINTEMAIL())nl()\
+	url(RXVTWEBPAGE())(RXVTWEBPAGE())nl()\
+    dit(Mailing list)
+	The Rxvt Workers email(<rxvt-workers@rxvt.org>)
+	mailing list has also been established for rxvt development, to
+	subscribe, email to 
+	email(<rxvt-workers-subscribe@rxvt.org>).
+	There is also a mailing list for announcements of new releases of
+	rxvt. To subscribe, email to
+	email(<rxvt-announce-subscribe@rxvt.org>).
+enddit()
+
+COMMENT(----------------------------------------------------------------------)
+manpageauthors()
+
+startdit()
+    dit(John Bovey)
+	University of Kent, 1992, wrote the original Xvt.
+    dit(Rob Nation email(<nation@rocket.sanders.lockheed.com>))
+	very heavily modified Xvt and came up with Rxvt
+    dit(Angelo Haritsis email(<ah@doc.ic.ac.uk>))
+	wrote the Greek Keyboard Input
+    dit(mj olesen email(<olesen@me.QueensU.CA>))
+	Wrote the menu system. nl()\
+	Project Coordinator (changes.txt 2.11 to 2.21)
+    dit(Oezguer Kesim email(<kesim@math.fu-berlin.de>))
+	Project Coordinator (changes.txt 2.21a to 2.4.5)
+    dit(Geoff Wing email(<gcw@pobox.com>))
+	Rewrote screen display and text selection routines. nl()\
+	Project Coordinator (changes.txt 2.4.6 - )
+enddit()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/rxvt.yo.in work/main.d/rxvt-2.6.4/doc/yodl/rxvt.yo.in
--- tmp/rxvt-2.6.4/doc/yodl/rxvt.yo.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/rxvt.yo.in	2000-07-20 22:44:23.000000000 -0300
@@ -0,0 +1,119 @@
+COMMENT(-- $Id: rxvt.yo.in,v 1.2.4.1 2000/07/21 01:44:23 gcw Exp $ --)
+CHDIR(yodl)
+includefile(versioninfo.yo)
+CHDIR(@srcdir@)
+includefile(masonyodl.yo)
+mailto(gcw@pobox.com)
+
+DEFINEMACRO(HOTKEY)(0)(Alt)
+DEFINEMACRO(BIGFONT)(0)(>)
+DEFINEMACRO(SMALLFONT)(0)(<)
+
+COMMENT(-----------------------------------------------------------------------
+-- We want the following macro's to be pre-defined
+--  RXVTDATE()
+--  RXVTVERSION()
+--  RXVTMAINT()
+--  RXVTMAINTEMAIL()
+--  RXVTWEBPAGE()
+--  RXVTWEBMAINT()
+--  RXVTWEBMAINTEMAIL()
+--  RXVTFTPSITE()
+------------------------------------------------------------------------------)
+
+COMMENT(----------------------------------------------------------------------)
+manpage(1)(RXVT)(RXVTDATE())(X Version 11)(X Tools)
+manpagename(rxvt (ouR XVT))(a VT102 emulator for the X window system)
+
+COMMENT(----------------------------------------------------------------------)
+manpagesynopsis()
+
+bf(rxvt) [options] [-e command [ args ]]
+
+COMMENT(----------------------------------------------------------------------)
+manpagedescription()
+
+bf(rxvt), version bf(RXVTVERSION()), is a colour vt102 terminal emulator
+intended as an em(xterm)(1) replacement for users who do not require
+features such as Tektronix 4014 emulation and toolkit-style configurability.
+As a result, bf(rxvt) uses much less swap space -- a significant
+advantage on a machine serving many X sessions.
+
+COMMENT(----------------------------------------------------------------------)
+
+includefile(rxvt-options.yo)
+includefile(rxvt-resources.yo)
+includefile(rxvt-scrollbar.yo)
+includefile(rxvt-mousereporting.yo)
+includefile(rxvt-textselection.yo)
+includefile(rxvt-fonts.yo)
+includefile(rxvt-login.yo)
+includefile(rxvt-colours.yo)
+includefile(rxvt-environment.yo)
+includefile(rxvt-files.yo)
+
+COMMENT(----------------------------------------------------------------------)
+manpageseealso()
+
+em(xterm)(1), em(sh)(1), em(resize)(1), em(X)(1), em(pty)(4), em(tty)(4),
+em(utmp)(5)
+
+See rxvtRef.html rxvtRef.txt for detailed information on recognized escape
+sequences and menuBar syntax, etc.
+
+COMMENT(----------------------------------------------------------------------)
+manpagebugs()
+
+Check the BUGS file for an up-to-date list.
+
+Cursor change support is not yet implemented.
+
+Click-and-drag doesn't work with X11 mouse report overriding.
+
+Graphics support is fairly crude.
+
+
+COMMENT(----------------------------------------------------------------------)
+manpagesection(FTP LOCATION)
+
+rxvt-+RXVTVERSION().tar.gz can be found at the following ftp sites
+url(RXVTFTPSITE())(RXVTFTPSITE())
+
+COMMENT(----------------------------------------------------------------------)
+manpagesection(CURRENT PROJECT COORDINATOR)
+
+startdit()
+    dit(Project Coordinator)
+	RXVTMAINT() email(RXVTMAINTEMAIL())nl()\
+    dit(Web page maintainter)
+	RXVTWEBMAINT() email(RXVTWEBMAINTEMAIL())nl()\
+	url(RXVTWEBPAGE())(RXVTWEBPAGE())nl()\
+    dit(Mailing list)
+	The Rxvt Workers email(<rxvt-workers@rxvt.org>)
+	mailing list has also been established for rxvt development, to
+	subscribe, email to 
+	email(<rxvt-workers-subscribe@rxvt.org>).
+	There is also a mailing list for announcements of new releases of
+	rxvt. To subscribe, email to
+	email(<rxvt-announce-subscribe@rxvt.org>).
+enddit()
+
+COMMENT(----------------------------------------------------------------------)
+manpageauthors()
+
+startdit()
+    dit(John Bovey)
+	University of Kent, 1992, wrote the original Xvt.
+    dit(Rob Nation email(<nation@rocket.sanders.lockheed.com>))
+	very heavily modified Xvt and came up with Rxvt
+    dit(Angelo Haritsis email(<ah@doc.ic.ac.uk>))
+	wrote the Greek Keyboard Input
+    dit(mj olesen email(<olesen@me.QueensU.CA>))
+	Wrote the menu system. nl()\
+	Project Coordinator (changes.txt 2.11 to 2.21)
+    dit(Oezguer Kesim email(<kesim@math.fu-berlin.de>))
+	Project Coordinator (changes.txt 2.21a to 2.4.5)
+    dit(Geoff Wing email(<gcw@pobox.com>))
+	Rewrote screen display and text selection routines. nl()\
+	Project Coordinator (changes.txt 2.4.6 - )
+enddit()
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/versioninfo.yo work/main.d/rxvt-2.6.4/doc/yodl/versioninfo.yo
--- tmp/rxvt-2.6.4/doc/yodl/versioninfo.yo	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/versioninfo.yo	2001-11-01 21:28:32.000000000 -0300
@@ -0,0 +1,17 @@
+COMMENT(-- $Id: versioninfo.yo.in,v 1.2 1998/04/20 07:24:27 mason Exp $ --)
+DEFINEMACRO(RXVTDATE)(0)
+	(02 NOVEMBER 2001)
+DEFINEMACRO(RXVTVERSION)(0)
+	(2.6.4)
+DEFINEMACRO(RXVTMAINT)(0)
+	(Geoff Wing)
+DEFINEMACRO(RXVTMAINTEMAIL)(0)
+	(<gcw@rxvt.org>)
+DEFINEMACRO(RXVTWEBMAINT)(0)
+	(Oezguer Kesim)
+DEFINEMACRO(RXVTWEBMAINTEMAIL)(0)
+	(<oec@rxvt.org>)
+DEFINEMACRO(RXVTWEBPAGE)(0)
+	(<http://www.rxvt.org/>)
+DEFINEMACRO(RXVTFTPSITE)(0)
+	(ftp://ftp.rxvt.org/pub/rxvt)
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/doc/yodl/versioninfo.yo.in work/main.d/rxvt-2.6.4/doc/yodl/versioninfo.yo.in
--- tmp/rxvt-2.6.4/doc/yodl/versioninfo.yo.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/doc/yodl/versioninfo.yo.in	1998-04-20 04:24:27.000000000 -0300
@@ -0,0 +1,17 @@
+COMMENT(-- $Id: versioninfo.yo.in,v 1.2 1998/04/20 07:24:27 mason Exp $ --)
+DEFINEMACRO(RXVTDATE)(0)
+	(@RXVT_DATE@)
+DEFINEMACRO(RXVTVERSION)(0)
+	(@RXVT_VERSION@)
+DEFINEMACRO(RXVTMAINT)(0)
+	(@RXVT_MAINT@)
+DEFINEMACRO(RXVTMAINTEMAIL)(0)
+	(@RXVT_MAINTEMAIL@)
+DEFINEMACRO(RXVTWEBMAINT)(0)
+	(@RXVT_WEBMAINT@)
+DEFINEMACRO(RXVTWEBMAINTEMAIL)(0)
+	(@RXVT_WEBMAINTEMAIL@)
+DEFINEMACRO(RXVTWEBPAGE)(0)
+	(@RXVT_WEBPAGE@)
+DEFINEMACRO(RXVTFTPSITE)(0)
+	(ftp://@RXVT_FTPSITENAME@@RXVT_FTPSITEDIR@)
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/INSTALL work/main.d/rxvt-2.6.4/INSTALL
--- tmp/rxvt-2.6.4/INSTALL	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/INSTALL	1998-09-22 15:02:27.000000000 -0300
@@ -0,0 +1,76 @@
+--------------------------------------------------------------------------
+Using GNU autoconfig
+--------------------------------------------------------------------------
+  1.	Run   ./configure   to generate config.h and the various Makefiles.
+	./configure --help   gives a list of possible options with slightly
+	longer descriptions in README.configure
+
+	Some systems require unusual options for compilation or linking that
+	the `configure' script does not know about.  You can give `configure'
+	initial values for variables by setting them in the environment.  Using
+	a Bourne-compatible shell, you can do that on the command line like
+	this:
+	        CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure
+	Or on systems that have the `env' program, you can do it like this:
+		env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure
+	Or if you're using a non Bourne-compatible shell, you can do:
+		sh -c 'CFLAGS="-O2 -g" ./configure
+
+  2.	set any other main preferences:
+    	    Edit "src/feature.h"
+	    Edit "config.h"   if you didn't use ./configure options
+	    If you're cross-compiling, edit the following in "config.h"
+		NO_XLOCALE
+		SIZEOF_*	# sizeof some types
+		R*INT*T		# types which are the same size
+				# as 16bit/32bit/pointer
+
+  3.	Build it (repeat step 2 as desired):
+	    make
+
+  4.	build rclock (small xclock with biff & appointments) and
+	optionally edit rclock/feature.h to add/remove features:
+	    make clock
+
+  5. 	Install both rxvt and rclock:
+	    make install
+
+	or install them separately
+	    (cd src; make install)
+	    (cd rclock; make install)
+
+	you may also want to install doc/etc/rxvt.terminfo and 
+	doc/etc/rxvt.termcap
+
+  6 a.	If compiled with UTMP_SUPPORT, you may need to install rxvt setuid
+	root or setuid/setgid to match the file permissions on /etc/utmp
+  6 b.  You may need to install setuid root anyway for some systems so that
+	they can give you ownership of the tty devices.
+
+  7.	On systems which dislike doc/rxvt.1
+	    (cd doc; rm rxvt.1; make rxvt.1)
+  	
+		 ===================================
+
+NB:	SunOS (with/without gcc?) gets reported by configure as
+
+		#undef STDC_HEADERS
+		#define HAVE_SYS_IOCTL_H 1
+
+	but the ioctl() defines aren't protected against multiple
+	inclusion, in this case by <termios.h> so use a hack in
+	"feature.h" to avoid the problem.
+
+	Gave up checking for `STDC_HEADERS', since they really should be
+	there and I don't want to deal with the problems when they don't
+	exist.
+
+	SunOS users might complain to the right places and get their
+	system headers fixed so that one day the rest of us won't have
+	to keep compensating :(
+
+	SVR4 users (that aren't using gcc) will have to add -DSVR4 to
+	CPPFLAGS for configure.
+
+--
+EOF
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/Makefile work/main.d/rxvt-2.6.4/Makefile
--- tmp/rxvt-2.6.4/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/Makefile	2007-01-15 18:03:53.000000000 -0300
@@ -0,0 +1,175 @@
+# Generated automatically from Makefile.in by configure.
+# ./Makefile.in			-*- Makefile -*-
+# $Id: Makefile.in,v 1.5 1999/03/29 05:31:37 mason Exp $
+
+# autoconf/Make.common.in	 -*- Makefile -*-
+# release date (man), LSM date, version number/name, current maintainer
+DATE=02 NOVEMBER 2001
+LSMDATE=02NOV01
+VERSION=2.6.4
+VERNAME=rxvt-$(VERSION)#
+MAINT=Geoff Wing#
+MAINTEMAIL=<gcw@rxvt.org>#
+WEBMAINT=Oezguer Kesim#
+WEBMAINTEMAIL=<oec@rxvt.org>#
+WEBPAGE=<http://www.rxvt.org/>#
+FTPSITENAME=ftp.rxvt.org#
+FTPSITEDIR=/pub/rxvt#
+#-------------------------------------------------------------------------
+
+SHELL = /bin/sh
+
+# This variable makes it possible to move the installation root to another
+# directory. This is useful when you're creating a binary distribution
+# If empty, normal root will be used.
+# You can run eg. 'make install DESTDIR=/packages/rxvt-xx' to accomplish
+# that.
+# DESTDIR = /usr/local/X11/$(VERNAME)
+
+# Installation target directories & other installation stuff
+prefix = //usr
+exec_prefix = //usr
+binprefix =
+manprefix =
+bindir = //usr/bin
+mandir = //usr/share/man/man1
+manext = 1
+
+# Tools & program stuff
+CC = i586-castorbox-linux-gnu-gcc
+CPP = i586-castorbox-linux-gnu-cpp
+MV = //media/gar-castorbox/images/build/usr/bin/mv
+RM = //media/gar-castorbox/images/build/usr/bin/rm
+RMF = //media/gar-castorbox/images/build/usr/bin/rm -f
+CP = //media/gar-castorbox/images/build/usr/bin/cp
+SED = //media/gar-castorbox/images/build/usr/bin/sed
+AWK = //media/gar-castorbox/images/build/usr/bin/awk
+ECHO = //media/gar-castorbox/images/build/usr/bin/echo
+CMP = //media/gar-castorbox/images/build/usr/bin/cmp
+TBL = 
+INSTALL = //media/gar-castorbox/images/build/usr/bin/install -c
+INSTALL_PROGRAM = //media/gar-castorbox/images/build/usr/bin/install -c -s -m 755
+INSTALL_DATA = //media/gar-castorbox/images/build/usr/bin/install -c -m 644
+
+# Flags & libs
+# add -DBINDIR=\""$(bindir)/"\" to CPPFLAGS, if we need to spawn a program
+
+CFLAGS = -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32 
+CPPFLAGS =  
+LDFLAGS = 
+DEFS = -DHAVE_CONFIG_H
+LIBS = 
+DINCLUDE = 
+DLIB = 
+
+# X Include directory
+XINC =  -I/media/gar-castorbox/images/main//usr/include 
+
+# extra libraries needed by X on some systems, X library location
+XLIB =  -L/media/gar-castorbox/images/main//usr/lib  -lX11 
+
+# End of common section of the Makefile
+#-------------------------------------------------------------------------
+
+srcdir =	.
+.PATH:		.
+
+first_rule: all
+dummy:
+
+subdirs = src doc rclock src/graphics
+
+DIST =	INSTALL README.configure configure Makefile Makefile.in ChangeLog
+
+DIST_CFG = autoconf/aclocal.m4 autoconf/configure.in \
+	autoconf/config.h.in  autoconf/acconfig.h  autoconf/Make.common.in \
+	autoconf/install-sh autoconf/mkinstalldirs
+
+MKDIR = $(srcdir)/autoconf/mkinstalldirs
+
+#-------------------------------------------------------------------------
+
+all allbin alldoc tags clean:
+	@for I in ${subdirs}; do (cd $$I; ${MAKE} $@ || exit 1); done
+
+#
+# entry points for other programs
+#
+rxvt:
+	(cd src; ${MAKE})
+
+clock:
+	(cd rclock; ${MAKE})
+
+graphics qplot:
+	(cd src/graphics; ${MAKE} qplot)
+
+#-------------------------------------------------------------------------
+configure: autoconf/configure.in autoconf/aclocal.m4 autoconf/acconfig.h autoconf/config.h.in
+	cd $(srcdir);
+	autoconf --localdir=$(srcdir)/autoconf \
+	autoconf/configure.in > configure
+	chmod 755 configure
+
+config.status:
+	if test -x config.status; then config.status --recheck; \
+	else $(SHELL) configure; fi
+
+autoconf/config.h.in: autoconf/configure.in autoconf/acconfig.h
+	cd $(srcdir);
+	autoheader --localdir=$(srcdir)/autoconf \
+	autoconf/configure.in > autoconf/config.h.in
+	chmod 644 autoconf/config.h.in
+
+installdirs:
+	$(MKDIR) $(DESTDIR)$(bindir)
+	$(MKDIR) $(DESTDIR)$(mandir)
+
+install: installdirs
+	@for I in $(subdirs); do (cd $$I; $(MAKE) DESTDIR=$(DESTDIR) $@ || exit 1); done
+
+Makefiles:
+	$(SHELL) config.status
+
+realclean:
+	$(RMF) *~ config.cache
+	@for I in ${subdirs}; do (cd $$I; ${MAKE} $@ || exit 1); done
+
+# distclean goal is for making a clean source tree, but if you have run
+# configure from a different directory, then doesn't destroy all your
+# hardly compiled and linked stuff. That's why there is always $(srcdir)/
+# In that case most of those commands do nothing, except cleaning *~
+# and cleaning source links.
+distclean:
+	(cd $(srcdir); $(RMF) *~ config.cache config.h config.log config.status)
+	@for I in $(subdirs); do (cd $$I; $(MAKE) $@ || exit 1); done
+	(cd $(srcdir); $(RMF) Makefile autoconf/Make.common)
+
+distdirs:
+	mkdir ../$(VERNAME);
+	mkdir ../$(VERNAME)/autoconf;
+	@for I in $(subdirs); do (cd $$I; $(MAKE) $@ || (echo "Failed to make distclean in $$I"; exit 0) ); done
+
+distcopy:
+	$(CP) -p $(DIST) ../$(VERNAME);
+	$(CP) -p $(DIST_CFG) ../$(VERNAME)/autoconf;
+	@for I in $(subdirs); do (cd $$I; $(MAKE) $@ || exit 1); done
+
+distrib: configure autoconf/config.h.in distdirs distcopy
+
+tar.gz:  ../$(VERNAME).tar.gz
+../$(VERNAME).tar.gz:
+	(cd ..; tar cvf - $(VERNAME) | gzip -f9 > $(VERNAME).tar.gz)
+
+tar.Z: ../$(VERNAME).tar.Z
+../$(VERNAME).tar.Z:
+	(cd ..; tar cvf - $(VERNAME) | compress > $(VERNAME).tar.Z)
+
+tar.bz2: ../$(VERNAME).tar.bz2
+../$(VERNAME).tar.bz2:
+	(cd ..; tar cvf - $(VERNAME) | bzip2 -f9 > $(VERNAME).tar.bz2)
+
+uuencode: tar.gz
+	uuencode ../$(VERNAME).tar.gz $(VERNAME).tar.gz > ../$(VERNAME).tgz.uu
+
+# ------------------------------------------------------------------------
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/Makefile.in work/main.d/rxvt-2.6.4/Makefile.in
--- tmp/rxvt-2.6.4/Makefile.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/Makefile.in	1999-03-29 02:31:37.000000000 -0300
@@ -0,0 +1,107 @@
+# ./Makefile.in			-*- Makefile -*-
+# $Id: Makefile.in,v 1.5 1999/03/29 05:31:37 mason Exp $
+@MCOMMON@
+
+srcdir =	@srcdir@
+VPATH =		@srcdir@
+.PATH:		@srcdir@
+
+first_rule: all
+dummy:
+
+subdirs = src doc rclock src/graphics
+
+DIST =	INSTALL README.configure configure Makefile Makefile.in ChangeLog
+
+DIST_CFG = autoconf/aclocal.m4 autoconf/configure.in \
+	autoconf/config.h.in  autoconf/acconfig.h  autoconf/Make.common.in \
+	autoconf/install-sh autoconf/mkinstalldirs
+
+MKDIR = $(srcdir)/autoconf/mkinstalldirs
+
+#-------------------------------------------------------------------------
+
+all allbin alldoc tags clean:
+	@for I in ${subdirs}; do (cd $$I; ${MAKE} $@ || exit 1); done
+
+#
+# entry points for other programs
+#
+rxvt:
+	(cd src; ${MAKE})
+
+clock:
+	(cd rclock; ${MAKE})
+
+graphics qplot:
+	(cd src/graphics; ${MAKE} qplot)
+
+#-------------------------------------------------------------------------
+configure: autoconf/configure.in autoconf/aclocal.m4 autoconf/acconfig.h autoconf/config.h.in
+	cd $(srcdir);
+	autoconf --localdir=$(srcdir)/autoconf \
+	autoconf/configure.in > configure
+	chmod 755 configure
+
+config.status:
+	if test -x config.status; then config.status --recheck; \
+	else $(SHELL) configure; fi
+
+autoconf/config.h.in: autoconf/configure.in autoconf/acconfig.h
+	cd $(srcdir);
+	autoheader --localdir=$(srcdir)/autoconf \
+	autoconf/configure.in > autoconf/config.h.in
+	chmod 644 autoconf/config.h.in
+
+installdirs:
+	$(MKDIR) $(DESTDIR)$(bindir)
+	$(MKDIR) $(DESTDIR)$(mandir)
+
+install: installdirs
+	@for I in $(subdirs); do (cd $$I; $(MAKE) DESTDIR=$(DESTDIR) $@ || exit 1); done
+
+Makefiles:
+	$(SHELL) config.status
+
+realclean:
+	$(RMF) *~ config.cache
+	@for I in ${subdirs}; do (cd $$I; ${MAKE} $@ || exit 1); done
+
+# distclean goal is for making a clean source tree, but if you have run
+# configure from a different directory, then doesn't destroy all your
+# hardly compiled and linked stuff. That's why there is always $(srcdir)/
+# In that case most of those commands do nothing, except cleaning *~
+# and cleaning source links.
+distclean:
+	(cd $(srcdir); $(RMF) *~ config.cache config.h config.log config.status)
+	@for I in $(subdirs); do (cd $$I; $(MAKE) $@ || exit 1); done
+	(cd $(srcdir); $(RMF) Makefile autoconf/Make.common)
+
+distdirs:
+	mkdir ../$(VERNAME);
+	mkdir ../$(VERNAME)/autoconf;
+	@for I in $(subdirs); do (cd $$I; $(MAKE) $@ || (echo "Failed to make distclean in $$I"; exit 0) ); done
+
+distcopy:
+	$(CP) -p $(DIST) ../$(VERNAME);
+	$(CP) -p $(DIST_CFG) ../$(VERNAME)/autoconf;
+	@for I in $(subdirs); do (cd $$I; $(MAKE) $@ || exit 1); done
+
+distrib: configure autoconf/config.h.in distdirs distcopy
+
+tar.gz:  ../$(VERNAME).tar.gz
+../$(VERNAME).tar.gz:
+	(cd ..; tar cvf - $(VERNAME) | gzip -f9 > $(VERNAME).tar.gz)
+
+tar.Z: ../$(VERNAME).tar.Z
+../$(VERNAME).tar.Z:
+	(cd ..; tar cvf - $(VERNAME) | compress > $(VERNAME).tar.Z)
+
+tar.bz2: ../$(VERNAME).tar.bz2
+../$(VERNAME).tar.bz2:
+	(cd ..; tar cvf - $(VERNAME) | bzip2 -f9 > $(VERNAME).tar.bz2)
+
+uuencode: tar.gz
+	uuencode ../$(VERNAME).tar.gz $(VERNAME).tar.gz > ../$(VERNAME).tgz.uu
+
+# ------------------------------------------------------------------------
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/rclock/feature.h work/main.d/rxvt-2.6.4/rclock/feature.h
--- tmp/rxvt-2.6.4/rclock/feature.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/rclock/feature.h	1998-04-20 04:30:42.000000000 -0300
@@ -0,0 +1,121 @@
+/*--------------------------------*-C-*---------------------------------*
+ * file:	feature.h
+ *
+ * Compile-time configuration.
+ *----------------------------------------------------------------------*
+ * Copyright (C) 1997 1998 mj olesen <olesen@me.QueensU.CA>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *----------------------------------------------------------------------*/
+
+#ifndef _FEATURE_H
+#define _FEATURE_H
+
+/*----------------------------------------------------------------------*
+ * #define ICONWIN
+ *	to enable fancy (active) icon
+ *
+ * #define REMINDERS
+ *	to enable the appointment reminder functions
+ *
+ * #define NO_REMINDER_EXEC
+ *      to disable the execution of a program on an appointment
+ *
+ * #define MAIL
+ *	to enable xbiff-type mail reminders
+ *
+ * #define MAIL_BELL
+ *	to enable xbiff-type mail reminders with a beep
+ *
+ * #define MAIL_SPAWN	"xmh\ -font\ 7x14\&"
+ *	to define a mail program to run
+ *
+ * #define MAIL_SPOOL	"/var/spool/mail/"
+ *	to define the mail spool when the $MAIL variable isn't set
+ *
+ * program size approximately doubles from no options to all options
+ *----------------------------------------------------------------------*/
+#define ICONWIN
+#define REMINDERS
+/* #define NO_REMINDER_EXEC */
+#define MAIL
+/* #define MAIL_BELL */
+/* #define MAIL_SPAWN	"xmh\ -font\ 7x14\&" */
+/* #define MAIL_SPOOL	"/var/spool/mail/" */
+
+/*----------------------------------------------------------------------*
+ * #define CLOCKUPDATE	30
+ * 	to define the frequency (seconds) to update the clock
+ *
+ * #define MAILUPDATE	60
+ * 	to define the frequency (seconds) to check for new mail
+ *
+ * #define REMINDERS_TIME	10
+ *	to define the frequency (minutes) to check ~/.rclock
+ *
+ * #define DEFER_TIME	3
+ *	to define the amount (minutes) to defer a message
+ *
+ * #define ADJUST_TIME
+ *	to add -adjust command-line option
+ *
+ * #define CENTURY	2000
+ *	to set the base century for 2 digit year short-hand
+ *----------------------------------------------------------------------*/
+#define	CLOCKUPDATE	30
+#define MAILUPDATE	60
+#define REMINDERS_TIME	10
+#define DEFER_TIME	3
+#define ADJUST_TIME
+/* #define CENTURY	2000 */
+
+/*----------------------------------------------------------------------*
+ * #define FONT_NAME	"7x14"
+ * 	to define the font to be used for appointment reminders
+ *
+ * #define FG_COLOR_NAME	"black"
+ * #define BG_COLOR_NAME	"white"
+ * 	to define the foreground/background colors to use
+ *----------------------------------------------------------------------*/
+#define FONT_NAME	"7x14"
+#define FG_COLOR_NAME	"black"
+#define BG_COLOR_NAME	"white"
+
+/*----------------------------------------------------------------------*
+ * #define DAY_NAMES	"umtwrfs*"
+ *	define this string appropriate for any language.
+ *
+ *	It starts with a symbol for Sunday, ends with Saturday, then '*'
+ *	NOTE: 8 characters total - 7 days of the week plus '*'
+ *----------------------------------------------------------------------*/
+#define DAY_NAMES	"umtwrfs*"
+
+/*----------------------------------------------------------------------*
+ * #define SUBTICKS
+ *	to show additional minute/second markings
+ *----------------------------------------------------------------------*/
+#define SUBTICKS
+
+/*----------------------------------------------------------------------*
+ * sort out conflicts
+ *----------------------------------------------------------------------*/
+#if defined (MAIL_BELL) || defined (MAIL_SPAWN) || defined (MAIL_SPOOL)
+# ifndef MAIL
+#  define MAIL
+# endif
+#endif
+
+#endif	/* whole file */
+/*----------------------- end-of-file (C header) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/rclock/Makefile work/main.d/rxvt-2.6.4/rclock/Makefile
--- tmp/rxvt-2.6.4/rclock/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/rclock/Makefile	2007-01-15 18:03:53.000000000 -0300
@@ -0,0 +1,153 @@
+# Generated automatically from Makefile.in by configure.
+# rclock/Makefile.in	-*- Makefile -*-
+
+# autoconf/Make.common.in	 -*- Makefile -*-
+# release date (man), LSM date, version number/name, current maintainer
+DATE=02 NOVEMBER 2001
+LSMDATE=02NOV01
+VERSION=2.6.4
+VERNAME=rxvt-$(VERSION)#
+MAINT=Geoff Wing#
+MAINTEMAIL=<gcw@rxvt.org>#
+WEBMAINT=Oezguer Kesim#
+WEBMAINTEMAIL=<oec@rxvt.org>#
+WEBPAGE=<http://www.rxvt.org/>#
+FTPSITENAME=ftp.rxvt.org#
+FTPSITEDIR=/pub/rxvt#
+#-------------------------------------------------------------------------
+
+SHELL = /bin/sh
+
+# This variable makes it possible to move the installation root to another
+# directory. This is useful when you're creating a binary distribution
+# If empty, normal root will be used.
+# You can run eg. 'make install DESTDIR=/packages/rxvt-xx' to accomplish
+# that.
+# DESTDIR = /usr/local/X11/$(VERNAME)
+
+# Installation target directories & other installation stuff
+prefix = //usr
+exec_prefix = //usr
+binprefix =
+manprefix =
+bindir = //usr/bin
+mandir = //usr/share/man/man1
+manext = 1
+
+# Tools & program stuff
+CC = i586-castorbox-linux-gnu-gcc
+CPP = i586-castorbox-linux-gnu-cpp
+MV = //media/gar-castorbox/images/build/usr/bin/mv
+RM = //media/gar-castorbox/images/build/usr/bin/rm
+RMF = //media/gar-castorbox/images/build/usr/bin/rm -f
+CP = //media/gar-castorbox/images/build/usr/bin/cp
+SED = //media/gar-castorbox/images/build/usr/bin/sed
+AWK = //media/gar-castorbox/images/build/usr/bin/awk
+ECHO = //media/gar-castorbox/images/build/usr/bin/echo
+CMP = //media/gar-castorbox/images/build/usr/bin/cmp
+TBL = 
+INSTALL = //media/gar-castorbox/images/build/usr/bin/install -c
+INSTALL_PROGRAM = //media/gar-castorbox/images/build/usr/bin/install -c -s -m 755
+INSTALL_DATA = //media/gar-castorbox/images/build/usr/bin/install -c -m 644
+
+# Flags & libs
+# add -DBINDIR=\""$(bindir)/"\" to CPPFLAGS, if we need to spawn a program
+
+CFLAGS = -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32 
+CPPFLAGS =  
+LDFLAGS = 
+DEFS = -DHAVE_CONFIG_H
+LIBS = 
+DINCLUDE = 
+DLIB = 
+
+# X Include directory
+XINC =  -I/media/gar-castorbox/images/main//usr/include 
+
+# extra libraries needed by X on some systems, X library location
+XLIB =  -L/media/gar-castorbox/images/main//usr/lib  -lX11 
+
+# End of common section of the Makefile
+#-------------------------------------------------------------------------
+
+srcdir =	.
+.PATH:		.
+
+basedir = ..
+thisdir = rclock
+
+first_rule: clock
+dummy:
+
+SRCS =	rclock.c
+OBJS =	rclock.o
+HDRS =	feature.h
+
+#
+# Distribution variables
+#
+
+DIST = $(HDRS) $(SRCS) Makefile.in rclock.1.in
+
+# inference rules
+.c.o:
+	$(CC) -c $(CPPFLAGS) $(XINC) -I. -I$(basedir) -I$(srcdir) $(DEFS) $(CFLAGS) $<
+#-------------------------------------------------------------------------
+all:
+clock: alldoc allbin
+
+rclock: $(OBJS)
+	$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS) $(XLIB)
+
+rclock.1: $(srcdir)/rclock.1.in
+	cat $(srcdir)/rclock.1.in\
+	|sed -e 's%@RXVT_VERSION@%$(VERSION)%g;'\
+	|sed -e 's%@RXVT_DATE@%$(DATE)%g;'\
+	|sed -e 's%@RXVT_MAINT@%$(MAINT)%g;'\
+	> $@
+
+rclock.html: rclock.1
+	rman -f HTML -S -r off rclock.1\
+	|sed -e 's%&lt\;file:]*\(.*\)&gt\;%<A HREF="\1">\1</A>%g;'\
+	|sed -e 's%&lt\;\([fht]*tp://\)\([^/]*\)\(.*\)&gt\;%<A HREF="\1\2\3">\2</A>%g;'\
+	|sed -e 's%&lt\;\([^ /]*\)&gt\;%<A HREF="mailto:\1">\1</A>%g;'\
+	> $@
+
+tags: $(SRCS)
+	ctags $(SRCS)
+
+allbin: rclock
+
+alldoc:	rclock.1
+
+clean:
+	$(RMF) rclock rclock.1 core a.out *.o *.bak *~
+
+realclean: clean
+	$(RMF) tags
+
+distclean:
+	(cd $(srcdir); $(RMF) rclock rclock.1 *~ *.o core a.out)
+	if test $(srcdir) = .; then $(MAKE) realclean; fi
+	(cd $(srcdir); $(RMF) Makefile)
+
+install: allbin alldoc
+	$(INSTALL_PROGRAM) rclock $(DESTDIR)$(bindir)/$(binprefix)rclock
+	$(INSTALL_DATA) rclock.1 $(DESTDIR)$(mandir)/$(manprefix)rclock.$(manext)
+
+uninstall:
+	cd $(bindir); $(RMF) $(binprefix)rclock
+	cd $(mandir); $(RMF) $(manprefix)rclock.$(manext)
+
+distdirs:
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)
+
+distcopy:  rclock.1
+	$(CP) -p $(DIST) $(basedir)/../$(VERNAME)/$(thisdir)
+	if test -f rclock.html; then \
+	$(CP) -p rclock.html $(basedir)/../$(VERNAME)/$(thisdir); \
+	fi
+
+# -----------------------------------------------------------------------
+# DO NOT DELETE: ugly dependency list follows
+rclock.o: rclock.c feature.h
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/rclock/Makefile.in work/main.d/rxvt-2.6.4/rclock/Makefile.in
--- tmp/rxvt-2.6.4/rclock/Makefile.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/rclock/Makefile.in	1998-11-26 02:28:27.000000000 -0300
@@ -0,0 +1,85 @@
+# rclock/Makefile.in	-*- Makefile -*-
+@MCOMMON@
+
+srcdir =	@srcdir@
+VPATH =		@srcdir@
+.PATH:		@srcdir@
+
+basedir = ..
+thisdir = rclock
+
+first_rule: clock
+dummy:
+
+SRCS =	rclock.c
+OBJS =	rclock.o
+HDRS =	feature.h
+
+#
+# Distribution variables
+#
+
+DIST = $(HDRS) $(SRCS) Makefile.in rclock.1.in
+
+# inference rules
+.c.o:
+	$(CC) -c $(CPPFLAGS) $(XINC) -I. -I$(basedir) -I$(srcdir) $(DEFS) $(CFLAGS) $<
+#-------------------------------------------------------------------------
+all:
+clock: alldoc allbin
+
+rclock: $(OBJS)
+	$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS) $(XLIB)
+
+rclock.1: $(srcdir)/rclock.1.in
+	cat $(srcdir)/rclock.1.in\
+	|sed -e 's%@RXVT_VERSION@%$(VERSION)%g;'\
+	|sed -e 's%@RXVT_DATE@%$(DATE)%g;'\
+	|sed -e 's%@RXVT_MAINT@%$(MAINT)%g;'\
+	> $@
+
+rclock.html: rclock.1
+	rman -f HTML -S -r off rclock.1\
+	|sed -e 's%&lt\;file:]*\(.*\)&gt\;%<A HREF="\1">\1</A>%g;'\
+	|sed -e 's%&lt\;\([fht]*tp://\)\([^/]*\)\(.*\)&gt\;%<A HREF="\1\2\3">\2</A>%g;'\
+	|sed -e 's%&lt\;\([^ /]*\)&gt\;%<A HREF="mailto:\1">\1</A>%g;'\
+	> $@
+
+tags: $(SRCS)
+	ctags $(SRCS)
+
+allbin: rclock
+
+alldoc:	rclock.1
+
+clean:
+	$(RMF) rclock rclock.1 core a.out *.o *.bak *~
+
+realclean: clean
+	$(RMF) tags
+
+distclean:
+	(cd $(srcdir); $(RMF) rclock rclock.1 *~ *.o core a.out)
+	if test $(srcdir) = .; then $(MAKE) realclean; fi
+	(cd $(srcdir); $(RMF) Makefile)
+
+install: allbin alldoc
+	$(INSTALL_PROGRAM) rclock $(DESTDIR)$(bindir)/$(binprefix)rclock
+	$(INSTALL_DATA) rclock.1 $(DESTDIR)$(mandir)/$(manprefix)rclock.$(manext)
+
+uninstall:
+	cd $(bindir); $(RMF) $(binprefix)rclock
+	cd $(mandir); $(RMF) $(manprefix)rclock.$(manext)
+
+distdirs:
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)
+
+distcopy:  rclock.1
+	$(CP) -p $(DIST) $(basedir)/../$(VERNAME)/$(thisdir)
+	if test -f rclock.html; then \
+	$(CP) -p rclock.html $(basedir)/../$(VERNAME)/$(thisdir); \
+	fi
+
+# -----------------------------------------------------------------------
+# DO NOT DELETE: ugly dependency list follows
+rclock.o: rclock.c feature.h
Binary files tmp/rxvt-2.6.4/rclock/rclock and work/main.d/rxvt-2.6.4/rclock/rclock differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/rclock/rclock.1 work/main.d/rxvt-2.6.4/rclock/rclock.1
--- tmp/rxvt-2.6.4/rclock/rclock.1	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/rclock/rclock.1	2007-01-15 18:04:19.000000000 -0300
@@ -0,0 +1,201 @@
+.\" @(#)rclock.1	-*- nroff -*-
+.TH RCLOCK 1 02 NOVEMBER 2001 "X Version 11" "X Tools"
+.UC
+.SH NAME
+rclock (ouR CLOCK)
+\(em clock and appointment reminder for X11
+.SH SYNOPSIS
+.B rclock
+.RI [ options ]
+
+.SH DESCRIPTION
+.B rclock
+\(em version
+.B 2.6.4
+\(em is an analog clock for X intended as an
+.IR xclock (1)
+replacement that conserves memory and has extra features:
+.B rclock
+enters reverse video if there is mail waiting; an appointment reminder
+is also builtin.
+
+.SH OPTIONS
+The options supported by
+.BR rclock :
+.TP
+.BI -display " displayname"
+Attempt to open a window on the named X display.
+In the absence of this option, the display specified by the DISPLAY
+environment variable is used.
+.TP
+.BI -geometry " geom"
+Create the window with the specified X window geometry [default 80x80].
+.TP
+.BI -bg " color"
+Window background color [default white].
+.TP
+.BI -fg " color"
+Window foreground color [default black].
+.TP
+.BI -fn " fontname"
+Select font used for reminders [default 7x14].
+.TP
+.B -iconic
+Start iconified, if supported by the window manager.
+.TP
+.BI -adjust " ddhhmm"
+Adjust the clock by +/\-
+.I ddhhmm
+.RI ( dd
+= days,
+.I hh
+= hours,
+.I mm =
+minutes) to fix an incorrect clock without being root or for working in
+another time-zone.
+.TP
+.BI -update " n"
+Update clock face every
+.I n
+seconds [default 30].
+If
+.IR n "=1,"
+a seconds hand is displayed.
+.TP
+.BI -mail " n"
+Check for new mail every
+.I n
+seconds [default 60].
+The actual interval is a multiple of the clock update interval.
+.TP
+.BI "#" geom
+Specify the preferred icon window size [default 65x65].
+
+.SH "X RESOURCES"
+No X resources are used \(em only command-line options.
+
+.SH "TITLES AND ICONS"
+The window and icon titles are set to the day of the week and the date.
+The icon window is "active" and will show the time, if supported by
+the window manager.
+
+.SH "REMINDERS"
+The
+.B "~/.rclock"
+file lists the messages to display and/or the programs to run at
+specified times and dates.
+At the specified time,
+.B rclock
+will pop-up a window in the center of the screen to display the
+message or will simply run the scheduled program.
+.B
+rclock will reads the
+.B "~/.rclock"
+file at startup, and every 10 minutes (to look for changes) and after
+a message window has been dismissed (to find the next appointment).
+
+An entry in
+.B "~/.rclock"
+may be one of two formats (blank and comment lines will be ignored):
+.sp
+.nf
+.B hh:mm  [dd]  MM/DD/YY message[; program]
+or
+.B [hh:mm  [dd]  MM/DD/YY [message]]; program
+.sp
+.BR hh " \- hour (0-23; * = current)"
+.BR mm " \- minute (0-59; * = 0)"
+.BR dd " \- days-of-week (some/all/none of umtwrfs; * = all)"
+.BR MM " \- month (1-12; * = current)"
+.BR DD " \- day of month (1-31; * = current)"
+.BR YY " \- year (0-99 or 1900-????; * = current)"
+.BR message " \- message to display"
+.BR program " \- program to execute"
+.fi
+.sp
+The days-of-the-week use the following abbreviations:
+.BR u =Sunday,
+.BR m =Monday,
+.BR t =Tuesday,
+.BR w =Wednesday,
+.BR r =Thursday,
+.BR f =Friday,
+.BR s =Saturday,
+.BR * =all.
+.sp
+If
+.B message
+is empty and
+.B program
+has been specified, it is executed without a dialog box.
+If time/date are also not specified,
+.B program
+is executed on start-up.
+Note
+.B message
+may contain escape values (\\n: newline, \\;: semicolon).
+
+Here's a silly example file that shows some of the permissible
+constructs:
+.nf
+.sp
+# ~/.rclock - My appointment file
+
+# startup functions
+; xsetroot -solid Black &
+
+# cron functions
+
+10:00; xsetroot -solid Grey25 &
+14:00; xsetroot -solid Grey75 &
+
+# daily/weekly reminders
+
+08:15 mtwrf *      Good Morning!\\nRead News?; rxvt -e News
+12:00 mtwrf *      Lunch Time!
+17:00 mtwrf *      Go Home
+23:00 mtwrf *      Still Here? Go to bed
+08:10 twrf  *      Did you do your time card yesterday?
+15:00 f     *      Friday, do your time card early!
+16:00 mtwr  *      Do your time card
+16:30 mtwrf *      Did you do your time card?
+*:00  us    *      It's the weekend, why are you here?
+8:15  f     */13/* Friday the 13th! Careful!
+8:15  *     4/1/*  fkrkrmfismsmkd...dkdfk
+8:16  *     4/1/*  April Fools!
+
+# birthdays/anniversaries
+
+16:00    05/21/*   Pam's Birthday (next week)
+16:00    05/24/*   Pam's Birthday (in a few days)
+
+# once-of appointments
+
+08:30    03/15/94    Dentist appointment
+08:30    03/15/1999  Dentist appointment
+08:30    03/15/2004  Dentist appointment
+.sp
+.fi
+
+.SH ENVIRONMENT
+.B rclock
+uses the environment variable
+.B MAIL
+to determine the location of the user's mail spool file.
+
+.SH BUGS
+.B rclock
+is not very smart about dealing with errors encountered while reading the
+.B "~/.rclock"
+file.
+Each reminder must be a single line not exceeding 255 characters.
+Reminder windows are sometimes not redrawn (left blank) when raised or
+uncovered.
+
+.SH AUTHOR
+Rob Nation <nation@rocket.sanders.lockheed.com>
+.LP
+Modifications by mj olesen <olesen@me.QueensU.CA>
+
+.SH "CURRENT MAINTAINER"
+Same as the current rxvt maintainer.
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/rclock/rclock.1.in work/main.d/rxvt-2.6.4/rclock/rclock.1.in
--- tmp/rxvt-2.6.4/rclock/rclock.1.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/rclock/rclock.1.in	1998-04-20 04:30:42.000000000 -0300
@@ -0,0 +1,201 @@
+.\" @(#)rclock.1	-*- nroff -*-
+.TH RCLOCK 1 @RXVT_DATE@ "X Version 11" "X Tools"
+.UC
+.SH NAME
+rclock (ouR CLOCK)
+\(em clock and appointment reminder for X11
+.SH SYNOPSIS
+.B rclock
+.RI [ options ]
+
+.SH DESCRIPTION
+.B rclock
+\(em version
+.B @RXVT_VERSION@
+\(em is an analog clock for X intended as an
+.IR xclock (1)
+replacement that conserves memory and has extra features:
+.B rclock
+enters reverse video if there is mail waiting; an appointment reminder
+is also builtin.
+
+.SH OPTIONS
+The options supported by
+.BR rclock :
+.TP
+.BI -display " displayname"
+Attempt to open a window on the named X display.
+In the absence of this option, the display specified by the DISPLAY
+environment variable is used.
+.TP
+.BI -geometry " geom"
+Create the window with the specified X window geometry [default 80x80].
+.TP
+.BI -bg " color"
+Window background color [default white].
+.TP
+.BI -fg " color"
+Window foreground color [default black].
+.TP
+.BI -fn " fontname"
+Select font used for reminders [default 7x14].
+.TP
+.B -iconic
+Start iconified, if supported by the window manager.
+.TP
+.BI -adjust " ddhhmm"
+Adjust the clock by +/\-
+.I ddhhmm
+.RI ( dd
+= days,
+.I hh
+= hours,
+.I mm =
+minutes) to fix an incorrect clock without being root or for working in
+another time-zone.
+.TP
+.BI -update " n"
+Update clock face every
+.I n
+seconds [default 30].
+If
+.IR n "=1,"
+a seconds hand is displayed.
+.TP
+.BI -mail " n"
+Check for new mail every
+.I n
+seconds [default 60].
+The actual interval is a multiple of the clock update interval.
+.TP
+.BI "#" geom
+Specify the preferred icon window size [default 65x65].
+
+.SH "X RESOURCES"
+No X resources are used \(em only command-line options.
+
+.SH "TITLES AND ICONS"
+The window and icon titles are set to the day of the week and the date.
+The icon window is "active" and will show the time, if supported by
+the window manager.
+
+.SH "REMINDERS"
+The
+.B "~/.rclock"
+file lists the messages to display and/or the programs to run at
+specified times and dates.
+At the specified time,
+.B rclock
+will pop-up a window in the center of the screen to display the
+message or will simply run the scheduled program.
+.B
+rclock will reads the
+.B "~/.rclock"
+file at startup, and every 10 minutes (to look for changes) and after
+a message window has been dismissed (to find the next appointment).
+
+An entry in
+.B "~/.rclock"
+may be one of two formats (blank and comment lines will be ignored):
+.sp
+.nf
+.B hh:mm  [dd]  MM/DD/YY message[; program]
+or
+.B [hh:mm  [dd]  MM/DD/YY [message]]; program
+.sp
+.BR hh " \- hour (0-23; * = current)"
+.BR mm " \- minute (0-59; * = 0)"
+.BR dd " \- days-of-week (some/all/none of umtwrfs; * = all)"
+.BR MM " \- month (1-12; * = current)"
+.BR DD " \- day of month (1-31; * = current)"
+.BR YY " \- year (0-99 or 1900-????; * = current)"
+.BR message " \- message to display"
+.BR program " \- program to execute"
+.fi
+.sp
+The days-of-the-week use the following abbreviations:
+.BR u =Sunday,
+.BR m =Monday,
+.BR t =Tuesday,
+.BR w =Wednesday,
+.BR r =Thursday,
+.BR f =Friday,
+.BR s =Saturday,
+.BR * =all.
+.sp
+If
+.B message
+is empty and
+.B program
+has been specified, it is executed without a dialog box.
+If time/date are also not specified,
+.B program
+is executed on start-up.
+Note
+.B message
+may contain escape values (\\n: newline, \\;: semicolon).
+
+Here's a silly example file that shows some of the permissible
+constructs:
+.nf
+.sp
+# ~/.rclock - My appointment file
+
+# startup functions
+; xsetroot -solid Black &
+
+# cron functions
+
+10:00; xsetroot -solid Grey25 &
+14:00; xsetroot -solid Grey75 &
+
+# daily/weekly reminders
+
+08:15 mtwrf *      Good Morning!\\nRead News?; rxvt -e News
+12:00 mtwrf *      Lunch Time!
+17:00 mtwrf *      Go Home
+23:00 mtwrf *      Still Here? Go to bed
+08:10 twrf  *      Did you do your time card yesterday?
+15:00 f     *      Friday, do your time card early!
+16:00 mtwr  *      Do your time card
+16:30 mtwrf *      Did you do your time card?
+*:00  us    *      It's the weekend, why are you here?
+8:15  f     */13/* Friday the 13th! Careful!
+8:15  *     4/1/*  fkrkrmfismsmkd...dkdfk
+8:16  *     4/1/*  April Fools!
+
+# birthdays/anniversaries
+
+16:00    05/21/*   Pam's Birthday (next week)
+16:00    05/24/*   Pam's Birthday (in a few days)
+
+# once-of appointments
+
+08:30    03/15/94    Dentist appointment
+08:30    03/15/1999  Dentist appointment
+08:30    03/15/2004  Dentist appointment
+.sp
+.fi
+
+.SH ENVIRONMENT
+.B rclock
+uses the environment variable
+.B MAIL
+to determine the location of the user's mail spool file.
+
+.SH BUGS
+.B rclock
+is not very smart about dealing with errors encountered while reading the
+.B "~/.rclock"
+file.
+Each reminder must be a single line not exceeding 255 characters.
+Reminder windows are sometimes not redrawn (left blank) when raised or
+uncovered.
+
+.SH AUTHOR
+Rob Nation <nation@rocket.sanders.lockheed.com>
+.LP
+Modifications by mj olesen <olesen@me.QueensU.CA>
+
+.SH "CURRENT MAINTAINER"
+Same as the current rxvt maintainer.
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/rclock/rclock.c work/main.d/rxvt-2.6.4/rclock/rclock.c
--- tmp/rxvt-2.6.4/rclock/rclock.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/rclock/rclock.c	2000-03-12 02:31:00.000000000 -0300
@@ -0,0 +1,1472 @@
+/*--------------------------------*-C-*---------------------------------*
+ * Copyright 1997 1998 Oezguer Kesim <kesim@math.fu-berlin.de>
+ * Copyright 1992, 1993 Robert Nation <nation@rocket.sanders.lockheed.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *----------------------------------------------------------------------*/
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#else
+/* # define STDC_HEADERS */
+# define HAVE_UNISTD_H
+# define TIME_WITH_SYS_TIME
+# define HAVE_SYS_TIME_H
+# ifdef _AIX
+#  define HAVE_SYS_SELECT_H
+# endif
+#endif
+
+#include "../src/version.h"
+#include "feature.h"
+
+#include <ctype.h>
+/* #ifdef STDC_HEADERS */
+# include <stdarg.h>
+# include <stdio.h>
+# include <stdlib.h>
+# include <string.h>
+/* #endif */
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#ifdef TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# ifdef HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+
+#if defined (__svr4__)
+# include <sys/resource.h>	/* for struct rlimit */
+#endif
+
+#ifdef HAVE_SYS_SELECT_H
+# include <sys/select.h>
+#endif
+#include <sys/stat.h>
+
+#ifdef MAIL
+#include <dirent.h>
+#endif
+
+#include <X11/Intrinsic.h>	/* Xlib, Xutil, Xresource, Xfuncproto */
+
+#define APL_CLASS	"Clock"
+#define APL_NAME	"rclock"
+#define MSG_CLASS	"Appointment"
+#define MSG_NAME	"Appointment"
+#define CONFIG_FILE	".rclock"
+
+#ifndef EXIT_SUCCESS	/* missed from <stdlib.h> ? */
+# define EXIT_SUCCESS	0
+# define EXIT_FAILURE	1
+#endif
+
+/*----------------------------------------------------------------------*/
+
+static Display*	Xdisplay;	/* X display */
+static int	Xfd;		/* file descriptor of server connection */
+static GC	Xgc, Xrvgc;	/* normal, reverse video GC */
+
+#define	Xscreen		DefaultScreen (Xdisplay)
+#define Xcmap		DefaultColormap (Xdisplay, Xscreen)
+#define Xroot		DefaultRootWindow (Xdisplay)
+
+/* windows and their sizes */
+typedef struct {
+   Window win;
+   int width, height;
+} mywindow_t;
+
+static mywindow_t	Clock = {None, 80, 80};	/* parent window */
+
+#define fgColor	0
+#define bgColor 1
+static const char *	rs_color [2] = { FG_COLOR_NAME, BG_COLOR_NAME };
+static Pixel		PixColors [2];
+static const char *	rs_geometry = NULL;
+
+#ifdef ICONWIN
+static const char *	rs_iconGeometry = NULL;
+static mywindow_t	Icon = {None, 65, 65};		/* icon window */
+static int		iconic_state = NormalState;	/* iconic startup? */
+#endif
+
+#ifdef REMINDERS
+static mywindow_t	Msg = {0, 0, 0};		/* message window */
+static struct {
+   Window
+# ifndef NO_REMINDER_EXEC
+     Start,
+# endif
+   Dismiss,
+   Defer;
+   int width, height;
+} msgButton;
+
+static XFontStruct * Xfont;
+#define FontHeight()	(Xfont->ascent + Xfont->descent)
+static int	Msg_Mapped = 0;		/* message window mapped? */
+static int	reminderTime = -1;
+static char	message [256] = "";
+#ifndef NO_REMINDER_EXEC
+static char	execPrgm [256] = "";
+#endif
+static const char * reminders_file = NULL;	/* name of ~/.rclock file */
+#endif
+
+#ifdef ADJUST_TIME
+static int	adjustTime = 0;
+#else
+# define	adjustTime	0
+#endif
+
+#ifdef	CENTURY
+# if (CENTURY < 1900)
+Error, Cenury incorrectly set.
+# endif
+#else
+# define CENTURY 1900
+#endif
+
+static int	clockUpdate = CLOCKUPDATE;
+
+#ifdef MAIL
+static int mailUpdate = MAILUPDATE;
+static char * mail_file = NULL;
+static int is_maildir = 0;
+#endif
+
+static XSizeHints szHint = {
+   PMinSize | PResizeInc | PBaseSize | PWinGravity,
+   0, 0, 80, 80,		/* x, y, width and height */
+   1, 1,			/* Min width and height */
+   0, 0,			/* Max width and height */
+   1, 1,			/* Width and height increments */
+   {1, 1},			/* x, y increments */
+   {1, 1},			/* Aspect ratio - not used */
+   0, 0,			/* base size */
+   NorthWestGravity		/* gravity */
+};
+
+/* subroutine declarations */
+static void	geometry2sizehint (mywindow_t * /* win */,
+				   const char * /* geom */);
+static void	Create_Windows (int /* argc */,
+				char * /* argv */ []);
+static void	getXevent (void);
+static void	print_error (const char * /* fmt */, ...);
+
+static void	Draw_Window (mywindow_t * /* this_win */,
+			     int /* full_redraw */);
+static void	Reminder (void);
+static void	Next_Reminder (int /* update_only */);
+
+/* Arguments for Next_Reminder() */
+#define REPLACE 0
+#define UPDATE 1
+
+/*----------------------------------------------------------------------*/
+
+static void
+usage (void)
+{
+   int i;
+   struct {
+      const char * const opt;
+      const char * const desc;
+   } optList[] = {
+#define optList_size()		(sizeof(optList)/sizeof(optList[0]))
+	{ "-display displayname", "X server to contact" },
+	{ "-geometry geom",	"size (in pixels) and position" },
+	{ "-bg color",		"background color" },
+	{ "-fg color",		"foreground color" },
+#ifdef REMINDERS
+	{ "-fn fontname",	"normal font for messages" },
+#endif
+#ifdef ICONWIN
+	{ "-iconic",		"start iconic" },
+#endif
+#ifdef ADJUST_TIME
+	{ "-adjust +/-ddhhmm",	"adjust clock time" },
+#endif
+	{ "-update seconds",	"clock update interval" },
+#ifdef MAIL
+	{ "-mail seconds",	"check $MAIL interval" },
+#endif
+	{ "#geom",		"icon window geometry" }
+   };
+
+   fprintf (stderr, "\nUsage v" VERSION ":\n  " APL_NAME " [options]\n\n"
+	    "where options include:\n");
+
+   for (i = 0; i < optList_size(); i++)
+     fprintf (stderr, "    %-29s%s\n", optList[i].opt, optList[i].desc);
+}
+
+
+/****************
+ * Check out if we are using a maildir drop (qmail)
+ * Note: this changes  mail_dir to hold the "new" diretory
+ */
+#ifdef MAIL
+static void
+CheckMaildir()
+{
+    struct stat st;
+    char *buf, *p;
+
+    if( !*mail_file || stat(mail_file, &st) || !S_ISDIR(st.st_mode) )
+	return; /* no */
+
+    if( !(buf = malloc(strlen(mail_file)+5)) ) {
+	print_error ("malloc error");
+	exit( EXIT_FAILURE );
+    }
+    strcpy(buf,mail_file);
+    p = buf+strlen(buf);
+    if( p[-1] != '/' )
+	*p++ = '/';
+
+    strcpy(p, "tmp" );
+    if( stat(buf, &st) || !S_ISDIR(st.st_mode ) )
+	goto leave;
+    strcpy(p, "cur" );
+    if( stat(buf, &st) || !S_ISDIR(st.st_mode ) )
+	goto leave;
+    strcpy(p, "new" );
+    if( stat(buf, &st) || !S_ISDIR(st.st_mode ) )
+	goto leave;
+
+    mail_file = buf;
+    is_maildir = 1;
+    return;
+  leave:
+    free(buf);
+}
+#endif
+
+/*----------------------------------------------------------------------*
+ * rclock - Rob's clock
+ * simple X windows clock with appointment reminder
+ *----------------------------------------------------------------------*/
+int
+main (int argc, char * argv [])
+{
+   int i;
+   char * opt, * val;
+   const char * display_name = NULL;
+   XGCValues gcv;
+
+#ifdef REMINDERS
+   const char * rs_font = FONT_NAME;
+
+   /* find the ~/.rclock file */
+   if ((val = getenv ("HOME")) != NULL)
+     {
+	char * p = malloc (strlen (CONFIG_FILE) + strlen (val) + 2);
+	if (p == NULL)
+	  goto Malloc_Error;
+
+	strcpy (p, val);
+	strcat (p, "/" CONFIG_FILE);
+
+	reminders_file = p;
+     }
+#endif
+#ifdef MAIL
+   val = getenv ("MAIL");	/* get the mail spool file name */
+#ifdef MAIL_SPOOL
+   if (val == NULL)		/* csh doesn't set $MAIL */
+     {
+	const char * spool = MAIL_SPOOL;
+	char * user = getenv ("USER");	/* assume this works */
+	val = malloc (strlen (spool) + strlen (user) + 1);
+	if (val == NULL)
+	  goto Malloc_Error;
+	strcpy (val, spool);
+	strcat (val, user);
+     }
+#endif
+   mail_file = val;
+   if( mail_file )
+       CheckMaildir();
+#endif
+
+   if ((display_name = getenv ("DISPLAY")) == NULL)
+     display_name = ":0";
+
+   /* parse the command line */
+   for (i = 1; i < argc; i += 2)
+     {
+	opt = argv [i];
+	val = argv [i+1];
+
+	switch (*opt++) {
+	 case '-':
+	   break;
+
+	 case '#':
+#ifdef ICONWIN
+	   rs_iconGeometry = opt;   /* drop */
+#endif
+	 default:
+	   continue;
+	   break;
+	}
+
+	if (*opt == 'd' && val)		display_name = val;	/* "d", "display" */
+	else if (*opt == 'g' && val)	rs_geometry = val;	/* "g", "geometry" */
+#ifdef ICONWIN
+	else if (*opt == 'i' && val)	/* "ic", "iconic" */
+	  {
+	     iconic_state = IconicState;
+	     i--;	/* no argument */
+	  }
+#endif
+	else if (!strcmp (opt, "fg") && val)	rs_color [fgColor] = val;
+	else if (!strcmp (opt, "bg") && val)	rs_color [bgColor] = val;
+#ifdef REMINDERS
+	else if (!strcmp (opt, "fn") && val)	rs_font = val;
+#endif
+	else if (!strcmp (opt, "update") && val)
+	  {
+	     int x = atoi (val);
+	     if (x < 1 || x > 60)
+	       print_error ("update: %d sec", clockUpdate);
+	     else
+	       clockUpdate = x;
+	  }
+#ifdef MAIL
+	else if (!strcmp (opt, "mail") && val)
+	  {
+	     int x = atoi (val);
+	     if (x < 1)
+	       print_error ("mail update: %d sec", mailUpdate);
+	     else
+	       mailUpdate = x;
+	  }
+#endif	/* MAIL */
+#ifdef ADJUST_TIME
+	else if (!strcmp (opt, "adjust") && val)
+	  {
+	     /* convert ddhhmm to seconds, minimal error checking */
+	     int x = atoi (val);
+	     adjustTime = ((((abs (x) / 10000) % 100) * 24	/* days */
+			    + ((abs (x) / 100) % 100)) * 60	/* hours */
+			   + (abs (x) % 100)) * 60;		/* minutes */
+	     if (x < 0)
+	       adjustTime = -adjustTime;
+	  }
+#endif	/* ADJUST_TIME */
+	else
+	  {
+	     usage ();
+	     goto Abort;
+	  }
+     }
+
+   /* open display */
+   Xdisplay = XOpenDisplay (display_name);
+   if (!Xdisplay)
+     {
+	print_error ("can't open display %s", display_name);
+	goto Abort;
+     }
+
+   /* get display info */
+   Xfd = XConnectionNumber (Xdisplay);
+     {
+	const char * const color_msg = "can't load color \"%s\"";
+	XColor xcol;
+
+	/* allocate foreground/background colors */
+	if (!XParseColor (Xdisplay, Xcmap, rs_color [fgColor], &xcol) ||
+	    !XAllocColor (Xdisplay, Xcmap, &xcol))
+	  {
+	     print_error (color_msg, rs_color [fgColor]);
+	     goto Abort;
+	  }
+	PixColors [fgColor] = xcol.pixel;
+
+	if (!XParseColor (Xdisplay, Xcmap, rs_color [bgColor], &xcol) ||
+	    !XAllocColor (Xdisplay, Xcmap, &xcol))
+	  {
+	     print_error (color_msg, rs_color [bgColor]);
+	     goto Abort;
+	  }
+	PixColors [bgColor] = xcol.pixel;
+     }
+
+#ifdef REMINDERS
+   /* load the font for messages */
+   if ((Xfont = XLoadQueryFont (Xdisplay, rs_font)) == NULL)
+     {
+	print_error ("can't load font \"%s\"", rs_font);
+	goto Abort;
+     }
+   gcv.font = Xfont->fid;
+#endif
+
+   Create_Windows (argc, argv);
+   /*  Create the graphics contexts */
+   gcv.foreground = PixColors [fgColor];
+   gcv.background = PixColors [bgColor];
+
+   Xgc = XCreateGC (Xdisplay, Clock.win,
+#ifdef REMINDERS
+		    GCFont |
+#endif
+		    GCForeground | GCBackground, &gcv);
+
+   gcv.foreground = PixColors [bgColor];
+   gcv.background = PixColors [fgColor];
+   Xrvgc = XCreateGC (Xdisplay, Clock.win,
+#ifdef REMINDERS
+		      GCFont |
+#endif
+		      GCForeground | GCBackground, &gcv);
+
+   getXevent ();
+   return EXIT_SUCCESS;
+
+   Malloc_Error:
+   print_error ("malloc error");
+   Abort:
+   print_error ("aborting");
+   return EXIT_FAILURE;
+}
+
+/*
+ * translate geometry string to appropriate sizehint
+ */
+static void
+geometry2sizehint (mywindow_t * win, const char * geom)
+{
+   int x, y, flags;
+   unsigned int width, height;
+
+   /* copy in values */
+   szHint.width  = win->width;
+   szHint.height = win->height;
+
+   if (geom == NULL)
+     return;
+
+   flags = XParseGeometry (geom, &x, &y, &width, &height);
+
+   if (flags & WidthValue)
+     {
+	szHint.width = width + szHint.base_width;
+	szHint.flags |= USSize;
+     }
+   if (flags & HeightValue)
+     {
+	szHint.height = height + szHint.base_height;
+	szHint.flags |= USSize;
+     }
+
+   if (flags & XValue)
+     {
+	if (flags & XNegative)
+	  {
+	     x += (DisplayWidth (Xdisplay, Xscreen) - szHint.width);
+	     szHint.win_gravity = NorthEastGravity;
+	  }
+	szHint.x = x;
+	szHint.flags |= USPosition;
+     }
+   if (flags & YValue)
+     {
+	if (flags & YNegative)
+	  {
+	     y += (DisplayHeight (Xdisplay, Xscreen) - szHint.height);
+	     szHint.win_gravity = (szHint.win_gravity == NorthEastGravity ?
+				     SouthEastGravity : SouthWestGravity);
+	  }
+	szHint.y = y;
+	szHint.flags |= USPosition;
+     }
+
+   /* copy out values */
+   win->width  = szHint.width;
+   win->height = szHint.height;
+}
+
+/*
+ * Open and map the windows
+ */
+static void
+Create_Windows (int argc, char * argv [])
+{
+   XClassHint classHint;
+   XWMHints wmHint;
+
+   geometry2sizehint (&Clock, rs_geometry);
+   Clock.win = XCreateSimpleWindow (Xdisplay, Xroot,
+				    szHint.x, szHint.y,
+				    Clock.width, Clock.height,
+				    0,
+				    PixColors [fgColor],
+				    PixColors [bgColor]);
+
+#ifdef ICONWIN
+   geometry2sizehint (&Icon, rs_iconGeometry);
+   Icon.win = XCreateSimpleWindow (Xdisplay, Xroot,
+				   szHint.x, szHint.y,
+				   Icon.width, Icon.height,
+				   0,
+				   PixColors [fgColor],
+				   PixColors [bgColor]);
+   wmHint.initial_state = iconic_state;
+   wmHint.icon_window = Icon.win;
+   wmHint.flags = InputHint | StateHint | IconWindowHint;
+#else
+   wmHint.flags = InputHint;
+#endif
+   wmHint.input = True;
+
+   /* ignore warning about discarded `const' */
+   classHint.res_name  = APL_NAME;
+   classHint.res_class = APL_CLASS;
+   XSetWMProperties (Xdisplay, Clock.win, NULL, NULL, argv, argc,
+		     &szHint, &wmHint, &classHint);
+
+   XSelectInput (Xdisplay, Clock.win,
+		 (ExposureMask|StructureNotifyMask|ButtonPressMask));
+
+#ifdef ICONWIN
+   XSelectInput (Xdisplay, Icon.win,
+		 (ExposureMask|ButtonPressMask));
+#endif
+   XMapWindow (Xdisplay, Clock.win);
+
+   /* create, but don't map a window for appointment reminders */
+#ifdef REMINDERS
+   Msg.win = XCreateSimpleWindow (Xdisplay, Xroot,
+				  szHint.x, szHint.y,
+				  szHint.width, szHint.height,
+				  0,
+				  PixColors [fgColor],
+				  PixColors [bgColor]);
+
+   szHint.flags |= USPosition;
+   /* ignore warning about discarded `const' */
+   classHint.res_name  = MSG_NAME;
+   classHint.res_class = MSG_CLASS;
+   wmHint.input = True;
+   wmHint.flags = InputHint;
+
+   XSetWMProperties (Xdisplay, Msg.win, NULL, NULL, argv, argc,
+		     &szHint, &wmHint, &classHint);
+     {
+	char * str = MSG_NAME;
+	XStoreName (Xdisplay, Msg.win, str);
+	XSetIconName (Xdisplay, Msg.win, str);
+     }
+
+   XSelectInput (Xdisplay, Msg.win,
+		 (ExposureMask|ButtonPressMask|KeyPressMask));
+
+   /* font already loaded */
+
+   msgButton.width  = 4 + 5 * XTextWidth (Xfont, "M", 1);
+   msgButton.height = 4 + FontHeight ();
+
+   msgButton.Dismiss = XCreateSimpleWindow (Xdisplay, Msg.win,
+					    0, 0,
+					    msgButton.width, msgButton.height,
+					    0,
+					    PixColors [bgColor],
+					    PixColors [fgColor]);
+
+   XMapWindow (Xdisplay, msgButton.Dismiss);
+
+   msgButton.Defer = XCreateSimpleWindow (Xdisplay, Msg.win,
+					  0, 0,
+					  msgButton.width, msgButton.height,
+					  0,
+					  PixColors [bgColor],
+					  PixColors [fgColor]);
+   XMapWindow (Xdisplay, msgButton.Defer);
+
+#ifndef NO_REMINDER_EXEC
+   msgButton.Start = XCreateSimpleWindow (Xdisplay, Msg.win,
+                                          0, 0,
+					  msgButton.width, msgButton.height,
+                                          0,
+					  PixColors [bgColor],
+					  PixColors [fgColor]);
+   XMapWindow (Xdisplay, msgButton.Start);
+#endif	/* NO_REMINDER_EXEC */
+#endif
+}
+
+static time_t
+mk_time (struct tm * tmval)
+{
+   return (tmval->tm_min
+	   + 60 * (tmval->tm_hour
+		   + 24 * (tmval->tm_mday
+			   + 31 * ((tmval->tm_mon+1)
+				   + 12 * tmval->tm_year))));
+}
+
+
+#ifdef MAIL
+static int
+MailAvailable()
+{
+    struct stat st;
+
+    if( is_maildir ) {
+	DIR *dirp;
+	struct dirent *d;
+
+	if( (dirp=opendir( mail_file )) ) {
+	    while( (d=readdir(dirp)) ) {
+		if( *d->d_name == '.' )
+		    continue;
+		if( isdigit(*d->d_name) ) {
+		    closedir(dirp);
+		    return 1;
+		}
+	    }
+	    closedir(dirp);
+	}
+	return 0;
+    }
+    else
+	return !stat(mail_file, &st) &&
+	       (st.st_size > 0) && (st.st_mtime >= st.st_atime);
+}
+#endif
+
+/*----------------------------------------------------------------------*
+ * Redraw the whole window after an exposure or size change.
+ * After a timeout, only redraw the hands.
+ * Provide reminder if needed.
+ *----------------------------------------------------------------------*/
+static void
+Draw_Window (mywindow_t * W, int full_redraw)
+{
+   /* pre-computed values for sin() x1000, to avoid using floats */
+   static const short Sin [60] = {
+      0,
+      105, 208, 309, 407, 500, 588, 669,
+      743, 809, 866, 914, 951, 978, 995,
+      1000,
+      995, 978, 951, 914, 866, 809, 743,
+      669, 588, 500, 407, 309, 208, 105,
+      0,
+      -105, -208, -309, -407, -500, -588, -669,
+      -743, -809, -866, -914, -951, -978, -995,
+      -1000,
+      -995, -978, -951, -914, -866, -809, -743,
+      -669, -588, -500, -407, -309, -208, -105
+   };
+
+   static int savedDay = -1;
+
+   time_t currentTime;
+   struct tm * tmval;
+   int ctr_x, ctr_y;
+
+   typedef struct {
+      int h_x, h_y;		/* hour */
+      int m_x, m_y;		/* minute */
+      int s_x, s_y;		/* second */
+   } hands_t;			/* hand positions (x,y) */
+
+   hands_t HandsNow, * pHandsOld;
+
+   GC X_gc, X_rvgc;
+
+   static hands_t HandsOld = { -1 };
+#ifdef ICONWIN
+   static hands_t HandsOld_icon = { -1 };
+#endif
+#ifdef REMINDERS
+   static int lastUpdateTime = -10;
+#endif
+
+#ifdef MAIL
+   static time_t mailTime = 0;
+   static int MailUp = 0, MailUp_rvideo = 0;
+#ifdef ICONWIN
+   static int MailUp_icon = 0;
+#endif
+#endif	/* MAIL */
+
+   currentTime = time (NULL) + adjustTime;	/* get the current time */
+   tmval = localtime (&currentTime);
+
+#ifdef MAIL
+#ifdef REMINDERS
+   if (W->win != Msg.win)
+#endif
+     {
+	int * pMailUp = (
+#ifdef ICONWIN
+			 W->win == Icon.win ? &MailUp_icon :
+#endif
+			 &MailUp);
+
+	if ((currentTime - mailTime) >= mailUpdate)
+	  {
+	     struct stat st;
+
+	     if (
+#ifdef ICONWIN
+		 MailUp != MailUp_icon ? MailUp :
+#endif
+		   ((mail_file != NULL) && MailAvailable() )   )
+	       {
+		  if (!*pMailUp)
+		    {
+		       *pMailUp = 1;
+		       full_redraw = 1;
+		       XSetWindowBackground (Xdisplay, W->win,
+					     PixColors [fgColor]);
+#ifdef MAIL_BELL
+		       XBell (Xdisplay, 0);
+#endif
+		    }
+	       }
+	     else
+	       {
+		  if (*pMailUp)
+		    {
+		       *pMailUp = 0;
+		       full_redraw = 1;
+		       XSetWindowBackground (Xdisplay, W->win,
+					     PixColors [bgColor]);
+		    }
+	       }
+#ifdef ICONWIN
+	     if (MailUp == MailUp_icon)
+#endif
+	       mailTime = currentTime;
+
+	     MailUp_rvideo = *pMailUp;
+	  }
+     }
+#endif	/* MAIL */
+
+   /* once every day, update the window and icon name */
+   if (tmval->tm_yday != savedDay)
+     {
+	char str [20];
+
+	savedDay = tmval->tm_yday;
+	strftime (str, sizeof(str), "%a %h %d", tmval);
+	XStoreName (Xdisplay, Clock.win, str);
+	XSetIconName (Xdisplay, Clock.win, str);
+     }
+
+   if (full_redraw)
+     XClearWindow (Xdisplay, W->win);
+
+#ifdef REMINDERS
+   /* for a message window, just re-draw the message */
+   if (W->win == Msg.win)
+     {
+	char * beg, * next;
+	int lines;
+
+	for (beg = message, lines = 0; beg; beg = next, lines++)
+	  {
+	     char * end;
+
+	     if ((end = strstr (beg, "\\n")) == NULL)
+	       {
+		  end = beg + strlen (beg);
+		  next = NULL;
+	       }
+	     else
+	       {
+		  next = end + 2;
+	       }
+
+	     XDrawString (Xdisplay, Msg.win,
+			  Xgc,
+			  (Msg.width -
+			   XTextWidth (Xfont, beg, (end-beg))) / 2,
+			  10 + Xfont->ascent + FontHeight () * lines,
+			  beg, (end-beg));
+	  }
+
+	XDrawString (Xdisplay, msgButton.Dismiss,
+		     Xrvgc,
+		     (msgButton.width - XTextWidth (Xfont, "Done", 4)) / 2,
+		     Xfont->ascent + 2,
+		     "Done", 4);
+
+	XDrawString (Xdisplay, msgButton.Defer,
+		     Xrvgc,
+		     (msgButton.width - XTextWidth (Xfont, "Defer", 5)) / 2,
+		     Xfont->ascent + 2,
+		     "Defer", 5);
+
+# ifndef NO_REMINDER_EXEC
+	XDrawString (Xdisplay, msgButton.Start,
+		     Xrvgc,
+		     (msgButton.width - XTextWidth (Xfont, "Start", 5)) / 2,
+		     Xfont->ascent + 2,
+		     "Start", 5);
+
+        if (strlen (execPrgm) > 1)
+	  XMapWindow (Xdisplay, msgButton.Start);
+        else
+	  XUnmapWindow (Xdisplay, msgButton.Start);
+# endif	/* NO_REMINDER_EXEC */
+	return;
+     }
+
+   /*
+    * Convert multi-field time info to a single integer with a resolution
+    * in minutes.
+    */
+   currentTime = mk_time (tmval);
+
+   /* is there a reminder pending? */
+   if (reminderTime >= 0 && currentTime >= reminderTime)
+     Reminder ();
+
+   /* every 10 minutes, or at start of day, check for revised entries */
+   if (!Msg_Mapped &&
+       (currentTime > lastUpdateTime + REMINDERS_TIME ||
+	(currentTime != lastUpdateTime &&
+	 tmval->tm_hour == 0 && tmval->tm_min == 0)))
+     {
+	Next_Reminder (UPDATE);
+	lastUpdateTime = currentTime;
+     }
+#endif
+
+   /*
+    * draw clock
+    */
+
+   ctr_x = (W->width  / 2);
+   ctr_y = (W->height / 2);
+
+#define XPOS(i,val) (ctr_x + (W->width  * Sin[i%60] * (val) + 100000) / 200000)
+#define YPOS(i,val) (ctr_y - (W->height * Sin[(i+15)%60] * (val) + 100000) / 200000)
+   /*
+    * how to draw the clock face
+    */
+
+   /* calculate the positions of the hands */
+     {
+	int angle = (tmval->tm_hour % 12) * 5 + (tmval->tm_min / 12);
+	HandsNow.h_x = XPOS (angle, 60);
+	HandsNow.h_y = YPOS (angle, 60);
+     }
+     {
+	int angle = tmval->tm_min;
+	HandsNow.m_x = XPOS (angle, 80);
+	HandsNow.m_y = YPOS (angle, 80);
+     }
+   if (clockUpdate == 1)
+     {
+	int angle = tmval->tm_sec;
+	HandsNow.s_x = XPOS (angle, 85);
+	HandsNow.s_y = YPOS (angle, 85);
+     }
+
+   pHandsOld = (
+#ifdef ICONWIN
+		W->win == Icon.win ?  &HandsOld_icon :
+#endif
+		&HandsOld);
+
+#ifdef MAIL
+   if (MailUp_rvideo)
+     {
+	X_gc = Xrvgc;
+	X_rvgc = Xgc;
+     }
+   else
+#endif
+     {
+	X_gc = Xgc;
+	X_rvgc = Xrvgc;
+     }
+
+   if (full_redraw)
+     {
+	int angle;
+	/*
+	 * draw clock face
+	 */
+#ifdef SUBTICKS
+	for (angle = 0; angle < 60; angle++)
+	  XDrawPoint (Xdisplay, W->win, X_gc,
+		      XPOS (angle, 95),
+		      YPOS (angle, 95));
+#endif
+	for (angle = 0; angle < 60; angle += 5)
+	  XDrawLine (Xdisplay, W->win, X_gc,
+		     XPOS (angle, 90),
+		     YPOS (angle, 90),
+		     XPOS (angle, 100),
+		     YPOS (angle, 100));
+     }
+   else if (memcmp (pHandsOld, &HandsNow, sizeof(hands_t)))
+     {
+	int i, j;
+	/*
+	 * erase old hands
+	 */
+	for (i = -1; i < 2; i++) for (j = -1; j < 2; j++)
+	  {
+	     /* hour/minute hands */
+	     XDrawLine (Xdisplay, W->win, X_rvgc,
+			ctr_x + i,
+			ctr_y + j,
+			pHandsOld->h_x, pHandsOld->h_y);
+	     XDrawLine (Xdisplay, W->win, X_rvgc,
+			ctr_x + i,
+			ctr_y + j,
+			pHandsOld->m_x, pHandsOld->m_y);
+	  }
+
+	if (clockUpdate == 1)	/* seconds hand */
+	  XDrawLine (Xdisplay,
+		     W->win, X_rvgc,
+		     ctr_x,
+		     ctr_y,
+		     pHandsOld->s_x, pHandsOld->s_y);
+     }
+
+   if (full_redraw || memcmp (pHandsOld, &HandsNow, sizeof(hands_t)))
+     {
+	int i, j;
+	/*
+	 * draw new hands
+	 */
+	for (i = -1; i < 2; i++) for (j = -1; j < 2; j++)
+	  {
+	     /* hour/minute hands */
+	     XDrawLine (Xdisplay, W->win, X_gc,
+			ctr_x + i,
+			ctr_y + j,
+			HandsNow.h_x, HandsNow.h_y);
+
+	     XDrawLine (Xdisplay, W->win, X_gc,
+			ctr_x + i,
+			ctr_y + j,
+			HandsNow.m_x, HandsNow.m_y);
+	  }
+	if (clockUpdate == 1)	/* seconds hand */
+	  XDrawLine (Xdisplay, W->win, X_gc,
+		     ctr_x,
+		     ctr_y,
+		     HandsNow.s_x, HandsNow.s_y);
+
+	*pHandsOld = HandsNow;
+     }
+}
+
+#ifdef REMINDERS
+/*
+ * Read a single integer from *pstr, returns default value if it finds "*"
+ * DELIM = trailing delimiter to skip
+ */
+static int
+GetOneNum (char ** pstr, int def)
+{
+   int num, hit = 0;
+
+   for (num = 0; isdigit (**pstr); (*pstr)++)
+     {
+	num = num * 10 + (**pstr - '0');
+	hit = 1;
+     }
+   if (!hit)
+     {
+	num = def;
+	while (**pstr == '*') (*pstr)++;
+     }
+   return num;
+}
+
+/*
+ * find if TODAY is found in PSTR
+ */
+static int
+isToday (char ** pstr, int wday)
+{
+   const char * dayNames = DAY_NAMES;
+   int rval, today;
+
+   today = dayNames [wday];
+   /* no day specified is same as wildcard */
+   if (!strchr (dayNames, tolower (**pstr)))
+     return 1;
+
+   for (rval = 0; strchr (dayNames, tolower (**pstr)); (*pstr)++)
+     {
+	if (today == tolower (**pstr) || **pstr == '*')
+	  rval = 1;		/* found it */
+     }
+   return rval;
+}
+
+static char *
+trim_string (char * str)
+{
+   if (str && *str)
+     {
+	int n;
+	while (*str && isspace (*str)) str++;
+
+	n = strlen (str) - 1;
+	while (n > 0 && isspace (str [n])) n--;
+	str [n+1] = '\0';
+     }
+   return str;
+}
+
+# ifndef NO_REMINDER_EXEC
+static char *
+extract_program (char * text)
+{
+   char * prgm = text;
+   while ((prgm = strchr (prgm, ';')) != NULL)
+     {
+	if (*(prgm-1) == '\\')    /* backslash escaped */
+	  {
+	     /* remove backslash - avoid memmove() */
+	     int i, n = strlen (prgm);
+	     for (i = 0; i <= n; i++)
+	       prgm [i - 1] = prgm [i];
+	  }
+	else
+	  {
+	     *prgm++ = '\0';
+	     /* remove leading/trailing space */
+	     prgm = trim_string (prgm);
+	     break;
+	  }
+     }
+   return prgm;
+}
+# endif	/* NO_REMINDER_EXEC */
+
+/*
+ * Read the ~/.rclock file and find the next reminder
+ *
+ * update_only = 1
+ *	look for a reminder whose time is greater than the current time,
+ *	but less than the currently set reminder time
+ *
+ * update_only = 0
+ *	look for a reminder whose time is greater than the reminder that
+ *	just went off
+ */
+static void
+Next_Reminder (int update_only)
+{
+   struct tm * tmval;
+   char buffer [256];
+#ifndef INT_MAX
+# define INT_MAX	1e8
+#endif
+   time_t currentTime;
+   int savedTime = INT_MAX;
+   FILE * fd;
+
+   if (reminders_file == NULL || (fd = fopen (reminders_file, "r")) == NULL)
+     {
+	reminderTime = -1;	/* no config file, no reminders */
+	return;
+     }
+
+   currentTime = time (NULL) + adjustTime;	/* get the current time */
+   tmval = localtime (&currentTime);
+   currentTime = mk_time (tmval);
+
+   /* initial startup*/
+   if (reminderTime < 0)
+     {
+	/* ignore reminders that have already occurred */
+	reminderTime = currentTime;
+# ifndef NO_REMINDER_EXEC
+	/* scan for programs run on start-up */
+	while (fgets (buffer, sizeof(buffer), fd))
+	  {
+	     char * prgm, * text;
+
+	     text = trim_string (buffer);
+	     if (*text != ';') continue;
+
+	     prgm = extract_program (text);
+	     if (prgm != NULL && strlen (prgm) > 1)
+	       system (prgm);
+	  }
+	rewind (fd);
+# endif /* NO_REMINDER_EXEC */
+     }
+
+   /* now scan for next reminder */
+   while (fgets (buffer, sizeof(buffer), fd))
+     {
+	int testTime, hh, mm, mo, dd, yy;
+	char * text;
+
+	text = trim_string (buffer);
+	if (*text == '#') continue;	/* comment */
+	if (*text == ';') continue;	/* program run on startup */
+	/*
+	 * parse the line, format is hh:mm mo/dd/yr message; program
+	 * any of hh, mm, mo, dd, yr could be a wildcard `*'
+	 */
+	hh = GetOneNum (&text, tmval->tm_hour);  if (*text == ':') text++;
+	mm = GetOneNum (&text, 0);
+
+	while (isspace (*text)) text++;
+	if (!isToday (&text, tmval->tm_wday)) continue;
+	while (isspace (*text)) text++;
+
+	mo = GetOneNum (&text, tmval->tm_mon+1); if (*text == '/') text++;
+	dd = GetOneNum (&text, tmval->tm_mday);  if (*text == '/') text++;
+	yy = GetOneNum (&text, tmval->tm_year);
+
+	/* handle 20th/21st centuries */
+	if (yy > CENTURY)
+	  yy -= 1900;
+	else if (yy < CENTURY)
+	  yy += (CENTURY - 1900);
+
+	while (isspace (*text)) text++;
+	if (!*text) continue;
+
+	testTime = (mm + 60 * (hh + 24 * (dd + 31 * (mo + 12 * yy))));
+
+	if (testTime > (update_only ? currentTime : reminderTime))
+	  {
+#ifndef NO_REMINDER_EXEC
+	     char * prgm = extract_program (text);
+#endif	/* NO_REMINDER_EXEC */
+	     /* trim leading/trailing space */
+	     text = trim_string (text);
+
+	     /*
+	      * have a reminder whose time is greater than the last
+	      * reminder, now make sure it is the smallest available
+	      */
+	     if (testTime < savedTime)
+	       {
+		  savedTime = testTime;
+		  strncpy (message, text, sizeof(message));
+#ifndef NO_REMINDER_EXEC
+		  strncpy (execPrgm, (prgm ? prgm : ""), sizeof(execPrgm));
+#endif
+	       }
+	     else if (testTime == savedTime)
+	       {
+                  if (strlen (text))
+		    {
+		       int n = (sizeof(message) - strlen (message) - 3);
+		       if (n > 0)
+			 {
+			    /* for co-occurring events */
+			    strcat (message, "\\n");
+			    strncat (message, text, n);
+			 }
+		    }
+#ifndef NO_REMINDER_EXEC
+                  if (prgm != NULL)
+		    {
+		       int n = (sizeof(execPrgm) - strlen (execPrgm) - 2);
+		       if ((n > 0) && (n >= strlen (prgm)))
+			 {
+			    /* for co-occurring programs */
+			    strcat (execPrgm, ";");
+			    strncat (execPrgm, prgm, n);
+			 }
+		    }
+#endif /* NO_REMINDER_EXEC */
+	       }
+	  }
+     }
+
+   reminderTime = (savedTime < INT_MAX) ? savedTime : -1;
+   fclose (fd);
+}
+
+/*
+ * Provide reminder by mapping the message window
+ */
+static void
+Reminder (void)
+{
+   char * beg, * next;
+   int lines;
+
+   if (Msg_Mapped)
+     return;
+
+#ifndef NO_REMINDER_EXEC
+   if (strlen (message) == 0)
+     {
+	if (strlen (execPrgm) > 1)
+	  {
+	     system (execPrgm);
+	     Next_Reminder (REPLACE);
+	  }
+	return;			/* some sort of error */
+     }
+#endif
+
+   /* compute the window size */
+#ifdef NO_REMINDER_EXEC
+   Msg.width = 10 * XTextWidth (Xfont, "M", 1);
+#else
+   Msg.width = 18 * XTextWidth (Xfont, "M", 1);
+#endif
+
+   for (beg = message, lines = 1; beg; beg = next, lines++)
+     {
+	int width;
+	char * end;
+
+	if ((end = strstr (beg, "\\n")) == NULL)
+	  {
+	     end = beg + strlen (beg);
+	     next = NULL;
+	  }
+	else
+	  {
+	     next = end + 2;
+	  }
+
+	width = XTextWidth (Xfont, beg, (end-beg));
+	if (Msg.width < width)
+	  Msg.width = width;
+     }
+
+   Msg.width += 30;
+   Msg.height = (lines+1) * FontHeight () + 30;
+
+   /* resize and centre the window */
+   XMoveResizeWindow (Xdisplay, Msg.win,
+		      (DisplayWidth (Xdisplay, Xscreen)  - Msg.width ) / 2,
+		      (DisplayHeight (Xdisplay, Xscreen) - Msg.height) / 2,
+		      Msg.width, Msg.height);
+
+#define BUTTON_MARGIN	8
+
+   XMoveWindow (Xdisplay, msgButton.Dismiss,
+		BUTTON_MARGIN,
+		(Msg.height - msgButton.height - BUTTON_MARGIN));
+   XMoveWindow (Xdisplay, msgButton.Defer,
+		(Msg.width - msgButton.width - BUTTON_MARGIN),
+		(Msg.height - msgButton.height - BUTTON_MARGIN));
+#ifndef NO_REMINDER_EXEC
+   XMoveWindow (Xdisplay, msgButton.Start,
+		(Msg.width - msgButton.width) / 2,
+		(Msg.height - msgButton.height - BUTTON_MARGIN));
+#endif
+
+   XMapRaised (Xdisplay, Msg.win);
+   XBell (Xdisplay, 0);
+   Msg_Mapped = 1;
+}
+#endif	/* REMINDERS */
+
+#ifndef _POSIX_VERSION
+# if defined (__svr4__)
+static int
+getdtablesize (void)
+{
+   struct rlimit rlim;
+   getrlimit (RLIMIT_NOFILE, &rlim);
+   return rlim.rlim_cur;
+}
+# endif
+#endif
+
+/*
+ * Loops forever, looking for stuff to do. Sleeps 1 minute if nothing to do
+ */
+static void
+getXevent (void)
+{
+   XEvent ev;
+   int num_fds;		/* number of file descriptors being used */
+   struct timeval tm;
+   struct tm * tmval;
+   Atom wmDeleteWindow;
+   fd_set in_fdset;
+
+   /* Enable delete window protocol */
+   wmDeleteWindow = XInternAtom (Xdisplay, "WM_DELETE_WINDOW", False);
+   XSetWMProtocols (Xdisplay, Clock.win, &wmDeleteWindow, 1);
+#ifdef ICONWIN
+   XSetWMProtocols (Xdisplay, Icon.win,  &wmDeleteWindow, 1);
+#endif
+#ifdef REMINDERS
+   XSetWMProtocols (Xdisplay, Msg.win,   &wmDeleteWindow, 1);
+#endif
+
+#ifdef _POSIX_VERSION
+   num_fds = sysconf (_SC_OPEN_MAX);
+#else
+   num_fds = getdtablesize ();
+#endif
+
+   while (1) {
+      /* take care of all pending X events */
+      while (XPending (Xdisplay)) {
+	 XNextEvent (Xdisplay, &ev);
+	 switch (ev.type) {
+	  case ClientMessage:
+	    /* check for delete window requests */
+	    if ((ev.xclient.format == 32) &&
+		(ev.xclient.data.l[0] == wmDeleteWindow))
+	      {
+#ifdef REMINDERS
+		 if (ev.xany.window == Msg.win)
+		   {
+		      XUnmapWindow (Xdisplay, Msg.win);
+		      Msg_Mapped = 0;
+		      Next_Reminder (REPLACE);
+		   }
+		 else
+#endif
+		   return;	/* delete window is how this terminates */
+	      }
+	    break;
+
+	  case Expose:
+	  case GraphicsExpose:
+	    /* need to re-draw a window */
+	    if (ev.xany.window == Clock.win)
+	      Draw_Window (&Clock, 1);
+#ifdef ICONWIN
+	    else if (ev.xany.window == Icon.win)
+	      Draw_Window (&Icon, 1);
+#endif
+#ifdef REMINDERS
+	    else
+	      Draw_Window (&Msg, 1);
+#endif
+	    break;
+
+	  case ConfigureNotify:
+	    /* window has been re-sized */
+	    if (ev.xany.window == Clock.win)
+	      {
+		 Clock.width  = ev.xconfigure.width;
+		 Clock.height = ev.xconfigure.height;
+	      }
+	    break;
+
+#ifdef REMINDERS
+	  case KeyPress:
+	    /* any key press to dismiss message window */
+	    if (ev.xany.window == Msg.win)
+	      {
+		 Next_Reminder (REPLACE);
+		 Msg_Mapped = 0;
+		 XUnmapWindow (Xdisplay, Msg.win);
+	      }
+	    break;
+#endif
+
+	  case ButtonPress:
+#ifdef REMINDERS
+	    /* button press to dismiss message window */
+	    if (ev.xany.window == Msg.win)
+	      {
+		 if (ev.xbutton.subwindow == msgButton.Dismiss)
+		   {
+		      Next_Reminder (REPLACE);
+		      Msg_Mapped = 0;
+		      XUnmapWindow (Xdisplay, Msg.win);
+		   }
+		 else if (ev.xbutton.subwindow == msgButton.Defer)
+		   {
+		      time_t t = time (NULL) + adjustTime;
+		      tmval = localtime (&t);
+		      reminderTime = mk_time (tmval) + DEFER_TIME;
+		      Msg_Mapped = 0;
+		      XUnmapWindow (Xdisplay, Msg.win);
+		   }
+#ifndef NO_REMINDER_EXEC
+                 else if (ev.xbutton.subwindow == msgButton.Start)
+                   {
+		      system (execPrgm);
+                      Next_Reminder (REPLACE);
+                      Msg_Mapped = 0;
+                      XUnmapWindow (Xdisplay, Msg.win);
+                   }
+#endif	/* NO_REMINDER_EXEC */
+	      }
+#endif
+#ifdef MAIL
+	    if (ev.xany.window == Clock.win)
+	      {
+#ifdef MAIL_SPAWN
+		 /* left button action - spawn a mail reader */
+		 if (ev.xbutton.button == Button1)
+		   system (MAIL_SPAWN);
+#endif
+		 /* redraw the window */
+		 Draw_Window (&Clock, 1);
+	      }
+#endif
+            break;
+	 }
+      }
+
+      /* Now wait for time out or new X event */
+      FD_ZERO (&in_fdset);
+      FD_SET (Xfd, &in_fdset);
+      tm.tv_sec = clockUpdate;
+      tm.tv_usec = 0;
+      select (num_fds, &in_fdset, NULL, NULL, &tm);
+
+      Draw_Window (&Clock, 0);
+#ifdef ICONWIN
+      Draw_Window (&Icon, 0);
+#endif
+   }
+}
+
+/*
+ * Print an error message.
+ */
+static void
+print_error (const char * fmt, ...)
+{
+   va_list arg_ptr;
+
+   va_start (arg_ptr, fmt);
+   fprintf (stderr, APL_NAME ": ");
+   vfprintf (stderr, fmt, arg_ptr);
+   fprintf (stderr,"\n");
+   va_end (arg_ptr);
+}
+/*----------------------- end-of-file (C source) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/rclock/rclock.html work/main.d/rxvt-2.6.4/rclock/rclock.html
--- tmp/rxvt-2.6.4/rclock/rclock.html	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/rclock/rclock.html	1998-04-20 04:31:04.000000000 -0300
@@ -0,0 +1,194 @@
+<!-- manual page source format generated by RosettaMan v3.0a3, -->
+<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->
+
+<HTML>
+<HEAD>
+<TITLE>RCLOCK(1) manual page</TITLE>
+</HEAD>
+<BODY>
+<A HREF="#toc">Table of Contents</A><P>
+ 
+<H2><A NAME="sect0" HREF="#toc0">NAME</A></H2>
+rclock (ouR CLOCK)  clock and appointment reminder for X11 
+<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS</A></H2>
+<B>rclock</B> 
+ <P>
+ 
+<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION</A></H2>
+<B>rclock</B>  version <B>2.21a3</B>  is an analog clock for X intended 
+as an <I><I>xclock</I>(1)</I> replacement that conserves memory and has extra features: 
+<B>rclock</B> enters reverse video if there is mail waiting; an appointment reminder 
+is also builtin. <P>
+ 
+<H2><A NAME="sect3" HREF="#toc3">OPTIONS</A></H2>
+The options supported by <B>rclock</B>: 
+<DL>
+
+<DT><B>-display</B><I> displayname</I> 
+</DT>
+<DD>Attempt to open a window on the named X display. In the absence of this 
+option, the display specified by the DISPLAY environment variable is used. 
+</DD>
+
+<DT><B>-geometry</B><I> geom</I> </DT>
+<DD>Create the window with the specified X window geometry [default 
+80x80]. </DD>
+
+<DT><B>-bg</B><I> color</I> </DT>
+<DD>Window background color [default white]. </DD>
+
+<DT><B>-fg</B><I> color</I> </DT>
+<DD>Window 
+foreground color [default black]. </DD>
+
+<DT><B>-fn</B><I> fontname</I> </DT>
+<DD>Select font used for reminders 
+[default 7x14]. </DD>
+
+<DT><B>-iconic</B> </DT>
+<DD>Start iconified, if supported by the window manager. 
+</DD>
+
+<DT><B>-adjust</B><I> ddhhmm</I> </DT>
+<DD>Adjust the clock by +/- <I>ddhhmm</I>  = days, <I>hh</I> = hours, <I>mm</I> = 
+minutes) to fix an incorrect clock without being root or for working in 
+another time-zone. </DD>
+
+<DT><B>-update</B><I> n</I> </DT>
+<DD>Update clock face every <I>n</I> seconds [default 30]. 
+If <I>n</I>=1, a seconds hand is displayed. </DD>
+
+<DT><B>-mail</B><I> n</I> </DT>
+<DD>Check for new mail every <I>n</I> 
+seconds [default 60]. The actual interval is a multiple of the clock update 
+interval. </DD>
+
+<DT><B>#</B><I>geom</I> </DT>
+<DD>Specify the preferred icon window size [default 65x65]. 
+</DD>
+</DL>
+<P>
+ 
+<H2><A NAME="sect4" HREF="#toc4">X RESOURCES</A></H2>
+No X resources are used  only command-line options. <P>
+ 
+<H2><A NAME="sect5" HREF="#toc5">TITLES 
+AND ICONS</A></H2>
+The window and icon titles are set to the day of the week and 
+the date. The icon window is "active" and will show the time, if supported 
+by the window manager. <P>
+ 
+<H2><A NAME="sect6" HREF="#toc6">REMINDERS</A></H2>
+The <B>~/.rclock</B> file lists the messages to 
+display and/or the programs to run at specified times and dates. At the 
+specified time, <B>rclock</B> will pop-up a window in the center of the screen 
+to display the message or will simply run the scheduled program. <B></B> rclock 
+will reads the <B>~/.rclock</B> file at startup, and every 10 minutes (to look 
+for changes) and after a message window has been dismissed (to find the 
+next appointment). <P>
+ An entry in <B>~/.rclock</B> may be one of two formats (blank 
+and comment lines will be ignored): <P>
+<B>hh:mm  [dd]  MM/DD/YY message[; program]</B> 
+or<BR>
+ <B>[hh:mm  [dd]  MM/DD/YY [message]]; program</B> <BR>
+<B>hh</B> - hour (0-23; * = current) 
+<B>mm</B> - minute (0-59; * = 0) <B>dd</B> - days-of-week (some/all/none of umtwrfs; * = 
+all) <B>MM</B> - month (1-12; * = current) <B>DD</B> - day of month (1-31; * = current) 
+<B>YY</B> - year (0-99 or 1900-????; * = current) <B>message</B> - message to display <B>program</B> 
+- program to execute <P>
+The days-of-the-week use the following abbreviations: 
+<B>u</B>=Sunday, <B>m</B>=Monday, <B>t</B>=Tuesday, <B>w</B>=Wednesday, <B>r</B>=Thursday, <B>f</B>=Friday, <B>s</B>=Saturday, 
+<B>*</B>=all. <P>
+If <B>message</B> is empty and <B>program</B> has been specified, it is executed 
+without a dialog box. If time/date are also not specified, <B>program</B> is executed 
+on start-up. Note <B>message</B> may contain escape values (\n: newline, \;: semicolon). 
+<P>
+ Here's a silly example file that shows some of the permissible constructs: 
+<BR>
+# ~/.rclock - My appointment file<BR>
+ <P>
+ # startup functions<BR>
+ ; xsetroot -solid 
+Black &amp;<BR>
+ <P>
+ # cron functions<BR>
+ <P>
+ 10:00; xsetroot -solid Grey25 &amp;<BR>
+ 14:00; xsetroot 
+-solid Grey75 &amp;<BR>
+ <P>
+ # daily/weekly reminders<BR>
+ <P>
+ 08:15 mtwrf *      Good Morning!\nRead 
+News?; rxvt -e News<BR>
+ 12:00 mtwrf *      Lunch Time!<BR>
+ 17:00 mtwrf *      Go 
+Home<BR>
+ 23:00 mtwrf *      Still Here? Go to bed<BR>
+ 08:10 twrf  *      Did you 
+do your time card yesterday?<BR>
+ 15:00 f     *      Friday, do your time card 
+early!<BR>
+ 16:00 mtwr  *      Do your time card<BR>
+ 16:30 mtwrf *      Did you 
+do your time card?<BR>
+ *:00  us    *      It's the weekend, why are you here?<BR>
+ 
+8:15  f     */13/* Friday the 13th! Careful!<BR>
+ 8:15  *     4/1/*  fkrkrmfismsmkd...dkdfk<BR>
+ 
+8:16  *     4/1/*  April Fools!<BR>
+ <P>
+ # birthdays/anniversaries<BR>
+ <P>
+ 16:00    05/21/* 
+  Pam's Birthday (next week)<BR>
+ 16:00    05/24/*   Pam's Birthday (in a few 
+days)<BR>
+ <P>
+ # once-of appointments<BR>
+ <P>
+ 08:30    03/15/94    Dentist appointment<BR>
+ 
+08:30    03/15/1999  Dentist appointment<BR>
+ 08:30    03/15/2004  Dentist 
+appointment<BR>
+ <BR>
+<P>
+ 
+<H2><A NAME="sect7" HREF="#toc7">ENVIRONMENT</A></H2>
+<B>rclock</B> uses the environment variable <B>MAIL</B> to determine 
+the location of the user's mail spool file. <P>
+ 
+<H2><A NAME="sect8" HREF="#toc8">BUGS</A></H2>
+<B>rclock</B> is not very smart 
+about dealing with errors encountered while reading the <B>~/.rclock</B> file. 
+Each reminder must be a single line not exceeding 255 characters. Reminder 
+windows are sometimes not redrawn (left blank) when raised or uncovered. 
+<P>
+ 
+<H2><A NAME="sect9" HREF="#toc9">AUTHOR</A></H2>
+Rob Nation <A HREF="mailto:nation@rocket.sanders.lockheed.com">nation@rocket.sanders.lockheed.com</A> <P>
+Modifications by mj 
+olesen <A HREF="mailto:olesen@me.QueensU.CA">olesen@me.QueensU.CA</A> <P>
+ 
+<H2><A NAME="sect10" HREF="#toc10">CURRENT MAINTAINER</A></H2>
+Same as the current rxvt 
+maintainer. <P>
+
+<HR><P>
+<A NAME="toc"><B>Table of Contents</B></A><P>
+<UL>
+<LI><A NAME="toc1" HREF="#sect1">NAME</A></LI>
+<LI><A NAME="toc2" HREF="#sect2">SYNOPSIS</A></LI>
+<LI><A NAME="toc3" HREF="#sect3">DESCRIPTION</A></LI>
+<LI><A NAME="toc4" HREF="#sect4">OPTIONS</A></LI>
+<LI><A NAME="toc5" HREF="#sect5">X RESOURCES</A></LI>
+<LI><A NAME="toc6" HREF="#sect6">TITLES AND ICONS</A></LI>
+<LI><A NAME="toc7" HREF="#sect7">REMINDERS</A></LI>
+<LI><A NAME="toc8" HREF="#sect8">ENVIRONMENT</A></LI>
+<LI><A NAME="toc9" HREF="#sect9">BUGS</A></LI>
+<LI><A NAME="toc10" HREF="#sect10">AUTHOR</A></LI>
+<LI><A NAME="toc11" HREF="#sect11">CURRENT MAINTAINER</A></LI>
+</UL>
+</BODY></HTML>
Binary files tmp/rxvt-2.6.4/rclock/rclock.o and work/main.d/rxvt-2.6.4/rclock/rclock.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/README.configure work/main.d/rxvt-2.6.4/README.configure
--- tmp/rxvt-2.6.4/README.configure	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/README.configure	1999-05-16 21:47:05.000000000 -0300
@@ -0,0 +1,90 @@
+--enable-utmp
+	write user and tty to utmp file (used by programs like ``w'') on
+	creation of rxvt and delete when rxvt exits.
+--enable-wtmp
+	write user and tty to wtmp file (used by programs like ``last'') on
+	creation of rxvt and write logout when rxvt exits.
+--enable-xpm-background
+ 	add support for XPM background pixmaps
+--enable-transparency
+	add support for inheriting parent backgrounds thus giving a fake
+	transparency to the term
+--enable-menubar
+	add support for our menu bar system
+--enable-graphics
+	add support for our graphics mode (see src/graphics)
+--enable-next-scroll
+	make the scrollbar look like a NeXT scrollbar
+--enable-xterm-scroll
+	make the scrollbar look like an Xterm scrollbar
+--enable-half-shadow
+	make shadows on the scrollbar only half the normal width & height.
+	only applicable to non-Xterm scrollbars
+--enable-xim
+	add support for XIM (X Input Method) protocol.  This allows using
+	alternative input methods (e.g. kinput2) and will also correctly
+	set up the input for people using dead keys.
+--enable-kanji
+	add support for Kanji characters (EUC-JP or SJIS)
+--enable-big5
+	add support for Chinese characters (BIG5)
+--enable-gb
+	add support for Chinese characters (GB) (zh_CN, i.e. GB2312)
+--enable-greek
+	add support for greek keyboard
+--enable-ttygid
+	change tty device setting to group "tty" - only use this if
+        your system uses this type of security
+--disable-backspace-key
+	disable any handling of the backspace key by us - let the X server
+	do it
+--disable-delete-key
+	disable any handling of the delete key by us - let the X server
+	do it
+--disable-resources
+	remove all resources checking
+--enable-xgetdefault
+	make resources checking via XGetDefault() instead of our small
+	version which only checks ~/.Xdefaults, or if that doesn't exist
+	then ~/.Xresources
+--disable-memset
+	remove support for our possibly faster memset() function and 
+	use your system's version instead - which may have been hand-crafted
+	in assembly.
+--disable-swapscreen
+	remove support for swap screen
+--disable-keepscrolling
+	remove support for continual scrolling of the display when you hold
+	the mouse button down on a scrollbar arrow
+--disable-mousewheel
+	remove support for scrolling via mouse wheel or buttons 4 & 5
+--disable-old-selection
+	remove support for reverting the mouse selection style to that
+	of v2.20 (and prior)
+--disable-new-selection
+	remove support for mouse selection style like that of xterm
+--enable-dmalloc
+	use Gray Watson's malloc - which is good for debugging
+	See  http://www.letters.com/dmalloc/  for details
+        If you use either this or the next option, you may need to
+	edit src/Makefile after compiling to point DINCLUDE and DLIB to
+	the right places.
+        You can only use either this option and the following (should
+	you use either) 
+--enable-dlmalloc
+	use Doug Lea's malloc - which is good for a production version
+	See  http://g.oswego.edu/dl/html/malloc.html  for details
+--with-term=NAME
+	change the environmental variable for the terminal to NAME
+	(default "xterm")
+--with-terminfo=PATH
+	change the environmental variable for the path to the terminfo
+	tree to PATH
+--with-x
+	use the X Window System (pretty much default, eh?)
+--with-xpm-includes=DIR
+	look for the XPM includes in DIR
+--with-xpm-library=DIR
+	look for the XPM library in DIR
+--with-xpm
+	not needed - define via --enable-xpm-background
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/rxvt-2.6.4.lsm work/main.d/rxvt-2.6.4/rxvt-2.6.4.lsm
--- tmp/rxvt-2.6.4/rxvt-2.6.4.lsm	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/rxvt-2.6.4.lsm	2001-11-01 21:36:57.000000000 -0300
@@ -0,0 +1,51 @@
+Begin3
+Title:		rxvt
+Version:	2.6.4
+Entered-date:	02NOV01
+
+Description:	<http://www.rxvt.org/>
+		Rxvt is an 8-bit clean, colour xterm replacement that uses
+		significantly less memory than a conventional xterm, mostly
+		since it doesn't support toolkit configurability or Tek
+		graphics, but also since features can be removed at
+		compile-time to reflect your needs.  Some rxvt features
+		(compilation dependent): ANSI-color, bold/blink attributes
+		modify foreground/background colours, scrollbars with arrow
+		buttons, kanji and greek support, printer-pipe, XPM
+		backgrounds with on-the-fly scaling, user-definable menus.
+
+		The distribution also includes rclock, the smaller/better
+		xclock replacement with appointment scheduling and xbiff
+		functionality.
+
+Keywords:	rxvt colour color kanji xterm X11 vt100 terminal-emulator
+		rclock xbiff xpm menu
+
+Author:		* John Bovey [Univ. Kent at Canterbury] was the creator of
+		  the original xvt.
+
+		* Rob Nation [Lockheed] re-wrote most of xvt to make a
+		  substantiallly enhanced version called rxvt (Rob's xvt)
+		  and also wrote rclock (Rob's clock).
+
+		* Mark Olesen [Queen's Univ. at Kingston] made various
+		  improvements and cleanups. 
+		  Coordinated development, versions 2.11 - 2.21
+
+		* Oezguer Kesim [FU Berlin] 
+		  Coordinated development, versions 2.21a - 2.4.5
+
+		* Geoff Wing rewrote much of the screen refreshing routines
+		  and mouse selection.
+		  Coordinated development, versions 2.4.6 - 
+
+Maintained-by:	Geoff Wing <gcw@rxvt.org> Project Coordinator
+
+Original-site:	ftp.rxvt.org /pub/rxvt
+		301k	rxvt-2.6.4.tar.gz
+
+Platforms:	requires X11 installed
+
+Copying-policy:	GPL
+
+End
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/command.c work/main.d/rxvt-2.6.4/src/command.c
--- tmp/rxvt-2.6.4/src/command.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/command.c	2001-11-01 21:18:57.000000000 -0300
@@ -0,0 +1,3734 @@
+/*--------------------------------*-C-*---------------------------------*
+ * File:	command.c
+ *----------------------------------------------------------------------*
+ * $Id: command.c,v 1.85.2.35 2001/11/02 00:18:57 gcw Exp $
+ *
+ * All portions of code are copyright by their respective author/s.
+ * Copyright (C) 1992      John Bovey, University of Kent at Canterbury <jdb@ukc.ac.uk>
+ *				- original version
+ * Copyright (C) 1994      Robert Nation <nation@rocket.sanders.lockheed.com>
+ * 				- extensive modifications
+ * Copyright (C) 1995      Garrett D'Amore <garrett@netcom.com>
+ *				- vt100 printing
+ * Copyright (C) 1995      Steven Hirsch <hirsch@emba.uvm.edu>
+ *				- X11 mouse report mode and support for
+ *				  DEC "private mode" save/restore functions.
+ * Copyright (C) 1995      Jakub Jelinek <jj@gnu.ai.mit.edu>
+ *				- key-related changes to handle Shift+function
+ *				  keys properly.
+ * Copyright (C) 1997      MJ Olesen <olesen@me.queensu.ca>
+ *				- extensive modifications
+ * Copyright (C) 1997      Raul Garcia Garcia <rgg@tid.es>
+ *				- modification and cleanups for Solaris 2.x
+ *				  and Linux 1.2.x
+ * Copyright (C) 1997,1998 Oezguer Kesim <kesim@math.fu-berlin.de>
+ * Copyright (C) 1998      Geoff Wing <gcw@pobox.com>
+ * Copyright (C) 1998      Alfredo K. Kojima <kojima@windowmaker.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *----------------------------------------------------------------------*/
+
+/*{{{ includes: */
+#include "rxvt.h"		/* NECESSARY */
+#include "version.h"
+#include "command.h"
+#include "X11/keysymdef.h"
+
+/*{{{ local variables */
+static char    *ttydev = NULL;	/* pty/tty name */
+static int      cmd_fd = -1;	/* file descriptor connected to the command */
+static pid_t    cmd_pid = -1;	/* process id if child */
+static int      Xfd = -1;	/* file descriptor of X server connection */
+static unsigned int num_fds = 0;	/* number of file descriptors being used */
+static struct stat ttyfd_stat;	/* original status of the tty we will use */
+static short    changettyowner = 1;
+
+#ifndef NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING
+static int      scroll_arrow_delay;
+#endif
+#ifdef META8_OPTION
+static unsigned char meta_char;	/* Alt-key prefix */
+#endif
+static unsigned int ModMetaMask, ModNumLockMask;
+
+static unsigned long PrivateModes = PrivMode_Default;
+static unsigned long SavedModes = PrivMode_Default;
+
+static int      refresh_count = 0, refresh_limit = 1, refresh_type = SLOW_REFRESH;
+static Atom     wmDeleteWindow;
+
+/* OffiX Dnd (drag 'n' drop) support */
+#ifdef OFFIX_DND
+static Atom     DndProtocol, DndSelection;
+#endif				/* OFFIX_DND */
+
+#ifdef USE_XIM
+static XIC      Input_Context;	/* input context */
+#endif				/* NO_XLOCALE */
+
+static XCNQueue_t *XCNQueue = NULL;
+
+static char    *v_buffer;	/* pointer to physical buffer */
+static char    *v_bufstr = NULL;	/* beginning of area to write */
+static char    *v_bufptr;	/* end of area to write */
+static char    *v_bufend;	/* end of physical buffer */
+
+/*----------------------------------------------------------------------*/
+
+/*{{{ substitute system functions */
+#if defined(__svr4__) && ! defined(_POSIX_VERSION)
+/* INTPROTO */
+int
+getdtablesize(void)
+{
+    struct rlimit   rlim;
+
+    getrlimit(RLIMIT_NOFILE, &rlim);
+    return rlim.rlim_cur;
+}
+#endif
+/*}}} */
+
+/*{{{ take care of suid/sgid super-user (root) privileges */
+/* EXTPROTO */
+void
+privileges(int mode)
+{
+#if ! defined(__CYGWIN32__)
+# ifdef HAVE_SETEUID
+    static uid_t    euid;
+    static gid_t    egid;
+
+    switch (mode) {
+    case IGNORE:
+    /*
+     * change effective uid/gid - not real uid/gid - so we can switch
+     * back to root later, as required
+     */
+	seteuid(getuid());
+	setegid(getgid());
+	break;
+    case SAVE:
+	euid = geteuid();
+	egid = getegid();
+	break;
+    case RESTORE:
+	seteuid(euid);
+	setegid(egid);
+	break;
+    }
+# else
+    switch (mode) {
+    case IGNORE:
+	setuid(getuid());
+	setgid(getgid());
+    /* FALLTHROUGH */
+    case SAVE:
+    /* FALLTHROUGH */
+    case RESTORE:
+	break;
+    }
+# endif
+#endif
+}
+/*}}} */
+
+/*{{{ signal handling, exit handler */
+/*
+ * Catch a SIGCHLD signal and exit if the direct child has died
+ */
+/* ARGSUSED */
+/* INTPROTO */
+RETSIGTYPE
+Child_signal(int unused)
+{
+    int             pid, save_errno = errno;
+
+    do {
+	errno = 0;
+    }
+    while ((-1 == (pid = waitpid(-1, NULL, WNOHANG)))
+	   && (errno == EINTR));
+
+    if (pid == cmd_pid)
+	exit(EXIT_SUCCESS);
+    errno = save_errno;
+
+    signal(SIGCHLD, Child_signal);
+}
+
+/*
+ * Catch a fatal signal and tidy up before quitting
+ */
+/* INTPROTO */
+RETSIGTYPE
+Exit_signal(int sig)
+{
+#ifdef DEBUG_CMD
+    print_error("signal %d", sig);
+#endif
+    signal(sig, SIG_DFL);
+
+#ifdef UTMP_SUPPORT
+    if (!(Options & Opt_utmpInhibit)) {
+	privileges(RESTORE);
+	cleanutent();
+	privileges(IGNORE);
+    }
+#endif
+
+    kill(getpid(), sig);
+}
+
+/*
+ * Exit gracefully, clearing the utmp entry and restoring tty attributes
+ * TODO: this should free up any known resources if we can
+ */
+/* INTPROTO */
+void
+clean_exit(void)
+{
+    scr_release();
+#if defined(UTMP_SUPPORT) || ! defined(__CYGWIN32__)
+    privileges(RESTORE);
+# ifndef __CYGWIN32__
+    if (changettyowner) {
+#ifdef DEBUG_CMD
+    fprintf(stderr, "Restoring \"%s\" to mode %03o, uid %d, gid %d\n",
+	    ttydev, ttyfd_stat.st_mode, ttyfd_stat.st_uid, ttyfd_stat.st_gid);
+#endif
+	chmod(ttydev, ttyfd_stat.st_mode);
+	chown(ttydev, ttyfd_stat.st_uid, ttyfd_stat.st_gid);
+    }
+# endif
+# ifdef UTMP_SUPPORT
+    cleanutent();
+# endif
+    privileges(IGNORE);
+#endif				/* UTMP_SUPPORT || ! __CYGWIN32__ */
+}
+
+/*}}} */
+
+/*{{{ Acquire a pseudo-teletype from the system. */
+/*
+ * On failure, returns -1.
+ * On success, returns the file descriptor.
+ *
+ * If successful, ttydev and ptydev point to the names of the
+ * master and slave parts
+ */
+/* INTPROTO */
+int
+get_pty(void)
+{
+    int             fd;
+    char           *ptydev;
+
+#ifdef PTYS_ARE__GETPTY
+    if ((ptydev = ttydev = _getpty(&fd, O_RDWR | O_NDELAY, 0622, 0)) != NULL)
+	goto Found;
+#endif
+#ifdef PTYS_ARE_GETPTY
+    while ((ptydev = getpty()) != NULL)
+	if ((fd = open(ptydev, O_RDWR)) >= 0) {
+	   ttydev = ptydev;
+	   goto Found;
+	}
+#endif
+#if defined(HAVE_GRANTPT) && defined(HAVE_UNLOCKPT)
+# if defined(PTYS_ARE_GETPT) || defined(PTYS_ARE_PTMX)
+    {
+	extern char    *ptsname();
+
+#  ifdef PTYS_ARE_GETPT
+	if ((fd = getpt()) >= 0) {
+#  else
+	if ((fd = open("/dev/ptmx", O_RDWR)) >= 0) {
+#  endif
+	    if (grantpt(fd) == 0 	/* change slave permissions */
+		&& unlockpt(fd) == 0) {	/* slave now unlocked */
+		ptydev = ttydev = ptsname(fd);	/* get slave's name */
+		changettyowner = 0;
+		goto Found;
+	    }
+	    close(fd);
+	}
+    }
+# endif
+#endif
+#ifdef PTYS_ARE_PTC
+    if ((fd = open("/dev/ptc", O_RDWR)) >= 0) {
+	ptydev = ttydev = ttyname(fd);
+	goto Found;
+    }
+#endif
+#ifdef PTYS_ARE_CLONE
+    if ((fd = open("/dev/ptym/clone", O_RDWR)) >= 0) {
+	ptydev = ttydev = ptsname(fd);
+	goto Found;
+    }
+#endif
+#ifdef PTYS_ARE_NUMERIC
+    {
+	int             idx;
+	char           *c1, *c2;
+	char            pty_name[] = "/dev/ptyp???";
+	char            tty_name[] = "/dev/ttyp???";
+
+	ptydev = pty_name;
+	ttydev = tty_name;
+
+	c1 = &(pty_name[sizeof(pty_name) - 4]);
+	c2 = &(tty_name[sizeof(tty_name) - 4]);
+	for (idx = 0; idx < 256; idx++) {
+	    sprintf(c1, "%d", idx);
+	    sprintf(c2, "%d", idx);
+	    if (access(ttydev, F_OK) < 0) {
+		idx = 256;
+		break;
+	    }
+	    if ((fd = open(ptydev, O_RDWR)) >= 0) {
+		if (access(ttydev, R_OK | W_OK) == 0) {
+		    ttydev = strdup(tty_name);
+		    goto Found;
+		}
+		close(fd);
+	    }
+	}
+    }
+#endif
+#ifdef PTYS_ARE_SEARCHED
+    {
+	int             len;
+	const char     *c1, *c2;
+	char            pty_name[] = "/dev/pty??";
+	char            tty_name[] = "/dev/tty??";
+
+	len = sizeof(pty_name) - 3;
+	ptydev = pty_name;
+	ttydev = tty_name;
+
+# define PTYCHAR1	"pqrstuvwxyz"
+# define PTYCHAR2	"0123456789abcdef"
+	for (c1 = PTYCHAR1; *c1; c1++) {
+	    ptydev[len] = ttydev[len] = *c1;
+	    for (c2 = PTYCHAR2; *c2; c2++) {
+		ptydev[len + 1] = ttydev[len + 1] = *c2;
+	        if ((fd = open(ptydev, O_RDWR)) >= 0) {
+		    if (access(ttydev, R_OK | W_OK) == 0) {
+			ttydev = strdup(tty_name);
+			goto Found;
+		    }
+		    close(fd);
+		}
+	    }
+	}
+    }
+#endif
+
+    print_error("can't open pseudo-tty");
+    return -1;
+
+  Found:
+    fcntl(fd, F_SETFL, O_NDELAY);
+    return fd;
+}
+/*}}} */
+
+/*{{{ establish a controlling teletype for new session */
+/*
+ * On some systems this can be done with ioctl() but on others we
+ * need to re-open the slave tty.
+ */
+/* INTPROTO */
+int
+get_tty(void)
+{
+    int             fd, i;
+    pid_t           pid;
+
+/*
+ * setsid() [or setpgrp] must be before open of the terminal,
+ * otherwise there is no controlling terminal (Solaris 2.4, HP-UX 9)
+ */
+#ifndef ultrix
+# ifdef NO_SETSID
+    pid = setpgrp(0, 0);
+# else
+    pid = setsid();
+# endif
+    if (pid < 0)
+	perror(rs[Rs_name]);
+# ifdef DEBUG_TTYMODE
+    print_error("(%s: line %d): PID = %d\n", __FILE__, __LINE__, pid);
+# endif
+#endif				/* ultrix */
+
+    if ((fd = open(ttydev, O_RDWR)) < 0
+	&& (fd = open("/dev/tty", O_RDWR)) < 0) {
+	print_error("can't open slave tty %s", ttydev);
+	exit(EXIT_FAILURE);
+    }
+#ifdef PTYS_ARE_PTMX
+/*
+ * Push STREAMS modules:
+ *    ptem: pseudo-terminal hardware emulation module.
+ *    ldterm: standard terminal line discipline.
+ *    ttcompat: V7, 4BSD and XENIX STREAMS compatibility module.
+ */
+    if (!changettyowner) {
+	ioctl(fd, I_PUSH, "ptem");
+	ioctl(fd, I_PUSH, "ldterm");
+	ioctl(fd, I_PUSH, "ttcompat");
+    }
+#endif
+    if (changettyowner) {
+    /* change ownership of tty to real uid and real group */
+	unsigned int    mode = 0622;
+	gid_t           gid = getgid();
+
+#ifdef TTY_GID_SUPPORT
+	{
+	    struct group   *gr = getgrnam("tty");
+
+	    if (gr) {
+	    /* change ownership of tty to real uid, "tty" gid */
+		gid = gr->gr_gid;
+		mode = 0620;
+	    }
+	}
+#endif				/* TTY_GID_SUPPORT */
+#ifndef __CYGWIN32__
+	privileges(RESTORE);
+	fchown(fd, getuid(), gid);	/* fail silently */
+	fchmod(fd, mode);
+	privileges(IGNORE);
+#endif
+    }
+
+/*
+ * Close all file descriptors.  If only stdin/out/err are closed,
+ * child processes remain alive upon deletion of the window.
+ */
+    for (i = 0; i < num_fds; i++)
+	if (i != fd)
+	    close(i);
+
+/* Reopen stdin, stdout and stderr over the tty file descriptor */
+    dup2(fd, 0);		/* stdin */
+    dup2(fd, 1);		/* stdout */
+    dup2(fd, 2);		/* stderr */
+
+    if (fd > 2)
+	close(fd);
+
+#ifdef ultrix
+    if ((fd = open("/dev/tty", O_RDONLY)) >= 0) {
+	ioctl(fd, TIOCNOTTY, 0);
+	close(fd);
+    } else {
+	pid = setpgrp(0, 0);
+	if (pid < 0)
+	    perror(rs[Rs_name]);
+    }
+
+/* no error, we could run with no tty to begin with */
+#else				/* ultrix */
+# ifdef TIOCSCTTY
+    ioctl(0, TIOCSCTTY, 0);
+# endif
+
+/* set process group */
+# if defined (_POSIX_VERSION) || defined (__svr4__)
+    tcsetpgrp(0, pid);
+# elif defined (TIOCSPGRP)
+    ioctl(0, TIOCSPGRP, &pid);
+# endif
+
+/* svr4 problems: reports no tty, no job control */
+/* # if !defined (__svr4__) && defined (TIOCSPGRP) */
+    close(open(ttydev, O_RDWR, 0));
+/* # endif */
+#endif				/* ultrix */
+
+    return fd;
+}
+/*}}} */
+
+/*{{{ debug_ttymode() */
+#ifdef DEBUG_TTYMODE
+/* INTPROTO */
+void
+debug_ttymode(const ttymode_t * ttymode)
+{
+#ifdef HAVE_TERMIOS_H
+/* c_iflag bits */
+    fprintf(stderr, "Input flags\n");
+
+/* cpp token stringize doesn't work on all machines <sigh> */
+# define FOO(flag,name)		\
+    if ((ttymode->c_iflag) & flag)	\
+	fprintf (stderr, "%s ", name)
+
+/* c_iflag bits */
+    FOO(IGNBRK, "IGNBRK");
+    FOO(BRKINT, "BRKINT");
+    FOO(IGNPAR, "IGNPAR");
+    FOO(PARMRK, "PARMRK");
+    FOO(INPCK, "INPCK");
+    FOO(ISTRIP, "ISTRIP");
+    FOO(INLCR, "INLCR");
+    FOO(IGNCR, "IGNCR");
+    FOO(ICRNL, "ICRNL");
+    FOO(IXON, "IXON");
+    FOO(IXOFF, "IXOFF");
+# ifdef IUCLC
+    FOO(IUCLC, "IUCLC");
+# endif
+# ifdef IXANY
+    FOO(IXANY, "IXANY");
+# endif
+# ifdef IMAXBEL
+    FOO(IMAXBEL, "IMAXBEL");
+# endif
+    fprintf(stderr, "\n\n");
+
+# undef FOO
+# define FOO(entry, name) \
+    fprintf (stderr, "%s = %#3o\n", name, ttymode->c_cc [entry])
+
+    FOO(VINTR, "VINTR");
+    FOO(VQUIT, "VQUIT");
+    FOO(VERASE, "VERASE");
+    FOO(VKILL, "VKILL");
+    FOO(VEOF, "VEOF");
+    FOO(VEOL, "VEOL");
+# ifdef VEOL2
+    FOO(VEOL2, "VEOL2");
+# endif
+# ifdef VSWTC
+    FOO(VSWTC, "VSWTC");
+# endif
+# ifdef VSWTCH
+    FOO(VSWTCH, "VSWTCH");
+# endif
+    FOO(VSTART, "VSTART");
+    FOO(VSTOP, "VSTOP");
+    FOO(VSUSP, "VSUSP");
+# ifdef VDSUSP
+    FOO(VDSUSP, "VDSUSP");
+# endif
+# ifdef VREPRINT
+    FOO(VREPRINT, "VREPRINT");
+# endif
+# ifdef VDISCRD
+    FOO(VDISCRD, "VDISCRD");
+# endif
+# ifdef VWERSE
+    FOO(VWERSE, "VWERSE");
+# endif
+# ifdef VLNEXT
+    FOO(VLNEXT, "VLNEXT");
+# endif
+    fprintf(stderr, "\n\n");
+# undef FOO
+#endif				/* HAVE_TERMIOS_H */
+}
+
+#endif				/* DEBUG_TTYMODE */
+/*}}} */
+
+/*{{{ get_ttymode() */
+/* INTPROTO */
+void
+get_ttymode(ttymode_t * tio)
+{
+#ifdef HAVE_TERMIOS_H
+/*
+ * standard System V termios interface
+ */
+    if (GET_TERMIOS(0, tio) < 0) {
+    /* return error - use system defaults */
+	tio->c_cc[VINTR] = CINTR;
+	tio->c_cc[VQUIT] = CQUIT;
+	tio->c_cc[VERASE] = CERASE;
+	tio->c_cc[VKILL] = CKILL;
+	tio->c_cc[VSTART] = CSTART;
+	tio->c_cc[VSTOP] = CSTOP;
+	tio->c_cc[VSUSP] = CSUSP;
+# ifdef VDSUSP
+	tio->c_cc[VDSUSP] = CDSUSP;
+# endif
+# ifdef VREPRINT
+	tio->c_cc[VREPRINT] = CRPRNT;
+# endif
+# ifdef VDISCRD
+	tio->c_cc[VDISCRD] = CFLUSH;
+# endif
+# ifdef VWERSE
+	tio->c_cc[VWERSE] = CWERASE;
+# endif
+# ifdef VLNEXT
+	tio->c_cc[VLNEXT] = CLNEXT;
+# endif
+    }
+    tio->c_cc[VEOF] = CEOF;
+    tio->c_cc[VEOL] = VDISABLE;
+# ifdef VEOL2
+    tio->c_cc[VEOL2] = VDISABLE;
+# endif
+# ifdef VSWTC
+    tio->c_cc[VSWTC] = VDISABLE;
+# endif
+# ifdef VSWTCH
+    tio->c_cc[VSWTCH] = VDISABLE;
+# endif
+# if VMIN != VEOF
+    tio->c_cc[VMIN] = 1;
+# endif
+# if VTIME != VEOL
+    tio->c_cc[VTIME] = 0;
+# endif
+
+/* input modes */
+    tio->c_iflag = (BRKINT | IGNPAR | ICRNL | IXON
+# ifdef IMAXBEL
+		    | IMAXBEL
+# endif
+	);
+
+/* output modes */
+    tio->c_oflag = (OPOST | ONLCR);
+
+/* control modes */
+    tio->c_cflag = (CS8 | CREAD);
+
+/* line discipline modes */
+    tio->c_lflag = (ISIG | ICANON | IEXTEN | ECHO | ECHOE | ECHOK
+# if defined (ECHOCTL) && defined (ECHOKE)
+		    | ECHOCTL | ECHOKE
+# endif
+	);
+#else				/* HAVE_TERMIOS_H */
+
+/*
+ * sgtty interface
+ */
+
+/* get parameters -- gtty */
+    if (ioctl(0, TIOCGETP, &(tio->sg)) < 0) {
+	tio->sg.sg_erase = CERASE;	/* ^H */
+	tio->sg.sg_kill = CKILL;	/* ^U */
+    }
+    tio->sg.sg_flags = (CRMOD | ECHO | EVENP | ODDP);
+
+/* get special characters */
+    if (ioctl(0, TIOCGETC, &(tio->tc)) < 0) {
+	tio->tc.t_intrc = CINTR;	/* ^C */
+	tio->tc.t_quitc = CQUIT;	/* ^\ */
+	tio->tc.t_startc = CSTART;	/* ^Q */
+	tio->tc.t_stopc = CSTOP;	/* ^S */
+	tio->tc.t_eofc = CEOF;	/* ^D */
+	tio->tc.t_brkc = -1;
+    }
+/* get local special chars */
+    if (ioctl(0, TIOCGLTC, &(tio->lc)) < 0) {
+	tio->lc.t_suspc = CSUSP;	/* ^Z */
+	tio->lc.t_dsuspc = CDSUSP;	/* ^Y */
+	tio->lc.t_rprntc = CRPRNT;	/* ^R */
+	tio->lc.t_flushc = CFLUSH;	/* ^O */
+	tio->lc.t_werasc = CWERASE;	/* ^W */
+	tio->lc.t_lnextc = CLNEXT;	/* ^V */
+    }
+/* get line discipline */
+    ioctl(0, TIOCGETD, &(tio->line));
+# ifdef NTTYDISC
+    tio->line = NTTYDISC;
+# endif				/* NTTYDISC */
+    tio->local = (LCRTBS | LCRTERA | LCTLECH | LPASS8 | LCRTKIL);
+#endif				/* HAVE_TERMIOS_H */
+}
+/*}}} */
+
+/*{{{ run_command() */
+/*
+ * Run the command in a subprocess and return a file descriptor for the
+ * master end of the pseudo-teletype pair with the command talking to
+ * the slave.
+ */
+/* INTPROTO */
+void
+run_command(const char *const *argv)
+{
+    ttymode_t       tio;
+    int             i;
+
+    cmd_fd = get_pty();
+    if (cmd_fd < 0)
+	return;
+
+/* store original tty status for restoration clean_exit() -- rgg 04/12/95 */
+    lstat(ttydev, &ttyfd_stat);
+#ifdef DEBUG_CMD
+    fprintf(stderr, "Original settings of %s are mode %o, uid %d, gid %d\n",
+	    ttydev, ttyfd_stat.st_mode, ttyfd_stat.st_uid, ttyfd_stat.st_gid);
+#endif
+
+/* install exit handler for cleanup */
+#ifdef HAVE_ATEXIT
+    atexit(clean_exit);
+#else
+# if defined (__sun__)
+    on_exit(clean_exit, NULL);	/* non-ANSI exit handler */
+# else
+#  ifdef UTMP_SUPPORT
+    print_error("no atexit(), UTMP entries can't be cleaned");
+#  endif
+# endif
+#endif
+
+/*
+ * get tty settings before fork()
+ * and make a reasonable guess at the value for BackSpace
+ */
+    get_ttymode(&tio);
+
+/* add value for scrollBar */
+    if (scrollbar_visible()) {
+	PrivateModes |= PrivMode_scrollBar;
+	SavedModes |= PrivMode_scrollBar;
+    }
+    if (menubar_visible()) {
+	PrivateModes |= PrivMode_menuBar;
+	SavedModes |= PrivMode_menuBar;
+    }
+#ifdef DEBUG_TTYMODE
+    debug_ttymode(&tio);
+#endif
+
+/* spin off the command interpreter */
+    signal(SIGHUP, Exit_signal);
+#ifndef __svr4__
+    signal(SIGINT, Exit_signal);
+#endif
+    signal(SIGQUIT, Exit_signal);
+    signal(SIGTERM, Exit_signal);
+    signal(SIGCHLD, Child_signal);
+
+/* need to trap SIGURG for SVR4 (Unixware) rlogin */
+/* signal (SIGURG, SIG_DFL); */
+
+    cmd_pid = fork();
+    if (cmd_pid < 0) {
+	print_error("can't fork");
+	cmd_fd = -1;
+	return;
+    }
+    if (cmd_pid == 0) {		/* child */
+    /* signal (SIGHUP, Exit_signal); */
+    /* signal (SIGINT, Exit_signal); */
+#ifdef HAVE_UNSETENV
+    /* avoid passing old settings and confusing term size */
+	unsetenv("LINES");
+	unsetenv("COLUMNS");
+    /* avoid passing termcap since terminfo should be okay */
+	unsetenv("TERMCAP");
+#endif				/* HAVE_UNSETENV */
+    /* establish a controlling teletype for the new session */
+	get_tty();
+
+    /* initialize terminal attributes */
+	SET_TTYMODE(0, &tio);
+
+    /* become virtual console, fail silently */
+	if (Options & Opt_console) {
+#ifdef TIOCCONS
+	    unsigned int    on = 1;
+
+	    ioctl(0, TIOCCONS, &on);
+#elif defined (SRIOCSREDIR)
+	    int             fd = open(CONSOLE, O_WRONLY);
+
+	    if (fd < 0 || ioctl(fd, SRIOCSREDIR, 0) < 0) {
+		if (fd >= 0)
+		    close(fd);
+	    }
+#endif				/* SRIOCSREDIR */
+	}
+	tt_winsize(0);		/* set window size */
+
+    /* reset signals and spin off the command interpreter */
+	signal(SIGINT, SIG_DFL);
+	signal(SIGQUIT, SIG_DFL);
+	signal(SIGCHLD, SIG_DFL);
+    /*
+     * mimick login's behavior by disabling the job control signals
+     * a shell that wants them can turn them back on
+     */
+#ifdef SIGTSTP
+	signal(SIGTSTP, SIG_IGN);
+	signal(SIGTTIN, SIG_IGN);
+	signal(SIGTTOU, SIG_IGN);
+#endif				/* SIGTSTP */
+
+    /* command interpreter path */
+	if (argv != NULL) {
+#ifdef DEBUG_CMD
+	    int             i;
+
+	    for (i = 0; argv[i]; i++)
+		fprintf(stderr, "argv [%d] = \"%s\"\n", i, argv[i]);
+#endif
+	    execvp(argv[0], (char *const *)argv);
+	} else {
+	    const char     *argv0, *shell;
+
+	    if ((shell = getenv("SHELL")) == NULL || *shell == '\0')
+		shell = "/bin/sh";
+
+	    argv0 = my_basename(shell);
+	    if (Options & Opt_loginShell) {
+		char           *p = MALLOC((strlen(argv0) + 2) * sizeof(char));
+
+		p[0] = '-';
+		STRCPY(&p[1], argv0);
+		argv0 = p;
+	    }
+	    execlp(shell, argv0, NULL);
+	}
+	exit(EXIT_FAILURE);
+    }
+/*
+ * Close all unused file descriptors. 
+ * We don't want them, we don't need them.
+ * XXX: is not having 0, 1, 2 for PRINTPIPE a security prob?  Must check. 
+ */
+    for (i = 0; i < num_fds; i++) {
+	if (i == 2 || i == cmd_fd || i == Xfd)
+	    continue;
+	close(i);
+    }
+/*
+ * Reduce num_fds to what we use, so select() is more efficient
+ */
+    num_fds = max(2, cmd_fd);
+    MAX_IT(num_fds, Xfd);
+    num_fds++;			/* counts from 0 */
+
+#ifdef UTMP_SUPPORT
+    if (!(Options & Opt_utmpInhibit)) {
+	privileges(RESTORE);
+	makeutent(ttydev, rs[Rs_display_name]);		/* stamp /etc/utmp */
+	privileges(IGNORE);
+    }
+#endif
+}
+/*}}} */
+
+/*
+ * Probe the modifier keymap to get the Meta (Alt) and Num_Lock settings
+ * Use resource ``modifier'' to override the modifier
+ */
+/* INTPROTO */
+void
+get_ourmods(void)
+{
+    int             i, j, k;
+    int             got_meta, got_numlock;
+    int             realmeta, realalt;
+    XModifierKeymap *map;
+    KeyCode        *kc;
+    const char     *cm;
+    unsigned int    modmasks[] =
+	{ Mod1Mask, Mod2Mask, Mod3Mask, Mod4Mask, Mod5Mask };
+
+    got_meta = got_numlock = realmeta = realalt = 0;
+    if (rs[Rs_modifier]
+	&& rs[Rs_modifier][0] == 'm'
+	&& rs[Rs_modifier][1] == 'o'
+	&& rs[Rs_modifier][2] == 'd'
+	&& rs[Rs_modifier][3] >= '1' && rs[Rs_modifier][3] <= '5'
+	&& !rs[Rs_modifier][4]) {
+	ModMetaMask = modmasks[(rs[Rs_modifier][3] - '1')];
+	got_meta = 1;
+    }
+    map = XGetModifierMapping(Xdisplay);
+    kc = map->modifiermap;
+    for (i = 3; i < 8; i++) {
+	k = i * map->max_keypermod;
+	for (j = 0; j < map->max_keypermod; j++, k++) {
+	    if (kc[k] == 0)
+		break;
+	    cm = NULL;
+	    switch (XKeycodeToKeysym(Xdisplay, kc[k], 0)) {
+	    case XK_Num_Lock:
+		if (!got_numlock) {
+		    ModNumLockMask = modmasks[i - 3];
+		    got_numlock = 1;
+		}
+		break;
+	    case XK_Meta_L:
+	    case XK_Meta_R:
+		cm = "meta";
+		realmeta = i;
+		break;
+	    case XK_Alt_L:
+	    case XK_Alt_R:
+		cm = "alt";
+		realalt = i;
+		break;
+	    case XK_Super_L:
+	    case XK_Super_R:
+		cm = "super";
+		break;
+	    case XK_Hyper_L:
+	    case XK_Hyper_R:
+		cm = "hyper";
+		/* FALLTHROUGH */
+	    default:
+		break;
+	    }
+	    if (cm && rs[Rs_modifier]
+		&& !strncasecmp(rs[Rs_modifier], cm, strlen(cm))) {
+		ModMetaMask = modmasks[i - 3];
+		got_meta = 1;
+	    }
+	}
+    }
+    XFreeModifiermap(map);
+    if (!got_meta) {
+	if (realmeta)
+	    ModMetaMask = modmasks[realmeta - 3];
+	else if (realalt)
+	    ModMetaMask = modmasks[realalt - 3];
+    }
+}
+
+/*{{{ init_command() */
+/* EXTPROTO */
+void
+init_command(const char *const *argv)
+{
+/*
+ * Initialize the command connection.
+ * This should be called after the X server connection is established.
+ */
+
+/* Enable delete window protocol */
+    wmDeleteWindow = XInternAtom(Xdisplay, "WM_DELETE_WINDOW", False);
+    XSetWMProtocols(Xdisplay, TermWin.parent[0], &wmDeleteWindow, 1);
+
+#ifdef OFFIX_DND
+/* Enable OffiX Dnd (drag 'n' drop) protocol */
+    DndProtocol = XInternAtom(Xdisplay, "DndProtocol", False);
+    DndSelection = XInternAtom(Xdisplay, "DndSelection", False);
+#endif				/* OFFIX_DND */
+
+/* get number of available file descriptors */
+#if defined(_POSIX_VERSION) || ! defined(__svr4__)
+    num_fds = sysconf(_SC_OPEN_MAX);
+#else
+    num_fds = getdtablesize();
+#endif
+
+#ifdef META8_OPTION
+    meta_char = (Options & Opt_meta8 ? 0x80 : 033);
+#endif
+    get_ourmods();
+    if (!(Options & Opt_scrollTtyOutput))
+	PrivateModes |= PrivMode_TtyOutputInh;
+    if (Options & Opt_scrollKeypress)
+	PrivateModes |= PrivMode_Keypress;
+#ifndef NO_BACKSPACE_KEY
+    if (strcmp(key_backspace, "DEC") == 0)
+	PrivateModes |= PrivMode_HaveBackSpace;
+#endif
+
+#ifdef GREEK_SUPPORT
+    greek_init();
+#endif
+
+    Xfd = XConnectionNumber(Xdisplay);
+    cmdbuf_ptr = cmdbuf_endp = cmdbuf_base;
+
+    run_command(argv);
+    if (cmd_fd < 0) {
+	print_error("aborting");
+	exit(EXIT_FAILURE);
+    }
+}
+/*}}} */
+
+/*{{{ Xlocale */
+/*
+ * This is more or less stolen straight from XFree86 xterm.
+ * This should support all European type languages.
+ */
+/* EXTPROTO */
+void
+init_xlocale(void)
+{
+    char           *locale = NULL;
+
+#if !defined(NO_XSETLOCALE) || !defined(NO_SETLOCALE)
+    locale = setlocale(LC_CTYPE, "");
+#endif
+#ifdef USE_XIM
+    if (locale == NULL)
+	print_error("Setting locale failed.");
+    else {
+    /* To avoid Segmentation Fault in C locale */
+	setTermFontSet();
+        if (strcmp(locale, "C"))
+	    XRegisterIMInstantiateCallback(Xdisplay, NULL, NULL, NULL,
+					   IMInstantiateCallback, NULL);
+    }
+#endif
+}
+/*}}} */
+
+/*{{{ window resizing */
+/*
+ * Tell the teletype handler what size the window is.
+ * Called after a window size change.
+ */
+/* INTPROTO */
+void
+tt_winsize(int fd)
+{
+    struct winsize  ws;
+
+    if (fd < 0)
+	return;
+
+    ws.ws_col = (unsigned short)TermWin.ncol;
+    ws.ws_row = (unsigned short)TermWin.nrow;
+    ws.ws_xpixel = ws.ws_ypixel = 0;
+    ioctl(fd, TIOCSWINSZ, &ws);
+}
+
+/* EXTPROTO */
+void
+tt_resize(void)
+{
+    tt_winsize(cmd_fd);
+}
+
+/*}}} */
+
+/*{{{ Convert the keypress event into a string */
+/* INTPROTO */
+void
+lookup_key(XEvent * ev)
+{
+    int             ctrl, meta, shft, len;
+    KeySym          keysym;
+    static XComposeStatus compose = {NULL, 0};
+    static unsigned char kbuf[KBUFSZ];
+    static int      numlock_state = 0;
+#ifdef DEBUG_CMD
+    static int      debug_key = 1;	/* accessible by a debugger only */
+#endif
+#ifdef GREEK_SUPPORT
+    static short    greek_mode = 0;
+#endif
+#ifdef USE_XIM
+    int             valid_keysym;
+#endif
+
+/*
+ * use Num_Lock to toggle Keypad on/off.  If Num_Lock is off, allow an
+ * escape sequence to toggle the Keypad.
+ *
+ * Always permit `shift' to override the current setting
+ */
+    shft = (ev->xkey.state & ShiftMask);
+    ctrl = (ev->xkey.state & ControlMask);
+    meta = (ev->xkey.state & ModMetaMask);
+    if (numlock_state || (ev->xkey.state & ModNumLockMask)) {
+	numlock_state = (ev->xkey.state & ModNumLockMask);
+	PrivMode((!numlock_state), PrivMode_aplKP);
+    }
+#ifdef USE_XIM
+    len = 0;
+    if (Input_Context != NULL) {
+	Status          status_return;
+
+	kbuf[0] = '\0';
+	len = XmbLookupString(Input_Context, &ev->xkey, (char *)kbuf,
+			      sizeof(kbuf), &keysym, &status_return);
+	valid_keysym = ((status_return == XLookupKeySym)
+			|| (status_return == XLookupBoth));
+    } else
+	len = XLookupString(&ev->xkey, (char *)kbuf, sizeof(kbuf), &keysym,
+			    &compose);
+#else				/* USE_XIM */
+    len = XLookupString(&ev->xkey, (char *)kbuf, sizeof(kbuf), &keysym,
+			&compose);
+/*
+ * map unmapped Latin[2-4]/Katakana/Arabic/Cyrillic/Greek entries -> Latin1
+ * good for installations with correct fonts, but without XLOCALE
+ */
+    if (!len && (keysym >= 0x0100) && (keysym < 0x0800)) {
+	len = 1;
+	kbuf[0] = (keysym & 0xFF);
+    }
+#endif				/* USE_XIM */
+
+#ifdef USE_XIM
+    if (valid_keysym) {
+#endif
+
+/* for some backwards compatibility */
+#if defined(HOTKEY_CTRL) || defined(HOTKEY_META)
+# ifdef HOTKEY_CTRL
+    if (ctrl) {
+# else
+    if (meta) {
+# endif
+	if (keysym == ks_bigfont) {
+	    change_font(0, FONT_UP);
+	    return;
+	} else if (keysym == ks_smallfont) {
+	    change_font(0, FONT_DN);
+	    return;
+	}
+    }
+#endif
+
+    if (TermWin.saveLines) {
+#ifdef UNSHIFTED_SCROLLKEYS
+	if (!ctrl && !meta) {
+#else
+	if (IS_SCROLL_MOD) {
+#endif
+	    int             lnsppg;
+
+#ifdef PAGING_CONTEXT_LINES
+	    lnsppg = TermWin.nrow - PAGING_CONTEXT_LINES;
+#else
+	    lnsppg = TermWin.nrow * 4 / 5;
+#endif
+	    if (keysym == XK_Prior) {
+		scr_page(UP, lnsppg);
+		return;
+	    } else if (keysym == XK_Next) {
+		scr_page(DN, lnsppg);
+		return;
+	    }
+	}
+#ifdef SCROLL_ON_UPDOWN_KEYS
+	if (IS_SCROLL_MOD) {
+	    if (keysym == XK_Up) {
+		scr_page(UP, 1);
+		return;
+	    } else if (keysym == XK_Down) {
+		scr_page(DN, 1);
+		return;
+	    }
+	}
+#endif
+    }
+
+    if (shft) {
+    /* Shift + F1 - F10 generates F11 - F20 */
+	if (keysym >= XK_F1 && keysym <= XK_F10) {
+	    keysym += (XK_F11 - XK_F1);
+	    shft = 0;		/* turn off Shift */
+	} else if (!ctrl && !meta && (PrivateModes & PrivMode_ShiftKeys)) {
+	    switch (keysym) {
+	    /* normal XTerm key bindings */
+	    case XK_Insert:	/* Shift+Insert = paste mouse selection */
+		selection_request(ev->xkey.time, 0, 0);
+		return;
+	    /* rxvt extras */
+	    case XK_KP_Add:	/* Shift+KP_Add = bigger font */
+		change_font(0, FONT_UP);
+		return;
+	    case XK_KP_Subtract:	/* Shift+KP_Subtract = smaller font */
+		change_font(0, FONT_DN);
+		return;
+	    }
+	}
+    }
+
+#ifdef PRINTPIPE
+    if (keysym == XK_Print) {
+	scr_printscreen(ctrl | shft);
+	return;
+    }
+#endif
+#ifdef GREEK_SUPPORT
+    if (keysym == XK_Mode_switch) {
+	greek_mode = !greek_mode;
+	if (greek_mode) {
+	    xterm_seq(XTerm_title,
+		      (greek_getmode() == GREEK_ELOT928 ? "[Greek: iso]"
+							: "[Greek: ibm]"));
+	    greek_reset();
+	} else
+	    xterm_seq(XTerm_title, APL_NAME "-" VERSION);
+	return;
+    }
+#endif
+
+    if (keysym >= 0xFF00 && keysym <= 0xFFFF) {
+#ifdef KEYSYM_RESOURCE
+	if (!(shft | ctrl) && KeySym_map[keysym - 0xFF00] != NULL) {
+	    unsigned int    len;
+	    const unsigned char *kbuf;
+	    const unsigned char ch = '\033';
+
+	    kbuf = (KeySym_map[keysym - 0xFF00]);
+	    len = *kbuf++;
+
+	/* escape prefix */
+	    if (meta)
+# ifdef META8_OPTION
+		if (meta_char == 033)
+# endif
+		    tt_write(&ch, 1);
+	    tt_write(kbuf, len);
+	    return;
+	} else
+#endif
+	    switch (keysym) {
+#ifndef NO_BACKSPACE_KEY
+	    case XK_BackSpace:
+		if (PrivateModes & PrivMode_HaveBackSpace) {
+		    len = 1;
+		    kbuf[0] = ((!!(PrivateModes & PrivMode_BackSpace)
+				^ !!(shft | ctrl)) ? '\b' : '\177');
+		} else
+		    len = strlen(STRCPY(kbuf, key_backspace));
+		break;
+#endif
+#ifndef NO_DELETE_KEY
+	    case XK_Delete:
+		len = strlen(STRCPY(kbuf, key_delete));
+		break;
+#endif
+	    case XK_Tab:
+		if (shft) {
+		    len = 3;
+		    STRCPY(kbuf, "\033[Z");
+		}
+		break;
+
+#ifdef XK_KP_Home
+	    case XK_KP_Home:
+	    /* allow shift to override */
+		if ((PrivateModes & PrivMode_aplKP) ? !shft : shft) {
+		    len = 3;
+		    STRCPY(kbuf, "\033Ow");
+		    break;
+		}
+	    /* FALLTHROUGH */
+#endif
+	    case XK_Home:
+		len = strlen(STRCPY(kbuf, KS_HOME));
+		break;
+
+#ifdef XK_KP_Left
+	    case XK_KP_Up:	/* \033Ox or standard */
+	    case XK_KP_Down:	/* \033Ow or standard */
+	    case XK_KP_Right:	/* \033Ov or standard */
+	    case XK_KP_Left:	/* \033Ot or standard */
+		if ((PrivateModes & PrivMode_aplKP) ? !shft : shft) {
+		    len = 3;
+		    STRCPY(kbuf, "\033OZ");
+		    kbuf[2] = ("txvw"[keysym - XK_KP_Left]);
+		    break;
+		} else
+		/* translate to std. cursor key */
+		    keysym = XK_Left + (keysym - XK_KP_Left);
+	    /* FALLTHROUGH */
+#endif
+	    case XK_Up:		/* "\033[A" */
+	    case XK_Down:	/* "\033[B" */
+	    case XK_Right:	/* "\033[C" */
+	    case XK_Left:	/* "\033[D" */
+		len = 3;
+		STRCPY(kbuf, "\033[@");
+		kbuf[2] = ("DACB"[keysym - XK_Left]);
+	    /* do Shift first */
+		if (shft)
+		    kbuf[2] = ("dacb"[keysym - XK_Left]);
+		else if (ctrl) {
+		    kbuf[1] = 'O';
+		    kbuf[2] = ("dacb"[keysym - XK_Left]);
+		} else if (PrivateModes & PrivMode_aplCUR)
+		    kbuf[1] = 'O';
+		break;
+
+#ifndef UNSHIFTED_SCROLLKEYS
+# ifdef XK_KP_Prior
+	    case XK_KP_Prior:
+	    /* allow shift to override */
+		if ((PrivateModes & PrivMode_aplKP) ? !shft : shft) {
+		    len = 3;
+		    STRCPY(kbuf, "\033Oy");
+		    break;
+		}
+	    /* FALLTHROUGH */
+# endif
+	    case XK_Prior:
+		len = 4;
+		STRCPY(kbuf, "\033[5~");
+		break;
+# ifdef XK_KP_Next
+	    case XK_KP_Next:
+	    /* allow shift to override */
+		if ((PrivateModes & PrivMode_aplKP) ? !shft : shft) {
+		    len = 3;
+		    STRCPY(kbuf, "\033Os");
+		    break;
+		}
+	    /* FALLTHROUGH */
+# endif
+	    case XK_Next:
+		len = 4;
+		STRCPY(kbuf, "\033[6~");
+		break;
+#endif
+#ifdef XK_KP_End
+	    case XK_KP_End:
+	    /* allow shift to override */
+		if ((PrivateModes & PrivMode_aplKP) ? !shft : shft) {
+		    len = 3;
+		    STRCPY(kbuf, "\033Oq");
+		    break;
+		}
+	    /* FALLTHROUGH */
+#endif
+	    case XK_End:
+		len = strlen(STRCPY(kbuf, KS_END));
+		break;
+
+	    case XK_Select:
+		len = 4;
+		STRCPY(kbuf, "\033[4~");
+		break;
+#ifdef DXK_Remove		/* support for DEC remove like key */
+	    case DXK_Remove:
+	    /* FALLTHROUGH */
+#endif
+	    case XK_Execute:
+		len = 4;
+		STRCPY(kbuf, "\033[3~");
+		break;
+	    case XK_Insert:
+		len = 4;
+		STRCPY(kbuf, "\033[2~");
+		break;
+
+	    case XK_Menu:
+		len = 5;
+		STRCPY(kbuf, "\033[29~");
+		break;
+	    case XK_Find:
+		len = 4;
+		STRCPY(kbuf, "\033[1~");
+		break;
+	    case XK_Help:
+		len = 5;
+		STRCPY(kbuf, "\033[28~");
+		break;
+
+	    case XK_KP_Enter:
+	    /* allow shift to override */
+		if ((PrivateModes & PrivMode_aplKP) ? !shft : shft) {
+		    len = 3;
+		    STRCPY(kbuf, "\033OM");
+		} else {
+		    len = 1;
+		    kbuf[0] = '\r';
+		}
+		break;
+
+#ifdef XK_KP_Begin
+	    case XK_KP_Begin:
+		len = 3;
+		STRCPY(kbuf, "\033Ou");
+		break;
+
+	    case XK_KP_Insert:
+		len = 3;
+		STRCPY(kbuf, "\033Op");
+		break;
+
+	    case XK_KP_Delete:
+		len = 3;
+		STRCPY(kbuf, "\033On");
+		break;
+#endif
+
+	    case XK_KP_F1:	/* "\033OP" */
+	    case XK_KP_F2:	/* "\033OQ" */
+	    case XK_KP_F3:	/* "\033OR" */
+	    case XK_KP_F4:	/* "\033OS" */
+		len = 3;
+		STRCPY(kbuf, "\033OP");
+		kbuf[2] += (keysym - XK_KP_F1);
+		break;
+
+	    case XK_KP_Multiply:	/* "\033Oj" : "*" */
+	    case XK_KP_Add:	/* "\033Ok" : "+" */
+	    case XK_KP_Separator:	/* "\033Ol" : "," */
+	    case XK_KP_Subtract:	/* "\033Om" : "-" */
+	    case XK_KP_Decimal:	/* "\033On" : "." */
+	    case XK_KP_Divide:	/* "\033Oo" : "/" */
+	    case XK_KP_0:	/* "\033Op" : "0" */
+	    case XK_KP_1:	/* "\033Oq" : "1" */
+	    case XK_KP_2:	/* "\033Or" : "2" */
+	    case XK_KP_3:	/* "\033Os" : "3" */
+	    case XK_KP_4:	/* "\033Ot" : "4" */
+	    case XK_KP_5:	/* "\033Ou" : "5" */
+	    case XK_KP_6:	/* "\033Ov" : "6" */
+	    case XK_KP_7:	/* "\033Ow" : "7" */
+	    case XK_KP_8:	/* "\033Ox" : "8" */
+	    case XK_KP_9:	/* "\033Oy" : "9" */
+	    /* allow shift to override */
+		if ((PrivateModes & PrivMode_aplKP) ? !shft : shft) {
+		    len = 3;
+		    STRCPY(kbuf, "\033Oj");
+		    kbuf[2] += (keysym - XK_KP_Multiply);
+		} else {
+		    len = 1;
+		    kbuf[0] = ('*' + (keysym - XK_KP_Multiply));
+		}
+		break;
+
+#define FKEY(n, fkey)							\
+    len = 5;								\
+    sprintf((char *) kbuf,"\033[%02d~", (int)((n) + (keysym - fkey)))
+
+	    case XK_F1:	/* "\033[11~" */
+	    case XK_F2:	/* "\033[12~" */
+	    case XK_F3:	/* "\033[13~" */
+	    case XK_F4:	/* "\033[14~" */
+	    case XK_F5:	/* "\033[15~" */
+		FKEY(11, XK_F1);
+		break;
+
+	    case XK_F6:	/* "\033[17~" */
+	    case XK_F7:	/* "\033[18~" */
+	    case XK_F8:	/* "\033[19~" */
+	    case XK_F9:	/* "\033[20~" */
+	    case XK_F10:	/* "\033[21~" */
+		FKEY(17, XK_F6);
+		break;
+
+	    case XK_F11:	/* "\033[23~" */
+	    case XK_F12:	/* "\033[24~" */
+	    case XK_F13:	/* "\033[25~" */
+	    case XK_F14:	/* "\033[26~" */
+		FKEY(23, XK_F11);
+		break;
+
+	    case XK_F15:	/* "\033[28~" */
+	    case XK_F16:	/* "\033[29~" */
+		FKEY(28, XK_F15);
+		break;
+
+	    case XK_F17:	/* "\033[31~" */
+	    case XK_F18:	/* "\033[32~" */
+	    case XK_F19:	/* "\033[33~" */
+	    case XK_F20:	/* "\033[34~" */
+	    case XK_F21:	/* "\033[35~" */
+	    case XK_F22:	/* "\033[36~" */
+	    case XK_F23:	/* "\033[37~" */
+	    case XK_F24:	/* "\033[38~" */
+	    case XK_F25:	/* "\033[39~" */
+	    case XK_F26:	/* "\033[40~" */
+	    case XK_F27:	/* "\033[41~" */
+	    case XK_F28:	/* "\033[42~" */
+	    case XK_F29:	/* "\033[43~" */
+	    case XK_F30:	/* "\033[44~" */
+	    case XK_F31:	/* "\033[45~" */
+	    case XK_F32:	/* "\033[46~" */
+	    case XK_F33:	/* "\033[47~" */
+	    case XK_F34:	/* "\033[48~" */
+	    case XK_F35:	/* "\033[49~" */
+		FKEY(31, XK_F17);
+		break;
+#undef FKEY
+	    }
+    /*
+     * Pass meta for all function keys, if 'meta' option set
+     */
+#ifdef META8_OPTION
+	if (meta && (meta_char == 0x80) && len > 0)
+	    kbuf[len - 1] |= 0x80;
+#endif
+    } else if (ctrl && keysym == XK_minus) {
+	len = 1;
+	kbuf[0] = '\037';	/* Ctrl-Minus generates ^_ (31) */
+    } else {
+#ifdef META8_OPTION
+    /* set 8-bit on */
+	if (meta && (meta_char == 0x80)) {
+	    unsigned char  *ch;
+
+	    for (ch = kbuf; ch < kbuf + len; ch++)
+		*ch |= 0x80;
+	    meta = 0;
+	}
+#endif
+#ifdef GREEK_SUPPORT
+	if (greek_mode)
+	    len = greek_xlat(kbuf, len);
+#endif
+    /* nil */ ;
+    }
+#ifdef USE_XIM
+    }
+#endif
+
+    if (len <= 0)
+	return;			/* not mapped */
+
+    if (Options & Opt_scrollKeypress) {
+	want_refresh |= TermWin.view_start;
+	TermWin.view_start = 0;
+    }
+
+/*
+ * these modifications only affect the static keybuffer
+ * pass Shift/Control indicators for function keys ending with `~'
+ *
+ * eg,
+ *   Prior = "ESC[5~"
+ *   Shift+Prior = "ESC[5~"
+ *   Ctrl+Prior = "ESC[5^"
+ *   Ctrl+Shift+Prior = "ESC[5@"
+ * Meta adds an Escape prefix (with META8_OPTION, if meta == <escape>).
+ */
+    if (kbuf[0] == '\033' && kbuf[1] == '[' && kbuf[len - 1] == '~')
+	kbuf[len - 1] = (shft ? (ctrl ? '@' : '$') : (ctrl ? '^' : '~'));
+
+/* escape prefix */
+    if (meta
+#ifdef META8_OPTION
+	&& (meta_char == 033)
+#endif
+	) {
+	const unsigned char ch = '\033';
+
+	tt_write(&ch, 1);
+    }
+#ifdef DEBUG_CMD
+    if (debug_key) {		/* Display keyboard buffer contents */
+	char           *p;
+	int             i;
+
+	fprintf(stderr, "key 0x%04X [%d]: `", (unsigned int)keysym, len);
+	for (i = 0, p = kbuf; i < len; i++, p++)
+	    fprintf(stderr, (*p >= ' ' && *p < '\177' ? "%c" : "\\%03o"), *p);
+	fprintf(stderr, "'\n");
+    }
+#endif				/* DEBUG_CMD */
+    tt_write(kbuf, len);
+}
+/*}}} */
+
+#if (MENUBAR_MAX)
+/*{{{ cmd_write(), cmd_getc() */
+/* attempt to `write' COUNT to the input buffer */
+/* EXTPROTO */
+unsigned int
+cmd_write(const unsigned char *str, unsigned int count)
+{
+    int             n;
+
+    n = (count - (cmdbuf_ptr - cmdbuf_base));
+/* need to insert more chars that space available in the front */
+    if (n > 0) {
+    /* try and get more space from the end */
+	unsigned char  *src, *dst;
+
+	dst = (cmdbuf_base + sizeof(cmdbuf_base) - 1);	/* max pointer */
+
+	if ((cmdbuf_ptr + n) > dst)
+	    n = (dst - cmdbuf_ptr);	/* max # chars to insert */
+
+	if ((cmdbuf_endp + n) > dst)
+	    cmdbuf_endp = (dst - n);	/* truncate end if needed */
+
+    /* equiv: memmove ((cmdbuf_ptr+n), cmdbuf_ptr, n); */
+	src = cmdbuf_endp;
+	dst = src + n;
+    /* FIXME: anything special to avoid possible pointer wrap? */
+	while (src >= cmdbuf_ptr)
+	    *dst-- = *src--;
+
+    /* done */
+	cmdbuf_ptr += n;
+	cmdbuf_endp += n;
+    }
+    while (count-- && cmdbuf_ptr > cmdbuf_base) {
+    /* sneak one in */
+	cmdbuf_ptr--;
+	*cmdbuf_ptr = str[count];
+    }
+
+    return 0;
+}
+#endif				/* MENUBAR_MAX */
+/* cmd_getc() - Return next input character */
+/*
+ * Return the next input character after first passing any keyboard input
+ * to the command.
+ */
+/* INTPROTO */
+unsigned char
+cmd_getc(void)
+{
+#define TIMEOUT_USEC	5000
+    fd_set          readfds;
+    int             retval;
+    int             quick_timeout;
+    struct timeval  value;
+
+/* If there have been a lot of new lines, then update the screen
+ * What the heck I'll cheat and only refresh less than every page-full.
+ * the number of pages between refreshes is refresh_limit, which
+ * is incremented here because we must be doing flat-out scrolling.
+ *
+ * refreshing should be correct for small scrolls, because of the
+ * time-out */
+    if (refresh_count >= (refresh_limit * (TermWin.nrow - 1))) {
+	if (refresh_limit < REFRESH_PERIOD)
+	    refresh_limit++;
+	refresh_count = 0;
+	scr_refresh(refresh_type);
+    }
+
+/* characters already read in */
+    if (cmdbuf_ptr < cmdbuf_endp)
+	return (*cmdbuf_ptr++);
+
+    for (;;) {
+	if (v_bufstr < v_bufptr)	/* output any pending chars */
+	    tt_write(NULL, 0);
+
+	while (XPending(Xdisplay)) {	/* process pending X events */
+	    XProcessEvent(Xdisplay);
+	/* in case button actions pushed chars to cmdbuf */
+	    if (cmdbuf_ptr < cmdbuf_endp)
+		return (*cmdbuf_ptr++);
+	}
+
+#ifndef NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING
+	if (scrollbar_isUp()) {
+	    if (!scroll_arrow_delay-- && scr_page(UP, 1)) {
+		scroll_arrow_delay = SCROLLBAR_CONTINUOUS_DELAY;
+		refresh_type |= SMOOTH_REFRESH;
+	    }
+	} else if (scrollbar_isDn()) {
+	    if (!scroll_arrow_delay-- && scr_page(DN, 1)) {
+		scroll_arrow_delay = SCROLLBAR_CONTINUOUS_DELAY;
+		refresh_type |= SMOOTH_REFRESH;
+	    }
+	}
+#endif				/* NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING */
+
+    /* Nothing to do! */
+	FD_ZERO(&readfds);
+	FD_SET(cmd_fd, &readfds);
+	FD_SET(Xfd, &readfds);
+	value.tv_usec = TIMEOUT_USEC;
+	value.tv_sec = 0;
+
+	if (!TermWin.mapped)
+	    quick_timeout = 0;
+	else
+#ifdef NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING
+	    quick_timeout = want_refresh;
+#else
+	    quick_timeout = want_refresh || scrollbar_isUpDn();
+#endif
+	retval = select(num_fds, &readfds, NULL, NULL,
+			(quick_timeout ? &value : NULL));
+
+    /* See if we can read from the application */
+	if (FD_ISSET(cmd_fd, &readfds)) {
+	    int             count, n;
+
+	    cmdbuf_ptr = cmdbuf_endp = cmdbuf_base;
+	    for (count = BUFSIZ; count; count -= n, cmdbuf_endp += n)
+		if ((n = read(cmd_fd, cmdbuf_endp, count)) <= 0)
+		    break;
+	    if (count != BUFSIZ)	/* some characters read in */
+		return (*cmdbuf_ptr++);
+	}
+    /* select statement timed out - we're not hard and fast scrolling */
+	if (retval == 0) {
+	    refresh_count = 0;
+	    refresh_limit = 1;
+	}
+	if (want_refresh) {
+	    scr_refresh(refresh_type);
+	    scrollbar_show(1);
+#ifdef USE_XIM
+	    IMSendSpot();
+#endif
+	}
+    }
+/* NOTREACHED */
+}
+/*}}} */
+
+/*
+ * the 'essential' information for reporting Mouse Events
+ * pared down from XButtonEvent
+ */
+static struct {
+    int             clicks;
+    Time            time;	/* milliseconds */
+    unsigned int    state;	/* key or button mask */
+    unsigned int    button;	/* detail */
+} MEvent = {
+
+    0, CurrentTime, 0, AnyButton
+};
+
+/* INTPROTO */
+void
+mouse_report(const XButtonEvent * ev)
+{
+    int             button_number, key_state = 0;
+    int             x, y;
+
+    x = ev->x;
+    y = ev->y;
+    pixel_position(&x, &y);
+
+    button_number = ((MEvent.button == AnyButton) ? 3 :
+		     (MEvent.button - Button1));
+
+    if (PrivateModes & PrivMode_MouseX10) {
+    /*
+     * do not report ButtonRelease
+     * no state info allowed
+     */
+	key_state = 0;
+	if (button_number == 3)
+	    return;
+    } else {
+    /* XTerm mouse reporting needs these values:
+     *   4 = Shift
+     *   8 = Meta
+     *  16 = Control
+     * plus will add in our own Double-Click reporting
+     *  32 = Double Click
+     */
+	key_state = ((MEvent.state & ShiftMask) ? 4 : 0)
+	    + ((MEvent.state & ModMetaMask) ? 8 : 0)
+	    + ((MEvent.state & ControlMask) ? 16 : 0);
+#ifdef MOUSE_REPORT_DOUBLECLICK
+	key_state += ((MEvent.clicks > 1) ? 32 : 0);
+#endif
+    }
+
+#ifdef DEBUG_MOUSEREPORT
+    fprintf(stderr, "Mouse [");
+    if (key_state & 16)
+	fputc('C', stderr);
+    if (key_state & 4)
+	fputc('S', stderr);
+    if (key_state & 8)
+	fputc('A', stderr);
+    if (key_state & 32)
+	fputc('2', stderr);
+    fprintf(stderr, "]: <%d>, %d/%d\n",
+	    button_number,
+	    x + 1,
+	    y + 1);
+#else
+    tt_printf("\033[M%c%c%c",
+	      (32 + button_number + key_state),
+	      (32 + x + 1),
+	      (32 + y + 1));
+#endif
+}
+
+/*{{{ process an X event */
+/* INTPROTO */
+void
+process_x_event(XEvent * ev)
+{
+    int             reportmode;
+    Window          unused_root, unused_child;
+    int             unused_root_x, unused_root_y;
+    unsigned int    unused_mask;
+    static int      bypass_keystate = 0;
+    static int      csrO = 0;	/* Hops - csr offset in thumb/slider      */
+				/*        to give proper Scroll behaviour */
+#ifdef DEBUG_X
+    char           *eventnames[] = {	/* mason - this matches my system */
+	"",
+	"",
+	"KeyPress",
+	"KeyRelease",
+	"ButtonPress",
+	"ButtonRelease",
+	"MotionNotify",
+	"EnterNotify",
+	"LeaveNotify",
+	"FocusIn",
+	"FocusOut",
+	"KeymapNotify",
+	"Expose",
+	"GraphicsExpose",
+	"NoExpose",
+	"VisibilityNotify",
+	"CreateNotify",
+	"DestroyNotify",
+	"UnmapNotify",
+	"MapNotify",
+	"MapRequest",
+	"ReparentNotify",
+	"ConfigureNotify",
+	"ConfigureRequest",
+	"GravityNotify",
+	"ResizeRequest",
+	"CirculateNotify",
+	"CirculateRequest",
+	"PropertyNotify",
+	"SelectionClear",
+	"SelectionRequest",
+	"SelectionNotify",
+	"ColormapNotify",
+	"ClientMessage",
+	"MappingNotify"
+    };
+	
+    fprintf(stderr, "Event type: %-16s, Window: %lx (p:%lx,vt:%lx,sb:%lx)\n", eventnames[ev->type], ev->xany.window, TermWin.parent[0], TermWin.vt, scrollBar.win); fflush(stderr);
+#endif
+
+    switch (ev->type) {
+    case KeyPress:
+	lookup_key(ev);
+	break;
+
+    case ClientMessage:
+	if (ev->xclient.format == 32 && ev->xclient.data.l[0] == wmDeleteWindow)
+	    exit(EXIT_SUCCESS);
+#ifdef OFFIX_DND
+    /* OffiX Dnd (drag 'n' drop) protocol */
+	if (ev->xclient.message_type == DndProtocol
+	    && (ev->xclient.data.l[0] == DndFile
+		|| ev->xclient.data.l[0] == DndDir
+		|| ev->xclient.data.l[0] == DndLink)) {
+	/* Get Dnd data */
+	    Atom            ActualType;
+	    int             ActualFormat;
+	    unsigned char  *data;
+	    unsigned long   Size, RemainingBytes;
+
+	    XGetWindowProperty(Xdisplay, Xroot,
+			       DndSelection,
+			       0L, 1000000L,
+			       False, AnyPropertyType,
+			       &ActualType, &ActualFormat,
+			       &Size, &RemainingBytes,
+			       &data);
+	    XChangeProperty(Xdisplay, Xroot,
+			    XA_CUT_BUFFER0, XA_STRING,
+			    8, PropModeReplace,
+			    data, strlen(data));
+	    selection_paste(Xroot, XA_CUT_BUFFER0, True);
+	    XSetInputFocus(Xdisplay, Xroot, RevertToNone, CurrentTime);
+	}
+#endif				/* OFFIX_DND */
+	break;
+
+    case MappingNotify:
+	XRefreshKeyboardMapping(&(ev->xmapping));
+	break;
+
+    /*
+     * XXX: this is not the _current_ arrangement
+     * Here's my conclusion:
+     * If the window is completely unobscured, use bitblt's
+     * to scroll. Even then, they're only used when doing partial
+     * screen scrolling. When partially obscured, we have to fill
+     * in the GraphicsExpose parts, which means that after each refresh,
+     * we need to wait for the graphics expose or Noexpose events,
+     * which ought to make things real slow!
+     */
+    case VisibilityNotify:
+	switch (ev->xvisibility.state) {
+	case VisibilityUnobscured:
+	    refresh_type = FAST_REFRESH;
+	    break;
+	case VisibilityPartiallyObscured:
+	    refresh_type = SLOW_REFRESH;
+	    break;
+	default:
+	    refresh_type = NO_REFRESH;
+	    break;
+	}
+	break;
+
+    case FocusIn:
+	if (!TermWin.focus) {
+	    TermWin.focus = 1;
+	    want_refresh = 1;
+#if !defined(NO_XLOCALE) && defined(USE_XIM)
+	    if (Input_Context != NULL)
+		XSetICFocus(Input_Context);
+#endif
+	}
+	break;
+
+    case FocusOut:
+	if (TermWin.focus) {
+	    TermWin.focus = 0;
+	    want_refresh = 1;
+#if !defined(NO_XLOCALE) && defined(USE_XIM)
+	    if (Input_Context != NULL)
+		XUnsetICFocus(Input_Context);
+#endif
+	}
+	break;
+
+    case ConfigureNotify:
+	if (ev->xconfigure.window != TermWin.parent[0])
+	    break;
+#ifdef TRANSPARENT		/* XXX: maybe not needed - leave in for now */
+	if (Options & Opt_transparent)
+	    check_our_parents();
+#endif
+	if (!RemoveFromCNQueue(ev->xconfigure.width, ev->xconfigure.height)) {
+	    resize_window(ev->xconfigure.width, ev->xconfigure.height);
+#ifdef USE_XIM
+	    IMSetStatusPosition();
+#endif
+	}
+#ifdef TRANSPARENT
+	if (Options & Opt_transparent) {
+	    scr_clear();
+	    scr_touch();
+	}
+#endif
+	break;
+
+    case SelectionClear:
+	selection_clear();
+	break;
+
+    case SelectionNotify:
+	selection_paste(ev->xselection.requestor, ev->xselection.property,
+			True);
+	break;
+
+    case SelectionRequest:
+	selection_send(&(ev->xselectionrequest));
+	break;
+
+    case UnmapNotify:
+	TermWin.mapped = 0;
+	break;
+
+    case MapNotify:
+	TermWin.mapped = 1;
+	break;
+
+#ifdef TRANSPARENT
+    case PropertyNotify:
+	{
+	/*
+	 * if user used some Esetroot compatible prog to set the root
+	 * bg, use the property to determine that. We don't use it's
+	 * value, yet
+	 */
+	    static Atom     atom = 0;
+
+	    if (!atom)
+		atom = XInternAtom(Xdisplay, "_XROOTPMAP_ID", False);
+	    if (ev->xproperty.atom != atom)
+		break;
+	}
+	/* FALLTHROUGH */
+
+    case ReparentNotify:
+	if ((Options & Opt_transparent)
+	    && check_our_parents()) {	/* parents change then clear screen */
+	    scr_clear();
+	    scr_touch();
+	}
+	break;
+#endif				/* TRANSPARENT */
+
+    case GraphicsExpose:
+    case Expose:
+	if (ev->xany.window == TermWin.vt) {
+	    scr_expose(ev->xexpose.x, ev->xexpose.y,
+		       ev->xexpose.width, ev->xexpose.height);
+	} else {
+	    XEvent          unused_xevent;
+
+	    while (XCheckTypedWindowEvent(Xdisplay, ev->xany.window,
+					  Expose,
+					  &unused_xevent)) ;
+	    while (XCheckTypedWindowEvent(Xdisplay, ev->xany.window,
+					  GraphicsExpose,
+					  &unused_xevent)) ;
+	    if (isScrollbarWindow(ev->xany.window)) {
+		scrollbar_setNone();
+		scrollbar_show(0);
+	    }
+	    if (menubar_visible() && isMenuBarWindow(ev->xany.window))
+		menubar_expose();
+	    Gr_expose(ev->xany.window);
+	}
+	break;
+
+    case ButtonPress:
+	bypass_keystate = (ev->xbutton.state & (ModMetaMask | ShiftMask));
+	reportmode = (bypass_keystate ?
+		      0 : (PrivateModes & PrivMode_mouse_report));
+
+	if (ev->xany.window == TermWin.vt) {
+	    if (ev->xbutton.subwindow != None)
+		Gr_ButtonPress(ev->xbutton.x, ev->xbutton.y);
+	    else {
+		if (reportmode) {
+		/* mouse report from vt window */
+		/* save the xbutton state (for ButtonRelease) */
+		    MEvent.state = ev->xbutton.state;
+#ifdef MOUSE_REPORT_DOUBLECLICK
+		    if (ev->xbutton.button == MEvent.button
+		     && (ev->xbutton.time - MEvent.time < MULTICLICK_TIME)) {
+		    /* same button, within alloted time */
+			MEvent.clicks++;
+			if (MEvent.clicks > 1) {
+			/* only report double clicks */
+			    MEvent.clicks = 2;
+			    mouse_report(&(ev->xbutton));
+
+			/* don't report the release */
+			    MEvent.clicks = 0;
+			    MEvent.button = AnyButton;
+			}
+		    } else {
+		    /* different button, or time expired */
+			MEvent.clicks = 1;
+			MEvent.button = ev->xbutton.button;
+			mouse_report(&(ev->xbutton));
+		    }
+#else
+		    MEvent.button = ev->xbutton.button;
+		    mouse_report(&(ev->xbutton));
+#endif				/* MOUSE_REPORT_DOUBLECLICK */
+		} else {
+		    if (ev->xbutton.button != MEvent.button)
+			MEvent.clicks = 0;
+		    switch (ev->xbutton.button) {
+		    case Button1:
+			if (MEvent.button == Button1
+			&& (ev->xbutton.time - MEvent.time < MULTICLICK_TIME))
+			    MEvent.clicks++;
+			else
+			    MEvent.clicks = 1;
+			selection_click(MEvent.clicks, ev->xbutton.x,
+					ev->xbutton.y);
+			MEvent.button = Button1;
+			break;
+
+		    case Button3:
+			if (MEvent.button == Button3
+			&& (ev->xbutton.time - MEvent.time < MULTICLICK_TIME))
+			    selection_rotate(ev->xbutton.x, ev->xbutton.y);
+			else
+			    selection_extend(ev->xbutton.x, ev->xbutton.y, 1);
+			MEvent.button = Button3;
+			break;
+		    }
+		}
+		MEvent.time = ev->xbutton.time;
+		return;
+	    }
+	}
+	if (isScrollbarWindow(ev->xany.window)) {
+	    scrollbar_setNone();
+	/*
+	 * Rxvt-style scrollbar:
+	 * move up if mouse is above slider
+	 * move dn if mouse is below slider
+	 *
+	 * XTerm-style scrollbar:
+	 * Move display proportional to pointer location
+	 * pointer near top -> scroll one line
+	 * pointer near bot -> scroll full page
+	 */
+#ifndef NO_SCROLLBAR_REPORT
+	    if (reportmode) {
+	    /*
+	     * Mouse report disabled scrollbar:
+	     * arrow buttons - send up/down
+	     * click on scrollbar - send pageup/down
+	     */
+		if (scrollbar_upButton(ev->xbutton.y))
+		    tt_printf("\033[A");
+		else if (scrollbar_dnButton(ev->xbutton.y))
+		    tt_printf("\033[B");
+		else
+		    switch (ev->xbutton.button) {
+		    case Button2:
+			tt_printf("\014");
+			break;
+		    case Button1:
+			tt_printf("\033[6~");
+			break;
+		    case Button3:
+			tt_printf("\033[5~");
+			break;
+		    }
+	    } else
+#endif				/* NO_SCROLLBAR_REPORT */
+	    {
+		if (scrollbar_upButton(ev->xbutton.y)) {
+#ifndef NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING
+		    scroll_arrow_delay = SCROLLBAR_INITIAL_DELAY;
+#endif
+		    if (scr_page(UP, 1))
+			scrollbar_setUp();
+		} else if (scrollbar_dnButton(ev->xbutton.y)) {
+#ifndef NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING
+		    scroll_arrow_delay = SCROLLBAR_INITIAL_DELAY;
+#endif
+		    if (scr_page(DN, 1))
+			scrollbar_setDn();
+		} else
+		    switch (ev->xbutton.button) {
+		    case Button2:
+#if ! defined(FUNKY_SCROLL_BEHAVIOUR)
+		    /* align to thumb centre */
+			csrO = (scrollBar.bot - scrollBar.top) / 2;
+#elif ! defined(XTERM_SCROLLBAR)
+			if (scrollbar_above_slider(ev->xbutton.y)
+			    || scrollbar_below_slider(ev->xbutton.y))
+#endif				/* FUNKY_SCROLL_BEHAVIOUR */
+			    scr_move_to(scrollbar_position(ev->xbutton.y) - csrO,
+					scrollbar_size());
+			scrollbar_setMotion();
+			break;
+
+		    case Button1:
+#ifndef FUNKY_SCROLL_BEHAVIOUR
+		    /* ptr offset in thumb */
+			csrO = ev->xbutton.y - scrollBar.top;
+#endif
+		    /* FALLTHROUGH */
+
+		    case Button3:
+#ifndef XTERM_SCROLLBAR
+			if (scrollbar_above_slider(ev->xbutton.y))
+# ifdef RXVT_SCROLL_FULL
+			    scr_page(UP, TermWin.nrow - 1);
+# else
+			    scr_page(UP, TermWin.nrow / 4);
+# endif
+			else if (scrollbar_below_slider(ev->xbutton.y))
+# ifdef RXVT_SCROLL_FULL
+			    scr_page(DN, TermWin.nrow - 1);
+# else
+			    scr_page(DN, TermWin.nrow / 4);
+# endif
+			else
+			    scrollbar_setMotion();
+#else				/* XTERM_SCROLLBAR */
+			scr_page((ev->xbutton.button == Button1 ? DN : UP),
+				 (TermWin.nrow *
+				  scrollbar_position(ev->xbutton.y) /
+				  scrollbar_size())
+			    );
+#endif				/* XTERM_SCROLLBAR */
+			break;
+		    }
+	    }
+	    return;
+	}
+	if (isMenuBarWindow(ev->xany.window)) {
+	    menubar_control(&(ev->xbutton));
+	    return;
+	}
+	break;
+
+    case ButtonRelease:
+	csrO = 0;		/* reset csr Offset */
+	reportmode = bypass_keystate ? 0
+	    : (PrivateModes & PrivMode_mouse_report);
+
+	if (scrollbar_isUpDn()) {
+	    scrollbar_setNone();
+	    scrollbar_show(0);
+#ifndef NO_SCROLLBAR_BUTTON_CONTINUAL_SCROLLING
+	    refresh_type &= ~SMOOTH_REFRESH;
+#endif
+	}
+	if (ev->xany.window == TermWin.vt) {
+	    if (ev->xbutton.subwindow != None)
+		Gr_ButtonRelease(ev->xbutton.x, ev->xbutton.y);
+	    else {
+		if (reportmode) {
+		/* mouse report from vt window */
+#ifdef MOUSE_REPORT_DOUBLECLICK
+		/* only report the release of 'slow' single clicks */
+		    if (MEvent.button != AnyButton
+			&& (ev->xbutton.button != MEvent.button
+			    || (ev->xbutton.time - MEvent.time > MULTICLICK_TIME / 2))
+			) {
+			MEvent.clicks = 0;
+			MEvent.button = AnyButton;
+			mouse_report(&(ev->xbutton));
+		    }
+#else				/* MOUSE_REPORT_DOUBLECLICK */
+		    MEvent.button = AnyButton;
+		    mouse_report(&(ev->xbutton));
+#endif				/* MOUSE_REPORT_DOUBLECLICK */
+		    return;
+		}
+	    /*
+	     * dumb hack to compensate for the failure of click-and-drag
+	     * when overriding mouse reporting
+	     */
+		if (PrivateModes & PrivMode_mouse_report
+		    && bypass_keystate
+		    && ev->xbutton.button == Button1
+		    && MEvent.clicks <= 1)
+		    selection_extend(ev->xbutton.x, ev->xbutton.y, 0);
+
+		switch (ev->xbutton.button) {
+		case Button1:
+		case Button3:
+		    selection_make(ev->xbutton.time);
+		    break;
+		case Button2:
+		    selection_request(ev->xbutton.time,
+				      ev->xbutton.x, ev->xbutton.y);
+		    break;
+#ifndef NO_MOUSE_WHEEL
+		case Button4:
+		case Button5:
+		    {
+			int             i, v;
+
+			i = (ev->xbutton.state & ShiftMask) ? 1 : 5;
+			v = (ev->xbutton.button == Button4) ? UP : DN;
+# ifdef JUMP_MOUSE_WHEEL
+			scr_page(v, i);
+			scr_refresh(SMOOTH_REFRESH);
+			scrollbar_show(1);
+# else
+			for (; i--;) {
+			    scr_page(v, 1);
+			    scr_refresh(SMOOTH_REFRESH);
+			    scrollbar_show(1);
+			}
+# endif
+		    }
+		    break;
+#endif
+		}
+	    }
+	} else if (isMenuBarWindow(ev->xany.window)) {
+	    menubar_control(&(ev->xbutton));
+	}
+	break;
+
+    case MotionNotify:
+	if (isMenuBarWindow(ev->xany.window)) {
+	    menubar_control(&(ev->xbutton));
+	    break;
+	}
+	if ((PrivateModes & PrivMode_mouse_report) && !(bypass_keystate))
+	    break;
+
+	if (ev->xany.window == TermWin.vt) {
+	    if ((ev->xbutton.state & (Button1Mask | Button3Mask))) {
+		while (XCheckTypedWindowEvent(Xdisplay, TermWin.vt,
+					      MotionNotify, ev)) ;
+		XQueryPointer(Xdisplay, TermWin.vt,
+			      &unused_root, &unused_child,
+			      &unused_root_x, &unused_root_y,
+			      &(ev->xbutton.x), &(ev->xbutton.y),
+			      &unused_mask);
+#ifdef MOUSE_THRESHOLD
+	    /* deal with a `jumpy' mouse */
+		if ((ev->xmotion.time - MEvent.time) > MOUSE_THRESHOLD)
+#endif
+		    selection_extend((ev->xbutton.x), (ev->xbutton.y),
+				  (ev->xbutton.state & Button3Mask) ? 2 : 0);
+	    }
+	} else if (isScrollbarWindow(ev->xany.window) && scrollbar_isMotion()) {
+	    while (XCheckTypedWindowEvent(Xdisplay, scrollBar.win,
+					  MotionNotify, ev)) ;
+	    XQueryPointer(Xdisplay, scrollBar.win,
+			  &unused_root, &unused_child,
+			  &unused_root_x, &unused_root_y,
+			  &(ev->xbutton.x), &(ev->xbutton.y),
+			  &unused_mask);
+	    scr_move_to(scrollbar_position(ev->xbutton.y) - csrO,
+			scrollbar_size());
+	    scr_refresh(refresh_type);
+	    refresh_count = refresh_limit = 0;
+	    scrollbar_show(1);
+#ifdef USE_XIM
+	    IMSendSpot();
+#endif
+	}
+	break;
+    }
+}
+
+#ifdef TRANSPARENT
+/*
+ * Check our parents are still who we think they are.
+ */
+/* INTPROTO */
+int
+check_our_parents(void)
+{
+    int             i, pchanged;
+    unsigned int    n;
+    Window          root, oldp, *list;
+
+/* Get all X ops out of the queue so that our information is up-to-date. */
+    XSync(Xdisplay, False);
+
+/*
+ * Make the frame window set by the window manager have
+ * the root background. Some window managers put multiple nested frame
+ * windows for each client, so we have to take care about that.
+ */
+    pchanged = 0;
+    for (i = 1; i < KNOW_PARENTS; i++) {
+	oldp = TermWin.parent[i];
+	XQueryTree(Xdisplay, TermWin.parent[i - 1], &root,
+		   &TermWin.parent[i], &list, &n);
+	XFree(list);
+	if (TermWin.parent[i] == Xroot) {
+	    if (oldp != None)
+		pchanged = 1;
+	    break;
+	}
+	if (oldp != TermWin.parent[i])
+	    pchanged = 1;
+    }
+    n = 0;
+    if (pchanged) {
+	XWindowAttributes wattr;
+	int             d;
+
+	XGetWindowAttributes(Xdisplay, Xroot, &wattr);
+	d = wattr.depth;
+	for (n = 0; n < i; n++) {
+	    XGetWindowAttributes(Xdisplay, TermWin.parent[n], &wattr);
+	    if (wattr.depth != d || wattr.class == InputOnly) {
+		n = KNOW_PARENTS + 1;
+		break;
+	    }
+	}
+    }
+    if (n > KNOW_PARENTS) {
+	XSetWindowBackground(Xdisplay, TermWin.parent[0], PixColors[Color_fg]);
+	XSetWindowBackground(Xdisplay, TermWin.vt, PixColors[Color_bg]);
+	/* XXX: also turn off Opt_transparent? */
+    } else
+	for (n = 0; n < i; n++)
+	    XSetWindowBackgroundPixmap(Xdisplay, TermWin.parent[n],
+				       ParentRelative);
+
+    for (; i < KNOW_PARENTS; i++)
+	TermWin.parent[i] = None;
+    return pchanged;
+}
+#endif
+
+/*}}} */
+
+/*
+ * Send printf() formatted output to the command.
+ * Only use for small ammounts of data.
+ */
+/* EXTPROTO */
+void
+tt_printf(const char *fmt,...)
+{
+    va_list         arg_ptr;
+    unsigned char   buf[256];
+
+    va_start(arg_ptr, fmt);
+    vsprintf(buf, fmt, arg_ptr);
+    va_end(arg_ptr);
+    tt_write(buf, strlen(buf));
+}
+
+/*{{{ print pipe */
+/*----------------------------------------------------------------------*/
+#ifdef PRINTPIPE
+/* EXTPROTO */
+FILE           *
+popen_printer(void)
+{
+    FILE           *stream = popen(rs[Rs_print_pipe], "w");
+
+    if (stream == NULL)
+	print_error("can't open printer pipe");
+    return stream;
+}
+
+/* EXTPROTO */
+int
+pclose_printer(FILE * stream)
+{
+    fflush(stream);
+/* pclose() reported not to work on SunOS 4.1.3 */
+# if defined (__sun__)		/* TODO: RESOLVE THIS */
+/* pclose works provided SIGCHLD handler uses waitpid */
+    return pclose(stream);	/* return fclose (stream); */
+# else
+    return pclose(stream);
+# endif
+}
+
+/*
+ * simulate attached vt100 printer
+ */
+/* INTPROTO */
+void
+process_print_pipe(void)
+{
+    int             done;
+    FILE           *fd;
+
+    if ((fd = popen_printer()) == NULL)
+	return;
+
+/* 
+ * Send all input to the printer until either ESC[4i or ESC[?4i 
+ * is received. 
+ */
+    for (done = 0; !done;) {
+	unsigned char   buf[8];
+	unsigned char   ch;
+	unsigned int    i, len;
+
+	if ((ch = cmd_getc()) != '\033') {
+	    if (putc(ch, fd) == EOF)
+		break;		/* done = 1 */
+	} else {
+	    len = 0;
+	    buf[len++] = ch;
+
+	    if ((buf[len++] = cmd_getc()) == '[') {
+		if ((ch = cmd_getc()) == '?') {
+		    buf[len++] = '?';
+		    ch = cmd_getc();
+		}
+		if ((buf[len++] = ch) == '4') {
+		    if ((buf[len++] = cmd_getc()) == 'i')
+			break;	/* done = 1 */
+		}
+	    }
+	    for (i = 0; i < len; i++)
+		if (putc(buf[i], fd) == EOF) {
+		    done = 1;
+		    break;
+		}
+	}
+    }
+    pclose_printer(fd);
+}
+#endif				/* PRINTPIPE */
+/*}}} */
+
+/*{{{ process escape sequences */
+/* INTPROTO */
+void
+process_escape_seq(void)
+{
+    unsigned char   ch = cmd_getc();
+
+    switch (ch) {
+    /* case 1:        do_tek_mode (); break; */
+    case '#':
+	if (cmd_getc() == '8')
+	    scr_E();
+	break;
+    case '(':
+	scr_charset_set(0, cmd_getc());
+	break;
+    case ')':
+	scr_charset_set(1, cmd_getc());
+	break;
+    case '*':
+	scr_charset_set(2, cmd_getc());
+	break;
+    case '+':
+	scr_charset_set(3, cmd_getc());
+	break;
+#ifdef MULTICHAR_SET
+    case '$':
+	scr_charset_set(-2, cmd_getc());
+	break;
+#endif
+    case '6':
+#ifndef NO_FRILLS
+	scr_backindex();
+#endif
+	break;
+    case '7':
+	scr_cursor(SAVE);
+	break;
+    case '8':
+	scr_cursor(RESTORE);
+	break;
+    case '9':
+#ifndef NO_FRILLS
+	scr_forwardindex();
+#endif
+	break;
+    case '=':
+    case '>':
+	PrivMode((ch == '='), PrivMode_aplKP);
+	break;
+    case '@':
+	(void)cmd_getc();
+	break;
+    case 'D':
+	scr_index(UP);
+	break;
+    case 'E':
+	scr_add_lines((const unsigned char *)"\n\r", 1, 2);
+	break;
+    case 'G':
+	process_graphics();
+	break;
+    case 'H':
+	scr_set_tab(1);
+	break;
+    case 'M':
+	scr_index(DN);
+	break;
+    /*case 'N': scr_single_shift (2);   break; */
+    /*case 'O': scr_single_shift (3);   break; */
+    case 'Z':
+	tt_printf(ESCZ_ANSWER);
+	break;			/* steal obsolete ESC [ c */
+    case '[':
+	process_csi_seq();
+	break;
+    case ']':
+	process_xterm_seq();
+	break;
+    case 'c':
+	scr_poweron();
+	break;
+    case 'n':
+	scr_charset_choose(2);
+	break;
+    case 'o':
+	scr_charset_choose(3);
+	break;
+    }
+}
+/*}}} */
+
+/*{{{ process CSI (code sequence introducer) sequences `ESC[' */
+/* INTPROTO */
+void
+process_csi_seq(void)
+{
+    unsigned char   ch, priv;
+    unsigned int    nargs;
+    int             arg[ESC_ARGS];
+
+    for (nargs = ESC_ARGS; nargs > 0;)
+	arg[--nargs] = 0;
+
+    priv = 0;
+    ch = cmd_getc();
+    if (ch >= '<' && ch <= '?') {
+	priv = ch;
+	ch = cmd_getc();
+    }
+/* read any numerical arguments */
+    do {
+	int             n = 0;
+
+	if (isdigit(ch)) {
+	    for (; isdigit(ch); ch = cmd_getc())
+		n = n * 10 + (ch - '0');
+	    if (nargs < ESC_ARGS)
+		arg[nargs++] = n;
+	}
+	if (ch == '\b') {
+	    scr_backspace();
+	} else if (ch == 033) {
+	    process_escape_seq();
+	    return;
+	} else if (ch < ' ') {
+	    scr_add_lines(&ch, 0, 1);
+	    return;
+	}
+	if (ch < '@')
+	    ch = cmd_getc();
+    } while (ch >= ' ' && ch < '@');
+    if (ch == 033) {
+	process_escape_seq();
+	return;
+    } else if (ch < ' ')
+	return;
+
+    switch (ch) {
+#ifdef PRINTPIPE
+    case 'i':			/* printing */
+	switch (arg[0]) {
+	case 0:
+	    scr_printscreen(0);
+	    break;
+	case 5:
+	    process_print_pipe();
+	    break;
+	}
+	break;
+#endif
+    case 'A':
+    case 'e':			/* up <n> */
+	scr_gotorc(arg[0] ? -arg[0] : -1, 0, RELATIVE);
+	break;
+    case 'B':			/* down <n> */
+	scr_gotorc(arg[0] ? arg[0] : 1, 0, RELATIVE);
+	break;
+    case 'C':
+    case 'a':			/* right <n> */
+	scr_gotorc(0, arg[0] ? arg[0] : 1, RELATIVE);
+	break;
+    case 'D':			/* left <n> */
+	scr_gotorc(0, arg[0] ? -arg[0] : -1, RELATIVE);
+	break;
+    case 'E':			/* down <n> & to first column */
+	scr_gotorc(arg[0] ? arg[0] : 1, 0, R_RELATIVE);
+	break;
+    case 'F':			/* up <n> & to first column */
+	scr_gotorc(arg[0] ? -arg[0] : -1, 0, R_RELATIVE);
+	break;
+    case 'G':
+    case '`':			/* move to col <n> */
+	scr_gotorc(0, arg[0] ? arg[0] - 1 : 1, R_RELATIVE);
+	break;
+    case 'd':			/* move to row <n> */
+	scr_gotorc(arg[0] ? arg[0] - 1 : 1, 0, C_RELATIVE);
+	break;
+    case 'H':
+    case 'f':			/* position cursor */
+	switch (nargs) {
+	case 0:
+	    scr_gotorc(0, 0, 0);
+	    break;
+	case 1:
+	    scr_gotorc(arg[0] ? arg[0] - 1 : 0, 0, 0);
+	    break;
+	default:
+	    scr_gotorc(arg[0] - 1, arg[1] - 1, 0);
+	    break;
+	}
+	break;
+    case 'I':
+	scr_tab(arg[0] ? arg[0] : 1);
+	break;
+    case 'Z':
+	scr_tab(arg[0] ? -arg[0] : -1);
+	break;
+    case 'J':
+	scr_erase_screen(arg[0]);
+	break;
+    case 'K':
+	scr_erase_line(arg[0]);
+	break;
+    case '@':
+	scr_insdel_chars(arg[0] ? arg[0] : 1, INSERT);
+	break;
+    case 'L':
+	scr_insdel_lines(arg[0] ? arg[0] : 1, INSERT);
+	break;
+    case 'M':
+	scr_insdel_lines(arg[0] ? arg[0] : 1, DELETE);
+	break;
+    case 'X':
+	scr_insdel_chars(arg[0] ? arg[0] : 1, ERASE);
+	break;
+    case 'P':
+	scr_insdel_chars(arg[0] ? arg[0] : 1, DELETE);
+	break;
+    case 'T':
+    case '^':
+	scr_scroll_text(arg[0] ? -arg[0] : -1);
+	break;
+    case 'S':
+	scr_scroll_text(arg[0] ? arg[0] : 1);
+	break;
+    case 'c':
+	tt_printf(VT100_ANS);
+	break;
+    case 'm':
+	process_sgr_mode(nargs, arg);
+	break;
+    case 'n':			/* request for information */
+	switch (arg[0]) {
+	case 5:
+	    tt_printf("\033[0n");
+	    break;		/* ready */
+	case 6:
+	    scr_report_position();
+	    break;
+#if defined (ENABLE_DISPLAY_ANSWER)
+	case 7:
+	    tt_printf("%-.250s\n", rs[Rs_display_name]);
+	    break;
+#endif
+	case 8:
+	    xterm_seq(XTerm_title, APL_NAME "-" VERSION);
+	    break;
+	}
+	break;
+    case 'r':			/* set top and bottom margins */
+	if (priv != '?') {
+	    if (nargs < 2 || arg[0] >= arg[1])
+		scr_scroll_region(0, 10000);
+	    else
+		scr_scroll_region(arg[0] - 1, arg[1] - 1);
+	    break;
+	}
+    /* FALLTHROUGH */
+    case 's':
+    case 'h':
+    case 'l':
+	process_terminal_mode(ch, priv, nargs, arg);
+	break;
+    case 't':
+	if (priv)
+	    process_terminal_mode(ch, priv, nargs, arg);
+#ifndef NO_FRILLS
+	else
+	    process_window_ops(arg, nargs);
+#endif
+	break;
+    case 'g':
+	switch (arg[0]) {
+	case 0:
+	    scr_set_tab(0);
+	    break;		/* delete tab */
+	case 3:
+	    scr_set_tab(-1);
+	    break;		/* clear all tabs */
+	}
+	break;
+    case 'W':
+	switch (arg[0]) {
+	case 0:
+	    scr_set_tab(1);
+	    break;		/* = ESC H */
+	case 2:
+	    scr_set_tab(0);
+	    break;		/* = ESC [ 0 g */
+	case 5:
+	    scr_set_tab(-1);
+	    break;		/* = ESC [ 3 g */
+	}
+	break;
+    }
+}
+/*}}} */
+
+#ifndef NO_FRILLS
+/* ARGSUSED */
+/* INTPROTO */
+void
+process_window_ops(const int *args, int nargs)
+{
+    int             x, y;
+    char           *s;
+    XWindowAttributes wattr;
+    Window          wdummy;
+
+    if (nargs == 0)
+	return;
+    switch (args[0]) {
+    /*
+     * commands
+     */
+    case 1:			/* deiconify window */
+	XMapWindow(Xdisplay, TermWin.parent[0]);
+	break;
+    case 2:			/* iconify window */
+	XIconifyWindow(Xdisplay, TermWin.parent[0], DefaultScreen(Xdisplay));
+	break;
+    case 3:			/* set position (pixels) */
+	AddToCNQueue(szHint.width, szHint.height);
+	XMoveWindow(Xdisplay, TermWin.parent[0], args[1], args[2]);
+	break;
+    case 4:			/* set size (pixels) */
+	set_widthheight(args[2], args[1]);
+	break;
+    case 5:			/* raise window */
+	XRaiseWindow(Xdisplay, TermWin.parent[0]);
+	break;
+    case 6:			/* lower window */
+	XLowerWindow(Xdisplay, TermWin.parent[0]);
+	break;
+    case 7:			/* refresh window */
+	scr_touch();
+	break;
+    case 8:			/* set size (chars) */
+	set_widthheight(args[2] * TermWin.fwidth, args[1] * TermWin.fheight);
+	break;
+    default:
+	if (args[0] >= 24)	/* set height (chars) */
+	    set_widthheight(TermWin.width, args[1] * TermWin.fheight);
+	break;
+    /*
+     * reports - some output format copied from XTerm
+     */
+    case 11:			/* report window state */
+	XGetWindowAttributes(Xdisplay, TermWin.parent[0], &wattr);
+	tt_printf("\033[%dt", wattr.map_state == IsViewable ? 1 : 2);
+	break;
+    case 13:			/* report window position */
+	XGetWindowAttributes(Xdisplay, TermWin.parent[0], &wattr);
+	XTranslateCoordinates(Xdisplay, TermWin.parent[0], wattr.root,
+			      -wattr.border_width, -wattr.border_width,
+			      &x, &y, &wdummy);
+	tt_printf("\033[3;%d;%dt", x, y);
+	break;
+    case 14:			/* report window size (pixels) */
+	XGetWindowAttributes(Xdisplay, TermWin.parent[0], &wattr);
+	tt_printf("\033[4;%d;%dt", wattr.height, wattr.width);
+	break;
+    case 18:			/* report window size (chars) */
+	tt_printf("\033[8;%d;%dt", TermWin.nrow, TermWin.ncol);
+	break;
+    case 20:			/* report icon label */
+	XGetIconName(Xdisplay, TermWin.parent[0], &s);
+	tt_printf("\033]L%-.200s\033\\", s ? s : "");
+	break;
+    case 21:			/* report window title */
+	XFetchName(Xdisplay, TermWin.parent[0], &s);
+	tt_printf("\033]l%-.200s\033\\", s ? s : "");
+	break;
+    }
+}
+#endif
+
+/*{{{ process xterm text parameters sequences `ESC ] Ps ; Pt BEL' */
+/* INTPROTO */
+void
+process_xterm_seq(void)
+{
+    unsigned char   ch, string[STRING_MAX];
+    int             arg;
+
+    ch = cmd_getc();
+    for (arg = 0; isdigit(ch); ch = cmd_getc())
+	arg = arg * 10 + (ch - '0');
+
+    if (ch == ';') {
+	int             n = 0;
+
+	while ((ch = cmd_getc()) != 007) {
+	    if (ch) {
+		if (ch == '\t')
+		    ch = ' ';	/* translate '\t' to space */
+		else if (ch < ' ')
+		    return;	/* control character - exit */
+
+		if (n < sizeof(string) - 1)
+		    string[n++] = ch;
+	    }
+	}
+	string[n] = '\0';
+    /*
+     * menubar_dispatch() violates the constness of the string,
+     * so do it here
+     */
+	if (arg == XTerm_Menu)
+	    menubar_dispatch((char *)string);
+	else
+	    xterm_seq(arg, (char *)string);
+    }
+}
+
+/*}}} */
+
+/*{{{ process DEC private mode sequences `ESC [ ? Ps mode' */
+/*
+ * mode can only have the following values:
+ *      'l' = low
+ *      'h' = high
+ *      's' = save
+ *      'r' = restore
+ *      't' = toggle
+ * so no need for fancy checking
+ */
+/* INTPROTO */
+void
+process_terminal_mode(int mode, int priv, unsigned int nargs, const int *arg)
+{
+    unsigned int    i;
+    int             state;
+
+    if (nargs == 0)
+	return;
+
+/* make lo/hi boolean */
+    if (mode == 'l')
+	mode = 0;
+    else if (mode == 'h')
+	mode = 1;
+
+#define PrivCases(bit)							\
+    if (mode == 's') {							\
+	SavedModes |= (PrivateModes & bit);				\
+	break;								\
+    } else {								\
+	if (mode == 'r')						\
+	    state = (SavedModes & bit) ? 1 : 0;				\
+	else								\
+	    state = (mode == 't') ? !(PrivateModes & bit) : mode;	\
+	PrivMode(state, bit);						\
+    } 
+
+    switch (priv) {
+    case 0:
+	if (mode && mode != 1)
+	    return;		/* only do high/low */
+	for (i = 0; i < nargs; i++)
+	    switch (arg[i]) {
+	    case 4:
+		scr_insert_mode(mode);
+		break;
+	    /* case 38:  TEK mode */
+	    }
+	break;
+
+    case '?':
+	for (i = 0; i < nargs; i++)
+	    switch (arg[i]) {
+	    case 1:		/* application cursor keys */
+		PrivCases(PrivMode_aplCUR);
+		break;
+
+	    /* case 2:   - reset charsets to USASCII */
+
+	    case 3:		/* 80/132 */
+		PrivCases(PrivMode_132);
+		if (PrivateModes & PrivMode_132OK)
+		    set_widthheight((state ? 132 : 80) * TermWin.fwidth,
+				    TermWin.height);
+		break;
+
+	    /* case 4:   - smooth scrolling */
+
+	    case 5:		/* reverse video */
+		PrivCases(PrivMode_rVideo);
+		scr_rvideo_mode(state);
+		break;
+
+	    case 6:		/* relative/absolute origins  */
+		PrivCases(PrivMode_relOrigin);
+		scr_relative_origin(state);
+		break;
+
+	    case 7:		/* autowrap */
+		PrivCases(PrivMode_Autowrap);
+		scr_autowrap(state);
+		break;
+
+	    /* case 8:   - auto repeat, can't do on a per window basis */
+
+	    case 9:		/* X10 mouse reporting */
+		PrivCases(PrivMode_MouseX10);
+	    /* orthogonal */
+		if (PrivateModes & PrivMode_MouseX10)
+		    PrivateModes &= ~(PrivMode_MouseX11);
+		break;
+#ifdef menuBar_esc
+	    case menuBar_esc:
+		PrivCases(PrivMode_menuBar);
+		map_menuBar(state);
+		break;
+#endif
+#ifdef scrollBar_esc
+	    case scrollBar_esc:
+		PrivCases(PrivMode_scrollBar);
+		map_scrollBar(state);
+		break;
+#endif
+	    case 25:		/* visible/invisible cursor */
+		PrivCases(PrivMode_VisibleCursor);
+		scr_cursor_visible(state);
+		break;
+
+	    case 35:
+		PrivCases(PrivMode_ShiftKeys);
+		break;
+
+	    case 40:		/* 80 <--> 132 mode */
+		PrivCases(PrivMode_132OK);
+		break;
+
+	    case 47:		/* secondary screen */
+		PrivCases(PrivMode_Screen);
+		scr_change_screen(state);
+		break;
+
+	    case 66:		/* application key pad */
+		PrivCases(PrivMode_aplKP);
+		break;
+
+	    case 67:
+#ifndef NO_BACKSPACE_KEY
+		if (PrivateModes & PrivMode_HaveBackSpace) {
+		    PrivCases(PrivMode_BackSpace);
+		}
+#endif
+		break;
+
+	    case 1000:		/* X11 mouse reporting */
+		PrivCases(PrivMode_MouseX11);
+	    /* orthogonal */
+		if (PrivateModes & PrivMode_MouseX11)
+		    PrivateModes &= ~(PrivMode_MouseX10);
+		break;
+#if 0
+	    case 1001:
+		break;		/* X11 mouse highlighting */
+#endif
+	    case 1010:		/* scroll to bottom on TTY output inhibit */
+		PrivCases(PrivMode_TtyOutputInh);
+		if (PrivateModes & PrivMode_TtyOutputInh)
+		    Options &= ~Opt_scrollTtyOutput;
+		else
+		    Options |= Opt_scrollTtyOutput;
+		break;
+
+	    case 1011:		/* scroll to bottom on key press */
+		PrivCases(PrivMode_Keypress);
+		if (PrivateModes & PrivMode_Keypress)
+		    Options |= Opt_scrollKeypress;
+		else
+		    Options &= ~Opt_scrollKeypress;
+		break;
+
+	    default:
+		break;
+	    }
+	break;
+    }
+#undef PrivCases
+}
+/*}}} */
+
+/*{{{ process sgr sequences */
+/* INTPROTO */
+void
+process_sgr_mode(unsigned int nargs, const int *arg)
+{
+    unsigned int    i;
+
+    if (nargs == 0) {
+	scr_rendition(0, ~RS_None);
+	return;
+    }
+    for (i = 0; i < nargs; i++)
+	switch (arg[i]) {
+	case 0:
+	    scr_rendition(0, ~RS_None);
+	    break;
+	case 1:
+	    scr_rendition(1, RS_Bold);
+	    break;
+	case 4:
+	    scr_rendition(1, RS_Uline);
+	    break;
+	case 5:
+	    scr_rendition(1, RS_Blink);
+	    break;
+	case 7:
+	    scr_rendition(1, RS_RVid);
+	    break;
+	case 22:
+	    scr_rendition(0, RS_Bold);
+	    break;
+	case 24:
+	    scr_rendition(0, RS_Uline);
+	    break;
+	case 25:
+	    scr_rendition(0, RS_Blink);
+	    break;
+	case 27:
+	    scr_rendition(0, RS_RVid);
+	    break;
+
+	case 30:
+	case 31:		/* set fg color */
+	case 32:
+	case 33:
+	case 34:
+	case 35:
+	case 36:
+	case 37:
+	    scr_color(minCOLOR + (arg[i] - 30), RS_Bold);
+	    break;
+	case 39:		/* default fg */
+	    scr_color(restoreFG, RS_Bold);
+	    break;
+
+	case 40:
+	case 41:		/* set bg color */
+	case 42:
+	case 43:
+	case 44:
+	case 45:
+	case 46:
+	case 47:
+	    scr_color(minCOLOR + (arg[i] - 40), RS_Blink);
+	    break;
+	case 49:		/* default bg */
+	    scr_color(restoreBG, RS_Blink);
+	    break;
+	}
+}
+/*}}} */
+
+/*{{{ process Rob Nation's own graphics mode sequences */
+/* INTPROTO */
+void
+process_graphics(void)
+{
+    unsigned char   ch, cmd = cmd_getc();
+
+#ifndef RXVT_GRAPHICS
+    if (cmd == 'Q') {		/* query graphics */
+	tt_printf("\033G0\n");	/* no graphics */
+	return;
+    }
+/* swallow other graphics sequences until terminating ':' */
+    do
+	ch = cmd_getc();
+    while (ch != ':');
+#else
+    int             nargs;
+    int             args[NGRX_PTS];
+    unsigned char  *text = NULL;
+
+    if (cmd == 'Q') {		/* query graphics */
+	tt_printf("\033G1\n");	/* yes, graphics (color) */
+	return;
+    }
+    for (nargs = 0; nargs < (sizeof(args) / sizeof(args[0])) - 1;) {
+	int             neg;
+
+	ch = cmd_getc();
+	neg = (ch == '-');
+	if (neg || ch == '+')
+	    ch = cmd_getc();
+
+	for (args[nargs] = 0; isdigit(ch); ch = cmd_getc())
+	    args[nargs] = args[nargs] * 10 + (ch - '0');
+	if (neg)
+	    args[nargs] = -args[nargs];
+
+	nargs++;
+	args[nargs] = 0;
+	if (ch != ';')
+	    break;
+    }
+
+    if ((cmd == 'T') && (nargs >= 5)) {
+	int             i, len = args[4];
+
+	text = MALLOC((len + 1) * sizeof(char));
+
+	if (text != NULL) {
+	    for (i = 0; i < len; i++)
+		text[i] = cmd_getc();
+	    text[len] = '\0';
+	}
+    }
+    Gr_do_graphics(cmd, nargs, args, text);
+# ifdef USE_XIM
+    IMSendSpot();
+# endif
+#endif
+}
+/*}}} */
+
+/* ------------------------------------------------------------------------- */
+/*
+ * A simple queue to hold ConfigureNotify events we've generated so we can
+ * bypass them when they come in.  Don't bother keeping a pointer to the tail
+ * since we don't expect masses of CNs at any one time.
+ */
+/* EXTPROTO */
+void
+AddToCNQueue(int width, int height)
+{
+    XCNQueue_t     *rq, *nrq;
+
+    nrq = (XCNQueue_t *) MALLOC(sizeof(XCNQueue_t));
+    assert(nrq);
+    nrq->next = NULL;
+    nrq->width = width;
+    nrq->height = height;
+    if (XCNQueue == NULL)
+	XCNQueue = nrq;
+    else {
+	for (rq = XCNQueue; rq->next; rq = rq->next)
+	/* nothing */ ;
+	rq->next = nrq;
+    }
+}
+
+/* INTPROTO */
+int
+RemoveFromCNQueue(int width, int height)
+{
+    XCNQueue_t     *rq, *prq;
+    int		    new_ncol, new_nrow;
+
+/*
+ * If things are working properly we should only need to check the first one
+ */
+    for (rq = XCNQueue, prq = NULL; rq; rq = rq->next) {
+	if (rq->width == width && rq->height == height) {
+	    new_ncol = (width - szHint.base_width) / TermWin.fwidth;
+	    new_nrow = (height - szHint.base_height) / TermWin.fheight;
+	    if (new_ncol == TermWin.ncol && new_nrow == TermWin.nrow) {
+	    /* unlink rq */
+		if (prq)
+		    prq->next = rq->next;
+		else
+		    XCNQueue = rq->next;
+		FREE(rq);
+		return 1;
+	    }
+	}
+	prq = rq;
+    }
+    return 0;
+}
+/* ------------------------------------------------------------------------- */
+
+/*{{{ Read and process output from the application */
+/* EXTPROTO */
+void
+main_loop(void)
+{
+    int             nlines;
+    unsigned char   ch, *str;
+
+    for (;;) {
+	while ((ch = cmd_getc()) == 0) ;	/* wait for something */
+
+	if (ch >= ' ' || ch == '\t' || ch == '\n' || ch == '\r') {
+	/* Read a text string from the input buffer */
+	/*
+	 * point `str' to the start of the string,
+	 * decrement first since it was post incremented in cmd_getc()
+	 */
+	    for (str = --cmdbuf_ptr, nlines = 0; cmdbuf_ptr < cmdbuf_endp;) {
+		ch = *cmdbuf_ptr++;
+		if (ch == '\n') {
+		    nlines++;
+		    if (++refresh_count >= (refresh_limit * (TermWin.nrow - 1)))
+			break;
+		} else if (ch < ' ' && ch != '\t' && ch != '\r') {
+		/* unprintable */
+		    cmdbuf_ptr--;
+		    break;
+		}
+	    }
+	    scr_add_lines(str, nlines, (cmdbuf_ptr - str));
+	} else
+	    switch (ch) {
+	    case 005:		/* terminal Status */
+		tt_printf(VT100_ANS);
+		break;
+	    case 007:		/* bell */
+		scr_bell();
+		break;
+	    case '\b':		/* backspace */
+		scr_backspace();
+		break;
+	    case 013:		/* vertical tab, form feed */
+	    case 014:
+		scr_index(UP);
+		break;
+	    case 016:		/* shift out - acs */
+		scr_charset_choose(1);
+		break;
+	    case 017:		/* shift in - acs */
+		scr_charset_choose(0);
+		break;
+	    case 033:		/* escape char */
+		process_escape_seq();
+		break;
+	    }
+    }
+/* NOTREACHED */
+}
+
+/* ---------------------------------------------------------------------- */
+/* Addresses pasting large amounts of data and rxvt hang
+ * code pinched from xterm (v_write()) and applied originally to
+ * rxvt-2.18 - Hops
+ * Write data to the pty as typed by the user, pasted with the mouse,
+ * or generated by us in response to a query ESC sequence.
+ */
+/* EXTPROTO */
+void
+tt_write(const unsigned char *d, int len)
+{
+    int             riten, p;
+
+    if (v_bufstr == NULL && len > 0) {
+	v_buffer = v_bufstr = v_bufptr = MALLOC(len);
+	v_bufend = v_buffer + len;
+    }
+/*
+ * Append to the block we already have.  Always doing this simplifies the
+ * code, and isn't too bad, either.  If this is a short block, it isn't
+ * too expensive, and if this is a long block, we won't be able to write
+ * it all anyway.
+ */
+    if (len > 0) {
+	if (v_bufend < v_bufptr + len) {	/* we've run out of room */
+	    if (v_bufstr != v_buffer) {
+	    /* there is unused space, move everything down */
+	    /* possibly overlapping bcopy here */
+	    /* bcopy(v_bufstr, v_buffer, v_bufptr - v_bufstr); */
+		memcpy(v_buffer, v_bufstr, v_bufptr - v_bufstr);
+		v_bufptr -= v_bufstr - v_buffer;
+		v_bufstr = v_buffer;
+	    }
+	    if (v_bufend < v_bufptr + len) {
+	    /* still won't fit: get more space */
+	    /* Don't use XtRealloc because an error is not fatal. */
+		int             size = v_bufptr - v_buffer;
+
+	    /* save across realloc */
+		v_buffer = REALLOC(v_buffer, size + len);
+		if (v_buffer) {
+		    v_bufstr = v_buffer;
+		    v_bufptr = v_buffer + size;
+		    v_bufend = v_bufptr + len;
+		} else {
+		/* no memory: ignore entire write request */
+		    print_error("cannot allocate buffer space");
+		    v_buffer = v_bufstr;	/* restore clobbered pointer */
+		}
+	    }
+	}
+	if (v_bufend >= v_bufptr + len) {	/* new stuff will fit */
+	    memcpy(v_bufptr, d, len);	/* bcopy(d, v_bufptr, len); */
+	    v_bufptr += len;
+	}
+    }
+/*
+ * Write out as much of the buffer as we can.
+ * Be careful not to overflow the pty's input silo.
+ * We are conservative here and only write a small amount at a time.
+ *
+ * If we can't push all the data into the pty yet, we expect write
+ * to return a non-negative number less than the length requested
+ * (if some data written) or -1 and set errno to EAGAIN,
+ * EWOULDBLOCK, or EINTR (if no data written).
+ *
+ * (Not all systems do this, sigh, so the code is actually
+ * a little more forgiving.)
+ */
+
+#define MAX_PTY_WRITE 128	/* 1/2 POSIX minimum MAX_INPUT */
+
+    if ((p = v_bufptr - v_bufstr) > 0) {
+	riten = write(cmd_fd, v_bufstr, p < MAX_PTY_WRITE ? p : MAX_PTY_WRITE);
+	if (riten < 0)
+	    riten = 0;
+	v_bufstr += riten;
+	if (v_bufstr >= v_bufptr)	/* we wrote it all */
+	    v_bufstr = v_bufptr = v_buffer;
+    }
+/*
+ * If we have lots of unused memory allocated, return it
+ */
+    if (v_bufend - v_bufptr > 1024) {	/* arbitrary hysteresis */
+    /* save pointers across realloc */
+	int             start = v_bufstr - v_buffer;
+	int             size = v_bufptr - v_buffer;
+	int             allocsize = size ? size : 1;
+
+	v_buffer = REALLOC(v_buffer, allocsize);
+	if (v_buffer) {
+	    v_bufstr = v_buffer + start;
+	    v_bufptr = v_buffer + size;
+	    v_bufend = v_buffer + allocsize;
+	} else {
+	/* should we print a warning if couldn't return memory? */
+	    v_buffer = v_bufstr - start;	/* restore clobbered pointer */
+	}
+    }
+}
+
+#ifdef USE_XIM
+/* INTPROTO */
+void
+setSize(XRectangle * size)
+{
+    size->x = TermWin_internalBorder;
+    size->y = TermWin_internalBorder;
+    size->width = Width2Pixel(TermWin.ncol);
+    size->height = Height2Pixel(TermWin.nrow);
+}
+
+/* INTPROTO */
+void
+setColor(unsigned long *fg, unsigned long *bg)
+{
+    *fg = PixColors[Color_fg];
+    *bg = PixColors[Color_bg];
+}
+
+/* INTPROTO */
+void
+IMSendSpot(void)
+{
+    XPoint          spot;
+    XVaNestedList   preedit_attr;
+    XIMStyle        input_style;
+
+    if (Input_Context == NULL || !TermWin.focus)
+	return;
+    else {
+	XGetICValues(Input_Context, XNInputStyle, &input_style, NULL);
+	if (!(input_style & XIMPreeditPosition))
+	    return;
+    }
+    setPosition(&spot);
+
+    preedit_attr = XVaCreateNestedList(0, XNSpotLocation, &spot, NULL);
+    XSetICValues(Input_Context, XNPreeditAttributes, preedit_attr, NULL);
+    XFree(preedit_attr);
+}
+
+/* INTPROTO */
+void
+setTermFontSet(void)
+{
+    char           *string;
+    long            length, i;
+
+#ifdef DEBUG_CMD
+fprintf(stderr, "setTermFontSet()\n");
+#endif
+    if (TermWin.fontset != NULL) {
+	XFreeFontSet(Xdisplay, TermWin.fontset);
+	TermWin.fontset = NULL;
+    }
+    length = 0;
+    for (i = 0; i < NFONTS; i++) {
+	if (rs[Rs_font + i])
+	    length += strlen(rs[Rs_font + i]) + 1;
+# ifdef MULTICHAR_SET
+	if (rs[Rs_mfont + i])
+	    length += strlen(rs[Rs_mfont + i]) + 1;
+# endif
+    }
+    if (length == 0
+	|| (string = MALLOC(length + 1)) == NULL)
+	TermWin.fontset = NULL;
+    else {
+	int             missing_charsetcount;
+	char          **missing_charsetlist, *def_string;
+
+	string[0] = '\0';
+	for (i = 0; i < NFONTS; i++) {
+	    if (rs[Rs_font + i]) {
+		strcat(string, rs[Rs_font + i]);
+		strcat(string, ",");
+	    }
+# ifdef MULTICHAR_SET
+	    if (rs[Rs_mfont + i]) {
+		strcat(string, rs[Rs_mfont + i]);
+		strcat(string, ",");
+	    }
+# endif
+	}
+	string[strlen(string) - 1] = '\0';
+	TermWin.fontset = XCreateFontSet(Xdisplay, string,
+					 &missing_charsetlist,
+					 &missing_charsetcount,
+					 &def_string);
+	FREE(string);
+    }
+}
+
+/* INTPROTO */
+void
+setPreeditArea(XRectangle *preedit_rect, XRectangle *status_rect, XRectangle *needed_rect)
+{
+    preedit_rect->x = needed_rect->width
+		      + (scrollbar_visible() && !(Options & Opt_scrollBar_right)
+			 ? (SB_WIDTH + sb_shadow * 2) : 0);
+    preedit_rect->y = Height2Pixel(TermWin.nrow - 1)
+		      + ((menuBar.state == 1) ? menuBar_TotalHeight() : 0);
+
+    preedit_rect->width = Width2Pixel(TermWin.ncol + 1) - needed_rect->width
+			  + (!(Options & Opt_scrollBar_right)
+			     ? (SB_WIDTH + sb_shadow * 2) : 0);
+    preedit_rect->height = Height2Pixel(1);
+  
+    status_rect->x = (scrollbar_visible() && !(Options & Opt_scrollBar_right))
+		     ? (SB_WIDTH + sb_shadow * 2) : 0;
+    status_rect->y = Height2Pixel(TermWin.nrow - 1)
+		     + ((menuBar.state == 1) ? menuBar_TotalHeight() : 0);
+
+    status_rect->width = needed_rect->width ? needed_rect->width
+					    : Width2Pixel(TermWin.ncol + 1);
+    status_rect->height = Height2Pixel(1);
+}
+
+/* INTPROTO */
+void
+IMDestroyCallback(XIM xim, XPointer client_data, XPointer call_data)
+{
+    Input_Context = NULL;
+    XRegisterIMInstantiateCallback(Xdisplay, NULL, NULL, NULL,
+				   IMInstantiateCallback, NULL);
+}
+
+/* INTPROTO */
+void
+IMInstantiateCallback(Display *display, XPointer client_data, XPointer call_data)
+{
+    char           *p, *s, buf[64], tmp[1024];
+    char           *end, *next_s;
+    XIM             xim = NULL;
+    XIMStyle        input_style = 0;
+    XIMStyles      *xim_styles = NULL;
+    int             found;
+    XPoint          spot;
+    XRectangle      rect, status_rect, needed_rect;
+    unsigned long   fg, bg;
+    XVaNestedList   preedit_attr = NULL;
+    XVaNestedList   status_attr = NULL;
+    XIMCallback     ximcallback;
+
+    if (Input_Context)
+	return;
+
+    ximcallback.callback = IMDestroyCallback;
+    ximcallback.client_data = NULL;
+
+    if (rs[Rs_inputMethod] && *rs[Rs_inputMethod]) {
+	STRNCPY(tmp, rs[Rs_inputMethod], sizeof(tmp) - 1);
+	for (s = tmp; *s; s = next_s + 1) {
+	    for (; *s && isspace(*s); s++) ;
+	    if (!*s)
+		break;
+	    for (end = s; (*end && (*end != ',')); end++) ;
+	    for (next_s = end--; ((end >= s) && isspace(*end)); end--) ;
+	    *(end + 1) = '\0';
+
+	    if (*s) {
+		STRCPY(buf, "@im=");
+		strncat(buf, s, sizeof(buf) - 4 - 1);
+		if ((p = XSetLocaleModifiers(buf)) != NULL && *p
+		    && (xim = XOpenIM(Xdisplay, NULL, NULL, NULL)) != NULL)
+		    break;
+	    }
+	    if (!*next_s)
+		break;
+	}
+    }
+
+    /* try with XMODIFIERS env. var. */
+    if (xim == NULL && (p = XSetLocaleModifiers("")) != NULL && *p)
+	xim = XOpenIM(Xdisplay, NULL, NULL, NULL);
+
+    /* try with no modifiers base */
+    if (xim == NULL && (p = XSetLocaleModifiers("@im=none")) != NULL && *p)
+	xim = XOpenIM(Xdisplay, NULL, NULL, NULL);
+
+    if (xim == NULL)
+	return;
+    XSetIMValues(xim, XNDestroyCallback, &ximcallback, NULL);
+
+    if (XGetIMValues(xim, XNQueryInputStyle, &xim_styles, NULL)
+	|| !xim_styles) {
+	print_error("input method doesn't support any style");
+	XCloseIM(xim);
+	return;
+    }
+    STRNCPY(tmp, (rs[Rs_preeditType] ? rs[Rs_preeditType]
+				     : "OverTheSpot,OffTheSpot,Root"),
+	    sizeof(tmp) - 1);
+    for (found = 0, s = tmp; *s && !found; s = next_s + 1) {
+	unsigned short  i;
+
+	for (; *s && isspace(*s); s++) ;
+	if (!*s)
+	    break;
+	for (end = s; (*end && (*end != ',')); end++) ;
+	for (next_s = end--; ((end >= s) && isspace(*end)); end--) ;
+	*(end + 1) = '\0';
+
+	if (!strcmp(s, "OverTheSpot"))
+	    input_style = (XIMPreeditPosition | XIMStatusNothing);
+	else if (!strcmp(s, "OffTheSpot"))
+	    input_style = (XIMPreeditArea | XIMStatusArea);
+	else if (!strcmp(s, "Root"))
+	    input_style = (XIMPreeditNothing | XIMStatusNothing);
+
+	for (i = 0; i < xim_styles->count_styles; i++)
+	    if (input_style == xim_styles->supported_styles[i]) {
+		found = 1;
+		break;
+	    }
+    }
+    XFree(xim_styles);
+
+    if (found == 0) {
+	print_error("input method doesn't support my preedit type");
+	XCloseIM(xim);
+	return;
+    }
+    if ((input_style != (XIMPreeditNothing | XIMStatusNothing))
+	&& (input_style != (XIMPreeditArea | XIMStatusArea))
+	&& (input_style != (XIMPreeditPosition | XIMStatusNothing))) {
+	print_error("This program does not support the preedit type");
+	XCloseIM(xim);
+	return;
+    }
+    if (input_style & XIMPreeditPosition) {
+	setSize(&rect);
+	setPosition(&spot);
+	setColor(&fg, &bg);
+
+	preedit_attr = XVaCreateNestedList(0, XNArea, &rect, 
+					   XNSpotLocation, &spot,
+					   XNForeground, fg,
+					   XNBackground, bg,
+					   XNFontSet, TermWin.fontset,
+					   NULL);
+    } else if (input_style & XIMPreeditArea) {
+	setColor(&fg, &bg);
+
+	/* 
+	 * The necessary width of preedit area is unknown
+	 * until create input context.
+	 */
+	needed_rect.width = 0;
+
+	setPreeditArea(&rect, &status_rect, &needed_rect);
+
+	preedit_attr = XVaCreateNestedList(0, XNArea, &rect,
+					   XNForeground, fg,
+					   XNBackground, bg,
+					   XNFontSet, TermWin.fontset,
+					   NULL);
+	status_attr = XVaCreateNestedList(0, XNArea, &status_rect,
+					  XNForeground, fg,
+					  XNBackground, bg,
+					  XNFontSet, TermWin.fontset,
+					  NULL);
+    }
+    Input_Context = XCreateIC(xim, XNInputStyle, input_style,
+			      XNClientWindow, TermWin.parent[0],
+			      XNFocusWindow, TermWin.parent[0],
+			      XNDestroyCallback, &ximcallback,
+			      preedit_attr ? XNPreeditAttributes : NULL,
+			      preedit_attr,
+			      status_attr ? XNStatusAttributes : NULL,
+			      status_attr,
+			      NULL);
+    XFree(preedit_attr);
+    XFree(status_attr);
+    if (Input_Context == NULL) {
+	print_error("Failed to create input context");
+	XCloseIM(xim);
+    }
+    if (input_style & XIMPreeditArea)
+	IMSetStatusPosition();
+}
+
+/* EXTPROTO */
+void
+IMSetStatusPosition(void)
+{
+    XIMStyle        input_style;
+    XRectangle      preedit_rect, status_rect, *needed_rect;
+    XVaNestedList   preedit_attr, status_attr;
+
+    if (Input_Context == NULL)
+	return;
+
+    XGetICValues(Input_Context, XNInputStyle, &input_style, NULL);
+
+    if (input_style & XIMPreeditArea) {
+        /* Getting the necessary width of preedit area */
+	status_attr = XVaCreateNestedList(0, XNAreaNeeded, &needed_rect, NULL);
+	XGetICValues(Input_Context, XNStatusAttributes, status_attr, NULL);
+	XFree(status_attr);
+
+	setPreeditArea(&preedit_rect, &status_rect, needed_rect);
+
+	preedit_attr = XVaCreateNestedList(0, XNArea, &preedit_rect, NULL);
+	status_attr = XVaCreateNestedList(0, XNArea, &status_rect, NULL);
+
+	XSetICValues(Input_Context,
+		     XNPreeditAttributes, preedit_attr,
+		     XNStatusAttributes, status_attr, NULL);
+
+	XFree(preedit_attr);
+	XFree(status_attr);
+    }
+}
+#endif				/* USE_XIM */
+
+/* INTPROTO */
+void
+XProcessEvent(Display *display)
+{
+    XEvent          xev;
+
+    XNextEvent(display, &xev);
+#ifdef USE_XIM
+    if (!XFilterEvent(&xev, xev.xany.window))
+	process_x_event(&xev);
+#else
+    process_x_event(&xev);
+#endif
+    return;
+}
+
+/*}}} */
+/*----------------------- end-of-file (C source) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/command.extpro work/main.d/rxvt-2.6.4/src/command.extpro
--- tmp/rxvt-2.6.4/src/command.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/command.extpro	2001-11-01 21:28:28.000000000 -0300
@@ -0,0 +1,12 @@
+void             privileges              __PROTO((int mode));
+void             init_command            __PROTO((const char *const *argv));
+void             init_xlocale            __PROTO((void));
+void             tt_resize               __PROTO((void));
+unsigned int     cmd_write               __PROTO((const unsigned char *str, unsigned int count));
+void             tt_printf               __PROTO((const char *fmt,...));
+FILE           * popen_printer           __PROTO((void));
+int              pclose_printer          __PROTO((FILE * stream));
+void             AddToCNQueue            __PROTO((int width, int height));
+void             main_loop               __PROTO((void));
+void             tt_write                __PROTO((const unsigned char *d, int len));
+void             IMSetStatusPosition     __PROTO((void));
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/command.h work/main.d/rxvt-2.6.4/src/command.h
--- tmp/rxvt-2.6.4/src/command.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/command.h	1999-06-22 04:49:05.000000000 -0300
@@ -0,0 +1,281 @@
+/* ways to deal with getting/setting termios structure */
+#ifdef HAVE_TERMIOS_H
+/* termios interface */
+# include <termios.h>
+typedef struct termios ttymode_t;
+
+# ifdef TCSANOW			/* POSIX */
+#  define GET_TERMIOS(fd,tios)	tcgetattr (fd, tios)
+#  define SET_TERMIOS(fd,tios)		\
+	cfsetospeed (tios, BAUDRATE),	\
+	cfsetispeed (tios, BAUDRATE),	\
+	tcsetattr (fd, TCSANOW, tios)
+# else
+#  ifdef TIOCSETA
+#   define GET_TERMIOS(fd,tios)	ioctl (fd, TIOCGETA, tios)
+#   define SET_TERMIOS(fd,tios)		\
+	tios->c_cflag |= BAUDRATE,	\
+	ioctl (fd, TIOCSETA, tios)
+#  else
+#   define GET_TERMIOS(fd,tios)	ioctl (fd, TCGETS, tios)
+#   define SET_TERMIOS(fd,tios)		\
+	tios->c_cflag |= BAUDRATE,	\
+	ioctl (fd, TCSETS, tios)
+#  endif
+# endif
+# define SET_TTYMODE(fd,tios)		SET_TERMIOS (fd, tios)
+#else
+/* sgtty interface */
+# include <sgtty.h>
+typedef struct {
+    struct sgttyb   sg;
+    struct tchars   tc;
+    struct ltchars  lc;
+    int             line;
+    int             local;
+} ttymode_t;
+
+# define SET_TTYMODE(fd,tt)				\
+	tt->sg.sg_ispeed = tt->sg.sg_ospeed = BAUDRATE,	\
+	ioctl (fd, TIOCSETP, &(tt->sg)),		\
+	ioctl (fd, TIOCSETC, &(tt->tc)),		\
+	ioctl (fd, TIOCSLTC, &(tt->lc)),		\
+	ioctl (fd, TIOCSETD, &(tt->line)),		\
+	ioctl (fd, TIOCLSET, &(tt->local))
+#endif				/* HAVE_TERMIOS_H */
+
+#ifdef OFFIX_DND
+# include <X11/Xatom.h>
+# define DndFile	2
+# define DndDir		5
+# define DndLink	7
+#endif
+
+#include <X11/keysym.h>
+#ifndef NO_XLOCALE
+# if (XtSpecificationRelease < 6)
+#  define NO_XLOCALE
+# endif
+#endif
+
+#ifndef NO_XSETLOCALE
+# define X_LOCALE
+# include <X11/Xlocale.h>
+#else
+# ifndef NO_SETLOCALE
+#  include <locale.h>
+# endif
+#endif				/* NO_XLOCALE */
+
+#ifdef TTY_GID_SUPPORT
+# include <grp.h>
+#endif
+
+#ifdef PTYS_ARE_PTMX
+# include <sys/resource.h>	/* for struct rlimit */
+# include <sys/stropts.h>	/* for I_PUSH */
+# define _NEW_TTY_CTRL		/* to get proper defines in <termios.h> */
+#endif
+
+
+/* #define DEBUG_TTYMODE */
+/* #define DEBUG_CMD */
+
+/* use the fastest baud-rate */
+#ifdef B38400
+# define BAUDRATE	B38400
+#else
+# ifdef B19200
+#  define BAUDRATE	B19200
+# else
+#  define BAUDRATE	B9600
+# endif
+#endif
+
+/* Disable special character functions */
+#ifdef _POSIX_VDISABLE
+# define VDISABLE	_POSIX_VDISABLE
+#else
+# define VDISABLE	255
+#endif
+
+/*----------------------------------------------------------------------*
+ * system default characters if defined and reasonable
+ */
+#ifndef CINTR
+# define CINTR		'\003'	/* ^C */
+#endif
+#ifndef CQUIT
+# define CQUIT		'\034'	/* ^\ */
+#endif
+#ifndef CERASE
+# ifdef linux
+#  define CERASE	'\177'	/* ^? */
+# else
+#  define CERASE	'\010'	/* ^H */
+# endif
+#endif
+#ifndef CKILL
+# define CKILL		'\025'	/* ^U */
+#endif
+#ifndef CEOF
+# define CEOF		'\004'	/* ^D */
+#endif
+#ifndef CSTART
+# define CSTART		'\021'	/* ^Q */
+#endif
+#ifndef CSTOP
+# define CSTOP		'\023'	/* ^S */
+#endif
+#ifndef CSUSP
+# define CSUSP		'\032'	/* ^Z */
+#endif
+#ifndef CDSUSP
+# define CDSUSP		'\031'	/* ^Y */
+#endif
+#ifndef CRPRNT
+# define CRPRNT		'\022'	/* ^R */
+#endif
+#ifndef CFLUSH
+# define CFLUSH		'\017'	/* ^O */
+#endif
+#ifndef CWERASE
+# define CWERASE	'\027'	/* ^W */
+#endif
+#ifndef CLNEXT
+# define CLNEXT		'\026'	/* ^V */
+#endif
+
+#ifndef VDISCRD
+# ifdef VDISCARD
+#  define VDISCRD	VDISCARD
+# endif
+#endif
+
+#ifndef VWERSE
+# ifdef VWERASE
+#  define VWERSE	VWERASE
+# endif
+#endif
+
+#define KBUFSZ		512	/* size of keyboard mapping buffer */
+#define STRING_MAX	512	/* max string size for process_xterm_seq() */
+#define ESC_ARGS	32	/* max # of args for esc sequences */
+
+/* a large REFRESH_PERIOD causes problems with `cat' */
+#define REFRESH_PERIOD		1
+
+#ifndef MULTICLICK_TIME
+# define MULTICLICK_TIME	500
+#endif
+#ifndef SCROLLBAR_INITIAL_DELAY
+# ifdef NEXT_SCROLLER
+#  define SCROLLBAR_INITIAL_DELAY	20
+# else
+#  define SCROLLBAR_INITIAL_DELAY	40
+# endif
+#endif
+#ifndef SCROLLBAR_CONTINUOUS_DELAY
+# define SCROLLBAR_CONTINUOUS_DELAY	2
+#endif
+
+/* time factor to slow down a `jumpy' mouse */
+#define MOUSE_THRESHOLD		50
+#define CONSOLE		"/dev/console"	/* console device */
+
+/*
+ * key-strings: if only these keys were standardized <sigh>
+ */
+#ifdef LINUX_KEYS
+# define KS_HOME	"\033[1~"	/* Home == Find */
+# define KS_END		"\033[4~"	/* End == Select */
+#else
+# define KS_HOME	"\033[7~"	/* Home */
+# define KS_END		"\033[8~"	/* End */
+#endif
+
+#ifdef SCROLL_ON_SHIFT
+# define SCROLL_SHIFTKEY (shft)
+#else
+# define SCROLL_SHIFTKEY 0
+#endif
+#ifdef SCROLL_ON_CTRL
+# define SCROLL_CTRLKEY  (ctrl)
+#else
+# define SCROLL_CTRLKEY 0
+#endif
+#ifdef SCROLL_ON_META
+# define SCROLL_METAKEY  (meta)
+#else
+# define SCROLL_METAKEY 0
+#endif
+#define IS_SCROLL_MOD  (SCROLL_SHIFTKEY || SCROLL_CTRLKEY || SCROLL_METAKEY)
+
+typedef struct XCNQueue_t {
+    struct XCNQueue_t *next;
+    int16_t         width, height;
+} XCNQueue_t;
+
+/*
+ * ESC-Z processing:
+ *
+ * By stealing a sequence to which other xterms respond, and sending the
+ * same number of characters, but having a distinguishable sequence,
+ * we can avoid having a timeout (when not under an rxvt) for every login
+ * shell to auto-set its DISPLAY.
+ *
+ * This particular sequence is even explicitly stated as obsolete since
+ * about 1985, so only very old software is likely to be confused, a
+ * confusion which can likely be remedied through termcap or TERM. Frankly,
+ * I doubt anyone will even notice.  We provide a #ifdef just in case they
+ * don't care about auto-display setting.  Just in case the ancient
+ * software in question is broken enough to be case insensitive to the 'c'
+ * character in the answerback string, we make the distinguishing
+ * characteristic be capitalization of that character. The length of the
+ * two strings should be the same so that identical read(2) calls may be
+ * used.
+ */
+#define VT100_ANS	"\033[?1;2c"	/* vt100 answerback */
+#ifndef ESCZ_ANSWER
+# define ESCZ_ANSWER	VT100_ANS	/* obsolete ANSI ESC[c */
+#endif
+
+/* DEC private modes */
+#define PrivMode_132		(1LU<<0)
+#define PrivMode_132OK		(1LU<<1)
+#define PrivMode_rVideo		(1LU<<2)
+#define PrivMode_relOrigin	(1LU<<3)
+#define PrivMode_Screen		(1LU<<4)
+#define PrivMode_Autowrap	(1LU<<5)
+#define PrivMode_aplCUR		(1LU<<6)
+#define PrivMode_aplKP		(1LU<<7)
+#define PrivMode_HaveBackSpace	(1LU<<8)
+#define PrivMode_BackSpace	(1LU<<9)
+#define PrivMode_ShiftKeys	(1LU<<10)
+#define PrivMode_VisibleCursor	(1LU<<11)
+#define PrivMode_MouseX10	(1LU<<12)
+#define PrivMode_MouseX11	(1LU<<13)
+#define PrivMode_scrollBar	(1LU<<14)
+#define PrivMode_menuBar	(1LU<<15)
+#define PrivMode_TtyOutputInh	(1LU<<16)
+#define PrivMode_Keypress	(1LU<<17)
+/* too annoying to implement X11 highlight tracking */
+/* #define PrivMode_MouseX11Track       (1LU<<18) */
+
+#define PrivMode_mouse_report	(PrivMode_MouseX10|PrivMode_MouseX11)
+#define PrivMode(test,bit)		\
+    if (test)				\
+	PrivateModes |= (bit);		\
+    else				\
+	PrivateModes &= ~(bit)
+
+#define PrivMode_Default						 \
+(PrivMode_Autowrap|PrivMode_aplKP|PrivMode_ShiftKeys|PrivMode_VisibleCursor)
+
+/* command input buffering */
+#ifndef BUFSIZ
+# define BUFSIZ		4096
+#endif
+static unsigned char cmdbuf_base[BUFSIZ], *cmdbuf_ptr, *cmdbuf_endp;
+
+#include "command.intpro"	/* PROTOS for internal routines */
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/command.intpro work/main.d/rxvt-2.6.4/src/command.intpro
--- tmp/rxvt-2.6.4/src/command.intpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/command.intpro	2001-11-01 21:28:30.000000000 -0300
@@ -0,0 +1,33 @@
+int              getdtablesize           __PROTO((void));
+RETSIGTYPE       Child_signal            __PROTO((int unused));
+RETSIGTYPE       Exit_signal             __PROTO((int sig));
+void             clean_exit              __PROTO((void));
+int              get_pty                 __PROTO((void));
+int              get_tty                 __PROTO((void));
+void             debug_ttymode           __PROTO((const ttymode_t * ttymode));
+void             get_ttymode             __PROTO((ttymode_t * tio));
+void             run_command             __PROTO((const char *const *argv));
+void             get_ourmods             __PROTO((void));
+void             tt_winsize              __PROTO((int fd));
+void             lookup_key              __PROTO((XEvent * ev));
+unsigned char    cmd_getc                __PROTO((void));
+void             mouse_report            __PROTO((const XButtonEvent * ev));
+void             process_x_event         __PROTO((XEvent * ev));
+int              check_our_parents       __PROTO((void));
+void             process_print_pipe      __PROTO((void));
+void             process_escape_seq      __PROTO((void));
+void             process_csi_seq         __PROTO((void));
+void             process_window_ops      __PROTO((const int *args, int nargs));
+void             process_xterm_seq       __PROTO((void));
+void             process_terminal_mode   __PROTO((int mode, int priv, unsigned int nargs, const int *arg));
+void             process_sgr_mode        __PROTO((unsigned int nargs, const int *arg));
+void             process_graphics        __PROTO((void));
+int              RemoveFromCNQueue       __PROTO((int width, int height));
+void             setSize                 __PROTO((XRectangle * size));
+void             setColor                __PROTO((unsigned long *fg, unsigned long *bg));
+void             IMSendSpot              __PROTO((void));
+void             setTermFontSet          __PROTO((void));
+void             setPreeditArea          __PROTO((XRectangle *preedit_rect, XRectangle *status_rect, XRectangle *needed_rect));
+void             IMDestroyCallback       __PROTO((XIM xim, XPointer client_data, XPointer call_data));
+void             IMInstantiateCallback   __PROTO((Display *display, XPointer client_data, XPointer call_data));
+void             XProcessEvent           __PROTO((Display *display));
Binary files tmp/rxvt-2.6.4/src/command.o and work/main.d/rxvt-2.6.4/src/command.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/feature.h work/main.d/rxvt-2.6.4/src/feature.h
--- tmp/rxvt-2.6.4/src/feature.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/feature.h	2000-07-05 04:26:17.000000000 -0300
@@ -0,0 +1,404 @@
+/*
+ * File:	feature.h
+ * $Id: feature.h,v 1.20.2.9 2000/07/05 07:26:17 gcw Exp $
+ *
+ * Compile-time configuration.
+ *-----------------------------------------------------------------------
+ * Copyright (C) 1997,1998 Oezguer Kesim <kesim@math.fu-berlin.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *----------------------------------------------------------------------*/
+#ifndef _FEATURE_H
+#define _FEATURE_H
+
+/*
+ * Define to remove handling of extra escape sequences and other rarely
+ * used features.
+ */
+/* #define NO_FRILLS */
+
+/*-----------------------SCREEN OPTIONS AND COLOURS---------------------*/
+/*
+ * Define the name of the environment variable to be used in
+ * addition to the "PATH" environment and the `path' resource.
+ * Usually it should point to where you keep your background pixmaps and/or
+ * your menu files
+ */
+#define PATH_ENV	"RXVTPATH"
+
+/*
+ * Avoid enabling the colour cursor (-cr, cursorColor, cursorColor2)
+ */
+/* #define NO_CURSORCOLOR */
+ 
+/*
+ * Suppress use of BOLD and BLINK attributes for setting bright foreground
+ * and background, respectively.  Simulate BOLD using colorBD, boldFont or
+ * overstrike characters.
+ */
+/* #define NO_BRIGHTCOLOR */
+
+/*
+ * Disable separate colours for bold/underline
+ */
+/* #define NO_BOLDUNDERLINE */
+
+/*
+ * Disable using simulated bold using overstrike.  You can also turn off
+ * overstrike just for multi char fonts
+ * Note: NO_BOLDOVERSTRIKE implies NO_BOLDOVERSTRIKE_MULTI
+ */
+/* #define NO_BOLDOVERSTRIKE */
+/* #define NO_BOLDOVERSTRIKE_MULTI */
+
+/*
+ * Also use bold font or overstrike even if we use colour for bold
+ */
+#define VERYBOLD
+ 
+/*
+ * Compile without support for real bold fonts
+ */
+/* #define NO_BOLDFONT */
+ 
+/*
+ * If the screen has 24 bit mode, use that even if the default is 8 bit.
+ */
+#define PREFER_24BIT
+
+/*
+ * Define maximum possible columns and rows
+ */
+#define MAX_COLS	400
+#define MAX_ROWS	300
+
+/*
+ * Define default colours for certain items.  If you have a low colour
+ * display, then consider using colours which are already pre-allocated:
+ *   Black		(#000000)
+ *   Red3		(#CD0000)	+ these
+ *   Green3		(#00CD00)	+ colours
+ *   Yellow3		(#CDCD00)	+ are
+ *   Blue3		(#0000CD)	+ not
+ *   Magenta3		(#CD00CD)	+ pre-allocated
+ *   Cyan3		(#00CDCD)	+ if
+ *   AntiqueWhite	(#FAEBD7)	+ NO_BRIGHTCOLOR
+ *   Grey25		(#404040)	+ defined
+ *   Red		(#FF0000)
+ *   Green		(#00FF00)
+ *   Yellow		(#FFFF00)
+ *   Blue		(#0000FF)
+ *   Magenta		(#FF00FF)
+ *   Cyan		(#00FFFF)
+ *   White		(#FFFFFF)
+ */  
+/* These colours MUST be defined */
+#define COLOR_FOREGROUND	"Black"
+#define COLOR_BACKGROUND	"White"
+#define COLOR_SCROLLBAR		"#B2B2B2"	/* scrollColor match Netscape */
+#define COLOR_SCROLLTROUGH	"#969696"
+/*
+ * The cursor colours are special.  Be very careful about setting these: 
+ * foreground/background colours may be modified by command line or resources
+ * prior to this allocation.  Also, they are not valid if NO_CURSORCOLOR is
+ * defined
+ */
+#define COLOR_CURSOR_FOREGROUND	NULL	/* if NULL, use background colour */
+#define COLOR_CURSOR_BACKGROUND	NULL	/* if NULL, use foreground colour */
+
+/*
+ * Use alternative code for screen-refreshes when compiled with xpm-support.
+ * Seems to be obsolete due to the new screen-update routines.
+ */
+/* #define XPM_BUFFERING */
+
+/*
+ * Printer pipe which will be used for emulation of attached vt100 printer
+ */
+#define PRINTPIPE	"lpr"
+
+/*------------------------------RESOURCES-------------------------------*/
+/*
+ * Define where to find installed application defaults for rxvt
+ * Only if USE_XGETDEFAULT is not defined.
+ */
+#ifndef XAPPLOADDIR
+/* #define XAPPLOADDIR	"/usr/lib/X11/app-defaults" */
+#endif
+ 
+/*
+ * Add support for the Offix DND (Drag 'n' Drop) protocol
+ */
+/* #define OFFIX_DND */
+
+/*---------------------------------KEYS---------------------------------*/
+
+/*
+ * Define defaults for backspace and delete keys - unless they have been
+ * configured out with --disable-backspace-key / --disable-delete-key
+ */
+/* #define DEFAULT_BACKSPACE	"DEC"		*/ /* SPECIAL */
+/* #define DEFAULT_BACKSPACE	"\177"		*/
+/* #define DEFAULT_DELETE	"\033[3~"	*/
+
+/*
+ * Choose one of these values to be the `hotkey' for changing font.
+ * This has been superceded and is only for you older users
+ */
+/* #define HOTKEY_CTRL */
+/* #define HOTKEY_META */
+
+/*
+ * To use
+ *	Home = "\E[1~", End = "\E[4~"
+ * instead of
+ *	Home = "\E[7~", End = "\E[8~"	[default]
+ */
+/* #define LINUX_KEYS */
+
+/*
+ * Enable the keysym resource which allows you to define strings associated
+ * with various KeySyms (0xFF00 - 0xFFFF).
+ * Only works with the default hand-rolled resources.
+ */
+#ifndef NO_RESOURCES
+# define KEYSYM_RESOURCE
+#endif
+
+/*
+ * Modifier/s to use to allow up/down arrows and Priot/Next keys
+ * to scroll single or page-fulls
+ */
+#define SCROLL_ON_SHIFT
+/* #define SCROLL_ON_CTRL */
+/* #define SCROLL_ON_META */
+
+/*
+ * Allow scrolling with modifier+Up/Down keys, in addition
+ * to modifier+Prior/Next? (modifier is controlled with
+ * SCROLL_ON_* defines above.)
+ *
+ */
+/* #define SCROLL_ON_UPDOWN_KEYS */
+
+/*
+ * Allow unshifted Next/Prior keys to scroll forward/back
+ * (in addition to shift+Next/shift+Prior)       --pjh
+ */
+/* #define UNSHIFTED_SCROLLKEYS */
+
+/* (Hops) Set to choose a number of lines of context between pages 
+ *      (rather than a proportion (1/5) of savedlines buffer) 
+ *      when paging the savedlines with SHIFT-{Prior,Next} keys.
+ */
+#define PAGING_CONTEXT_LINES 1 /* */
+  
+/*--------------------------------MOUSE---------------------------------*/
+/*
+ * Disable sending escape sequences (up, down, page up/down)
+ * from the scrollbar when XTerm mouse reporting is enabled
+ */
+/* #define NO_SCROLLBAR_REPORT */
+
+/*
+ * Default separating chars for multiple-click selection
+ * Space and tab are separate separating characters and are not settable
+ */
+#define CUTCHARS	"\"&'()*,;<=>?@[\\]^`{|}~"
+
+/*
+ * Add run-time support for changing the cutchars for double click selection
+ */
+#define CUTCHAR_RESOURCE
+
+/*
+ * Have mouse reporting include double-click info for button1
+ */
+/* #define MOUSE_REPORT_DOUBLECLICK */
+
+/*
+ * Set delay between multiple click events [default: 500]
+ */
+/* #define MULTICLICK_TIME 500 */
+
+/*
+ * If mouse wheel is defined, then scrolling is by 5 lines (or 1 line
+ * if the shift key is down).  Scrolling can be smooth or jump scrolling
+ */
+/* #define JUMP_MOUSE_WHEEL */
+
+/*
+ * Set delay periods for continuous scrolling with scrollbar buttons
+ */
+/* #define SCROLLBAR_INITIAL_DELAY 40 */
+/* #define SCROLLBAR_CONTINUOUS_DELAY 2 */
+
+/*--------------------------------BELL----------------------------------*/
+/*
+ * Disable automatic de-iconify when a bell is received
+ */
+/* #define NO_MAPALERT */
+
+/*
+ * Have mapAlert behaviour selectable with mapAlert resource
+ */
+#define MAPALERT_OPTION
+
+/*-----------------------------SCROLL BAR-------------------------------*/
+/*
+ * Choose the scrollbar width - should be an even number [default: 10]
+ * Except for XTERM_SCROLLBAR: it is *always* 15
+ * 	and for NEXT_SCROLLBAR, which is *always* 19
+ */
+/* #define SB_WIDTH 10 */
+
+/* 
+ * When using Rxvt scrollbar, clicking above or below the slider will move
+ * 1/4 of the screen height, if possible.  Setting RXVT_SCROLL_FULL will move
+ * it one screen height less one line, if possible
+ */
+#define RXVT_SCROLL_FULL 1
+
+/* 
+ * (Hops) draw an internal border line on inside edge of the scrollbar
+ */
+/* #define SB_BORDER */
+
+/*
+ * (Hops)  Uncomment to revert to original funky behaviour of
+ * of having scroll thumb align on thumb top rather than ptr
+ * position in thumb (or center of thumb).
+ * Default Behavior becomes alignment to where grab thumb.
+ * Only for non XTERM scrollbar
+ */
+/* #define FUNKY_SCROLL_BEHAVIOUR */
+
+/*------------------------------MENU BAR--------------------------------*/
+/*
+ * Choose how many of (experimental) menuBars you want to be able to stack at
+ * one time.
+ *  A value of 1 disables menuBar stacking.
+ *  A value of 0 disables menuBar all together.
+ *  Note that the amount of memory overhead is the same for any value >= 2.
+ */
+#define MENUBAR_MAX 8
+
+/*
+ * Change the default shadow style
+ */
+/* #define MENUBAR_SHADOW_IN */
+
+/*
+ * Change the default shadow style
+ */
+#define MENU_SHADOW_IN
+
+/*---------------------------MULTILINGUAL-------------------------------*/
+/*
+ * Allow run-time selection of Meta (Alt) to set the 8th bit on
+ */
+#define META8_OPTION
+
+/*---------------------------DISPLAY OPTIONS----------------------------*/
+/*
+ * Calls to the local X server are handled quickly
+ */
+#define INEXPENSIVE_LOCAL_X_CALLS
+
+/*
+ * Force local connection to be socket (or other local) communication
+ */
+/* #define LOCAL_X_IS_UNIX */
+
+/*
+ * Have DISPLAY environment variable & "\E[7n" transmit display with IP number
+ */
+/* #define DISPLAY_IS_IP */
+
+/*
+ * Have "\E[7n" transmit the display name.
+ * This has been cited as a potential security hole.
+ */
+/* #define ENABLE_DISPLAY_ANSWER */
+
+/* 
+ * Change what ESC Z transmits instead of the default "\E[?1;2c"
+ */
+/* #define ESCZ_ANSWER	"\033[?1;2C" */
+
+/*
+ * Check the current value of the window-time/icon-name and avoid
+ * re-setting it to the same value -- avoids unnecessary window refreshes
+ */
+#define SMART_WINDOW_TITLE
+
+/*
+ * Allow foreground/background colour to be changed with an
+ * xterm escape sequence "\E]39;colour^G" -- still experimental
+ */
+#define XTERM_COLOR_CHANGE
+
+/*
+ * Width of the term border
+ */
+#define BORDERWIDTH	1
+
+/*
+ * Default number of lines in the scrollback buffer
+ */
+#define SAVELINES	64
+
+/*
+ * Provide support for pathetic applications which expect specifically
+ * undefined "bw" (termcap/terminfo) behaviour to be specifically defined
+ * as xterm defines it.
+ */
+#define SUPPORT_BROKEN_APPS_WHICH_RELY_ON_UNDEFINED_BW_BEHAVIOUR_AS_XTERM
+
+/*
+ * List of default fonts available
+ * NFONTS is the number of fonts in the list
+ * FONT0_IDX is the default font in the list (starting at 0)
+ * Sizes between multi-char fonts sets (MFONT_LIST) and single-char font
+ * sets (NFONT_LIST) have been matched up
+ */
+#ifndef MULTICHAR_SET		/* no Kanji or Big5 or GB support */
+# define NFONTS		5
+# define FONT0_IDX	2
+# undef  MFONT_LIST
+# define NFONT_LIST	"7x14", "6x10", "6x13", "8x13", "9x15"
+#endif
+#ifdef KANJI
+# define NFONTS		5
+# define FONT0_IDX	2
+# define MFONT_LIST	"k14", "jiskan16", "jiskan18", "jiskan24", "jiskan26"
+# define NFONT_LIST	"7x14", "8x16", "9x18", "12x24", "13x26"
+#endif
+#ifdef ZH
+# define NFONTS		5
+# define FONT0_IDX	1
+# define MFONT_LIST	"taipei16", "taipeik20", "taipeik24", "taipeik20", \
+       			"taipei16"
+# define NFONT_LIST	"8x16", "10x20", "12x24", "10x20", "8x16"
+#endif
+#ifdef ZHCN		/* Here are our default GB fonts. */
+# define NFONTS		3
+# define FONT0_IDX	1
+# define MFONT_LIST	"hanzigb16st", "hanzigb24st", "hanzigb16fs"
+# define NFONT_LIST	"8x16", "12x24", "8x16"
+#endif
+
+#endif
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/gcc-Wall work/main.d/rxvt-2.6.4/src/gcc-Wall
--- tmp/rxvt-2.6.4/src/gcc-Wall	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/gcc-Wall	1998-04-20 04:31:12.000000000 -0300
@@ -0,0 +1,40 @@
+#!/bin/sh
+# gcc -Wall plus other important warnings not included in -Wall
+
+for arg
+do
+    case $arg in
+	-O*) Wuninitialized=-Wuninitialized;;  # only makes sense with `-O'
+    esac
+done
+
+exec gcc \
+	-Wall $Wuninitialized \
+	-Wwrite-strings \
+	-Wcast-qual \
+	-Wbad-function-cast \
+	-Wpointer-arith \
+	-Wstrict-prototypes \
+	-Wmissing-prototypes \
+	-Wmissing-declarations \
+	-Wnested-externs \
+	-Wtraditional \
+	-Wconversion \
+	-Wcomment \
+	-Wcast-align \
+	-Winline \
+	-Wshadow \
+	-Wredundant-decls \
+	-Wid-clash-31 \
+	"$@"
+
+#    -Wall implies:
+#	-Wimplicit
+#	-Wreturn-type
+#	-Wunused
+#	-Wswitch
+#	-Wformat
+#	-Wchar-subscripts
+#	-Wparentheses
+#	-Wmissing-braces
+------------------------------------------------------------------------------
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/graphics/data work/main.d/rxvt-2.6.4/src/graphics/data
--- tmp/rxvt-2.6.4/src/graphics/data	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/graphics/data	1998-04-20 04:31:14.000000000 -0300
@@ -0,0 +1,5 @@
+0 1e+4
+1e+4 2e+4
+
+2e+6 5e+2
+5e+2 7e+5
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/graphics/grxlib.c work/main.d/rxvt-2.6.4/src/graphics/grxlib.c
--- tmp/rxvt-2.6.4/src/graphics/grxlib.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/graphics/grxlib.c	1998-11-13 01:14:24.000000000 -0300
@@ -0,0 +1,171 @@
+/*
+ * $Id: grxlib.c,v 1.3 1998/11/13 04:14:24 mason Exp $
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <math.h>
+
+#ifdef _AIX
+# include <termio.h>
+#else
+# include <termios.h>
+#endif
+
+#include "grxlib.h"
+
+/*----------------------------------------------------------------------*/
+
+void Done (void)		{ putchar (':'); }
+void StartLine (long id)	{ printf ("\033GL%ld", id); }
+void StartPoint (long id)	{ printf ("\033GP%ld", id); }
+void StartFill (long id)	{ printf ("\033GF%ld", id); }
+void Extend (int x, int y)	{ printf (";%d;%d", x, y); }
+void FillArea (int x1, int y1, int x2, int y2)
+{
+   printf (";%d;%d;%d;%d", x1, y1, x2, y2);
+}
+
+void PlaceText (long id, int x, int y, int mode, char *text)
+{
+   printf ("\033GT%ld;%d;%d;%d;%d:%s", id, x, y, mode, strlen(text), text);
+   fflush (stdout);
+}
+
+void ClearWindow (long id)	{ printf ("\033GC%ld:", id); }
+void ForeColor (int col)	{ printf ("\033[3%dm", (col<0||col>7)?0:col); }
+void DefaultRendition (void)	{ printf ("\033[m"); }
+
+#define LINESZ	100
+static char line [LINESZ];
+static FILE *infd = NULL;
+
+long
+CreateWin (int x, int y, int w, int h)
+{
+   long id = 0;
+
+   fflush (stdout);
+   printf ("\033GW%d;%d;%d;%d:", x, y, w, h);
+   fflush (stdout);
+   while (1)
+     {
+	if ((fgets (line, LINESZ, infd) != NULL) &&
+	    (sscanf (line,"\033W%ld", &id) == 1))
+	  break;
+     }
+   return id;
+}
+
+void
+QueryWin (long id, int *nfwidth, int *nfheight)
+{
+   int id1, x, y, width, height, fwidth, fheight;
+   printf ("\033GG%ld:",id);
+   fflush (stdout);
+   while (1)
+     {
+	if ((fgets (line, sizeof(line), infd) != NULL) &&
+	    (sscanf (line,"\033G%ld %ld %ld %ld %ld %ld %ld %ld %ld",
+		     &id1, &x, &y, &width, &height,
+		     &fwidth, &fheight, nfwidth, nfheight) != 0))
+	  break;
+     }
+}
+
+int
+WaitForCarriageReturn (long *win, int *x, int *y)
+{
+   int i, len;
+
+   fgets (line, LINESZ, infd);
+   line [LINESZ-1] = 0;
+   len = strlen (line);
+   for (i = 0; i < len; i++)
+     {
+	if (line [i] == '\033')
+	  {
+	     int ret = 1;
+	     i++;
+	     switch (line[i]) {
+	      case 'R': ret++;
+		/* drop */
+	      case 'P':
+		sscanf (&line[i+1],"%ld;%d;%d", win, x, y);
+		return ret;
+		break;
+	     }
+	  }
+     }
+   return 0;
+}
+
+static int fno2;
+static struct termios ttmode;
+
+int
+InitializeGraphics (int scroll_text_up)
+{
+   int fno, i;
+   char *screen_tty;
+   struct winsize winsize;
+
+   fno = fileno (stdout);
+   if (!isatty (fno))
+     {
+	fprintf (stderr, "stdout must be a tty\n");
+	return 0;
+     }
+   screen_tty = ttyname (fno);
+   ioctl (fno, TCGETS, (char *)&ttmode);
+   ttmode.c_lflag &= ~ECHO;
+   ioctl (fno, TCSETS, (char *)&ttmode);
+
+   infd = fopen (screen_tty, "rw");
+
+   fno2 = fileno (infd);
+   ioctl (fno2, TCGETS, (char *)&ttmode);
+   ttmode.c_lflag &= ~ECHO;
+   ioctl (fno2, TCSETS, (char *)&ttmode);
+
+   /* query rxvt to find if graphics are available */
+   fflush (stdout);
+   printf ("\033GQ");
+   fflush (stdout);
+   while (1)
+     {
+	if ((fgets (line, LINESZ, infd) != NULL) &&
+	    (sscanf (line,"\033G%d", &i) == 1))
+	  {
+	     if (!i)
+	       {
+		  fprintf (stderr, "rxvt graphics not available\n");
+		  CloseGraphics ();
+		  return 0;
+	       }
+	     break;
+	  }
+     }
+   if (scroll_text_up)
+     {
+	ioctl (fno, TIOCGWINSZ, &winsize);
+	fflush (stdout);
+	for (i = 0; i < winsize.ws_row; i++)
+	  putchar ('\n');
+	fflush (stdout);
+     }
+   return i;
+}
+
+void
+CloseGraphics (void)
+{
+   DefaultRendition ();
+   fflush (stdout);
+   ttmode.c_lflag |= ECHO;
+   ioctl (fno2, TCSETS, (char *)&ttmode);
+   fclose (infd);
+}
+/*----------------------- end-of-file (C source) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/graphics/grxlib.h work/main.d/rxvt-2.6.4/src/graphics/grxlib.h
--- tmp/rxvt-2.6.4/src/graphics/grxlib.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/graphics/grxlib.h	1998-04-20 04:26:21.000000000 -0300
@@ -0,0 +1,31 @@
+/* 
+ * $Id: grxlib.h,v 1.2 1998/04/20 07:26:21 mason Exp $
+ */
+#include "rxvtgrx.h"		/* text alignment */
+
+/*function pointer to either StartLine or StartPoint */
+typedef void (*LineFunction) (long id);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+   extern void	StartLine (long id);
+   extern void	StartPoint (long id);
+   extern void	Extend (int x, int y);
+   extern void	StartFill (long id);
+   extern void	FillArea (int x1, int y1, int x2, int y2);
+   extern void	Done (void);
+   extern void	PlaceText (long id, int x, int y, int mode, char *text);
+
+   extern void	ClearWindow (long id);
+   extern long	CreateWin (int x, int y, int w, int h);
+   extern void	QueryWin (long id, int *nfwidth, int *nfheight);
+   extern void	ForeColor (int color);
+   extern void	DefaultRendition (void);
+   extern int	WaitForCarriageReturn (long *win, int *x, int *y);
+   extern int	InitializeGraphics (int scroll_text_up);
+   extern void	CloseGraphics (void);
+#ifdef __cplusplus
+}
+#endif
+/*----------------------- end-of-file (C header) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/graphics/Makefile work/main.d/rxvt-2.6.4/src/graphics/Makefile
--- tmp/rxvt-2.6.4/src/graphics/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/graphics/Makefile	2007-01-15 18:03:53.000000000 -0300
@@ -0,0 +1,131 @@
+# Generated automatically from Makefile.in by configure.
+# test/graphics/Makefile.in	-*- Makefile -*-
+# $Id: Makefile.in,v 1.3 1998/11/26 05:28:28 mason Exp $
+
+# autoconf/Make.common.in	 -*- Makefile -*-
+# release date (man), LSM date, version number/name, current maintainer
+DATE=02 NOVEMBER 2001
+LSMDATE=02NOV01
+VERSION=2.6.4
+VERNAME=rxvt-$(VERSION)#
+MAINT=Geoff Wing#
+MAINTEMAIL=<gcw@rxvt.org>#
+WEBMAINT=Oezguer Kesim#
+WEBMAINTEMAIL=<oec@rxvt.org>#
+WEBPAGE=<http://www.rxvt.org/>#
+FTPSITENAME=ftp.rxvt.org#
+FTPSITEDIR=/pub/rxvt#
+#-------------------------------------------------------------------------
+
+SHELL = /bin/sh
+
+# This variable makes it possible to move the installation root to another
+# directory. This is useful when you're creating a binary distribution
+# If empty, normal root will be used.
+# You can run eg. 'make install DESTDIR=/packages/rxvt-xx' to accomplish
+# that.
+# DESTDIR = /usr/local/X11/$(VERNAME)
+
+# Installation target directories & other installation stuff
+prefix = //usr
+exec_prefix = //usr
+binprefix =
+manprefix =
+bindir = //usr/bin
+mandir = //usr/share/man/man1
+manext = 1
+
+# Tools & program stuff
+CC = i586-castorbox-linux-gnu-gcc
+CPP = i586-castorbox-linux-gnu-cpp
+MV = //media/gar-castorbox/images/build/usr/bin/mv
+RM = //media/gar-castorbox/images/build/usr/bin/rm
+RMF = //media/gar-castorbox/images/build/usr/bin/rm -f
+CP = //media/gar-castorbox/images/build/usr/bin/cp
+SED = //media/gar-castorbox/images/build/usr/bin/sed
+AWK = //media/gar-castorbox/images/build/usr/bin/awk
+ECHO = //media/gar-castorbox/images/build/usr/bin/echo
+CMP = //media/gar-castorbox/images/build/usr/bin/cmp
+TBL = 
+INSTALL = //media/gar-castorbox/images/build/usr/bin/install -c
+INSTALL_PROGRAM = //media/gar-castorbox/images/build/usr/bin/install -c -s -m 755
+INSTALL_DATA = //media/gar-castorbox/images/build/usr/bin/install -c -m 644
+
+# Flags & libs
+# add -DBINDIR=\""$(bindir)/"\" to CPPFLAGS, if we need to spawn a program
+
+CFLAGS = -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32 
+CPPFLAGS =  
+LDFLAGS = 
+DEFS = -DHAVE_CONFIG_H
+LIBS = 
+DINCLUDE = 
+DLIB = 
+
+# X Include directory
+XINC =  -I/media/gar-castorbox/images/main//usr/include 
+
+# extra libraries needed by X on some systems, X library location
+XLIB =  -L/media/gar-castorbox/images/main//usr/lib  -lX11 
+
+# End of common section of the Makefile
+#-------------------------------------------------------------------------
+
+srcdir =	.
+.PATH:		.
+
+basedir = ../..
+thisdir = src/graphics
+
+first_rule: qplot
+dummy:
+
+SRCS = grxlib.c qplot.c
+OBJS = grxlib.o qplot.o
+HDRS = grxlib.h
+
+#
+# Distribution variables
+#
+
+DIST = $(HDRS) $(SRCS) README data Makefile.in
+
+# inference rules
+.c.o:
+	$(CC) -c $(CPPFLAGS) -I. -I$(basedir) -I$(srcdir) -I$(srcdir)/.. $(DEFS) $(CFLAGS) $<
+#-------------------------------------------------------------------------
+all:
+
+graphics: qplot
+
+qplot: $(OBJS)
+	$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS) -lm
+
+tags: $(SRCS)
+	ctags $(SRCS)
+
+alldoc:
+
+allbin: qplot
+
+clean:
+	$(RMF) qplot core a.out *.o *.bak *~
+
+realclean: clean
+	$(RMF) tags
+
+distclean:
+	(cd $(srcdir); $(RMF) qplot *~ *.o core a.out)
+	if test $(srcdir) = .; then $(MAKE) realclean; fi
+	(cd $(srcdir); $(RMF) Makefile)
+
+install uninstall:
+
+distdirs:
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)
+
+distcopy:
+	$(CP) -p $(DIST) $(basedir)/../$(VERNAME)/$(thisdir)
+
+# -----------------------------------------------------------------------
+# forget dependencies, there are too few
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/graphics/Makefile.in work/main.d/rxvt-2.6.4/src/graphics/Makefile.in
--- tmp/rxvt-2.6.4/src/graphics/Makefile.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/graphics/Makefile.in	1998-11-26 02:28:28.000000000 -0300
@@ -0,0 +1,63 @@
+# test/graphics/Makefile.in	-*- Makefile -*-
+# $Id: Makefile.in,v 1.3 1998/11/26 05:28:28 mason Exp $
+@MCOMMON@
+
+srcdir =	@srcdir@
+VPATH =		@srcdir@
+.PATH:		@srcdir@
+
+basedir = ../..
+thisdir = src/graphics
+
+first_rule: qplot
+dummy:
+
+SRCS = grxlib.c qplot.c
+OBJS = grxlib.o qplot.o
+HDRS = grxlib.h
+
+#
+# Distribution variables
+#
+
+DIST = $(HDRS) $(SRCS) README data Makefile.in
+
+# inference rules
+.c.o:
+	$(CC) -c $(CPPFLAGS) -I. -I$(basedir) -I$(srcdir) -I$(srcdir)/.. $(DEFS) $(CFLAGS) $<
+#-------------------------------------------------------------------------
+all:
+
+graphics: qplot
+
+qplot: $(OBJS)
+	$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS) -lm
+
+tags: $(SRCS)
+	ctags $(SRCS)
+
+alldoc:
+
+allbin: qplot
+
+clean:
+	$(RMF) qplot core a.out *.o *.bak *~
+
+realclean: clean
+	$(RMF) tags
+
+distclean:
+	(cd $(srcdir); $(RMF) qplot *~ *.o core a.out)
+	if test $(srcdir) = .; then $(MAKE) realclean; fi
+	(cd $(srcdir); $(RMF) Makefile)
+
+install uninstall:
+
+distdirs:
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)
+
+distcopy:
+	$(CP) -p $(DIST) $(basedir)/../$(VERNAME)/$(thisdir)
+
+# -----------------------------------------------------------------------
+# forget dependencies, there are too few
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/graphics/qplot.c work/main.d/rxvt-2.6.4/src/graphics/qplot.c
--- tmp/rxvt-2.6.4/src/graphics/qplot.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/graphics/qplot.c	1998-11-13 01:14:25.000000000 -0300
@@ -0,0 +1,259 @@
+/*
+ * $Id: qplot.c,v 1.3 1998/11/13 04:14:25 mason Exp $
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <signal.h>
+#include "grxlib.h"
+
+#define Real float
+
+#ifndef GRX_SCALE
+#  define GRX_SCALE	10000
+#endif
+
+#define DEFAULT_DATA_FILE	"data"
+
+static void
+axis_round (Real *min, Real *max, Real *grid_spacing)
+{
+   int logspace;
+
+   logspace = (int)(log10 ((*max  - *min)/10.0) + 0.5);
+   *grid_spacing = pow (10, (double)logspace);
+   *min = (Real)((int)(*min / (*grid_spacing))) * (*grid_spacing);
+   *max = (Real)((int)(*max / (*grid_spacing))+1) * (*grid_spacing);
+}
+
+static int
+nice_end (int junk)
+{
+   CloseGraphics ();
+   putchar ('\n');
+   exit (EXIT_SUCCESS);
+   return 0;
+}
+
+int
+main (int argc, char **argv)
+{
+   char line[256], *file = NULL;
+   long id,winclick;
+   int Do_Start = 1,tmp;
+   Real x[1000000], y[1000000];
+   Real nls[1000];
+   int m, p, i, j, n, nchars, theight, twidth, xclick, yclick;
+   int downx = 1000,downy = 1000,upx,upy;
+   Real xmax, xmin, ymax, ymin, xdiff, ydiff, xgrid_spacing, ygrid_spacing;
+   FILE *fd;
+   char axis[100];
+
+   LineFunction linetype = StartLine;
+
+   ymax = xmax = -HUGE_VAL;
+   ymin = xmin = HUGE_VAL;
+
+   for (i = 1; i < argc; i++)
+     {
+	if (*argv[i] == '-')
+	  {
+	     if (!strcmp (argv[i], "-nl"))
+	       linetype = StartPoint;
+	     else if (argv[i][1] == '\0')	/* use stdin */
+	       file = argv [i];
+	     else
+	       {
+
+		  fprintf(stderr,
+			  "Usage:\n\t %s [options] [file]\n\n", argv[0]);
+		  fprintf(stderr,
+			  "where options include:\n"
+			  "  -pt                   plot with points instead of lines\n\n");
+
+		  fprintf(stderr,
+			  "file name `-' specifies stdin\n"
+			  "if no file name is specified, "
+			  "the default is \"%s\"\n\n",
+			  DEFAULT_DATA_FILE);
+
+		  return EXIT_FAILURE;
+	       }
+	  }
+	else
+	  {
+	     file = argv [i];
+	  }
+     }
+
+   if (!strcmp (file, "-"))
+     {
+	fd = stdin;
+	file = "stdin";
+     }
+   else
+     {
+	if (file == NULL) file = DEFAULT_DATA_FILE;
+
+	if ((fd = fopen (file, "r")) == NULL)
+	  {
+	     fprintf (stderr, "%s: can't open file \"%s\"\n", argv[0], file);
+	     return EXIT_FAILURE;
+	  }
+     }
+   m = 0;
+   p = 0;
+   while (fgets(line, sizeof(line),fd) != NULL)
+     {
+	if (sscanf(line,"%f %f",&x[m], &y[m]) == 2)
+	  {
+	     if (x[m] > xmax) xmax = x[m]; else if (x[m] < xmin) xmin = x[m];
+	     if (y[m] > ymax) ymax = y[m]; else if (y[m] < ymin) ymin = y[m];
+	     m++;
+	  }
+	else
+	  {
+	     nls [p] = m;
+	     p++;
+	  }
+     }
+   nls [p++] = m;
+
+   if (m == 0)
+     return;
+
+   signal (SIGTERM, nice_end);
+   signal (SIGSTOP, nice_end);
+   signal (SIGTSTP, nice_end);
+   signal (SIGINT,  nice_end);
+   signal (SIGQUIT, nice_end);
+   if (!InitializeGraphics (1))
+     return EXIT_FAILURE;
+
+   n = 1;
+   do
+     {
+	axis_round (&xmin, &xmax, &xgrid_spacing);
+	axis_round (&ymin, &ymax, &ygrid_spacing);
+
+	id = CreateWin (0, 0, GRX_SCALE, GRX_SCALE);
+	if (id == 0)
+	  {
+	     fprintf (stderr,"Help id = 0\n");
+	     return EXIT_FAILURE;
+	  }
+	/* Fill the window in black for real eye-catching graphics! */
+	ForeColor (0);
+	StartFill (id);
+	FillArea (0, 0, GRX_SCALE, GRX_SCALE);
+	Done ();
+
+	/* draw outline box in white */
+	ForeColor (7);
+
+	/* Draw outline box */
+	StartLine(id);
+	Extend (1000, 1000);
+	Extend (1000, 9000);
+	Extend (9000, 9000);
+	Extend (9000, 1000);
+	Extend (1000, 1000);
+	Done();
+
+	/* Draw the data - either lines or dots */
+	xdiff = 8000 / (xmax-xmin);
+	ydiff = 8000 / (ymax-ymin);
+
+	for (i = j = 0; j < p; j++)
+	  {
+	     int n = 0;
+
+	     ForeColor (j%6+1);
+	     while (((x[i] < xmin) || (x[i] > xmax) ||
+		     (y[i] < ymin) || (y[i] > ymax)) && (i < nls [j]))
+	       i++;
+
+	     while (i < nls [j])
+	       {
+		  if (n == 0)
+		    linetype (id);
+		  Extend (1000+(x[i]-xmin)*xdiff,9000-(y[i]-ymin)*ydiff);
+		  n++;
+		  if (n > 450)
+		    {
+		       Done ();
+		       n = 0;
+		       continue;
+		    }
+		  i++;
+		  while ((i < nls [j]) &&
+			 ((x [i] < xmin) || (x [i] > xmax) ||
+			  (y [i] < ymin) || (y [i] > ymax)))
+		    i++;
+	       }
+	     if (n > 0)
+	       Done ();
+	  }
+
+	/* Do axis labels in black */
+	ForeColor (7);
+	QueryWin (id, &twidth,&theight);
+	PlaceText (id, GRX_SCALE/2, 0, HCENTER_TEXT|TOP_TEXT, file);
+	PlaceText (id, GRX_SCALE/2, GRX_SCALE, HCENTER_TEXT|BOTTOM_TEXT, "X");
+	PlaceText (id, 0, GRX_SCALE/2, LEFT_TEXT|VCENTER_TEXT, "Y");
+	sprintf (axis, "%f", ymax);
+	nchars = 1000 / twidth;
+
+	axis [nchars] = 0;
+	PlaceText (id, GRX_SCALE/10, GRX_SCALE/10,
+		   RIGHT_TEXT|TOP_TEXT, axis);
+	sprintf (axis, "%f", ymin);
+	axis [nchars] = 0;
+	PlaceText (id, GRX_SCALE/10, 9*GRX_SCALE/10,
+		   RIGHT_TEXT|BOTTOM_TEXT,axis);
+	sprintf (axis, "%f",xmax);
+	PlaceText (id, 9*GRX_SCALE/10, 9*GRX_SCALE/10,
+		   HCENTER_TEXT|TOP_TEXT,axis);
+	sprintf (axis,"%f",xmin);
+	PlaceText (id, GRX_SCALE/10, 9*GRX_SCALE/10,
+		   HCENTER_TEXT|TOP_TEXT,axis);
+	fflush (stdout);
+
+	do
+	  {
+	     n = WaitForCarriageReturn (&winclick, &xclick, &yclick);
+	     switch (n) {
+	      case 1:
+		downx = xclick;
+		downy = yclick;
+		break;
+	      case 2:
+		upx = xclick;
+		upy = yclick;
+		if (upx < downx)
+		  {
+		     tmp = downx;
+		     downx = upx;
+		     upx = tmp;
+		  }
+		if (upy < downy)
+		  {
+		     tmp = downy;
+		     downy = upy;
+		     upy = tmp;
+		  }
+		xmin = (xmax - xmin) * (downx - 1000) / (8000) + xmin;
+		xmax = (xmax - xmin) * (upx - 1000) / (8000) + xmin;
+		ymax = ymax - (ymax - ymin) * (downy - 1000) / (8000);
+		ymin = ymax - (ymax - ymin) * (upy - 1000) / (8000);
+		break;
+	     }
+	  }
+	while (n && (n != 2));
+     }
+   while (n);
+   nice_end (EXIT_SUCCESS);
+   return EXIT_SUCCESS;
+}
+/*----------------------- end-of-file (C source) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/graphics/README work/main.d/rxvt-2.6.4/src/graphics/README
--- tmp/rxvt-2.6.4/src/graphics/README	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/graphics/README	1998-04-20 04:31:14.000000000 -0300
@@ -0,0 +1 @@
+This is an example of rxvt graphics.
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/graphics.c work/main.d/rxvt-2.6.4/src/graphics.c
--- tmp/rxvt-2.6.4/src/graphics.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/graphics.c	1999-04-16 02:44:06.000000000 -0300
@@ -0,0 +1,558 @@
+/*--------------------------------*-C-*---------------------------------*
+ * File:	graphics.c
+ *----------------------------------------------------------------------*
+ * $Id: graphics.c,v 1.19 1999/04/16 05:44:06 mason Exp $
+ *
+ * All portions of code are copyright by their respective author/s.
+ * Copyright (C) 1994      Rob Nation <nation@rocket.sanders.lockheed.com>
+ *				- original version
+ * Copyright (C) 1997      Raul Garcia Garcia <rgg@tid.es>
+ * Copyright (C) 1997,1998 mj olesen <olesen@me.queensu.ca>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *----------------------------------------------------------------------*/
+
+#include "rxvt.h"		/* NECESSARY */
+#include "graphics.intpro"	/* PROTOS for internal routines */
+#include <X11/cursorfont.h>
+
+/* commands:
+ * 'C' = Clear
+ * 'F' = Fill
+ * 'G' = Geometry
+ * 'L' = Line
+ * 'P' = Points
+ * 'T' = Text
+ * 'W' = Window
+ */
+
+#ifndef GRX_SCALE
+# define GRX_SCALE	10000
+#endif
+
+#ifdef RXVT_GRAPHICS
+static int      graphics_up = 0;
+static grwin_t *gr_root = NULL;
+#endif
+
+/*----------------------------------------------------------------------*
+ * local functions
+ */
+#ifdef RXVT_GRAPHICS
+/* ARGSUSED */
+/* INTPROTO */
+void
+Gr_NewWindow(int nargs, int args[])
+{
+    int             x, y;
+    unsigned int    w, h;
+    Window          win;
+    grwin_t        *grwin;
+    Cursor          cursor;
+
+    if (nargs != 4) {
+	print_error("NewWindow: 4 args needed, got %d\n", nargs);
+	return;
+    }
+    x = args[0] * TermWin.width / GRX_SCALE + TermWin_internalBorder;
+    y = args[1] * TermWin.height / GRX_SCALE + TermWin_internalBorder;
+    w = args[2] * TermWin.width / GRX_SCALE;
+    h = args[3] * TermWin.height / GRX_SCALE;
+
+    win = XCreateSimpleWindow(Xdisplay, TermWin.vt,
+			      x, y, w, h,
+			      0,
+			      PixColors[Color_fg],
+			      PixColors[Color_bg]);
+
+    cursor = XCreateFontCursor(Xdisplay, XC_crosshair);
+    XDefineCursor(Xdisplay, win, cursor);
+    XMapWindow(Xdisplay, win);
+    XSelectInput(Xdisplay, win, ExposureMask);
+
+    grwin = (grwin_t *) MALLOC(sizeof(grwin_t));
+    grwin->win = win;
+    grwin->x = x;
+    grwin->y = y;
+    grwin->w = w;
+    grwin->h = h;
+    grwin->screen = 0;
+    grwin->prev = NULL;
+    grwin->next = gr_root;
+    if (grwin->next)
+	grwin->next->prev = grwin;
+    gr_root = grwin;
+    grwin->graphics = NULL;
+    graphics_up++;
+
+    tt_printf("\033W%ld\n", (long)grwin->win);
+}
+
+/* ARGSUSED */
+/* INTPROTO */
+void
+Gr_ClearWindow(grwin_t *grwin)
+{
+    grcmd_t        *cmd, *next;
+
+    for (cmd = grwin->graphics; cmd != NULL; cmd = next) {
+	next = cmd->next;
+	free(cmd->coords);
+	if (cmd->text != NULL)
+	    free(cmd->text);
+	free(cmd);
+    }
+    grwin->graphics = NULL;
+    XClearWindow(Xdisplay, grwin->win);
+}
+
+/*
+ * arg [0] = x
+ * arg [1] = y
+ * arg [2] = alignment
+ * arg [3] = strlen (text)
+ */
+/* ARGSUSED */
+/* INTPROTO */
+void
+Gr_Text(grwin_t *grwin, grcmd_t *data)
+{
+    int             x, y, align;
+
+    if (data->ncoords < 4 || data->text == NULL || *(data->text) == '\0')
+	return;
+
+    x = data->coords[0] * grwin->w / GRX_SCALE;
+    y = data->coords[1] * grwin->h / GRX_SCALE;
+    align = data->coords[2];
+
+    if (align & RIGHT_TEXT)
+	x -= XTextWidth(TermWin.font, data->text, data->coords[3]);
+    else if (align & HCENTER_TEXT)
+	x -= (XTextWidth(TermWin.font, data->text, data->coords[3]) >> 1);
+
+    if (align & TOP_TEXT)
+	y += TermWin.font->ascent;
+    else if (align & BOTTOM_TEXT)
+	y -= TermWin.font->descent;
+
+    if (align & VCENTER_TEXT)
+	y -= TermWin.font->descent
+	     + ((TermWin.font->ascent + TermWin.font->descent) >> 1);
+    if (align & VCAPS_CENTER_TEXT)
+	y += (TermWin.font->ascent >> 1);
+
+    XPMClearArea(Xdisplay, grwin->win, x, y, Width2Pixel(data->coords[3]),
+		 Height2Pixel(1), 0);
+    XDrawString(Xdisplay, grwin->win, TermWin.gc, x, y,
+		data->text, data->coords[3]);
+}
+
+/* ARGSUSED */
+/* INTPROTO */
+void
+Gr_Geometry(grwin_t *grwin, grcmd_t *data)
+{
+    if (grwin)
+	tt_printf("\033G%ld %d %d %u %u %d %d %ld %ld %d\n",
+		  (long)grwin->win,
+		  grwin->x, grwin->y, grwin->w, grwin->h,
+		  TermWin.fwidth,
+		  TermWin.fheight,
+		  (long)GRX_SCALE * TermWin.fwidth / grwin->w,
+		  (long)GRX_SCALE * TermWin.fheight / grwin->h,
+		  Xdepth);
+    else			/* rxvt terminal window size */
+	tt_printf("\033G0 0 0 %d %d %d %d %ld %ld %d\n",
+		  TermWin.width - 2 * TermWin_internalBorder,
+		  TermWin.height - 2 * TermWin_internalBorder,
+		  TermWin.fwidth,
+		  TermWin.fheight,
+		  (long)GRX_SCALE * TermWin.fwidth
+		        / (TermWin.width - 2 * TermWin_internalBorder),
+		  (long)GRX_SCALE * TermWin.fheight
+		        / (TermWin.height - 2 * TermWin_internalBorder),
+		  Xdepth);
+}
+
+/* ARGSUSED */
+/* INTPROTO */
+void
+Gr_DestroyWindow(grwin_t *grwin)
+{
+    grcmd_t        *cmd, *next;
+
+    if (grwin == NULL)
+	return;
+
+    for (cmd = grwin->graphics; cmd; cmd = next) {
+	next = cmd->next;
+	free(cmd->coords);
+	if (cmd->text != NULL)
+	    free(cmd->text);
+	free(cmd);
+    }
+
+    XDestroyWindow(Xdisplay, grwin->win);
+    if (grwin->next != NULL)
+	grwin->next->prev = grwin->prev;
+    if (grwin->prev != NULL)
+	grwin->prev->next = grwin->next;
+    else
+	gr_root = grwin->next;
+    free(grwin);
+
+    graphics_up--;
+}
+
+/* ARGSUSED */
+/* INTPROTO */
+void
+Gr_Dispatch(grwin_t *grwin, grcmd_t *data)
+{
+    int             i, n;
+    union {
+	XPoint          pt[NGRX_PTS / 2];
+	XRectangle      rect[NGRX_PTS / 4];
+    } xdata;
+
+    if (data->color != Color_fg) {
+	XGCValues       gcv;
+
+	gcv.foreground = PixColors[data->color];
+	XChangeGC(Xdisplay, TermWin.gc, GCForeground, &gcv);
+    }
+    if (grwin)
+	switch (data->cmd) {
+	case 'L':
+	    if (data->ncoords > 3) {
+		for (n = i = 0; i < data->ncoords; i += 2, n++) {
+		    xdata.pt[n].x = data->coords[i] * grwin->w / GRX_SCALE;
+		    xdata.pt[n].y = data->coords[i + 1] * grwin->h / GRX_SCALE;
+		}
+		XDrawLines(Xdisplay,
+		       grwin->win, TermWin.gc, xdata.pt, n, CoordModeOrigin);
+	    }
+	    break;
+
+	case 'P':
+	    if (data->ncoords > 3) {
+		for (n = i = 0; i < data->ncoords; i += 2, n++) {
+		    xdata.pt[n].x = data->coords[i] * grwin->w / GRX_SCALE;
+		    xdata.pt[n].y = data->coords[i + 1] * grwin->h / GRX_SCALE;
+		}
+		XDrawPoints(Xdisplay,
+		       grwin->win, TermWin.gc, xdata.pt, n, CoordModeOrigin);
+	    }
+	    break;
+
+	case 'F':
+	    if (data->ncoords > 0) {
+		for (n = i = 0; i < data->ncoords; i += 4, n++) {
+		    xdata.rect[n].x = data->coords[i] * grwin->w / GRX_SCALE;
+		    xdata.rect[n].y = data->coords[i + 1] * grwin->h
+				      / GRX_SCALE;
+		    xdata.rect[n].width = ((data->coords[i + 2]
+					    - data->coords[i] + 1) *
+					   grwin->w / GRX_SCALE);
+		    xdata.rect[n].height = ((data->coords[i + 3]
+					     - data->coords[i + 1] + 1) *
+					    grwin->h / GRX_SCALE);
+		    XPMClearArea(Xdisplay, grwin->win,
+				 xdata.rect[n].x, xdata.rect[n].y,
+				 xdata.rect[n].width, xdata.rect[n].height,
+				 0);
+		}
+		XFillRectangles(Xdisplay, grwin->win, TermWin.gc, xdata.rect,
+				n);
+	    }
+	    break;
+	case 'T':
+	    Gr_Text(grwin, data);
+	    break;
+	case 'C':
+	    Gr_ClearWindow(grwin);
+	    break;
+	}
+    if (data->color != Color_fg) {
+	XGCValues       gcv;
+
+	gcv.foreground = PixColors[Color_fg];
+	XChangeGC(Xdisplay, TermWin.gc, GCForeground, &gcv);
+    }
+}
+
+/* ARGSUSED */
+/* INTPROTO */
+void
+Gr_Redraw(grwin_t *grwin)
+{
+    grcmd_t        *cmd;
+
+    for (cmd = grwin->graphics; cmd != NULL; cmd = cmd->next)
+	Gr_Dispatch(grwin, cmd);
+}
+#endif				/* RXVT_GRAPHICS */
+
+/*----------------------------------------------------------------------*
+ * end of static functions
+ */
+/* ARGSUSED */
+/* EXTPROTO */
+void
+Gr_ButtonReport(int but, int x, int y)
+{
+#ifdef RXVT_GRAPHICS
+    grwin_t        *grwin;
+
+    for (grwin = gr_root; grwin != NULL; grwin = grwin->next)
+	if ((x > grwin->x)
+	    && (y > grwin->y)
+	    && (x < grwin->x + grwin->w)
+	    && (y < grwin->y + grwin->h))
+	    break;
+
+    if (grwin == NULL)
+	return;
+
+    x = GRX_SCALE * (x - grwin->x) / grwin->w;
+    y = GRX_SCALE * (y - grwin->y) / grwin->h;
+    tt_printf("\033%c%ld;%d;%d;\n", but, (long)grwin->win, x, y);
+#endif
+}
+
+/* ARGSUSED */
+/* EXTPROTO */
+void
+Gr_do_graphics(int cmd, int nargs, int args[], unsigned char *text)
+{
+#ifdef RXVT_GRAPHICS
+    static Window   last_id = None;
+    long            win_id;
+    grwin_t        *grwin;
+    grcmd_t        *newcmd, *oldcmd;
+    int             i;
+
+    if (cmd == 'W') {
+	Gr_NewWindow(nargs, args);
+	return;
+    }
+    win_id = (nargs > 0) ? (Window) args[0] : None;
+
+    if ((cmd == 'G') && (win_id == None)) {
+	Gr_Geometry(NULL, NULL);
+	return;
+    }
+    if ((win_id == None) && (last_id != None))
+	win_id = last_id;
+
+    if (win_id == None)
+	return;
+
+    grwin = gr_root;
+    while ((grwin != NULL) && (grwin->win != win_id))
+	grwin = grwin->next;
+
+    if (grwin == NULL)
+	return;
+
+    if (cmd == 'G') {
+	Gr_Geometry(grwin, NULL);
+	return;
+    }
+    nargs--;
+    args++;			/* skip over window id */
+
+/* record this new command */
+    newcmd = (grcmd_t *) MALLOC(sizeof(grcmd_t));
+    newcmd->ncoords = nargs;
+    newcmd->coords = (int *)MALLOC((newcmd->ncoords * sizeof(int)));
+
+    newcmd->next = NULL;
+    newcmd->cmd = cmd;
+    newcmd->color = scr_get_fgcolor();
+    newcmd->text = text;
+
+    for (i = 0; i < newcmd->ncoords; i++)
+	newcmd->coords[i] = args[i];
+
+/*
+ * If newcmd == fill, and rectangle is full window, drop all prior
+ * commands.
+ */
+    if ((newcmd->cmd == 'F') && (grwin) && (grwin->graphics)) {
+	for (i = 0; i < newcmd->ncoords; i += 4) {
+	    if ((newcmd->coords[i] == 0)
+		&& (newcmd->coords[i + 1] == 0)
+		&& (newcmd->coords[i + 2] == GRX_SCALE)
+		&& (newcmd->coords[i + 3] == GRX_SCALE)) {
+	    /* drop previous commands */
+		oldcmd = grwin->graphics;
+		while (oldcmd->next != NULL) {
+		    grcmd_t        *tmp = oldcmd;
+
+		    oldcmd = oldcmd->next;
+		    free(tmp);
+		}
+		grwin->graphics = NULL;
+	    }
+	}
+    }
+/* insert new command into command list */
+    oldcmd = grwin->graphics;
+    if (oldcmd == NULL)
+	grwin->graphics = newcmd;
+    else {
+	while (oldcmd->next != NULL)
+	    oldcmd = oldcmd->next;
+	oldcmd->next = newcmd;
+    }
+    Gr_Dispatch(grwin, newcmd);
+#endif
+}
+
+/* ARGSUSED */
+/* EXTPROTO */
+void
+Gr_scroll(int count)
+{
+#ifdef RXVT_GRAPHICS
+    static short    prev_start = 0;
+    grwin_t        *grwin, *next;
+
+    if ((count == 0) && (prev_start == TermWin.view_start))
+	return;
+
+    prev_start = TermWin.view_start;
+
+    for (grwin = gr_root; grwin != NULL; grwin = next) {
+	next = grwin->next;
+	grwin->y -= (count * TermWin.fheight);
+	if ((grwin->y + grwin->h) < -(TermWin.saveLines * TermWin.fheight))
+	    Gr_DestroyWindow(grwin);
+	else
+	    XMoveWindow(Xdisplay, grwin->win,
+			grwin->x,
+			grwin->y + (TermWin.view_start * TermWin.fheight));
+    }
+#endif
+}
+
+/* EXTPROTO */
+void
+Gr_ClearScreen(void)
+{
+#ifdef RXVT_GRAPHICS
+    grwin_t        *grwin, *next;
+
+    for (grwin = gr_root; grwin != NULL; grwin = next) {
+	next = grwin->next;
+	if ((grwin->screen == 0) && (grwin->y + grwin->h > 0)) {
+	    if (grwin->y >= 0)
+		Gr_DestroyWindow(grwin);
+	    else
+		XResizeWindow(Xdisplay, grwin->win,
+			      grwin->w, -grwin->y);
+	}
+    }
+#endif
+}
+
+/* EXTPROTO */
+void
+Gr_ChangeScreen(void)
+{
+#ifdef RXVT_GRAPHICS
+    grwin_t        *grwin, *next;
+
+    for (grwin = gr_root; grwin != NULL; grwin = next) {
+	next = grwin->next;
+	if (grwin->y + grwin->h > 0) {
+	    if (grwin->screen == 1) {
+		XMapWindow(Xdisplay, grwin->win);
+		grwin->screen = 0;
+	    } else {
+		XUnmapWindow(Xdisplay, grwin->win);
+		grwin->screen = 1;
+	    }
+	}
+    }
+#endif
+}
+
+/* ARGSUSED */
+/* EXTPROTO */
+void
+Gr_expose(Window win)
+{
+#ifdef RXVT_GRAPHICS
+    grwin_t        *grwin;
+
+    for (grwin = gr_root; grwin != NULL; grwin = grwin->next) {
+	if (grwin->win == win) {
+	    Gr_Redraw(grwin);
+	    break;
+	}
+    }
+#endif
+}
+
+/* ARGSUSED */
+/* EXTPROTO */
+void
+Gr_Resize(int w, int h)
+{
+#ifdef RXVT_GRAPHICS
+    grwin_t        *grwin;
+
+    for (grwin = gr_root; grwin != NULL; grwin = grwin->next) {
+	if (TermWin.height != h) {
+	    grwin->y += (TermWin.height - h);
+	    XMoveWindow(Xdisplay, grwin->win,
+			grwin->x,
+			grwin->y + (TermWin.view_start * TermWin.fheight));
+	}
+	Gr_Redraw(grwin);
+    }
+#endif
+}
+
+/* EXTPROTO */
+void
+Gr_reset(void)
+{
+#ifdef RXVT_GRAPHICS
+    grwin_t        *grwin, *next;
+
+    for (grwin = gr_root; grwin != NULL; grwin = next) {
+	next = grwin->next;
+	Gr_DestroyWindow(grwin);
+    }
+
+    graphics_up = 0;
+#endif
+}
+
+/* EXTPROTO */
+int
+Gr_Displayed(void)
+{
+#ifdef RXVT_GRAPHICS
+    return graphics_up;
+#else
+    return 0;
+#endif
+}
+/*----------------------- end-of-file (C source) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/graphics.extpro work/main.d/rxvt-2.6.4/src/graphics.extpro
--- tmp/rxvt-2.6.4/src/graphics.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/graphics.extpro	2001-11-01 21:28:28.000000000 -0300
@@ -0,0 +1,9 @@
+void             Gr_ButtonReport         __PROTO((int but, int x, int y));
+void             Gr_do_graphics          __PROTO((int cmd, int nargs, int args[], unsigned char *text));
+void             Gr_scroll               __PROTO((int count));
+void             Gr_ClearScreen          __PROTO((void));
+void             Gr_ChangeScreen         __PROTO((void));
+void             Gr_expose               __PROTO((Window win));
+void             Gr_Resize               __PROTO((int w, int h));
+void             Gr_reset                __PROTO((void));
+int              Gr_Displayed            __PROTO((void));
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/graphics.intpro work/main.d/rxvt-2.6.4/src/graphics.intpro
--- tmp/rxvt-2.6.4/src/graphics.intpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/graphics.intpro	2001-11-01 21:28:30.000000000 -0300
@@ -0,0 +1,7 @@
+void             Gr_NewWindow            __PROTO((int nargs, int args[]));
+void             Gr_ClearWindow          __PROTO((grwin_t *grwin));
+void             Gr_Text                 __PROTO((grwin_t *grwin, grcmd_t *data));
+void             Gr_Geometry             __PROTO((grwin_t *grwin, grcmd_t *data));
+void             Gr_DestroyWindow        __PROTO((grwin_t *grwin));
+void             Gr_Dispatch             __PROTO((grwin_t *grwin, grcmd_t *data));
+void             Gr_Redraw               __PROTO((grwin_t *grwin));
Binary files tmp/rxvt-2.6.4/src/graphics.o and work/main.d/rxvt-2.6.4/src/graphics.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/grkelot.c work/main.d/rxvt-2.6.4/src/grkelot.c
--- tmp/rxvt-2.6.4/src/grkelot.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/grkelot.c	1998-11-12 01:51:12.000000000 -0300
@@ -0,0 +1,427 @@
+/*---------------------------------*C*--------------------------------------*
+ * File:      grkelot.c
+ *--------------------------------------------------------------------------*
+ * $Id: grkelot.c,v 1.10 1998/11/12 04:51:12 mason Exp $
+ *
+ * All portions of code are copyright by their respective author/s.
+ * Copyright (c) 1994,1995 Angelo Haritsis. All rights reserved.
+ *				- original version
+ * Copyright (C) 1997,1998 Oezger Kesim <kesim@math.fu-berlin.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *--------------------------------------------------------------------------*
+ * Synopsis:    string -> greek ELOT928 or IBM437 string;
+ *              4-state FSM implementation.
+ *
+ * System:      Any (ANSI C)
+ *
+ * This is code derived from a more generic key remapper written by the same
+ * author and used in other environments. It was not written only
+ * for greek kbd bindings. An extension to other languages is easy
+ * (well don't know how the FSM lends itself to Far East languages).
+ *
+ * The FSM can have MAX_STATES states (change it for more).
+ * Each state contains:
+ * 1.  many tranlsation tables (registered via kstate_add_xlat())
+ * 2.  many switch codes for transition to other states (registered via
+ *      kstate_add_switcher()) : limit is static now: MAX_SWITCHER
+ * 3.   life: the number of xlations allowed in a state (0 = unlimited)
+ *
+ * Format of tranlation strings:
+ *      <first>-<last>:n1,n2,n3,...
+ * Format of switcher string:
+ *      A<char>:<state_no>
+ * (other switchers apart from A=ascii can be supported; not in this context)
+ * Format of life string:
+ *      L<N>            (N=0,1,...)
+ *-------------------------------------------------------------------------*
+ * Written by Angelo Haritis.
+ *
+ * Redistribution and use in source and binary forms are permitted provided
+ * that the above copyright notice and this paragraph are duplicated in all
+ * such forms and that any documentation, advertising materials, and other
+ * materials related to such distribution and use acknowledge that the
+ * software was developed by Angelo Haritsis.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * NB: DO NOT ALTER! THIS CODE IS USED IN MANY PLATFORMS!!!
+ *
+ * TODO: make it more dynamic (linked lists is an idea but slower)
+ */
+
+#define RXVT			/* define for use by rxvt */
+
+#ifdef RXVT
+#include "rxvt.h"		/* NECESSARY */
+#include "grkelot.intpro"	/* PROTOS for internal routines */
+#endif				/* RXVT */
+
+#ifdef GREEK_SUPPORT
+#include "grkelot.h"
+#include <stdlib.h>
+#include <string.h>
+
+/* --- Macros, Types --------- */
+#define MAX_STATES	4	/* max # states for the FSM */
+#define MAX_SWITCHER	2U	/* per state */
+#define MAX_VAL 	256	/* for temp allocation */
+
+typedef unsigned char u_char;
+typedef unsigned int u_int;
+typedef unsigned long u_long;
+
+typedef struct s_xlat {
+    u_int           first, last;
+    u_int          *pval;	/* array of translated values */
+} K_XLAT;
+
+typedef struct s_switch {
+    u_char          type;	/* Ascii, Virtual, Scan */
+    u_int           code;
+    u_char          nextstate;
+    u_char          on;		/* current state of key: 0 = off */
+} K_SWITCH;
+
+typedef struct s_state {
+    u_int           num_xlat;	/* number of translations */
+    K_XLAT         *xlat;	/* State translations ((dynamic - realloc'ed) */
+    u_int           num_switcher;	/* number of switcher keys */
+    K_SWITCH        switcher[MAX_SWITCHER];	/* switcher keys to other states */
+    u_char          life;	/* 0 = until switched by key */
+    u_char          prev_state;	/* filled when jumped to a new state */
+} K_STATE;
+
+/* type for each one of the different greek standards (xlat types) */
+typedef struct s_xlat_type {
+    char           *plain;
+    char           *accent;
+    char           *accent_xtra;
+    char           *umlaut;
+    char           *acc_uml;
+} XLAT_TYPE;
+
+/* --- Local Data ------------ */
+static K_STATE  State[MAX_STATES];
+
+/* Current State */
+static u_char   nStateNow = 0;
+static K_STATE *pStateNow = &State[0];
+static int      GreekMode = GREEK_ELOT928;
+
+/*
+ * The following are hard-coded for now. The idea is that such strings would
+ * be read from a config file making it possible to change language/encodings
+ * more flexibly.
+ */
+/* elot 928 xlations */
+static char     elot_xlat_plain[] = "65-122:193,194,216,196,197,214,195,199,201,206,202,203,204,205,207,208,81,209,211,212,200,217,87,215,213,198,91,92,93,94,95,96,225,226,248,228,229,246,227,231,233,238,234,235,236,237,239,240,113,241,243,244,232,249,242,247,245,230";
+
+/* c and s give copyright and section sign */
+static char     elot_xlat_acc[] = "65-122:182,194,216,196,184,214,195,185,186,206,202,203,204,205,188,208,81,209,211,212,200,191,87,215,190,198,91,92,93,94,95,96,220,226," /*248 */ "169,228,221,246,227,222,223,238,234,235,236,237,252,240,113,241," /*243 */ "167,244,232,254,242,247,253,230";
+static char     elot_xlat_acc_xtra[] = "46-62:183,47,48,49,50,51,52,53,54,55,56,57,58,59,171,61,187";	/* anw teleia, quotes */
+static char     elot_xlat_uml[] = "65-122:193,194,216,196,197,214,195,199,218,206,202,203,204,205,207,208,81,209,211,212,200,217,87,215,219,198,91,92,93,94,95,96,225,226,248,228,229,246,227,231,250,238,234,235,236,237,239,240,113,241,243,244,232,249,242,247,251,230";
+static char     elot_xlat_umacc[] = "65-122:193,194,216,196,197,214,195,199,201,206,202,203,204,205,207,208,81,209,211,212,200,217,87,215,213,198,91,92,93,94,95,96,225,226,248,228,229,246,227,231,192,238,234,235,236,237,239,240,113,241,243,244,232,249,242,247,224,230";
+
+/* ibm 437 xlations */
+static char     i437_xlat_plain[] = "65-122:128,129,150,131,132,148,130,134,136,141,137,138,139,140,142,143,81,144,145,146,135,151,87,149,147,133,91,92,93,94,95,96,152,153,175,155,156,173,154,158,160,165,161,162,163,164,166,167,113,168,169,171,159,224,170,174,172,157";
+static char     i437_xlat_acc[] = "65-122:234,129,150,131,235,148,130,236,237,141,137,138,139,140,238,143,81,144,145,146,135,240,87,149,239,133,91,92,93,94,95,96,225,153,175,155,226,173,154,227,229,165,161,162,163,164,230,167,113,168,169,171,159,233,170,174,231,157";
+static char     i437_xlat_acc_xtra[] = "46-46:250";	/* anw teleia */
+static char     i437_xlat_uml[] = "65-122:128,129,150,131,132,148,130,134,136,141,137,138,139,140,142,143,81,144,145,146,135,151,87,149,147,133,91,92,93,94,95,96,152,153,175,155,156,173,154,158,228,165,161,162,163,164,166,167,113,168,169,171,159,224,170,174,232,157";
+static char     i437_xlat_umacc[] = "65-122:128,129,150,131,132,148,130,134,136,141,137,138,139,140,142,143,81,144,145,146,135,151,87,149,147,133,91,92,93,94,95,96,152,153,175,155,156,173,154,158,42,165,161,162,163,164,166,167,113,168,169,171,159,224,170,174,42,157";
+
+/*
+ * currently ELOT928 and IBM437 are supported; easy to include others
+ * (not recommended: stick to just these 2 if not only the ELOT one)
+ */
+static XLAT_TYPE xlat_type[] =
+{
+    {elot_xlat_plain, elot_xlat_acc, elot_xlat_acc_xtra, elot_xlat_uml, elot_xlat_umacc},
+    {i437_xlat_plain, i437_xlat_acc, i437_xlat_acc_xtra, i437_xlat_uml, i437_xlat_umacc},
+};
+
+/* the current trasnaltion type */
+static XLAT_TYPE *xlat_now = &xlat_type[GREEK_ELOT928];
+
+#define NUM_XLAT_TYPES	(sizeof(xlat_type) / sizeof(xlat_type[0]))
+
+static void     kstate_add_xlat(char *str);
+static void     kstate_add_switcher(char *str);
+static void     kstate_set_life(char *str);
+
+/* --- Functions ------------- */
+/* INTPROTO */
+void
+kstate_setcurr(int stateno)
+{
+    u_char          prev_state;
+
+    if ((u_int) stateno > (u_int) MAX_STATES)
+	return;
+    if (pStateNow->life == 1)
+	prev_state = pStateNow->prev_state;
+    else
+	prev_state = nStateNow;
+    pStateNow = &State[nStateNow = stateno];
+    pStateNow->prev_state = prev_state;
+}
+
+/* INTPROTO */
+void
+kstate_init(void)
+{
+    pStateNow->num_xlat = pStateNow->num_switcher = pStateNow->life = pStateNow->prev_state = 0;
+    pStateNow->xlat = NULL;
+}
+
+/* INTPROTO */
+void
+kstate_end(void)
+{
+    int             i;
+
+    for (i = 0; i < pStateNow->num_xlat; i++)
+	free(pStateNow->xlat[i].pval);
+    if (pStateNow->num_xlat > 0)
+	free(pStateNow->xlat);
+}
+
+/*
+ * Hard coded ELOT-928 translations. Could read these from an rc-type file
+ * to support other remappers.
+ */
+/* INTPROTO */
+void
+kstate_init_all(int greek_mode)
+{
+/* the translation tables for the 4 FSM states for ELOT-928 mappings */
+    int             i;
+
+    for (i = 0; i < MAX_STATES; i++) {
+	kstate_setcurr(i);
+	kstate_init();
+    }
+    if (greek_mode < 0 || greek_mode >= NUM_XLAT_TYPES)		/* avoid death */
+	greek_mode = GREEK_ELOT928;
+    xlat_now = &xlat_type[greek_mode];
+    kstate_setcurr(0);
+    kstate_add_xlat(xlat_now->plain);
+    kstate_add_switcher("A;:1");
+    kstate_add_switcher("A::2");
+    kstate_set_life("L0");
+
+    kstate_setcurr(1);
+    kstate_add_xlat(xlat_now->accent);
+    kstate_add_xlat(xlat_now->accent_xtra);
+    kstate_add_switcher("A::3");
+    kstate_set_life("L1");
+
+    kstate_setcurr(2);
+    kstate_add_xlat(xlat_now->umlaut);
+    kstate_add_switcher("A;:3");
+    kstate_set_life("L1");
+
+    kstate_setcurr(3);
+    kstate_add_xlat(xlat_now->acc_uml);
+    kstate_set_life("L1");
+}
+
+/* INTPROTO */
+void
+kstate_end_all(void)
+{
+    int             i;
+
+    for (i = 0; i < MAX_STATES; i++) {
+	kstate_setcurr(i);
+	kstate_end();
+    }
+    kstate_setcurr(0);
+}
+
+/*
+ * reset FSM
+ */
+/* INTPROTO */
+void
+kstate_reset(void)
+{
+    kstate_setcurr(0);
+}
+
+/* INTPROTO */
+void
+kstate_add_xlat(char *str)
+{
+    K_XLAT         *xlat;
+    u_int          *pval_tmp;
+    char           *sval;
+    int             i;
+
+    if (str == NULL)
+	return;
+/* add a new xlat table in state */
+    if (pStateNow->num_xlat == 0) {
+	pStateNow->xlat = malloc(sizeof(K_XLAT));
+    } else			/* prefer contiguous data, realloc */
+	pStateNow->xlat = realloc(pStateNow->xlat, (pStateNow->num_xlat + 1) * sizeof(K_XLAT));
+    xlat = &pStateNow->xlat[pStateNow->num_xlat];
+/* parse str and derive first, last, values */
+    xlat->first = (u_int) atoi(strtok(str, "-"));
+    xlat->last = (u_int) atoi(strtok(NULL, ":"));
+    i = 0;
+    pval_tmp = calloc(MAX_VAL, sizeof(K_XLAT));
+    while ((sval = strtok(NULL, ",")) != NULL)
+	pval_tmp[i++] = (u_int) (atoi(sval));
+    xlat->pval = calloc(i, sizeof(K_XLAT));
+    if (xlat->pval != NULL)
+	memcpy(xlat->pval, pval_tmp, i * sizeof(u_int));
+    free(pval_tmp);
+    pStateNow->num_xlat++;
+}
+
+/*
+ * Ascii only for this implementation
+ */
+/* INTPROTO */
+void
+kstate_add_switcher(char *str)
+{
+    K_SWITCH       *switcher;
+
+    if (str == NULL)
+	return;
+    if (pStateNow->num_switcher >= MAX_SWITCHER)
+	return;
+    switcher = &pStateNow->switcher[pStateNow->num_switcher];
+    switch (switcher->type = str[0]) {
+    case 'A':			/* ascii eg: A;:2 */
+	switcher->code = str[1];
+	switcher->nextstate = atoi(&str[3]);
+	break;
+    }
+    switcher->on = 0;
+    pStateNow->num_switcher++;
+}
+
+/* L1 or L0 */
+/* INTPROTO */
+void
+kstate_set_life(char *str)
+{
+    pStateNow->life = atoi(&str[1]);
+}
+
+/* INTPROTO */
+unsigned int
+kstate_cxlat(unsigned int c)
+{
+    int             i;
+
+/* check for ascii switcher */
+    for (i = 0; i < pStateNow->num_switcher; i++)
+	if (pStateNow->switcher[i].type == 'A' &&	/* only ascii here */
+	    c == pStateNow->switcher[i].code) {
+	    kstate_setcurr(pStateNow->switcher[i].nextstate);
+	    pStateNow->switcher[i].on = 1;
+	    return ((unsigned int)-1);
+	}
+/* do translation */
+    for (i = 0; i < pStateNow->num_xlat; i++)
+	if (c >= pStateNow->xlat[i].first && c <= pStateNow->xlat[i].last) {
+	    c = pStateNow->xlat[i].pval[c - pStateNow->xlat[i].first];
+	    break;
+	}
+/* switch back to previous state if life of current is 1 */
+    if (pStateNow->life == 1)
+	kstate_setcurr(pStateNow->prev_state);
+    return (c);
+}
+
+#ifdef RXVT
+/* EXTPROTO */
+void
+greek_init(void)
+{
+    kstate_init_all(GreekMode);
+}
+
+/* EXTPROTO */
+void
+greek_end(void)
+{
+    kstate_end_all();
+}
+
+/* EXTPROTO */
+void
+greek_reset(void)
+{
+    kstate_reset();
+}
+
+/* EXTPROTO */
+void
+greek_setmode(int greek_mode)
+{
+    GreekMode = greek_mode;
+}
+
+/* EXTPROTO */
+int
+greek_getmode(void)
+{
+    return (GreekMode);
+}
+
+/*
+ * xlate a given string in-place - return new string length
+ */
+/* EXTPROTO */
+int
+greek_xlat(char *s, int num_chars)
+{
+    int             i, count;
+    unsigned int    c;
+
+    for (i = 0, count = 0; i < num_chars; i++) {
+	c = kstate_cxlat((unsigned int)s[i]);
+	if (c != -1)
+	    s[count++] = (char)c;
+    }
+    s[count] = '\0';
+    return (count);
+
+}
+
+#ifdef TEST
+int
+main(void)
+{
+/*char text[] = "abcdef;aGDZXC"; */
+    char            text[] = "abcdef;a:ibgdezhuiklmnjoprstyfxcv";
+
+    kstate_init_all(GREEK_ELOT928);
+    printf("text: %s\n", text);
+    greek_xlat(text, strlen(text));
+    printf("xlat'ed text: %s\n", text);
+    kstate_end_all();
+    return 0;
+}
+#endif
+#endif				/* RXVT */
+
+#endif				/* GREEK_SUPPORT */
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/grkelot.extpro work/main.d/rxvt-2.6.4/src/grkelot.extpro
--- tmp/rxvt-2.6.4/src/grkelot.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/grkelot.extpro	2001-11-01 21:28:28.000000000 -0300
@@ -0,0 +1,6 @@
+void             greek_init              __PROTO((void));
+void             greek_end               __PROTO((void));
+void             greek_reset             __PROTO((void));
+void             greek_setmode           __PROTO((int greek_mode));
+int              greek_getmode           __PROTO((void));
+int              greek_xlat              __PROTO((char *s, int num_chars));
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/grkelot.h work/main.d/rxvt-2.6.4/src/grkelot.h
--- tmp/rxvt-2.6.4/src/grkelot.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/grkelot.h	1998-11-12 01:37:05.000000000 -0300
@@ -0,0 +1,43 @@
+/*
+ * File:	grkelot.h
+ * $Id: grkelot.h,v 1.4 1998/11/12 04:37:05 mason Exp $
+ *
+ * Synopsis:	string -> greek ELOT928 string; 4-state FSM.
+ *
+ * Copyright (c) 1994 Angelo Haritsis. All rights reserved.
+ * Copyright (C) 1997,1998 Oezguer Kesim <kesim@math.fu-berlin.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _GRKELOT_H
+#define _GRKELOT_H
+
+#define GREEK_ELOT928	0
+#define GREEK_IBM437	1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+   extern void	greek_init (void);
+   extern void	greek_end (void);
+   extern void	greek_reset (void);
+   extern void  greek_setmode(int greek_mode);
+   extern int   greek_getmode(void);
+   extern int	greek_xlat (char *s, int num_chars);
+#ifdef __cplusplus
+}
+#endif
+#endif	/* _GRKELOT_H */
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/grkelot.intpro work/main.d/rxvt-2.6.4/src/grkelot.intpro
--- tmp/rxvt-2.6.4/src/grkelot.intpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/grkelot.intpro	2001-11-01 21:28:30.000000000 -0300
@@ -0,0 +1,10 @@
+void             kstate_setcurr          __PROTO((int stateno));
+void             kstate_init             __PROTO((void));
+void             kstate_end              __PROTO((void));
+void             kstate_init_all         __PROTO((int greek_mode));
+void             kstate_end_all          __PROTO((void));
+void             kstate_reset            __PROTO((void));
+void             kstate_add_xlat         __PROTO((char *str));
+void             kstate_add_switcher     __PROTO((char *str));
+void             kstate_set_life         __PROTO((char *str));
+unsigned int     kstate_cxlat            __PROTO((unsigned int c));
Binary files tmp/rxvt-2.6.4/src/grkelot.o and work/main.d/rxvt-2.6.4/src/grkelot.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/.indent.pro work/main.d/rxvt-2.6.4/src/.indent.pro
--- tmp/rxvt-2.6.4/src/.indent.pro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/.indent.pro	1998-04-20 04:31:12.000000000 -0300
@@ -0,0 +1,27 @@
+--dont-format-comments
+--procnames-start-lines
+--parameter-indentation4
+--indent-level4
+--line-comments-indentation4
+--cuddle-else
+--brace-indent0
+--start-left-side-of-comments
+--no-blank-lines-after-commas
+--blank-lines-after-declarations
+--blank-lines-after-procedures
+--comment-indentation33
+--declaration-comment-column33
+--no-comment-delimiters-on-blank-lines
+--continuation-indentation4
+--case-indentation0
+--else-endif-column33
+--no-space-after-casts
+--no-blank-before-sizeof
+--declaration-indentation16
+--continue-at-parentheses
+--no-space-after-function-call-names
+--swallow-optional-blank-lines
+--space-special-semicolon
+--tab-size8
+--line-length79
+--braces-on-if-line
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/logging.c work/main.d/rxvt-2.6.4/src/logging.c
--- tmp/rxvt-2.6.4/src/logging.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/logging.c	2000-06-04 03:57:17.000000000 -0300
@@ -0,0 +1,299 @@
+/*--------------------------------*-C-*---------------------------------*
+ * File:	logging.c
+ *----------------------------------------------------------------------*
+ * $Id: logging.c,v 1.7.2.2 2000/06/04 06:57:17 gcw Exp $
+ *
+ * All portions of code are copyright by their respective author/s.
+ * Copyright (C) 1992      John Bovey <jdb@ukc.ac.uk>
+ *				- original version
+ * Copyright (C) 1993      lipka
+ * Copyright (C) 1993      Brian Stempien <stempien@cs.wmich.edu>
+ * Copyright (C) 1995      Raul Garcia Garcia <rgg@tid.es>
+ * Copyright (C) 1995      Piet W. Plomp <piet@idefix.icce.rug.nl>
+ * Copyright (C) 1997      Raul Garcia Garcia <rgg@tid.es>
+ * Copyright (C) 1997,1998 Geoff Wing <gcw@pobox.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *----------------------------------------------------------------------*/
+/*----------------------------------------------------------------------*
+ * Public:
+ *	extern void cleanutent (void);
+ *	extern void makeutent (const char * pty, const char * hostname);
+ *
+ * Private:
+ *	write_utmp ();
+ *	update_wtmp ();
+ *----------------------------------------------------------------------*/
+
+#include "rxvt.h"		/* NECESSARY */
+#include "logging.h"
+
+
+/*
+ * HAVE_SETUTENT corresponds to SYSV-style utmp support.
+ * Without it corresponds to using BSD utmp support.
+ * SYSV-style utmp support is further divided in normal utmp support
+ * and utmpx support (Solaris 2.x) by RXVT_UTMP_AS_UTMPX
+ */
+
+/*
+ * update wtmp entries - only for SYSV style UTMP systems
+ */
+#ifdef UTMP_SUPPORT
+static char     ut_id[5];	/* remember if entry to utmp made */
+# ifndef USE_SYSV_UTMP
+static int      utmp_pos;	/* BSD position of utmp-stamp */
+# endif
+#endif
+
+/* ------------------------------------------------------------------------- */
+#ifndef RXVT_UTMP_AS_UTMPX	/* supposedly we have updwtmpx ? */
+#ifdef WTMP_SUPPORT
+/* INTPROTO */
+void
+rxvt_update_wtmp(const char *fname, const struct utmp *putmp)
+{
+    int             fd, retry = 10;	/* 10 attempts at locking */
+    struct flock    lck;	/* fcntl locking scheme */
+
+    if ((fd = open(fname, O_WRONLY | O_APPEND, 0)) < 0)
+	return;
+
+    lck.l_whence = SEEK_END;	/* start lock at current eof */
+    lck.l_len = 0;		/* end at ``largest possible eof'' */
+    lck.l_start = 0;
+    lck.l_type = F_WRLCK;	/* we want a write lock */
+
+    while (retry--)
+    /* attempt lock with F_SETLK - F_SETLKW would cause a deadlock! */
+	if ((fcntl(fd, F_SETLK, &lck) < 0) && errno != EACCESS) {
+	    close(fd);
+	    return;		/* failed for unknown reason: give up */
+	}
+    write(fd, putmp, sizeof(struct utmp));
+
+/* unlocking the file */
+    lck.l_type = F_UNLCK;
+    fcntl(fd, F_SETLK, &lck);
+
+    close(fd);
+}
+#endif				/* WTMP_SUPPORT */
+#endif				/* !HAVE_UTMPX_H */
+/* ------------------------------------------------------------------------- */
+#ifdef UTMP_SUPPORT
+/*
+ * make a utmp entry
+ */
+/* EXTPROTO */
+void
+makeutent(const char *pty, const char *hostname)
+{
+    struct passwd  *pwent = getpwuid(getuid());
+    UTMP	    ut;
+
+#ifndef USE_SYSV_UTMP
+/*
+ * BSD style utmp entry
+ *      ut_line, ut_name, ut_host, ut_time
+ */
+    int             i;
+    FILE           *fd0, *fd1;
+    char            buf[256], name[256];
+
+#else
+/*
+ * SYSV style utmp entry
+ *      ut_user, ut_id, ut_line, ut_pid, ut_type, ut_exit, ut_time
+ */
+    char           *colon;
+
+#endif				/* !USE_SYSV_UTMP */
+
+/* BSD naming is of the form /dev/tty?? or /dev/pty?? */
+
+    MEMSET(&ut, 0, sizeof(UTMP));
+    if (!strncmp(pty, "/dev/", 5))
+	pty += 5;		/* skip /dev/ prefix */
+    if (!strncmp(pty, "pty", 3) || !strncmp(pty, "tty", 3))
+	STRNCPY(ut_id, (pty + 3), sizeof(ut_id));
+    else
+#ifndef USE_SYSV_UTMP
+    {
+	print_error("can't parse tty name \"%s\"", pty);
+	ut_id[0] = '\0';	/* entry not made */
+	return;
+    }
+
+    STRNCPY(ut.ut_line, pty, sizeof(ut.ut_line));
+    STRNCPY(ut.ut_name, (pwent && pwent->pw_name) ? pwent->pw_name : "?",
+	    sizeof(ut.ut_name));
+    STRNCPY(ut.ut_host, hostname, sizeof(ut.ut_host));
+    ut.ut_time = time(NULL);
+
+    if ((fd0 = fopen(RXVT_REAL_UTMP_FILE, "r+")) == NULL)
+	ut_id[0] = '\0';	/* entry not made */
+    else {
+	utmp_pos = -1;
+	if ((fd1 = fopen(TTYTAB_FILENAME, "r")) != NULL) {
+	    for (i = 1; (fgets(buf, sizeof(buf), fd1) != NULL); ) {
+		if (*buf == '#' || sscanf(buf, "%s", name) != 1)
+		    continue;
+		if (!strcmp(ut.ut_line, name)) {
+		    fclose(fd1);
+		    utmp_pos = i * sizeof(struct utmp);
+		    break;
+		}
+		i++;
+	    }
+	    fclose(fd1);
+	}
+	if (utmp_pos < 0)
+	    ut_id[0] = '\0';	/* entry not made */
+	else {
+	    fseek(fd0, utmp_pos, 0);
+	    fwrite(&ut, sizeof(UTMP), 1, fd0);
+	}
+	fclose(fd0);
+    }
+
+#else				/* USE_SYSV_UTMP */
+    {
+	int             n;
+
+	if (sscanf(pty, "pts/%d", &n) == 1)
+	    sprintf(ut_id, "vt%02x", (n % 256));	/* sysv naming */
+	else {
+	    print_error("can't parse tty name \"%s\"", pty);
+	    ut_id[0] = '\0';	/* entry not made */
+	    return;
+	}
+    }
+
+#if 0
+    /* XXX: most likely unnecessary.  could be harmful */
+    utmpname(RXVT_REAL_UTMP_FILE);
+#endif
+
+    setutent();			/* XXX: should be unnecessaray */
+
+    STRNCPY(ut.ut_id, ut_id, sizeof(ut.ut_id));
+    ut.ut_type = DEAD_PROCESS;
+    (void)getutid(&ut);		/* position to entry in utmp file */
+
+/* set up the new entry */
+    ut.ut_type = USER_PROCESS;
+#ifndef linux
+    ut.ut_exit.e_exit = 2;
+#endif
+    STRNCPY(ut.ut_user, (pwent && pwent->pw_name) ? pwent->pw_name : "?",
+	    sizeof(ut.ut_user));
+    STRNCPY(ut.ut_id, ut_id, sizeof(ut.ut_id));
+    STRNCPY(ut.ut_line, pty, sizeof(ut.ut_line));
+
+#if (defined(HAVE_UTMP_HOST) && ! defined(RXVT_UTMP_AS_UTMPX)) || (defined(HAVE_UTMPX_HOST) && defined(RXVT_UTMP_AS_UTMPX))
+    STRNCPY(ut.ut_host, hostname, sizeof(ut.ut_host));
+# ifndef linux
+    if ((colon = strrchr(ut.ut_host, ':')) != NULL)
+	*colon = '\0';
+# endif
+#endif
+
+/* ut_name is normally the same as ut_user, but .... */
+    STRNCPY(ut.ut_name, (pwent && pwent->pw_name) ? pwent->pw_name : "?",
+	    sizeof(ut.ut_name));
+
+    ut.ut_pid = getpid();
+
+#ifdef RXVT_UTMP_AS_UTMPX
+    ut.ut_session = getsid(0);
+    ut.ut_tv.tv_sec = time(NULL);
+    ut.ut_tv.tv_usec = 0;
+#else
+    ut.ut_time = time(NULL);
+#endif				/* HAVE_UTMPX_H */
+
+    pututline(&ut);
+
+#ifdef WTMP_SUPPORT
+    update_wtmp(RXVT_REAL_WTMP_FILE, &ut);
+#endif
+
+    endutent();			/* close the file */
+#endif				/* !USE_SYSV_UTMP */
+}
+#endif				/* UTMP_SUPPORT */
+
+/* ------------------------------------------------------------------------- */
+#ifdef UTMP_SUPPORT
+/*
+ * remove a utmp entry
+ */
+/* EXTPROTO */
+void
+cleanutent(void)
+{
+    UTMP            ut;
+
+#ifndef USE_SYSV_UTMP
+    FILE           *fd;
+
+    if (ut_id[0] && ((fd = fopen(RXVT_REAL_UTMP_FILE, "r+")) != NULL)) {
+	MEMSET(&ut, 0, sizeof(struct utmp));
+
+	fseek(fd, utmp_pos, 0);
+	fwrite(&ut, sizeof(struct utmp), 1, fd);
+
+	fclose(fd);
+    }
+#else				/* USE_SYSV_UTMP */
+    UTMP	   *putmp;
+
+    if (!ut_id[0])
+	return;			/* entry not made */
+
+#if 0
+    /* XXX: most likely unnecessary.  could be harmful */
+    utmpname(RXVT_REAL_UTMP_FILE);
+#endif
+    MEMSET(&ut, 0, sizeof(UTMP));
+    STRNCPY(ut.ut_id, ut_id, sizeof(ut.ut_id));
+    ut.ut_type = USER_PROCESS;
+
+    setutent();			/* XXX: should be unnecessaray */
+
+    putmp = getutid(&ut);
+    if (!putmp || putmp->ut_pid != getpid())
+	return;
+
+    putmp->ut_type = DEAD_PROCESS;
+
+#ifdef RXVT_UTMP_AS_UTMPX
+    putmp->ut_session = getsid(0);
+    putmp->ut_tv.tv_sec = time(NULL);
+    putmp->ut_tv.tv_usec = 0;
+#else				/* HAVE_UTMPX_H */
+    putmp->ut_time = time(NULL);
+#endif				/* HAVE_UTMPX_H */
+    pututline(putmp);
+
+#ifdef WTMP_SUPPORT
+    update_wtmp(RXVT_REAL_WTMP_FILE, putmp);
+#endif
+
+    endutent();
+#endif				/* !USE_SYSV_UTMP */
+}
+#endif
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/logging.extpro work/main.d/rxvt-2.6.4/src/logging.extpro
--- tmp/rxvt-2.6.4/src/logging.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/logging.extpro	2001-11-01 21:28:28.000000000 -0300
@@ -0,0 +1,2 @@
+void             makeutent               __PROTO((const char *pty, const char *hostname));
+void             cleanutent              __PROTO((void));
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/logging.h work/main.d/rxvt-2.6.4/src/logging.h
--- tmp/rxvt-2.6.4/src/logging.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/logging.h	1998-11-19 22:12:39.000000000 -0300
@@ -0,0 +1,80 @@
+#ifdef UTMP_SUPPORT
+# if ! defined(HAVE_STRUCT_UTMPX) && ! defined(HAVE_STRUCT_UTMP)
+#  error cannot build with utmp support - no utmp or utmpx struct found
+# endif
+
+# if defined(RXVT_UTMPX_FILE) && defined(HAVE_STRUCT_UTMPX)
+#   define RXVT_UTMP_AS_UTMPX
+# else
+#  if defined(RXVT_UTMP_FILE) && defined(HAVE_STRUCT_UTMP)
+#   undef RXVT_UTMP_AS_UTMPX
+#  endif
+# endif
+/* if you have both utmp and utmpx files lying around and are really
+ * using utmp not utmpx, then uncomment the following line */
+/* #undef RXVT_UTMP_AS_UTMPX */
+
+# ifdef RXVT_UTMP_AS_UTMPX
+#  define RXVT_REAL_UTMP_FILE	RXVT_UTMPX_FILE
+# else
+#  define RXVT_REAL_UTMP_FILE	RXVT_UTMP_FILE
+# endif
+
+# ifdef RXVT_UTMP_AS_UTMPX
+#  define USE_SYSV_UTMP
+#  include <utmpx.h>
+# else
+#  include <utmp.h>
+#  ifdef HAVE_SETUTENT
+#   define USE_SYSV_UTMP
+#  else
+#   undef USE_SYSV_UTMP
+#  endif
+# endif
+
+# ifdef HAVE_LASTLOG_H
+#  include <lastlog.h>
+# endif
+# include <pwd.h>
+
+# undef UTMP
+# ifdef USE_SYSV_UTMP
+#  ifndef USER_PROCESS
+#   define USER_PROCESS		7
+#  endif
+#  ifndef DEAD_PROCESS
+#   define DEAD_PROCESS		8
+#  endif
+#  ifdef RXVT_UTMP_AS_UTMPX
+#   define UTMP			struct utmpx
+#   define setutent		setutxent
+#   define getutent		getutxent
+#   define getutid		getutxid
+#   define endutent		endutxent
+#   define pututline		pututxline
+#  endif
+# endif
+# ifndef UTMP
+#  define UTMP			struct utmp
+# endif
+
+# ifdef WTMP_SUPPORT
+#  ifdef RXVT_UTMP_AS_UTMPX
+#   define update_wtmp		updwtmpx
+#   ifdef RXVT_WTMPX_FILE
+#    define RXVT_REAL_WTMP_FILE	RXVT_WTMPX_FILE
+#   else
+#    error cannot build with wtmp support - no wtmpx file found
+#   endif
+#  else
+#   define update_wtmp		rxvt_update_wtmp
+#   ifdef RXVT_WTMP_FILE
+#    define RXVT_REAL_WTMP_FILE	RXVT_WTMP_FILE
+#   else
+#    error cannot build with wtmp support - no wtmp file found
+#   endif
+#  endif
+# endif
+
+#include "logging.intpro"		/* PROTOS for internal routines */
+#endif
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/logging.intpro work/main.d/rxvt-2.6.4/src/logging.intpro
--- tmp/rxvt-2.6.4/src/logging.intpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/logging.intpro	2001-11-01 21:28:30.000000000 -0300
@@ -0,0 +1 @@
+void             rxvt_update_wtmp        __PROTO((const char *fname, const struct utmp *putmp));
Binary files tmp/rxvt-2.6.4/src/logging.o and work/main.d/rxvt-2.6.4/src/logging.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/main.c work/main.d/rxvt-2.6.4/src/main.c
--- tmp/rxvt-2.6.4/src/main.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/main.c	2000-10-28 02:44:28.000000000 -0300
@@ -0,0 +1,1417 @@
+/*--------------------------------*-C-*---------------------------------*
+ * File:	main.c
+ *----------------------------------------------------------------------*
+ * $Id: main.c,v 1.66.2.12 2000/10/28 05:44:28 gcw Exp $
+ *
+ * All portions of code are copyright by their respective author/s.
+ * Copyright (C) 1992      John Bovey, University of Canterbury
+ *				- original version
+ * Copyright (C) 1994      Robert Nation <nation@rocket.sanders.lockheed.com>
+ *				- extensive modifications
+ * Copyright (C) 1995      Garrett D'Amore <garrett@netcom.com>
+ * Copyright (C) 1997      mj olesen <olesen@me.QueensU.CA>
+ *				- extensive modifications
+ * Copyright (C) 1997,1998 Oezguer Kesim <kesim@math.fu-berlin.de>
+ * Copyright (C) 1998      Geoff Wing <gcw@pobox.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *---------------------------------------------------------------------*/
+
+#define INTERN			/* assign all global vars to me */
+#include "rxvt.h"		/* NECESSARY */
+#include "main.intpro"		/* PROTOS for internal routines */
+
+#include <X11/Xatom.h>
+
+static Cursor   TermWin_cursor;	/* cursor for vt window */
+
+static const char * const def_colorName[] =
+{
+    COLOR_FOREGROUND,
+    COLOR_BACKGROUND,
+/* low-intensity colors */
+    "Black",			/* 0: black             (#000000) */
+#ifndef NO_BRIGHTCOLOR
+    "Red3",			/* 1: red               (#CD0000) */
+    "Green3",			/* 2: green             (#00CD00) */
+    "Yellow3",			/* 3: yellow            (#CDCD00) */
+    "Blue3",			/* 4: blue              (#0000CD) */
+    "Magenta3",			/* 5: magenta           (#CD00CD) */
+    "Cyan3",			/* 6: cyan              (#00CDCD) */
+    "AntiqueWhite",		/* 7: white             (#FAEBD7) */
+/* high-intensity colors */
+    "Grey25",			/* 8: bright black      (#404040) */
+#endif				/* NO_BRIGHTCOLOR */
+    "Red",			/* 1/9: bright red      (#FF0000) */
+    "Green",			/* 2/10: bright green   (#00FF00) */
+    "Yellow",			/* 3/11: bright yellow  (#FFFF00) */
+    "Blue",			/* 4/12: bright blue    (#0000FF) */
+    "Magenta",			/* 5/13: bright magenta (#FF00FF) */
+    "Cyan",			/* 6/14: bright cyan    (#00FFFF) */
+    "White",			/* 7/15: bright white   (#FFFFFF) */
+#ifndef NO_CURSORCOLOR
+    COLOR_CURSOR_BACKGROUND,
+    COLOR_CURSOR_FOREGROUND,
+#endif				/* ! NO_CURSORCOLOR */
+    NULL,			/* Color_pointer                  */
+    NULL			/* Color_border                   */
+#ifndef NO_BOLDUNDERLINE
+  , NULL,			/* Color_BD                       */
+    NULL			/* Color_UL                       */
+#endif				/* ! NO_BOLDUNDERLINE */
+#ifdef KEEP_SCROLLCOLOR
+  , COLOR_SCROLLBAR,
+    COLOR_SCROLLTROUGH
+#endif				/* KEEP_SCROLLCOLOR */
+};
+
+#ifdef MULTICHAR_SET
+/* Multicharacter font names, roman fonts sized to match */
+static const char * const def_mfontName[] =
+{
+    MFONT_LIST
+};
+#endif				/* MULTICHAR_SET */
+
+static const char * const def_fontName[] =
+{
+    NFONT_LIST
+};
+
+/*----------------------------------------------------------------------*/
+/* ARGSUSED */
+/* INTPROTO */
+XErrorHandler
+xerror_handler(const Display *display, const XErrorEvent *event)
+{
+    print_error("XError: Request: %d . %d, Error: %d", event->request_code,
+		event->minor_code, event->error_code);
+    exit(EXIT_FAILURE);
+    /* NOTREACHED */
+}
+
+/* color aliases, fg/bg bright-bold */
+/* INTPROTO */
+void
+color_aliases(int idx)
+{
+    if (rs[Rs_color + idx] && isdigit(*(rs[Rs_color + idx]))) {
+	int             i = atoi(rs[Rs_color + idx]);
+
+	if (i >= 8 && i <= 15) {	/* bright colors */
+	    i -= 8;
+#ifndef NO_BRIGHTCOLOR
+	    rs[Rs_color + idx] = rs[Rs_color + minBrightCOLOR + i];
+	    return;
+#endif
+	}
+	if (i >= 0 && i <= 7)	/* normal colors */
+	    rs[Rs_color + idx] = rs[Rs_color + minCOLOR + i];
+    }
+}
+
+/*
+ * find if fg/bg matches any of the normal (low-intensity) colors
+ */
+/* INTPROTO */
+void
+set_colorfgbg(void)
+{
+    unsigned int    i;
+    char           *p;
+    int             fg = -1, bg = -1;
+    static char     env_colorfgbg[] = "COLORFGBG=default;default;bg";
+
+    for (i = Color_Black; i <= Color_White; i++) {
+	if (PixColors[Color_fg] == PixColors[i]) {
+	    fg = (i - Color_Black);
+	    break;
+	}
+    }
+    for (i = Color_Black; i <= Color_White; i++) {
+	if (PixColors[Color_bg] == PixColors[i]) {
+	    bg = (i - Color_Black);
+	    break;
+	}
+    }
+
+    p = strchr(env_colorfgbg, '=');
+    p++;
+    if (fg >= 0)
+	sprintf(p, "%d;", fg);
+    else
+	STRCPY(p, "default;");
+    p = strchr(p, '\0');
+    if (bg >= 0)
+	sprintf(p,
+#ifdef XPM_BACKGROUND
+		"default;"
+#endif
+		"%d", bg);
+    else
+	STRCPY(p, "default");
+    putenv(env_colorfgbg);
+
+#ifndef NO_BRIGHTCOLOR
+    colorfgbg = DEFAULT_RSTYLE;
+    for (i = minCOLOR; i <= maxCOLOR; i++) {
+	if (PixColors[Color_fg] == PixColors[i]
+# ifndef NO_BOLDUNDERLINE
+	    && PixColors[Color_fg] == PixColors[Color_BD]
+# endif				/* NO_BOLDUNDERLINE */
+    /* if we wanted boldFont to have precedence */
+# if 0				/* ifndef NO_BOLDFONT */
+	    && TermWin.boldFont == NULL
+# endif				/* NO_BOLDFONT */
+	    )
+	    colorfgbg = SET_FGCOLOR(colorfgbg, i);
+	if (PixColors[Color_bg] == PixColors[i])
+	    colorfgbg = SET_BGCOLOR(colorfgbg, i);
+    }
+#endif
+}
+
+/* INTPROTO */
+void
+Get_Colours(void)
+{
+    int             i;
+
+    for (i = 0; i < (Xdepth <= 2 ? 2 : NRS_COLORS); i++) {
+	const char     *msg = "can't load color \"%s\"";
+	XColor          xcol;
+
+	if (!rs[Rs_color + i])
+	    continue;
+
+	if (!XParseColor(Xdisplay, Xcmap, rs[Rs_color + i], &xcol)
+	    || !XAllocColor(Xdisplay, Xcmap, &xcol)) {
+	    print_error(msg, rs[Rs_color + i]);
+#ifndef XTERM_REVERSE_VIDEO
+	    if (i < 2 && (Options & Opt_reverseVideo)) {
+		rs[Rs_color + i] = def_colorName[!i];
+	    } else
+#endif
+	        rs[Rs_color + i] = def_colorName[i];
+	    if (!rs[Rs_color + i])
+		continue;
+	    if (!XParseColor(Xdisplay, Xcmap, rs[Rs_color + i], &xcol)
+		|| !XAllocColor(Xdisplay, Xcmap, &xcol)) {
+		print_error(msg, rs[Rs_color + i]);
+		switch (i) {
+		case Color_fg:
+		case Color_bg:
+		/* fatal: need bg/fg color */
+		    print_error("aborting");
+		    exit(EXIT_FAILURE);
+		    /* NOTREACHED */
+		    break;
+#ifndef NO_CURSORCOLOR
+		case Color_cursor2:
+		    xcol.pixel = PixColors[Color_fg];
+		    break;
+#endif				/* ! NO_CURSORCOLOR */
+		case Color_pointer:
+		    xcol.pixel = PixColors[Color_fg];
+		    break;
+		default:
+		    xcol.pixel = PixColors[Color_bg];	/* None */
+		    break;
+		}
+	    }
+	}
+	PixColors[i] = xcol.pixel;
+    }
+
+    if (Xdepth <= 2 || !rs[Rs_color + Color_pointer])
+	PixColors[Color_pointer] = PixColors[Color_fg];
+    if (Xdepth <= 2 || !rs[Rs_color + Color_border])
+	PixColors[Color_border] = PixColors[Color_fg];
+
+/*
+ * get scrollBar/menuBar shadow colors
+ *
+ * The calculations of topShadow/bottomShadow values are adapted
+ * from the fvwm window manager.
+ */
+#ifdef KEEP_SCROLLCOLOR
+    if (Xdepth <= 2) {		/* Monochrome */
+	PixColors[Color_scroll] = PixColors[Color_fg];
+	PixColors[Color_topShadow] = PixColors[Color_bg];
+	PixColors[Color_bottomShadow] = PixColors[Color_bg];
+    } else {
+	XColor          xcol, white;
+
+    /* bottomShadowColor */
+	xcol.pixel = PixColors[Color_scroll];
+	XQueryColor(Xdisplay, Xcmap, &xcol);
+
+	xcol.red = ((xcol.red) / 2);
+	xcol.green = ((xcol.green) / 2);
+	xcol.blue = ((xcol.blue) / 2);
+
+	if (!XAllocColor(Xdisplay, Xcmap, &xcol)) {
+	    print_error("can't allocate %s", "Color_bottomShadow");
+	    xcol.pixel = PixColors[minCOLOR];
+	}
+	PixColors[Color_bottomShadow] = xcol.pixel;
+
+    /* topShadowColor */
+# ifdef PREFER_24BIT
+	white.red = white.green = white.blue = (unsigned short) ~0;
+	XAllocColor(Xdisplay, Xcmap, &white);
+/*        XFreeColors(Xdisplay, Xcmap, &white.pixel, 1, ~0); */
+# else
+	white.pixel = WhitePixel(Xdisplay, Xscreen);
+	XQueryColor(Xdisplay, Xcmap, &white);
+# endif
+
+	xcol.pixel = PixColors[Color_scroll];
+	XQueryColor(Xdisplay, Xcmap, &xcol);
+
+	xcol.red = max((white.red / 5), xcol.red);
+	xcol.green = max((white.green / 5), xcol.green);
+	xcol.blue = max((white.blue / 5), xcol.blue);
+
+	xcol.red = min(white.red, (xcol.red * 7) / 5);
+	xcol.green = min(white.green, (xcol.green * 7) / 5);
+	xcol.blue = min(white.blue, (xcol.blue * 7) / 5);
+
+	if (!XAllocColor(Xdisplay, Xcmap, &xcol)) {
+	    print_error("can't allocate %s", "Color_topShadow");
+	    xcol.pixel = PixColors[Color_White];
+	}
+	PixColors[Color_topShadow] = xcol.pixel;
+    }
+#endif				/* KEEP_SCROLLCOLOR */
+
+
+}
+
+/* Create_Windows() - Open and map the window */
+/* INTPROTO */
+void
+Create_Windows(int argc, const char * const *argv)
+{
+    Cursor          cursor;
+    XClassHint      classHint;
+    XWMHints        wmHint;
+#ifdef PREFER_24BIT
+    XSetWindowAttributes attributes;
+
+    Xdepth = DefaultDepth(Xdisplay, Xscreen);
+    Xcmap = DefaultColormap(Xdisplay, Xscreen);
+    Xvisual = DefaultVisual(Xdisplay, Xscreen);
+/*
+ * If depth is not 24, look for a 24bit visual.
+ */
+    if (Xdepth != 24) {
+	XVisualInfo     vinfo;
+
+	if (XMatchVisualInfo(Xdisplay, Xscreen, 24, TrueColor, &vinfo)) {
+	    Xdepth = 24;
+	    Xvisual = vinfo.visual;
+	    Xcmap = XCreateColormap(Xdisplay, RootWindow(Xdisplay, Xscreen),
+				    Xvisual, AllocNone);
+	}
+    }
+#endif
+
+/* grab colors before netscape does */
+    Get_Colours();
+
+    change_font(1, NULL);
+    szhints_set();
+
+/* parent window - reverse video so we can see placement errors
+ * sub-window placement & size in resize_subwindows()
+ */
+
+#ifdef PREFER_24BIT
+    attributes.background_pixel = PixColors[Color_fg];
+    attributes.border_pixel = PixColors[Color_border];
+    attributes.colormap = Xcmap;
+    TermWin.parent[0] = XCreateWindow(Xdisplay, Xroot,
+				   szHint.x, szHint.y,
+				   szHint.width, szHint.height,
+				   BORDERWIDTH,
+				   Xdepth, InputOutput,
+				   Xvisual,
+				   CWBackPixel | CWBorderPixel | CWColormap,
+				   &attributes);
+#else
+    TermWin.parent[0] = XCreateSimpleWindow(Xdisplay, Xroot,
+					 szHint.x, szHint.y,
+					 szHint.width, szHint.height,
+					 BORDERWIDTH,
+					 PixColors[Color_border],
+					 PixColors[Color_fg]);
+#endif
+    xterm_seq(XTerm_title, rs[Rs_title]);
+    xterm_seq(XTerm_iconName, rs[Rs_iconName]);
+/* ignore warning about discarded `const' */
+    classHint.res_name = (char *) rs[Rs_name];
+    classHint.res_class = (char *) APL_CLASS;
+    wmHint.input = True;
+    wmHint.initial_state = (Options & Opt_iconic ? IconicState : NormalState);
+    wmHint.window_group = TermWin.parent[0];
+    wmHint.flags = (InputHint | StateHint | WindowGroupHint);
+
+    XSetWMProperties(Xdisplay, TermWin.parent[0], NULL, NULL, (char **) argv,
+		     argc, &szHint, &wmHint, &classHint);
+
+    XSelectInput(Xdisplay, TermWin.parent[0],
+		 (KeyPressMask | FocusChangeMask
+		  | VisibilityChangeMask
+		  | StructureNotifyMask));
+
+/* vt cursor: Black-on-White is standard, but this is more popular */
+    TermWin_cursor = XCreateFontCursor(Xdisplay, XC_xterm);
+    {
+	XColor          fg, bg;
+
+	fg.pixel = PixColors[Color_pointer];
+	XQueryColor(Xdisplay, Xcmap, &fg);
+	bg.pixel = PixColors[Color_bg];
+	XQueryColor(Xdisplay, Xcmap, &bg);
+	XRecolorCursor(Xdisplay, TermWin_cursor, &fg, &bg);
+    }
+
+/* cursor (menuBar/scrollBar): Black-on-White */
+    cursor = XCreateFontCursor(Xdisplay, XC_left_ptr);
+
+/* the vt window */
+    TermWin.vt = XCreateSimpleWindow(Xdisplay, TermWin.parent[0],
+				     0, 0,
+				     szHint.width, szHint.height,
+				     0,
+				     PixColors[Color_fg],
+				     PixColors[Color_bg]);
+
+    XDefineCursor(Xdisplay, TermWin.vt, TermWin_cursor);
+    XSelectInput(Xdisplay, TermWin.vt,
+		 (ExposureMask | ButtonPressMask | ButtonReleaseMask |
+		  Button1MotionMask | Button3MotionMask));
+
+/* scrollBar: size doesn't matter */
+    scrollBar.win = XCreateSimpleWindow(Xdisplay, TermWin.parent[0],
+					0, 0,
+					1, 1,
+					0,
+					PixColors[Color_fg],
+					PixColors[Color_bg]);
+
+    XDefineCursor(Xdisplay, scrollBar.win, cursor);
+    XSelectInput(Xdisplay, scrollBar.win,
+		 (ExposureMask | ButtonPressMask | ButtonReleaseMask |
+		  Button1MotionMask | Button2MotionMask | Button3MotionMask));
+
+    { /* ONLYIF MENUBAR */
+	create_menuBar(cursor);
+    }
+
+#ifdef XPM_BACKGROUND
+    if (rs[Rs_backgroundPixmap] != NULL && !(Options & Opt_transparent)) {
+	const char     *p = rs[Rs_backgroundPixmap];
+
+	if ((p = strchr(p, ';')) != NULL) {
+	    p++;
+	    scale_pixmap(p);
+	}
+	set_bgPixmap(rs[Rs_backgroundPixmap]);
+	scr_touch();
+    }
+# ifdef XPM_BUFFERING
+    else {
+	set_bgPixmap("");
+	scr_touch();
+    }
+# endif
+#endif
+
+/* graphics context for the vt window */
+    {
+	XGCValues       gcvalue;
+
+	gcvalue.font = TermWin.font->fid;
+	gcvalue.foreground = PixColors[Color_fg];
+	gcvalue.background = PixColors[Color_bg];
+	gcvalue.graphics_exposures = 0;
+	TermWin.gc = XCreateGC(Xdisplay, TermWin.vt,
+			       GCForeground | GCBackground |
+			       GCFont | GCGraphicsExposures,
+			       &gcvalue);
+    }
+}
+/* window resizing - assuming the parent window is the correct size */
+/* INTPROTO */
+void
+resize_subwindows(int width, int height)
+{
+    int             x = 0, y = 0;
+    int             old_width = TermWin.width, old_height = TermWin.height;
+
+    TermWin.width = TermWin.ncol * TermWin.fwidth;
+    TermWin.height = TermWin.nrow * TermWin.fheight;
+
+    szHint.width = width;
+    szHint.height = height;
+
+/* size and placement */
+    if (scrollbar_visible()) {
+	scrollBar.beg = 0;
+	scrollBar.end = height;
+#ifndef XTERM_SCROLLBAR
+    /* arrows are as high as wide - leave 1 pixel gap */
+# ifdef NEXT_SCROLLBAR
+	scrollBar.end -= SB_BUTTON_TOTAL_HEIGHT + SB_PADDING;
+# else
+	scrollBar.beg += (SB_WIDTH + 1) + sb_shadow;
+	scrollBar.end -= (SB_WIDTH + 1) + sb_shadow;
+# endif
+#endif
+	x = (SB_WIDTH + 2 * sb_shadow);	/* placement of vt window */
+	width -= x;
+	if ((Options & Opt_scrollBar_right) == 0)
+	    XMoveResizeWindow(Xdisplay, scrollBar.win, 0, 0,
+			      x, height);
+	else {
+	    XMoveResizeWindow(Xdisplay, scrollBar.win, width, 0,
+			      x, height);
+	    x = 0;		/* scrollbar on right so vt window at left */
+	}
+    }
+    { /* ONLYIF MENUBAR */
+	if (menubar_visible()) {
+	    y = menuBar_TotalHeight();	/* for placement of vt window */
+	    Resize_menuBar(x, 0, width, y);
+	}
+    }
+    XMoveResizeWindow(Xdisplay, TermWin.vt, x, y, width, height + 1);
+
+    if (old_width)
+	Gr_Resize(old_width, old_height);
+
+    scr_clear();
+    resize_pixmap();
+    XSync(Xdisplay, False);
+}
+
+/* EXTPROTO */
+void
+resize_all_windows(void)
+{
+    szhints_recalc();
+    XSetWMNormalHints(Xdisplay, TermWin.parent[0], &szHint);
+    AddToCNQueue(szHint.width, szHint.height);
+    XResizeWindow(Xdisplay, TermWin.parent[0], szHint.width, szHint.height);
+    resize_window(szHint.width, szHint.height);
+}
+
+/*
+ * Redraw window after exposure or size change
+ * width/height are those of the parent
+ */
+/* EXTPROTO */
+void
+resize_window(unsigned int width, unsigned int height)
+{
+    int             new_ncol, new_nrow;
+    static int      old_width, old_height = -1;
+
+    new_ncol = (width - szHint.base_width) / TermWin.fwidth;
+    new_nrow = (height - szHint.base_height) / TermWin.fheight;
+    if (new_ncol > MAX_COLS) {
+	new_ncol = MAX_COLS;
+	width = (MAX_COLS * TermWin.fwidth) + szHint.base_width;
+    }
+    if (new_nrow > MAX_ROWS) {
+	new_nrow = MAX_ROWS;
+	height = (MAX_ROWS * TermWin.fheight) + szHint.base_height;
+    }
+    if (old_height == -1
+	|| (new_ncol != TermWin.ncol)
+	|| (new_nrow != TermWin.nrow)) {
+	int             curr_screen = -1;
+
+    /* scr_reset only works on the primary screen */
+	if (old_height != -1) {	/* this is not the first time thru */
+	    selection_clear();
+	    curr_screen = scr_change_screen(PRIMARY);
+	}
+	TermWin.ncol = new_ncol;
+	TermWin.nrow = new_nrow;
+
+	resize_subwindows(width, height);
+	scr_reset();
+
+	if (curr_screen >= 0)	/* this is not the first time thru */
+	    scr_change_screen(curr_screen);
+    } else if (width != old_width || height != old_height)
+	resize_subwindows(width, height);
+    old_width = width;
+    old_height = height;
+}
+
+/*
+ * Set the width/height of the window in characters.  Units are pixels.
+ * good for toggling 80/132 columns
+ */
+/* EXTPROTO */
+void
+set_widthheight(unsigned int width, unsigned int height)
+{
+    XWindowAttributes wattr;
+
+    MIN_IT(width, (MAX_COLS * TermWin.fwidth));
+    MIN_IT(height, (MAX_ROWS * TermWin.fheight));
+    if (width == 0 || height == 0) {
+	XGetWindowAttributes(Xdisplay, Xroot, &wattr);
+	if (width == 0)
+	    width = wattr.width	- szHint.base_width;
+	if (height == 0)
+	    height = wattr.height - szHint.base_height;
+    }
+
+    if (width != TermWin.width || height != TermWin.height) {
+	width = szHint.base_width + width;
+	height = szHint.base_height + height;
+
+	AddToCNQueue(width, height);
+	XResizeWindow(Xdisplay, TermWin.parent[0], width, height);
+	resize_window(width, height);
+#ifdef USE_XIM
+	IMSetStatusPosition();
+#endif
+    }
+}
+
+/* INTPROTO */
+void
+szhints_set(void)
+{
+    int             x, y, flags;
+    unsigned int    width, height;
+
+    szHint.flags = PMinSize | PResizeInc | PBaseSize | PWinGravity;
+    szHint.win_gravity = NorthWestGravity;
+    szHint.min_aspect.x = szHint.min_aspect.y = 1;
+
+    flags = (rs[Rs_geometry] ?
+	     XParseGeometry(rs[Rs_geometry], &x, &y, &width, &height) : 0);
+
+    if (flags & WidthValue) {
+	TermWin.ncol = min(width, MAX_COLS);
+	szHint.flags |= USSize;
+    }
+    if (flags & HeightValue) {
+	TermWin.nrow = min(height, MAX_ROWS);
+	szHint.flags |= USSize;
+    }
+    TermWin.width = TermWin.ncol * TermWin.fwidth;
+    TermWin.height = TermWin.nrow * TermWin.fheight;
+    szhints_recalc();
+
+    if (flags & XValue) {
+	if (flags & XNegative) {
+	    x += (DisplayWidth(Xdisplay, Xscreen)
+		  - (szHint.width + TermWin_internalBorder));
+	    szHint.win_gravity = NorthEastGravity;
+	}
+	szHint.x = x;
+	szHint.flags |= USPosition;
+    }
+    if (flags & YValue) {
+	if (flags & YNegative) {
+	    y += (DisplayHeight(Xdisplay, Xscreen)
+		  - (szHint.height + TermWin_internalBorder));
+	    szHint.win_gravity = (szHint.win_gravity == NorthEastGravity ?
+				  SouthEastGravity : SouthWestGravity);
+	}
+	szHint.y = y;
+	szHint.flags |= USPosition;
+    }
+}
+
+/* INTPROTO */
+void
+szhints_recalc(void)
+{
+    szHint.base_width = (2 * TermWin_internalBorder);
+    szHint.base_height = (2 * TermWin_internalBorder);
+    szHint.base_width += (scrollbar_visible() ? (SB_WIDTH + 2 * sb_shadow) : 0);
+    szHint.base_height += (menubar_visible() ? menuBar_TotalHeight() : 0);
+    szHint.width_inc = TermWin.fwidth;
+    szHint.height_inc = TermWin.fheight;
+    szHint.min_width = szHint.base_width + szHint.width_inc;
+    szHint.min_height = szHint.base_height + szHint.height_inc;
+    szHint.width = szHint.base_width + TermWin.width;
+    szHint.height = szHint.base_height + TermWin.height;
+}
+
+/* xterm sequences - title, iconName, color (exptl) */
+/* INTPROTO */
+void
+set_title(const char *str)
+{
+#ifndef SMART_WINDOW_TITLE
+    XStoreName(Xdisplay, TermWin.parent[0], str);
+#else
+    char           *name;
+
+    if (XFetchName(Xdisplay, TermWin.parent[0], &name))
+	name = NULL;
+    if (name == NULL || strcmp(name, str))
+	XStoreName(Xdisplay, TermWin.parent[0], str);
+    if (name)
+	XFree(name);
+#endif
+}
+
+/* INTPROTO */
+void
+set_iconName(const char *str)
+{
+#ifndef SMART_WINDOW_TITLE
+    XSetIconName(Xdisplay, TermWin.parent[0], str);
+#else
+    char           *name;
+
+    if (XGetIconName(Xdisplay, TermWin.parent[0], &name))
+	name = NULL;
+    if (name == NULL || strcmp(name, str))
+	XSetIconName(Xdisplay, TermWin.parent[0], str);
+    if (name)
+	XFree(name);
+#endif
+}
+
+#ifdef XTERM_COLOR_CHANGE
+/* INTPROTO */
+void
+set_window_color(int idx, const char *color)
+{
+    const char     *msg = "can't load color \"%s\"";
+    XColor          xcol;
+    int             i;
+
+    if (color == NULL || *color == '\0')
+	return;
+
+/* handle color aliases */
+    if (isdigit(*color)) {
+	i = atoi(color);
+	if (i >= 8 && i <= 15) {	/* bright colors */
+	    i -= 8;
+# ifndef NO_BRIGHTCOLOR
+	    PixColors[idx] = PixColors[minBrightCOLOR + i];
+	    goto Done;
+# endif
+	}
+	if (i >= 0 && i <= 7) {	/* normal colors */
+	    PixColors[idx] = PixColors[minCOLOR + i];
+	    goto Done;
+	}
+    }
+    if (!XParseColor(Xdisplay, Xcmap, color, &xcol)
+	|| !XAllocColor(Xdisplay, Xcmap, &xcol)) {
+	print_error(msg, color);
+	return;
+    }
+/* XStoreColor (Xdisplay, Xcmap, XColor*); */
+
+/*
+ * FIXME: should free colors here, but no idea how to do it so instead,
+ * so just keep gobbling up the colormap
+ */
+# if 0
+    for (i = Color_Black; i <= Color_White; i++)
+	if (PixColors[idx] == PixColors[i])
+	    break;
+    if (i > Color_White) {
+    /* fprintf (stderr, "XFreeColors: PixColors [%d] = %lu\n", idx, PixColors [idx]); */
+	XFreeColors(Xdisplay, Xcmap, (PixColors + idx), 1,
+		    DisplayPlanes(Xdisplay, Xscreen));
+    }
+# endif
+
+    PixColors[idx] = xcol.pixel;
+
+/* XSetWindowAttributes attr; */
+/* Cursor cursor; */
+  Done:
+    if (idx == Color_bg && !(Options & Opt_transparent))
+	XSetWindowBackground(Xdisplay, TermWin.vt, PixColors[Color_bg]);
+
+/* handle Color_BD, scrollbar background, etc. */
+
+    set_colorfgbg();
+    {
+	XColor          fg, bg;
+
+	fg.pixel = PixColors[Color_pointer];
+	XQueryColor(Xdisplay, Xcmap, &fg);
+	bg.pixel = PixColors[Color_bg];
+	XQueryColor(Xdisplay, Xcmap, &bg);
+	XRecolorCursor(Xdisplay, TermWin_cursor, &fg, &bg);
+    }
+/* the only reasonable way to enforce a clean update */
+    scr_poweron();
+}
+#else
+# define set_window_color(idx,color)	((void)0)
+#endif				/* XTERM_COLOR_CHANGE */
+
+/*
+ * XTerm escape sequences: ESC ] Ps;Pt BEL
+ *       0 = change iconName/title
+ *       1 = change iconName
+ *       2 = change title
+ *      46 = change logfile (not implemented)
+ *      50 = change font
+ *
+ * rxvt extensions:
+ *      10 = menu
+ *      20 = bg pixmap
+ *      39 = change default fg color
+ *      49 = change default bg color
+ */
+/* EXTPROTO */
+void
+xterm_seq(int op, const char *str)
+{
+    int             changed = 0;
+
+    assert(str != NULL);
+    switch (op) {
+    case XTerm_name:
+	set_title(str);
+    /* FALLTHROUGH */
+    case XTerm_iconName:
+	set_iconName(str);
+	break;
+    case XTerm_title:
+	set_title(str);
+	break;
+    case XTerm_Menu:
+    /*
+     * menubar_dispatch() violates the constness of the string,
+     * so DON'T do it here
+     */
+	break;
+    case XTerm_Pixmap:
+	if (*str != ';') {
+	    scale_pixmap("");	/* reset to default scaling */
+	    set_bgPixmap(str);	/* change pixmap */
+	    scr_touch();
+	}
+	while ((str = strchr(str, ';')) != NULL) {
+	    str++;
+	    changed += scale_pixmap(str);
+	}
+	if (changed) {
+	    resize_pixmap();
+	    scr_touch();
+	}
+	break;
+
+    case XTerm_restoreFG:
+	set_window_color(Color_fg, str);
+	break;
+    case XTerm_restoreBG:
+	set_window_color(Color_bg, str);
+	break;
+    case XTerm_logfile:
+	break;
+    case XTerm_font:
+	change_font(0, str);
+	break;
+    }
+}
+
+/* change_font() - Switch to a new font */
+/*
+ * init = 1   - initialize
+ *
+ * fontname == FONT_UP  - switch to bigger font
+ * fontname == FONT_DN  - switch to smaller font
+ */
+/* EXTPROTO */
+void
+change_font(int init, const char *fontname)
+{
+    const char     *msg = "can't load font \"%s\"";
+    int             idx = 0;	/* index into rs[Rs_font] */
+    int             recheckfonts;
+    XFontStruct    *xfont;
+    static char    *newfont[NFONTS];
+    static int      fnum;		/* logical font number */
+#ifndef NO_BOLDFONT
+    static XFontStruct *boldFont;
+#endif
+
+#if (FONT0_IDX == 0)
+# define IDX2FNUM(i)	(i)
+# define FNUM2IDX(f)	(f)
+#else
+# define IDX2FNUM(i)	(i == 0 ? FONT0_IDX : (i <= FONT0_IDX ? (i-1) : i))
+# define FNUM2IDX(f)	(f == FONT0_IDX ? 0 : (f < FONT0_IDX  ? (f+1) : f))
+#endif
+#define FNUM_RANGE(i)	(i <= 0 ? 0 : (i >= NFONTS ? (NFONTS-1) : i))
+
+    if (init) {
+#ifndef NO_BOLDFONT
+	boldFont = NULL;
+#endif
+	fnum = FONT0_IDX;	/* logical font number */
+    } else {
+	switch (fontname[0]) {
+	case '\0':
+	    fnum = FONT0_IDX;
+	    fontname = NULL;
+	    break;
+
+	/* special (internal) prefix for font commands */
+	case FONT_CMD:
+	    idx = atoi(fontname + 1);
+	    switch (fontname[1]) {
+	    case '+':		/* corresponds to FONT_UP */
+		fnum += (idx ? idx : 1);
+		fnum = FNUM_RANGE(fnum);
+		break;
+
+	    case '-':		/* corresponds to FONT_DN */
+		fnum += (idx ? idx : -1);
+		fnum = FNUM_RANGE(fnum);
+		break;
+
+	    default:
+		if (fontname[1] != '\0' && !isdigit(fontname[1]))
+		    return;
+		if (idx < 0 || idx >= (NFONTS))
+		    return;
+		fnum = IDX2FNUM(idx);
+		break;
+	    }
+	    fontname = NULL;
+	    break;
+
+	default:
+	    if (fontname != NULL) {
+	    /* search for existing fontname */
+		for (idx = 0; idx < NFONTS; idx++) {
+		    if (!strcmp(rs[Rs_font + idx], fontname)) {
+			fnum = IDX2FNUM(idx);
+			fontname = NULL;
+			break;
+		    }
+		}
+	    } else
+		return;
+	    break;
+	}
+    /* re-position around the normal font */
+	idx = FNUM2IDX(fnum);
+
+	if (fontname != NULL) {
+	    char           *name;
+
+	    xfont = XLoadQueryFont(Xdisplay, fontname);
+	    if (!xfont)
+		return;
+
+	    name = MALLOC(strlen(fontname + 1) * sizeof(char));
+
+	    if (name == NULL) {
+		XFreeFont(Xdisplay, xfont);
+		return;
+	    }
+	    STRCPY(name, fontname);
+	    if (newfont[idx] != NULL)
+		FREE(newfont[idx]);
+	    newfont[idx] = name;
+	    rs[Rs_font + idx] = newfont[idx];
+	}
+    }
+    if (TermWin.font)
+	XFreeFont(Xdisplay, TermWin.font);
+
+/* load font or substitute */
+    xfont = XLoadQueryFont(Xdisplay, rs[Rs_font + idx]);
+    if (!xfont) {
+	print_error(msg, rs[Rs_font + idx]);
+	rs[Rs_font + idx] = "fixed";
+	xfont = XLoadQueryFont(Xdisplay, rs[Rs_font + idx]);
+	if (!xfont) {
+	    print_error(msg, rs[Rs_font + idx]);
+	    goto Abort;
+	}
+    }
+    TermWin.font = xfont;
+
+#ifndef NO_BOLDFONT
+/* fail silently */
+    if (init && rs[Rs_boldFont] != NULL)
+	boldFont = XLoadQueryFont(Xdisplay, rs[Rs_boldFont]);
+#endif
+
+#ifdef MULTICHAR_SET
+    if (TermWin.mfont)
+	XFreeFont(Xdisplay, TermWin.mfont);
+
+/* load font or substitute */
+    xfont = XLoadQueryFont(Xdisplay, rs[Rs_mfont + idx]);
+    if (!xfont) {
+	print_error(msg, rs[Rs_mfont + idx]);
+#ifdef ZHCN
+	rs[Rs_mfont + idx] = "-*-16-*-gb2312*-*";
+#else
+	rs[Rs_mfont + idx] = "k14";
+#endif
+	xfont = XLoadQueryFont(Xdisplay, rs[Rs_mfont + idx]);
+	if (!xfont) {
+	    print_error(msg, rs[Rs_mfont + idx]);
+	    goto Abort;
+	}
+    }
+    TermWin.mfont = xfont;
+#endif				/* MULTICHAR_SET */
+
+/* alter existing GC */
+    if (!init) {
+	XSetFont(Xdisplay, TermWin.gc, TermWin.font->fid);
+	menubar_expose();
+    }
+/* set the sizes */
+    {
+	int             i, cw, fh, fw = 0;
+
+	fw = get_fontwidest(TermWin.font);
+	fh = TermWin.font->ascent + TermWin.font->descent;
+
+	if (fw == TermWin.font->min_bounds.width)
+	    TermWin.fprop = 0;	/* Mono-spaced (fixed width) font */
+	else
+	    TermWin.fprop = 1;	/* Proportional font */
+
+	recheckfonts = !(fw == TermWin.fwidth && fh == TermWin.fheight);
+
+	TermWin.fwidth = fw;
+	TermWin.fheight = fh;
+    }
+
+/* check that size of boldFont is okay */
+#ifndef NO_BOLDFONT
+    if (recheckfonts) {
+	TermWin.boldFont = NULL;
+	if (boldFont != NULL) {
+	    int             fh, fw;
+
+	    fw = get_fontwidest(boldFont);
+	    fh = boldFont->ascent + boldFont->descent;
+	    if (fw <= TermWin.fwidth && fh <= TermWin.fheight)
+		TermWin.boldFont = boldFont;
+	    TermWin.bprop = !(fw == TermWin.fwidth /* && fh == TermWin.fheight */ );
+	}
+    }
+#endif				/* NO_BOLDFONT */
+
+#ifdef MULTICHAR_SET
+    if (recheckfonts)
+    /* TODO: XXX: This could be much better? */
+	if (TermWin.mfont != NULL) {
+	    int             fh, fw;
+
+	    fw = get_fontwidest(TermWin.mfont);
+	    fh = TermWin.mfont->ascent + TermWin.mfont->descent;
+	    if (fw <= TermWin.fwidth && fh <= TermWin.fheight)
+		/* WHAT TO DO!! */ ;
+	    TermWin.mprop = !(fw == TermWin.fwidth /* && fh == TermWin.fheight */ );
+	}
+#endif
+
+    set_colorfgbg();
+
+    TermWin.width = TermWin.ncol * TermWin.fwidth;
+    TermWin.height = TermWin.nrow * TermWin.fheight;
+
+    if (!init) {
+	resize_all_windows();
+	scr_touch();
+    }
+    return;
+  Abort:
+    print_error("aborting");	/* fatal problem */
+    exit(EXIT_FAILURE);
+#undef IDX2FNUM
+#undef FNUM2IDX
+#undef FNUM_RANGE
+    /* NOTREACHED */
+}
+/* INTPROTO */
+int
+get_fontwidest(XFontStruct *f)
+{
+    int             i, cw, fw = 0;
+
+    if (f->min_bounds.width == f->max_bounds.width)
+	return f->min_bounds.width;
+    if (f->per_char == NULL)
+	return 0;
+    for (i = f->max_char_or_byte2 - f->min_char_or_byte2; --i >= 0; ) {
+	cw = f->per_char[i].width;
+	MAX_IT(fw, cw);
+    }
+    return fw;
+}
+/* ------------------------------------------------------------------------- */
+/* INTPROTO */
+void
+init_vars(void)
+{
+    Options = Opt_scrollBar | Opt_scrollTtyOutput;
+    sb_shadow = 0;
+    TermWin.ncol = 80;
+    TermWin.nrow = 24;
+    TermWin.mapped = 0;
+    want_refresh = 1;
+    scrollBar.win = 0;
+#if (MENUBAR_MAX)
+    menuBar.win = 0;
+#endif
+
+#if defined (HOTKEY_CTRL) || defined (HOTKEY_META)
+/* recognized when combined with HOTKEY */
+    ks_bigfont = XK_greater;
+    ks_smallfont = XK_less;
+#endif
+#ifndef NO_BRIGHTCOLOR
+    colorfgbg = DEFAULT_RSTYLE;
+#endif
+#ifndef NO_NEW_SELECTION
+    selection_style = NEW_SELECT;
+#else
+    selection_style = OLD_SELECT;
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+/* INTPROTO */
+const char    **
+init_resources(int argc, const char * const *argv)
+{
+    int             i, r_argc;
+    char           *val;
+    const char     *tmp;
+    const char    **cmd_argv, **r_argv;
+
+/*
+ * Look for -exec option.  Find => split and make cmd_argv[] of command args
+ */
+    for (r_argc = 0; r_argc < argc; r_argc++)
+	if (!strcmp(argv[r_argc], "-e") || !strcmp(argv[r_argc], "-exec"))
+	    break;
+    r_argv = (const char **) MALLOC(sizeof(char *) * (r_argc + 1));
+    for (i = 0; i < r_argc; i++)
+	r_argv[i] = (const char *) argv[i];
+    r_argv[i] = NULL;
+    if (r_argc == argc)
+	cmd_argv = NULL;
+    else {
+	cmd_argv = (const char **) MALLOC(sizeof(char *) * (argc - r_argc));
+	for (i = 0; i < argc - r_argc - 1; i++)
+	    cmd_argv[i] = (const char *) argv[i + r_argc + 1];
+	cmd_argv[i] = NULL;
+    }
+
+/* clear all resources */
+    for (i = 0; i < TOTAL_RS; i++)
+	rs[i] = NULL;
+
+    rs[Rs_name] = my_basename(argv[0]);
+/*
+ * Open display, get options/resources and create the window
+ */
+    if ((rs[Rs_display_name] = getenv("DISPLAY")) == NULL)
+	rs[Rs_display_name] = ":0";
+#ifdef LOCAL_X_IS_UNIX
+    if (strncmp(rs[Rs_display_name], ":0", 2) == 0)
+	rs[Rs_display_name] = "unix:0";
+#endif
+
+    get_options(r_argc, r_argv);
+
+    FREE(r_argv);
+
+    if ((Xdisplay = XOpenDisplay(rs[Rs_display_name])) == NULL) {
+	print_error("can't open display %s", rs[Rs_display_name]);
+	exit(EXIT_FAILURE);
+    }
+#ifdef INEXPENSIVE_LOCAL_X_CALLS
+    /* it's hard to determine further if we're on a local display or not */
+    display_is_local = rs[Rs_display_name][0] == ':' ? 1 : 0;
+#endif
+
+    extract_resources(Xdisplay, rs[Rs_name]);
+
+#if ! defined(XTERM_SCROLLBAR) && ! defined(NEXT_SCROLLBAR)
+    if (!(Options & Opt_scrollBar_floating))
+	sb_shadow = SHADOW;
+#endif
+    
+/*
+ * set any defaults not already set
+ */
+    if (cmd_argv && cmd_argv[0]) {
+	if (!rs[Rs_title])
+	    rs[Rs_title] = my_basename(cmd_argv[0]);
+	if (!rs[Rs_iconName])
+	    rs[Rs_iconName] = rs[Rs_title];
+    } else {
+	if (!rs[Rs_title])
+	    rs[Rs_title] = rs[Rs_name];
+	if (!rs[Rs_iconName])
+	    rs[Rs_iconName] = rs[Rs_name];
+    }
+    if (!rs[Rs_saveLines] || (TermWin.saveLines = atoi(rs[Rs_saveLines])) < 0)
+	TermWin.saveLines = SAVELINES;
+
+/* no point having a scrollbar without having any scrollback! */
+    if (!TermWin.saveLines)
+	Options &= ~Opt_scrollBar;
+
+#ifdef PRINTPIPE
+    if (!rs[Rs_print_pipe])
+	rs[Rs_print_pipe] = PRINTPIPE;
+#endif
+    if (!rs[Rs_cutchars])
+	rs[Rs_cutchars] = CUTCHARS;
+#ifndef NO_BACKSPACE_KEY
+    if (!rs[Rs_backspace_key])
+# ifdef DEFAULT_BACKSPACE
+	key_backspace = DEFAULT_BACKSPACE;
+# else
+	key_backspace = "DEC";	/* can toggle between \033 or \177 */
+# endif
+    else {
+	val = strdup(rs[Rs_backspace_key]);
+	(void) Str_escaped(val);
+	key_backspace = val;
+    }
+#endif
+#ifndef NO_DELETE_KEY
+    if (!rs[Rs_delete_key])
+# ifdef DEFAULT_DELETE
+	key_delete = DEFAULT_DELETE;
+# else
+	key_delete = "\033[3~";
+# endif
+    else {
+	val = strdup(rs[Rs_delete_key]);
+	(void) Str_escaped(val);
+	key_delete = val;
+    }
+#endif
+
+    if (rs[Rs_selectstyle]) {
+	if (strncasecmp(rs[Rs_selectstyle], "oldword", 7) == 0)
+	    selection_style = OLD_WORD_SELECT;
+#ifndef NO_OLD_SELECTION
+	else if (strncasecmp(rs[Rs_selectstyle], "old", 3) == 0)
+	    selection_style = OLD_SELECT;
+#endif
+    }
+
+#ifndef NO_BOLDFONT
+    if (rs[Rs_font] == NULL && rs[Rs_boldFont] != NULL) {
+	rs[Rs_font] = rs[Rs_boldFont];
+	rs[Rs_boldFont] = NULL;
+    }
+#endif
+    for (i = 0; i < NFONTS; i++) {
+	if (!rs[Rs_font + i])
+	    rs[Rs_font + i] = def_fontName[i];
+#ifdef MULTICHAR_SET
+	if (!rs[Rs_mfont + i])
+	    rs[Rs_mfont + i] = def_mfontName[i];
+#endif
+    }
+    TermWin.fontset = NULL;
+
+#ifdef XTERM_REVERSE_VIDEO
+/* this is how xterm implements reverseVideo */
+    if (Options & Opt_reverseVideo) {
+	if (!rs[Rs_color + Color_fg])
+	    rs[Rs_color + Color_fg] = def_colorName[Color_bg];
+	if (!rs[Rs_color + Color_bg])
+	    rs[Rs_color + Color_bg] = def_colorName[Color_fg];
+    }
+#endif
+
+    for (i = 0; i < NRS_COLORS; i++)
+	if (!rs[Rs_color + i])
+	    rs[Rs_color + i] = def_colorName[i];
+
+#ifndef XTERM_REVERSE_VIDEO
+/* this is how we implement reverseVideo */
+    if (Options & Opt_reverseVideo)
+	SWAP_IT(rs[Rs_color + Color_fg], rs[Rs_color + Color_bg], tmp);
+#endif
+
+/* convenient aliases for setting fg/bg to colors */
+    color_aliases(Color_fg);
+    color_aliases(Color_bg);
+#ifndef NO_CURSORCOLOR
+    color_aliases(Color_cursor);
+    color_aliases(Color_cursor2);
+#endif				/* NO_CURSORCOLOR */
+    color_aliases(Color_pointer);
+    color_aliases(Color_border);
+#ifndef NO_BOLDUNDERLINE
+    color_aliases(Color_BD);
+    color_aliases(Color_UL);
+#endif				/* NO_BOLDUNDERLINE */
+
+    return cmd_argv;
+}
+
+/* ------------------------------------------------------------------------- */
+/* INTPROTO */
+void
+init_env(void)
+{
+    int             i;
+    unsigned int    u;
+    char           *val;
+/* these don't need to be static but do so to placate some mem checkers */
+    static char    *env_windowid, *env_display, *env_term;
+
+#ifdef DISPLAY_IS_IP
+/* Fixup display_name for export over pty to any interested terminal
+ * clients via "ESC[7n" (e.g. shells).  Note we use the pure IP number
+ * (for the first non-loopback interface) that we get from
+ * network_display().  This is more "name-resolution-portable", if you
+ * will, and probably allows for faster x-client startup if your name
+ * server is beyond a slow link or overloaded at client startup.  Of
+ * course that only helps the shell's child processes, not us.
+ *
+ * Giving out the display_name also affords a potential security hole
+ */
+    rs[Rs_display_name] = (const char *) val = network_display(rs[Rs_display_name]);
+    if (val == NULL)
+#endif				/* DISPLAY_IS_IP */
+	val = XDisplayString(Xdisplay);
+    if (rs[Rs_display_name] == NULL)
+	rs[Rs_display_name] = val;	/* use broken `:0' value */
+
+    i = strlen(val);
+    env_display = MALLOC((i + 9) * sizeof(char));
+    sprintf(env_display, "DISPLAY=%s", val);
+
+    /* avoiding the math library:
+     * i = (int)(ceil(log10((unsigned int)TermWin.parent[0]))) */
+    for (i = 0, u = (unsigned int)TermWin.parent[0]; u; u /= 10, i++);
+    MAX_IT(i, 1);
+    env_windowid = MALLOC((i + 10) * sizeof(char));
+    sprintf(env_windowid, "WINDOWID=%u", (unsigned int)TermWin.parent[0]);
+
+/* add entries to the environment:
+ * @ DISPLAY:   in case we started with -display
+ * @ WINDOWID:  X window id number of the window
+ * @ COLORTERM: terminal sub-name and also indicates its color
+ * @ TERM:      terminal name
+ * @ TERMINFO:	path to terminfo directory
+ */
+    putenv(env_display);
+    putenv(env_windowid);
+#ifdef RXVT_TERMINFO
+    putenv("TERMINFO=" RXVT_TERMINFO);
+#endif
+    if (Xdepth <= 2)
+	putenv("COLORTERM=" COLORTERMENV "-mono");
+    else
+	putenv("COLORTERM=" COLORTERMENVFULL);
+    if (rs[Rs_term_name] != NULL) {
+	env_term = MALLOC((strlen(rs[Rs_term_name]) + 6) * sizeof(char));
+	sprintf(env_term, "TERM=%s", rs[Rs_term_name]);
+	putenv(env_term);
+    } else {
+	putenv("TERM=" TERMENV);
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/* main() */
+/* INTPROTO */
+int
+main(int argc, const char * const *argv)
+{
+    const char    **cmd_argv;
+
+/*
+ * Save and then give up any super-user privileges
+ * If we need privileges in any area then we must specifically request it.
+ * We should only need to be root in these cases:
+ *  1.  write utmp entries on some systems
+ *  2.  chown tty on some systems
+ */
+    privileges(SAVE);
+    privileges(IGNORE);
+
+    init_vars();
+    cmd_argv = init_resources(argc, argv);
+
+#if (MENUBAR_MAX)
+    menubar_read(rs[Rs_menu]);
+#endif
+    scrollbar_mapping(Options & Opt_scrollBar);
+
+    Create_Windows(argc, argv);
+
+    init_xlocale();
+
+    scr_reset();		/* initialize screen */
+    Gr_reset();			/* reset graphics */
+
+#ifdef DEBUG_X
+    XSynchronize(Xdisplay, True);
+    XSetErrorHandler((XErrorHandler) abort);
+#else
+    XSetErrorHandler((XErrorHandler) xerror_handler);
+#endif
+
+    if (scrollbar_visible())
+	XMapWindow(Xdisplay, scrollBar.win);
+#if (MENUBAR_MAX)
+    if (menubar_visible())
+	XMapWindow(Xdisplay, menuBar.win);
+#endif
+#ifdef TRANSPARENT
+    if (Options & Opt_transparent) {
+	XSetWindowBackgroundPixmap(Xdisplay, TermWin.parent[0], ParentRelative);
+	XSetWindowBackgroundPixmap(Xdisplay, TermWin.vt, ParentRelative);
+	XSelectInput(Xdisplay, Xroot, PropertyChangeMask);
+    }
+#endif
+    XMapWindow(Xdisplay, TermWin.vt);
+    XMapWindow(Xdisplay, TermWin.parent[0]);
+
+    init_env();
+    init_command(cmd_argv);
+
+    main_loop();		/* main processing loop */
+    return EXIT_SUCCESS;
+}
+/*----------------------- end-of-file (C source) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/main.extpro work/main.d/rxvt-2.6.4/src/main.extpro
--- tmp/rxvt-2.6.4/src/main.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/main.extpro	2001-11-01 21:28:28.000000000 -0300
@@ -0,0 +1,5 @@
+void             resize_all_windows      __PROTO((void));
+void             resize_window           __PROTO((unsigned int width, unsigned int height));
+void             set_widthheight         __PROTO((unsigned int width, unsigned int height));
+void             xterm_seq               __PROTO((int op, const char *str));
+void             change_font             __PROTO((int init, const char *fontname));
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/main.intpro work/main.d/rxvt-2.6.4/src/main.intpro
--- tmp/rxvt-2.6.4/src/main.intpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/main.intpro	2001-11-01 21:28:30.000000000 -0300
@@ -0,0 +1,16 @@
+XErrorHandler    xerror_handler          __PROTO((const Display *display, const XErrorEvent *event));
+void             color_aliases           __PROTO((int idx));
+void             set_colorfgbg           __PROTO((void));
+void             Get_Colours             __PROTO((void));
+void             Create_Windows          __PROTO((int argc, const char * const *argv));
+void             resize_subwindows       __PROTO((int width, int height));
+void             szhints_set             __PROTO((void));
+void             szhints_recalc          __PROTO((void));
+void             set_title               __PROTO((const char *str));
+void             set_iconName            __PROTO((const char *str));
+void             set_window_color        __PROTO((int idx, const char *color));
+int              get_fontwidest          __PROTO((XFontStruct *f));
+void             init_vars               __PROTO((void));
+const char    ** init_resources          __PROTO((int argc, const char * const *argv));
+void             init_env                __PROTO((void));
+int              main                    __PROTO((int argc, const char * const *argv));
Binary files tmp/rxvt-2.6.4/src/main.o and work/main.d/rxvt-2.6.4/src/main.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/makeextprotos-awk work/main.d/rxvt-2.6.4/src/makeextprotos-awk
--- tmp/rxvt-2.6.4/src/makeextprotos-awk	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/makeextprotos-awk	1998-11-26 02:04:39.000000000 -0300
@@ -0,0 +1,11 @@
+/^\/\* EXTPROTO \*\/$/ {
+    getline	# function return
+    printf "%-16s ", $0
+    getline	# function name and args
+    l = index($0, "(")
+    outstring = sprintf("%%-23.%ds __PROTO(", l - 1)
+    printf outstring, $0
+    reststring = substr($0, l)
+    printf reststring
+    print ");"
+}
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/Makefile work/main.d/rxvt-2.6.4/src/Makefile
--- tmp/rxvt-2.6.4/src/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/Makefile	2007-01-15 18:03:53.000000000 -0300
@@ -0,0 +1,257 @@
+# Generated automatically from Makefile.in by configure.
+# $Id: Makefile.in,v 1.28.2.2 1999/10/14 23:48:55 mason Exp $
+
+# autoconf/Make.common.in	 -*- Makefile -*-
+# release date (man), LSM date, version number/name, current maintainer
+DATE=02 NOVEMBER 2001
+LSMDATE=02NOV01
+VERSION=2.6.4
+VERNAME=rxvt-$(VERSION)#
+MAINT=Geoff Wing#
+MAINTEMAIL=<gcw@rxvt.org>#
+WEBMAINT=Oezguer Kesim#
+WEBMAINTEMAIL=<oec@rxvt.org>#
+WEBPAGE=<http://www.rxvt.org/>#
+FTPSITENAME=ftp.rxvt.org#
+FTPSITEDIR=/pub/rxvt#
+#-------------------------------------------------------------------------
+
+SHELL = /bin/sh
+
+# This variable makes it possible to move the installation root to another
+# directory. This is useful when you're creating a binary distribution
+# If empty, normal root will be used.
+# You can run eg. 'make install DESTDIR=/packages/rxvt-xx' to accomplish
+# that.
+# DESTDIR = /usr/local/X11/$(VERNAME)
+
+# Installation target directories & other installation stuff
+prefix = //usr
+exec_prefix = //usr
+binprefix =
+manprefix =
+bindir = //usr/bin
+mandir = //usr/share/man/man1
+manext = 1
+
+# Tools & program stuff
+CC = i586-castorbox-linux-gnu-gcc
+CPP = i586-castorbox-linux-gnu-cpp
+MV = //media/gar-castorbox/images/build/usr/bin/mv
+RM = //media/gar-castorbox/images/build/usr/bin/rm
+RMF = //media/gar-castorbox/images/build/usr/bin/rm -f
+CP = //media/gar-castorbox/images/build/usr/bin/cp
+SED = //media/gar-castorbox/images/build/usr/bin/sed
+AWK = //media/gar-castorbox/images/build/usr/bin/awk
+ECHO = //media/gar-castorbox/images/build/usr/bin/echo
+CMP = //media/gar-castorbox/images/build/usr/bin/cmp
+TBL = 
+INSTALL = //media/gar-castorbox/images/build/usr/bin/install -c
+INSTALL_PROGRAM = //media/gar-castorbox/images/build/usr/bin/install -c -s -m 755
+INSTALL_DATA = //media/gar-castorbox/images/build/usr/bin/install -c -m 644
+
+# Flags & libs
+# add -DBINDIR=\""$(bindir)/"\" to CPPFLAGS, if we need to spawn a program
+
+CFLAGS = -pipe -march=c3-2 -Os -mfpmath=sse -ffast-math -m32 
+CPPFLAGS =  
+LDFLAGS = 
+DEFS = -DHAVE_CONFIG_H
+LIBS = 
+DINCLUDE = 
+DLIB = 
+
+# X Include directory
+XINC =  -I/media/gar-castorbox/images/main//usr/include 
+
+# extra libraries needed by X on some systems, X library location
+XLIB =  -L/media/gar-castorbox/images/main//usr/lib  -lX11 
+
+# End of common section of the Makefile
+#-------------------------------------------------------------------------
+
+srcdir =	.
+.PATH:		.
+
+basedir = ..
+thisdir = src
+
+# for developers: the following debug options may be used
+#	-DDEBUG_CMD -DDEBUG_MENU -DDEBUG_MENUARROWS -DDEBUG_MENUBAR_STACKING
+#	-DDEBUG_MENU_LAYOUT -DDEBUG_RESOURCES -DDEBUG_SCREEN
+#	-DDEBUG_SEARCH_PATH -DDEBUG_SELECT -DDEBUG_TTYMODE -DDEBUG_X
+#	-DDEBUG_STRICT
+DEBUG=	
+
+first_rule: all
+dummy:
+
+SRCS =	command.c graphics.c grkelot.c logging.c main.c menubar.c misc.c \
+	netdisp.c rmemset.c screen.c scrollbar.c xdefaults.c xpm.c
+
+HDRS =	command.h grkelot.h menubar.h protos.h rxvtgrx.h version.h \
+	feature.h logging.h netdisp.h rxvt.h screen.h
+
+# it's ``be kind to gmake week''
+#OBJS =	$(SRCS:S,.c,.o,)
+OBJS =	command.o graphics.o grkelot.o logging.o main.o menubar.o misc.o \
+	netdisp.o rmemset.o screen.o scrollbar.o xdefaults.o xpm.o
+
+# it's ``be kind to gmake week''
+#EXTPROS = $(SRCS:S,.c,.extpro,)
+EXTPROS = command.extpro graphics.extpro grkelot.extpro logging.extpro \
+	main.extpro menubar.extpro misc.extpro netdisp.extpro \
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro \
+	xpm.extpro
+
+# it's ``be kind to gmake week''
+#INTPROS = $(SRCS:S,.c,.intpro,)
+INTPROS = command.intpro graphics.intpro grkelot.intpro logging.intpro \
+	main.intpro menubar.intpro misc.intpro netdisp.intpro \
+	rmemset.intpro screen.intpro scrollbar.intpro xdefaults.intpro \
+	xpm.intpro
+
+DEPS =  rxvt.h ${basedir}/config.h feature.h rsizes.h
+
+#
+# Distribution variables
+#
+
+DIST = $(HDRS) $(SRCS) Makefile.in rsizes.h.in gcc-Wall .indent.pro \
+	makeintprotos-awk makeextprotos-awk $(INTPROS) $(EXTPROS)
+
+.SUFFIXES:	.c .o .intpro
+.PHONY:		protos
+.DONTCARE:	protos
+
+# inference rules
+.c.o:
+	$(CC) $(DEFS) $(DEBUG) -c $(CPPFLAGS) $(XINC)  -I. -I$(basedir) -I$(srcdir) $(DINCLUDE) $(CFLAGS) $<
+#-------------------------------------------------------------------------
+all: protos rxvt
+
+rxvt: version.h $(OBJS)
+	$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS) $(XLIB) $(DLIB)
+
+protos:
+	@for I in $(EXTPROS); do \
+	    $(RMF) tmpproto; \
+	    J=`echo $$I | $(SED) 's,.extpro,.c,'`; \
+	    $(AWK) -f $(srcdir)/makeextprotos-awk $(srcdir)/$$J > tmpproto; \
+	    if $(CMP) -s $$I tmpproto ; then : ; else $(ECHO) "Updating $$I"; $(CP) tmpproto $$I; fi; \
+	    $(RMF) tmpproto; \
+	done
+
+.c.intpro:
+	@$(RMF) tmpproto-$@
+	@$(AWK) -f $(srcdir)/makeintprotos-awk $< > tmpproto-$@
+	@if $(CMP) -s $@ tmpproto-$@ ; then : ; else $(ECHO) "Updating $@"; $(CP) tmpproto-$@ $@; fi
+	@$(RMF) tmpproto-$@
+
+tags: $(SRCS)
+	ctags $(SRCS)
+
+allbin: rxvt
+
+alldoc:
+
+clean:
+	$(RMF) rxvt core a.out $(OBJS) *.bak *~ *.intpro *.extpro
+
+realclean: clean
+	$(RMF) tags
+
+distclean: realclean
+	if test $(srcdir) = .; then $(MAKE) realclean; fi
+	(cd $(srcdir); $(RMF) Makefile)
+
+install: allbin alldoc
+	$(INSTALL_PROGRAM) rxvt $(DESTDIR)$(bindir)/$(binprefix)rxvt
+
+uninstall:
+	(cd $(bindir); $(RMF) $(binprefix)rxvt)
+
+distdirs:
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)
+
+distcopy: protos $(INTPROS)
+	$(CP) -p $(DIST) $(basedir)/../$(VERNAME)/$(thisdir)
+
+# Semi-automatic generation of dependencies:
+# Use gcc -MM because X11 `makedepend' doesn't work on all systems
+# and it also includes system headers.
+# `semi'-automatic since dependencies are generated at distribution time.
+
+#distdepend:
+#	mv Makefile.in Makefile.in~
+#	sed "/^# DO NOT DELETE:/,$$ d" Makefile.in~ > Makefile.in
+#	echo "# DO NOT DELETE: ugly dependency list follows" >> Makefile.in
+#	gcc -MM $(CPPFLAGS) $(XINC) -I. -I$(basedir) -I$(srcdir) $(SRCS) >> Makefile.in
+
+# -----------------------------------------------------------------------
+# DO NOT DELETE: nice dependency list follows
+command.o:   command.c   $(DEPS) command.h version.h			\
+	command.intpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+graphics.o:  graphics.c  $(DEPS)					\
+	command.extpro graphics.intpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+grkelot.o:   grkelot.c   $(DEPS) grkelot.h				\
+	command.extpro graphics.extpro grkelot.intpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+logging.o:   logging.c   $(DEPS) logging.h				\
+	command.extpro graphics.extpro grkelot.extpro logging.intpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+main.o:      main.c      $(DEPS) 					\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.intpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+menubar.o:   menubar.c   $(DEPS) menubar.h version.h			\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.intpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+misc.o:      misc.c      $(DEPS)					\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.intpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+netdisp.o:   netdisp.c   $(DEPS) netdisp.h				\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.intpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+rmemset.o:   rmemset.c   $(DEPS) 					\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.intpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+screen.o:    screen.c    $(DEPS) screen.h				\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.intpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+scrollbar.o: scrollbar.c $(DEPS)					\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.intpro xdefaults.extpro	\
+	xpm.extpro
+xdefaults.o: xdefaults.c $(DEPS) version.h				\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.intpro	\
+	xpm.extpro
+xpm.o:       xpm.c       $(DEPS) 					\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.intpro
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/Makefile.in work/main.d/rxvt-2.6.4/src/Makefile.in
--- tmp/rxvt-2.6.4/src/Makefile.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/Makefile.in	1999-10-14 20:48:55.000000000 -0300
@@ -0,0 +1,189 @@
+# $Id: Makefile.in,v 1.28.2.2 1999/10/14 23:48:55 mason Exp $
+@MCOMMON@
+
+srcdir =	@srcdir@
+VPATH =		@srcdir@
+.PATH:		@srcdir@
+
+basedir = ..
+thisdir = src
+
+# for developers: the following debug options may be used
+#	-DDEBUG_CMD -DDEBUG_MENU -DDEBUG_MENUARROWS -DDEBUG_MENUBAR_STACKING
+#	-DDEBUG_MENU_LAYOUT -DDEBUG_RESOURCES -DDEBUG_SCREEN
+#	-DDEBUG_SEARCH_PATH -DDEBUG_SELECT -DDEBUG_TTYMODE -DDEBUG_X
+#	-DDEBUG_STRICT
+DEBUG=	@DEBUG@
+
+first_rule: all
+dummy:
+
+SRCS =	command.c graphics.c grkelot.c logging.c main.c menubar.c misc.c \
+	netdisp.c rmemset.c screen.c scrollbar.c xdefaults.c xpm.c
+
+HDRS =	command.h grkelot.h menubar.h protos.h rxvtgrx.h version.h \
+	feature.h logging.h netdisp.h rxvt.h screen.h
+
+# it's ``be kind to gmake week''
+#OBJS =	$(SRCS:S,.c,.o,)
+OBJS =	command.o graphics.o grkelot.o logging.o main.o menubar.o misc.o \
+	netdisp.o rmemset.o screen.o scrollbar.o xdefaults.o xpm.o
+
+# it's ``be kind to gmake week''
+#EXTPROS = $(SRCS:S,.c,.extpro,)
+EXTPROS = command.extpro graphics.extpro grkelot.extpro logging.extpro \
+	main.extpro menubar.extpro misc.extpro netdisp.extpro \
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro \
+	xpm.extpro
+
+# it's ``be kind to gmake week''
+#INTPROS = $(SRCS:S,.c,.intpro,)
+INTPROS = command.intpro graphics.intpro grkelot.intpro logging.intpro \
+	main.intpro menubar.intpro misc.intpro netdisp.intpro \
+	rmemset.intpro screen.intpro scrollbar.intpro xdefaults.intpro \
+	xpm.intpro
+
+DEPS =  rxvt.h ${basedir}/config.h feature.h rsizes.h
+
+#
+# Distribution variables
+#
+
+DIST = $(HDRS) $(SRCS) Makefile.in rsizes.h.in gcc-Wall .indent.pro \
+	makeintprotos-awk makeextprotos-awk $(INTPROS) $(EXTPROS)
+
+.SUFFIXES:	.c .o .intpro
+.PHONY:		protos
+.DONTCARE:	protos
+
+# inference rules
+.c.o:
+	$(CC) $(DEFS) $(DEBUG) -c $(CPPFLAGS) $(XINC)  -I. -I$(basedir) -I$(srcdir) $(DINCLUDE) $(CFLAGS) $<
+#-------------------------------------------------------------------------
+all: protos rxvt
+
+rxvt: version.h $(OBJS)
+	$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS) $(XLIB) $(DLIB)
+
+protos:
+	@for I in $(EXTPROS); do \
+	    $(RMF) tmpproto; \
+	    J=`echo $$I | $(SED) 's,.extpro,.c,'`; \
+	    $(AWK) -f $(srcdir)/makeextprotos-awk $(srcdir)/$$J > tmpproto; \
+	    if $(CMP) -s $$I tmpproto ; then : ; else $(ECHO) "Updating $$I"; $(CP) tmpproto $$I; fi; \
+	    $(RMF) tmpproto; \
+	done
+
+.c.intpro:
+	@$(RMF) tmpproto-$@
+	@$(AWK) -f $(srcdir)/makeintprotos-awk $< > tmpproto-$@
+	@if $(CMP) -s $@ tmpproto-$@ ; then : ; else $(ECHO) "Updating $@"; $(CP) tmpproto-$@ $@; fi
+	@$(RMF) tmpproto-$@
+
+tags: $(SRCS)
+	ctags $(SRCS)
+
+allbin: rxvt
+
+alldoc:
+
+clean:
+	$(RMF) rxvt core a.out $(OBJS) *.bak *~ *.intpro *.extpro
+
+realclean: clean
+	$(RMF) tags
+
+distclean: realclean
+	if test $(srcdir) = .; then $(MAKE) realclean; fi
+	(cd $(srcdir); $(RMF) Makefile)
+
+install: allbin alldoc
+	$(INSTALL_PROGRAM) rxvt $(DESTDIR)$(bindir)/$(binprefix)rxvt
+
+uninstall:
+	(cd $(bindir); $(RMF) $(binprefix)rxvt)
+
+distdirs:
+	mkdir $(basedir)/../$(VERNAME)/$(thisdir)
+
+distcopy: protos $(INTPROS)
+	$(CP) -p $(DIST) $(basedir)/../$(VERNAME)/$(thisdir)
+
+# Semi-automatic generation of dependencies:
+# Use gcc -MM because X11 `makedepend' doesn't work on all systems
+# and it also includes system headers.
+# `semi'-automatic since dependencies are generated at distribution time.
+
+#distdepend:
+#	mv Makefile.in Makefile.in~
+#	sed "/^# DO NOT DELETE:/,$$ d" Makefile.in~ > Makefile.in
+#	echo "# DO NOT DELETE: ugly dependency list follows" >> Makefile.in
+#	gcc -MM $(CPPFLAGS) $(XINC) -I. -I$(basedir) -I$(srcdir) $(SRCS) >> Makefile.in
+
+# -----------------------------------------------------------------------
+# DO NOT DELETE: nice dependency list follows
+command.o:   command.c   $(DEPS) command.h version.h			\
+	command.intpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+graphics.o:  graphics.c  $(DEPS)					\
+	command.extpro graphics.intpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+grkelot.o:   grkelot.c   $(DEPS) grkelot.h				\
+	command.extpro graphics.extpro grkelot.intpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+logging.o:   logging.c   $(DEPS) logging.h				\
+	command.extpro graphics.extpro grkelot.extpro logging.intpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+main.o:      main.c      $(DEPS) 					\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.intpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+menubar.o:   menubar.c   $(DEPS) menubar.h version.h			\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.intpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+misc.o:      misc.c      $(DEPS)					\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.intpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+netdisp.o:   netdisp.c   $(DEPS) netdisp.h				\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.intpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+rmemset.o:   rmemset.c   $(DEPS) 					\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.intpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+screen.o:    screen.c    $(DEPS) screen.h				\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.intpro scrollbar.extpro xdefaults.extpro	\
+	xpm.extpro
+scrollbar.o: scrollbar.c $(DEPS)					\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.intpro xdefaults.extpro	\
+	xpm.extpro
+xdefaults.o: xdefaults.c $(DEPS) version.h				\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.intpro	\
+	xpm.extpro
+xpm.o:       xpm.c       $(DEPS) 					\
+	command.extpro graphics.extpro grkelot.extpro logging.extpro	\
+	main.extpro menubar.extpro misc.extpro netdisp.extpro		\
+	rmemset.extpro screen.extpro scrollbar.extpro xdefaults.extpro	\
+	xpm.intpro
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/makeintprotos-awk work/main.d/rxvt-2.6.4/src/makeintprotos-awk
--- tmp/rxvt-2.6.4/src/makeintprotos-awk	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/makeintprotos-awk	1998-11-26 02:04:39.000000000 -0300
@@ -0,0 +1,11 @@
+/^\/\* INTPROTO \*\/$/ {
+    getline	# function return
+    printf "%-16s ", $0
+    getline	# function name and args
+    l = index($0, "(")
+    outstring = sprintf("%%-23.%ds __PROTO(", l - 1)
+    printf outstring, $0
+    reststring = substr($0, l)
+    printf reststring
+    print ");"
+}
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/menubar.c work/main.d/rxvt-2.6.4/src/menubar.c
--- tmp/rxvt-2.6.4/src/menubar.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/menubar.c	1999-01-23 11:26:36.000000000 -0300
@@ -0,0 +1,2349 @@
+/*--------------------------------*-C-*---------------------------------*
+ * File:	menubar.c
+ *----------------------------------------------------------------------*
+ * $Id: menubar.c,v 1.27 1999/01/23 14:26:36 mason Exp $
+ *
+ * Copyright (C) 1997,1998  mj olesen <olesen@me.QueensU.CA>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *----------------------------------------------------------------------*
+ * refer.html (or refer.txt) contains up-to-date documentation.  The
+ * summary that appears at the end of this file was taken from there.
+ *----------------------------------------------------------------------*/
+
+#include "rxvt.h"		/* NECESSARY */
+#include "version.h"
+#include "menubar.h"
+
+#ifdef MENUBAR
+#define Menu_PixelWidth(menu)					\
+    (2 * SHADOW + Width2Pixel ((menu)->width + 3 * HSPACE))
+
+static GC       topShadowGC, botShadowGC, neutralGC, menubarGC;
+
+static int      menu_readonly = 1;	/* okay to alter menu? */
+static int      Arrows_x = 0;
+static const struct {
+    char            name;	/* (l)eft, (u)p, (d)own, (r)ight */
+    unsigned char   str[4];	/* str[0] = strlen (str+1) */
+} Arrows[NARROWS] = {
+    { 'l', "\003\033[D" },
+    { 'u', "\003\033[A" },
+    { 'd', "\003\033[B" },
+    { 'r', "\003\033[C" }
+};
+
+#if (MENUBAR_MAX > 1)
+static int      Nbars = 0;
+static bar_t   *CurrentBar = NULL;
+#else				/* (MENUBAR_MAX > 1) */
+static bar_t    BarList;
+static bar_t   *CurrentBar = &BarList;
+#endif				/* (MENUBAR_MAX > 1) */
+
+static menu_t  *ActiveMenu = NULL;	/* currently active menu */
+#endif
+
+/*}}} */
+
+#ifdef MENUBAR
+/*
+ * find an item called NAME in MENU
+ */
+/* INTPROTO */
+menuitem_t     *
+menuitem_find(const menu_t *menu, const char *name)
+{
+    menuitem_t     *item;
+
+    assert(name != NULL);
+    assert(menu != NULL);
+
+/* find the last item in the menu, this is good for separators */
+    for (item = menu->tail; item != NULL; item = item->prev) {
+	if (item->entry.type == MenuSubMenu) {
+	    if (!strcmp(name, (item->entry.submenu.menu)->name))
+		break;
+	} else if ((isSeparator(name) && isSeparator(item->name))
+		   || !strcmp(name, item->name))
+	    break;
+    }
+    return item;
+}
+#endif
+
+#ifdef MENUBAR
+/*
+ * unlink ITEM from its MENU and free its memory
+ */
+/* INTPROTO */
+void
+menuitem_free(menu_t *menu, menuitem_t *item)
+{
+/* disconnect */
+    menuitem_t     *prev, *next;
+
+    assert(menu != NULL);
+
+    prev = item->prev;
+    next = item->next;
+    if (prev != NULL)
+	prev->next = next;
+    if (next != NULL)
+	next->prev = prev;
+
+/* new head, tail */
+    if (menu->tail == item)
+	menu->tail = prev;
+    if (menu->head == item)
+	menu->head = next;
+
+    switch (item->entry.type) {
+    case MenuAction:
+    case MenuTerminalAction:
+	FREE(item->entry.action.str);
+	break;
+    case MenuSubMenu:
+	(void)menu_delete(item->entry.submenu.menu);
+	break;
+    }
+    if (item->name != NULL)
+	FREE(item->name);
+    if (item->name2 != NULL)
+	FREE(item->name2);
+    FREE(item);
+}
+#endif
+
+#ifdef MENUBAR
+/*
+ * sort command vs. terminal actions and
+ * remove the first character of STR if it's '\0'
+ */
+/* INTPROTO */
+int
+action_type(action_t *action, unsigned char *str)
+{
+    unsigned int    len;
+
+#if defined (DEBUG_MENU) || defined (DEBUG_MENUARROWS)
+    len = strlen(str);
+    fprintf(stderr, "(len %d) = %s\n", len, str);
+#else
+    len = Str_escaped((char *)str);
+#endif
+
+    if (!len)
+	return -1;
+
+/* sort command vs. terminal actions */
+    action->type = MenuAction;
+    if (str[0] == '\0') {
+    /* the functional equivalent: memmove (str, str+1, len); */
+	unsigned char  *dst = (str);
+	unsigned char  *src = (str + 1);
+	unsigned char  *end = (str + len);
+
+	while (src <= end)
+	    *dst++ = *src++;
+
+	len--;			/* decrement length */
+	if (str[0] != '\0')
+	    action->type = MenuTerminalAction;
+    }
+    action->str = str;
+    action->len = len;
+
+    return 0;
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+int
+action_dispatch(action_t *action)
+{
+    switch (action->type) {
+    case MenuTerminalAction:
+	cmd_write(action->str, action->len);
+	break;
+
+    case MenuAction:
+	tt_write(action->str, action->len);
+	break;
+
+    default:
+	return -1;
+	break;
+    }
+    return 0;
+}
+#endif
+
+#ifdef MENUBAR
+/* return the arrow index corresponding to NAME */
+/* INTPROTO */
+int
+menuarrow_find(char name)
+{
+    int             i;
+
+    for (i = 0; i < NARROWS; i++)
+	if (name == Arrows[i].name)
+	    return i;
+    return -1;
+}
+#endif
+
+#ifdef MENUBAR
+/* free the memory associated with arrow NAME of the current menubar */
+/* INTPROTO */
+void
+menuarrow_free(char name)
+{
+    int             i;
+
+    if (name) {
+	i = menuarrow_find(name);
+	if (i >= 0) {
+	    action_t       *act = &(CurrentBar->arrows[i]);
+
+	    switch (act->type) {
+	    case MenuAction:
+	    case MenuTerminalAction:
+		FREE(act->str);
+		act->str = NULL;
+		act->len = 0;
+		break;
+	    }
+	    act->type = MenuLabel;
+	}
+    } else {
+	for (i = 0; i < NARROWS; i++)
+	    menuarrow_free(Arrows[i].name);
+    }
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+menuarrow_add(char *string)
+{
+    int             i;
+    unsigned        xtra_len;
+    char           *p;
+
+    struct {
+	char           *str;
+	int             len;
+    } beg = {
+	NULL, 0
+    }, end = {
+	NULL, 0
+    }, *cur, parse[NARROWS];
+
+    MEMSET(parse, 0, sizeof(parse));
+
+/* fprintf(stderr, "add arrows = `%s'\n", string); */
+    for (p = string; p != NULL && *p; string = p) {
+	p = (string + 3);
+    /* fprintf(stderr, "parsing at %s\n", string); */
+	switch (string[1]) {
+	case 'b':
+	    cur = &beg;
+	    break;
+	case 'e':
+	    cur = &end;
+	    break;
+
+	default:
+	    i = menuarrow_find(string[1]);
+	    if (i >= 0)
+		cur = &(parse[i]);
+	    else
+		continue;	/* not found */
+	    break;
+	}
+
+	string = p;
+	cur->str = string;
+	cur->len = 0;
+
+	if (cur == &end) {
+	    p = strchr(string, '\0');
+	} else {
+	    char           *next = string;
+
+	    while (1) {
+		p = strchr(next, '<');
+		if (p != NULL) {
+		    if (p[1] && p[2] == '>')
+			break;
+		/* parsed */
+		} else {
+		    if (beg.str == NULL)	/* no end needed */
+			p = strchr(next, '\0');
+		    break;
+		}
+		next = (p + 1);
+	    }
+	}
+
+	if (p == NULL)
+	    return;
+	cur->len = (p - string);
+    }
+
+#ifdef DEBUG_MENUARROWS
+    cur = &beg;
+    fprintf(stderr, "<b>(len %d) = %.*s\n",
+	    cur->len, cur->len, (cur->str ? cur->str : ""));
+    for (i = 0; i < NARROWS; i++) {
+	cur = &(parse[i]);
+	fprintf(stderr, "<%c>(len %d) = %.*s\n",
+		Arrows[i].name,
+		cur->len,
+		cur->len,
+		(cur->str ? cur->str : ""));
+    }
+    cur = &end;
+    fprintf(stderr, "<e>(len %d) = %.*s\n",
+	    cur->len, cur->len, (cur->str ? cur->str : ""));
+#endif
+
+    xtra_len = (beg.len + end.len);
+    for (i = 0; i < NARROWS; i++) {
+	if (xtra_len || parse[i].len)
+	    menuarrow_free(Arrows[i].name);
+    }
+
+    for (i = 0; i < NARROWS; i++) {
+	unsigned char  *str;
+	unsigned int    len;
+
+	if (!parse[i].len)
+	    continue;
+
+	str = MALLOC(parse[i].len + xtra_len + 1);
+	if (str == NULL)
+	    continue;
+
+	len = 0;
+	if (beg.len) {
+	    STRNCPY(str + len, beg.str, beg.len);
+	    len += beg.len;
+	}
+	STRNCPY(str + len, parse[i].str, parse[i].len);
+	len += parse[i].len;
+
+	if (end.len) {
+	    STRNCPY(str + len, end.str, end.len);
+	    len += end.len;
+	}
+	str[len] = '\0';
+
+#ifdef DEBUG_MENUARROWS
+	fprintf(stderr, "<%c>(len %d) = %s\n", Arrows[i].name, len, str);
+#endif
+	if (action_type(&(CurrentBar->arrows[i]), str) < 0)
+	    FREE(str);
+    }
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+menuitem_t     *
+menuitem_add(menu_t *menu, const char *name, const char *name2, const char *action)
+{
+    menuitem_t     *item;
+    unsigned int    len;
+
+    assert(name != NULL);
+    assert(action != NULL);
+
+    if (menu == NULL)
+	return NULL;
+
+    if (isSeparator(name)) {
+    /* add separator, no action */
+	name = "";
+	action = "";
+    } else {
+    /*
+     * add/replace existing menu item
+     */
+	item = menuitem_find(menu, name);
+	if (item != NULL) {
+	    if (item->name2 != NULL && name2 != NULL) {
+		FREE(item->name2);
+		item->len2 = 0;
+		item->name2 = NULL;
+	    }
+	    switch (item->entry.type) {
+	    case MenuAction:
+	    case MenuTerminalAction:
+		FREE(item->entry.action.str);
+		item->entry.action.str = NULL;
+		break;
+	    }
+	    goto Item_Found;
+	}
+    }
+/* allocate a new itemect */
+    if ((item = (menuitem_t *) MALLOC(sizeof(menuitem_t))) == NULL)
+	return NULL;
+
+    item->len2 = 0;
+    item->name2 = NULL;
+
+    len = strlen(name);
+    item->name = MALLOC(len + 1);
+    if (item->name != NULL) {
+	STRCPY(item->name, name);
+	if (name[0] == '.' && name[1] != '.')
+	    len = 0;		/* hidden menu name */
+    } else {
+	FREE(item);
+	return NULL;
+    }
+    item->len = len;
+
+/* add to tail of list */
+    item->prev = menu->tail;
+    item->next = NULL;
+
+    if (menu->tail != NULL)
+	(menu->tail)->next = item;
+    menu->tail = item;
+/* fix head */
+    if (menu->head == NULL)
+	menu->head = item;
+
+/*
+ * add action
+ */
+  Item_Found:
+    if (name2 != NULL && item->name2 == NULL) {
+	len = strlen(name2);
+	if (len == 0 || (item->name2 = MALLOC(len + 1)) == NULL) {
+	    len = 0;
+	    item->name2 = NULL;
+	} else {
+	    STRCPY(item->name2, name2);
+	}
+	item->len2 = len;
+    }
+    item->entry.type = MenuLabel;
+    len = strlen(action);
+
+    if (len == 0 && item->name2 != NULL) {
+	action = item->name2;
+	len = item->len2;
+    }
+    if (len) {
+	unsigned char  *str = MALLOC(len + 1);
+
+	if (str == NULL) {
+	    menuitem_free(menu, item);
+	    return NULL;
+	}
+	STRCPY(str, action);
+
+	if (action_type(&(item->entry.action), str) < 0)
+	    FREE(str);
+    }
+/* new item and a possible increase in width */
+    if (menu->width < (item->len + item->len2))
+	menu->width = (item->len + item->len2);
+
+    return item;
+}
+#endif
+
+#ifdef MENUBAR
+/*
+ * search for the base starting menu for NAME.
+ * return a pointer to the portion of NAME that remains
+ */
+/* INTPROTO */
+char           *
+menu_find_base(menu_t **menu, char *path)
+{
+    menu_t         *m = NULL;
+    menuitem_t     *item;
+
+    assert(menu != NULL);
+    assert(CurrentBar != NULL);
+
+    if (path[0] == '\0')
+	return path;
+
+    if (strchr(path, '/') != NULL) {
+	register char  *p = path;
+
+	while ((p = strchr(p, '/')) != NULL) {
+	    p++;
+	    if (*p == '/')
+		path = p;
+	}
+	if (path[0] == '/') {
+	    path++;
+	    *menu = NULL;
+	}
+	while ((p = strchr(path, '/')) != NULL) {
+	    p[0] = '\0';
+	    if (path[0] == '\0')
+		return NULL;
+	    if (!strcmp(path, DOT)) {
+	    /* nothing to do */
+	    } else if (!strcmp(path, DOTS)) {
+		if (*menu != NULL)
+		    *menu = (*menu)->parent;
+	    } else {
+		path = menu_find_base(menu, path);
+		if (path[0] != '\0') {	/* not found */
+		    p[0] = '/';	/* fix-up name again */
+		    return path;
+		}
+	    }
+
+	    path = (p + 1);
+	}
+    }
+    if (!strcmp(path, DOTS)) {
+	path += strlen(DOTS);
+	if (*menu != NULL)
+	    *menu = (*menu)->parent;
+	return path;
+    }
+/* find this menu */
+    if (*menu == NULL) {
+	for (m = CurrentBar->tail; m != NULL; m = m->prev) {
+	    if (!strcmp(path, m->name))
+		break;
+	}
+    } else {
+    /* find this menu */
+	for (item = (*menu)->tail; item != NULL; item = item->prev) {
+	    if (item->entry.type == MenuSubMenu
+		&& !strcmp(path, (item->entry.submenu.menu)->name)) {
+		m = (item->entry.submenu.menu);
+		break;
+	    }
+	}
+    }
+    if (m != NULL) {
+	*menu = m;
+	path += strlen(path);
+    }
+    return path;
+}
+#endif
+
+#ifdef MENUBAR
+/*
+ * delete this entire menu
+ */
+/* INTPROTO */
+menu_t         *
+menu_delete(menu_t *menu)
+{
+    menu_t         *parent = NULL, *prev, *next;
+    menuitem_t     *item;
+
+    assert(CurrentBar != NULL);
+
+/* delete the entire menu */
+    if (menu == NULL)
+	return NULL;
+
+    parent = menu->parent;
+
+/* unlink MENU */
+    prev = menu->prev;
+    next = menu->next;
+    if (prev != NULL)
+	prev->next = next;
+    if (next != NULL)
+	next->prev = prev;
+
+/* fix the index */
+    if (parent == NULL) {
+	const int       len = (menu->len + HSPACE);
+
+	if (CurrentBar->tail == menu)
+	    CurrentBar->tail = prev;
+	if (CurrentBar->head == menu)
+	    CurrentBar->head = next;
+
+	for (next = menu->next; next != NULL; next = next->next)
+	    next->x -= len;
+    } else {
+	for (item = parent->tail; item != NULL; item = item->prev) {
+	    if (item->entry.type == MenuSubMenu
+		&& item->entry.submenu.menu == menu) {
+		item->entry.submenu.menu = NULL;
+		menuitem_free(menu->parent, item);
+		break;
+	    }
+	}
+    }
+
+    item = menu->tail;
+    while (item != NULL) {
+	menuitem_t     *p = item->prev;
+
+	menuitem_free(menu, item);
+	item = p;
+    }
+
+    if (menu->name != NULL)
+	FREE(menu->name);
+    FREE(menu);
+
+    return parent;
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+menu_t         *
+menu_add(menu_t *parent, char *path)
+{
+    menu_t         *menu;
+
+    assert(CurrentBar != NULL);
+
+    if (strchr(path, '/') != NULL) {
+	register char  *p;
+
+	if (path[0] == '/') {
+	/* shouldn't happen */
+	    path++;
+	    parent = NULL;
+	}
+	while ((p = strchr(path, '/')) != NULL) {
+	    p[0] = '\0';
+	    if (path[0] == '\0')
+		return NULL;
+
+	    parent = menu_add(parent, path);
+	    path = (p + 1);
+	}
+    }
+    if (!strcmp(path, DOTS))
+	return (parent != NULL ? parent->parent : parent);
+
+    if (!strcmp(path, DOT) || path[0] == '\0')
+	return parent;
+
+/* allocate a new menu */
+    if ((menu = (menu_t *) MALLOC(sizeof(menu_t))) == NULL)
+	return parent;
+
+    menu->width = 0;
+    menu->parent = parent;
+    menu->len = strlen(path);
+    menu->name = MALLOC((menu->len + 1));
+    if (menu->name == NULL) {
+	FREE(menu);
+	return parent;
+    }
+    STRCPY(menu->name, path);
+
+/* initialize head/tail */
+    menu->head = menu->tail = NULL;
+    menu->prev = menu->next = NULL;
+
+    menu->win = None;
+    menu->x = menu->y = menu->w = menu->h = 0;
+    menu->item = NULL;
+
+/* add to tail of list */
+    if (parent == NULL) {
+	menu->prev = CurrentBar->tail;
+	if (CurrentBar->tail != NULL)
+	    CurrentBar->tail->next = menu;
+	CurrentBar->tail = menu;
+	if (CurrentBar->head == NULL)
+	    CurrentBar->head = menu;	/* fix head */
+	if (menu->prev)
+	    menu->x = (menu->prev->x + menu->prev->len + HSPACE);
+    } else {
+	menuitem_t     *item;
+
+	item = menuitem_add(parent, path, "", "");
+	if (item == NULL) {
+	    FREE(menu);
+	    return parent;
+	}
+	assert(item->entry.type == MenuLabel);
+	item->entry.type = MenuSubMenu;
+	item->entry.submenu.menu = menu;
+    }
+
+    return menu;
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+drawbox_menubar(int x, int len, int state)
+{
+    GC              top, bot;
+
+    x = Width2Pixel(x);
+    len = Width2Pixel(len + HSPACE);
+    if (x >= TermWin.width)
+	return;
+    else if (x + len >= TermWin.width)
+	len = (TermWin_TotalWidth() - x);
+
+#ifdef MENUBAR_SHADOW_IN
+    state = -state;
+#endif
+    switch (state) {
+    case +1:
+	top = topShadowGC;
+	bot = botShadowGC;
+	break;			/* SHADOW_OUT */
+    case -1:
+	top = botShadowGC;
+	bot = topShadowGC;
+	break;			/* SHADOW_IN */
+    default:
+	top = bot = neutralGC;
+	break;			/* neutral */
+    }
+
+    Draw_Shadow(menuBar.win, top, bot,
+		x, 0, len, menuBar_TotalHeight());
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+drawtriangle(int x, int y, int state)
+{
+    GC              top, bot;
+    int             w;
+
+#ifdef MENU_SHADOW_IN
+    state = -state;
+#endif
+    switch (state) {
+    case +1:
+	top = topShadowGC;
+	bot = botShadowGC;
+	break;			/* SHADOW_OUT */
+    case -1:
+	top = botShadowGC;
+	bot = topShadowGC;
+	break;			/* SHADOW_IN */
+    default:
+	top = bot = neutralGC;
+	break;			/* neutral */
+    }
+
+    w = Height2Pixel(1) - 2 * SHADOW;
+
+    x -= SHADOW + (3 * w / 2);
+    y += SHADOW * 3;
+
+    Draw_Triangle(ActiveMenu->win, top, bot, x, y, w, 'r');
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+drawbox_menuitem(int y, int state)
+{
+    GC              top, bot;
+
+#ifdef MENU_SHADOW_IN
+    state = -state;
+#endif
+    switch (state) {
+    case +1:
+	top = topShadowGC;
+	bot = botShadowGC;
+	break;			/* SHADOW_OUT */
+    case -1:
+	top = botShadowGC;
+	bot = topShadowGC;
+	break;			/* SHADOW_IN */
+    default:
+	top = bot = neutralGC;
+	break;			/* neutral */
+    }
+
+    Draw_Shadow(ActiveMenu->win, top, bot,
+		SHADOW + 0,
+		SHADOW + y,
+		ActiveMenu->w - 2 * (SHADOW),
+		HEIGHT_TEXT + 2 * SHADOW);
+    XFlush(Xdisplay);
+}
+#endif
+
+#ifdef DEBUG_MENU_LAYOUT
+#ifdef MENUBAR
+/* INTPROTO */
+void
+print_menu_ancestors(menu_t *menu)
+{
+    if (menu == NULL) {
+	fprintf(stderr, "Top Level menu\n");
+	return;
+    }
+    fprintf(stderr, "menu %s ", menu->name);
+    if (menu->parent != NULL) {
+	menuitem_t     *item;
+
+	for (item = menu->parent->head; item != NULL; item = item->next) {
+	    if (item->entry.type == MenuSubMenu
+		&& item->entry.submenu.menu == menu) {
+		break;
+	    }
+	}
+	if (item == NULL) {
+	    fprintf(stderr, "is an orphan!\n");
+	    return;
+	}
+    }
+    fprintf(stderr, "\n");
+    print_menu_ancestors(menu->parent);
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+print_menu_descendants(menu_t *menu)
+{
+    menuitem_t     *item;
+    menu_t         *parent;
+    int             i, level = 0;
+
+    parent = menu;
+    do {
+	level++;
+	parent = parent->parent;
+    }
+    while (parent != NULL);
+
+    for (i = 0; i < level; i++)
+	fprintf(stderr, ">");
+    fprintf(stderr, "%s\n", menu->name);
+
+    for (item = menu->head; item != NULL; item = item->next) {
+	if (item->entry.type == MenuSubMenu) {
+	    if (item->entry.submenu.menu == NULL)
+		fprintf(stderr, "> %s == NULL\n", item->name);
+	    else
+		print_menu_descendants(item->entry.submenu.menu);
+	} else {
+	    for (i = 0; i < level; i++)
+		fprintf(stderr, "+");
+	    if (item->entry.type == MenuLabel)
+		fprintf(stderr, "label: ");
+	    fprintf(stderr, "%s\n", item->name);
+	}
+    }
+
+    for (i = 0; i < level; i++)
+	fprintf(stderr, "<");
+    fprintf(stderr, "\n");
+}
+#endif
+#endif
+
+#ifdef MENUBAR
+/* pop up/down the current menu and redraw the menuBar button */
+/* INTPROTO */
+void
+menu_show(void)
+{
+    int             x, y, xright;
+    menuitem_t     *item;
+
+    if (ActiveMenu == NULL)
+	return;
+
+    x = ActiveMenu->x;
+    if (ActiveMenu->parent == NULL) {
+	register int    h;
+
+	drawbox_menubar(x, ActiveMenu->len, -1);
+	x = Width2Pixel(x);
+
+	ActiveMenu->y = 1;
+	ActiveMenu->w = Menu_PixelWidth(ActiveMenu);
+
+	if ((x + ActiveMenu->w) >= TermWin.width)
+	    x = (TermWin_TotalWidth() - ActiveMenu->w);
+
+    /* find the height */
+	for (h = 0, item = ActiveMenu->head; item != NULL; item = item->next)
+	    h += isSeparator(item->name) ? HEIGHT_SEPARATOR
+					 : HEIGHT_TEXT + 2 * SHADOW;
+	ActiveMenu->h = h + 2 * SHADOW;
+    }
+    if (ActiveMenu->win == None) {
+	ActiveMenu->win = XCreateSimpleWindow(Xdisplay, TermWin.vt,
+					      x,
+					      ActiveMenu->y,
+					      ActiveMenu->w,
+					      ActiveMenu->h,
+					      0,
+					      PixColors[Color_fg],
+					      PixColors[Color_scroll]);
+	XMapWindow(Xdisplay, ActiveMenu->win);
+    }
+    Draw_Shadow(ActiveMenu->win,
+		topShadowGC, botShadowGC,
+		0, 0,
+		ActiveMenu->w, ActiveMenu->h);
+
+/* determine the correct right-alignment */
+    for (xright = 0, item = ActiveMenu->head; item != NULL; item = item->next)
+	if (item->len2 > xright)
+	    xright = item->len2;
+
+    for (y = 0, item = ActiveMenu->head; item != NULL; item = item->next) {
+	const int       xoff = (SHADOW + Width2Pixel(HSPACE) / 2);
+	register int    h;
+	GC              gc = menubarGC;
+
+	if (isSeparator(item->name)) {
+	    Draw_Shadow(ActiveMenu->win,
+			topShadowGC, botShadowGC,
+			SHADOW, y + SHADOW + 1,
+			ActiveMenu->w - 2 * SHADOW, 0);
+	    h = HEIGHT_SEPARATOR;
+	} else {
+	    char           *name = item->name;
+	    int             len = item->len;
+
+	    if (item->entry.type == MenuLabel) {
+		gc = botShadowGC;
+	    } else if (item->entry.type == MenuSubMenu) {
+		int             x1, y1;
+		menuitem_t     *it;
+		menu_t         *menu = item->entry.submenu.menu;
+
+		drawtriangle(ActiveMenu->w, y, +1);
+
+		name = menu->name;
+		len = menu->len;
+
+		y1 = ActiveMenu->y + y;
+
+		menu->w = Menu_PixelWidth(menu);
+
+	    /* place sub-menu at midpoint of parent menu */
+		x1 = ActiveMenu->w / 2;
+		if (x1 > menu->w)	/* right-flush menu if too small */
+		    x1 += (x1 - menu->w);
+		x1 += x;
+
+	    /* find the height of this submenu */
+		for (h = 0, it = menu->head; it != NULL; it = it->next)
+		    h += isSeparator(it->name) ? HEIGHT_SEPARATOR
+					       : HEIGHT_TEXT + 2 * SHADOW;
+		menu->h = h + 2 * SHADOW;
+
+	    /* ensure menu is in window limits */
+		if ((x1 + menu->w) >= TermWin.width)
+		    x1 = (TermWin_TotalWidth() - menu->w);
+
+		if ((y1 + menu->h) >= TermWin.height)
+		    y1 = (TermWin_TotalHeight() - menu->h);
+
+		menu->x = (x1 < 0 ? 0 : x1);
+		menu->y = (y1 < 0 ? 0 : y1);
+	    } else if (item->name2 && !strcmp(name, item->name2))
+		name = NULL;
+
+	    if (len && name)
+		XDrawString(Xdisplay,
+			    ActiveMenu->win, gc,
+			    xoff,
+			    2 * SHADOW + y + TermWin.font->ascent + 1,
+			    name, len);
+
+	    len = item->len2;
+	    name = item->name2;
+	    if (len && name)
+		XDrawString(Xdisplay,
+			    ActiveMenu->win, gc,
+			    ActiveMenu->w - (xoff + Width2Pixel(xright)),
+			    2 * SHADOW + y + TermWin.font->ascent + 1,
+			    name, len);
+
+	    h = HEIGHT_TEXT + 2 * SHADOW;
+	}
+	y += h;
+    }
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+menu_display(void (*update) (void))
+{
+    if (ActiveMenu == NULL)
+	return;
+    if (ActiveMenu->win != None)
+	XDestroyWindow(Xdisplay, ActiveMenu->win);
+    ActiveMenu->win = None;
+    ActiveMenu->item = NULL;
+
+    if (ActiveMenu->parent == NULL)
+	drawbox_menubar(ActiveMenu->x, ActiveMenu->len, +1);
+    ActiveMenu = ActiveMenu->parent;
+    update();
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+menu_hide_all(void)
+{
+    menu_display(menu_hide_all);
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+menu_hide(void)
+{
+    menu_display(menu_show);
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+menu_clear(menu_t *menu)
+{
+    if (menu != NULL) {
+	menuitem_t     *item = menu->tail;
+
+	while (item != NULL) {
+	    menuitem_free(menu, item);
+	/* it didn't get freed ... why? */
+	    if (item == menu->tail)
+		return;
+	    item = menu->tail;
+	}
+	menu->width = 0;
+    }
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+menubar_clear(void)
+{
+    if (CurrentBar != NULL) {
+	menu_t         *menu = CurrentBar->tail;
+
+	while (menu != NULL) {
+	    menu_t         *prev = menu->prev;
+
+	    menu_delete(menu);
+	    menu = prev;
+	}
+	CurrentBar->head = CurrentBar->tail = ActiveMenu = NULL;
+
+	if (CurrentBar->title) {
+	    FREE(CurrentBar->title);
+	    CurrentBar->title = NULL;
+	}
+	menuarrow_free(0);	/* remove all arrow functions */
+    }
+    ActiveMenu = NULL;
+}
+#endif
+
+#if (MENUBAR_MAX > 1)
+#ifdef MENUBAR
+/* find if menu already exists */
+/* INTPROTO */
+bar_t          *
+menubar_find(const char *name)
+{
+    bar_t          *bar = CurrentBar;
+
+#ifdef DEBUG_MENUBAR_STACKING
+    fprintf(stderr, "looking for [menu:%s] ...", name ? name : "(nil)");
+#endif
+    if (bar == NULL || name == NULL)
+	return NULL;
+
+    if (strlen(name) && strcmp(name, "*")) {
+	do {
+	    if (!strcmp(bar->name, name)) {
+#ifdef DEBUG_MENUBAR_STACKING
+		fprintf(stderr, " found!\n");
+#endif
+		return bar;
+	    }
+	    bar = bar->next;
+	}
+	while (bar != CurrentBar);
+	bar = NULL;
+    }
+#ifdef DEBUG_MENUBAR_STACKING
+    fprintf(stderr, "%s found!\n", (bar ? "" : " NOT"));
+#endif
+
+    return bar;
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+int
+menubar_push(const char *name)
+{
+    int             ret = 1;
+    bar_t          *bar;
+
+    if (CurrentBar == NULL) {
+    /* allocate first one */
+	bar = (bar_t *) MALLOC(sizeof(bar_t));
+
+	if (bar == NULL)
+	    return 0;
+
+	MEMSET(bar, 0, sizeof(bar_t));
+    /* circular linked-list */
+	bar->next = bar->prev = bar;
+	bar->head = bar->tail = NULL;
+	bar->title = NULL;
+	CurrentBar = bar;
+	Nbars++;
+
+	menubar_clear();
+    } else {
+    /* find if menu already exists */
+	bar = menubar_find(name);
+	if (bar != NULL) {
+	/* found it, use it */
+	    CurrentBar = bar;
+	} else {
+	/* create if needed, or reuse the existing empty menubar */
+	    if (CurrentBar->head != NULL) {
+	    /* need to malloc another one */
+		if (Nbars < MENUBAR_MAX)
+		    bar = (bar_t *) MALLOC(sizeof(bar_t));
+		else
+		    bar = NULL;
+
+	    /* malloc failed or too many menubars, reuse another */
+		if (bar == NULL) {
+		    bar = CurrentBar->next;
+		    ret = -1;
+		} else {
+		    bar->head = bar->tail = NULL;
+		    bar->title = NULL;
+
+		    bar->next = CurrentBar->next;
+		    CurrentBar->next = bar;
+		    bar->prev = CurrentBar;
+		    bar->next->prev = bar;
+
+		    Nbars++;
+		}
+		CurrentBar = bar;
+
+	    }
+	    menubar_clear();
+	}
+    }
+
+/* give menubar this name */
+    STRNCPY(CurrentBar->name, name, MAXNAME);
+    CurrentBar->name[MAXNAME - 1] = '\0';
+
+    return ret;
+}
+#endif
+
+#ifdef MENUBAR
+/* switch to a menu called NAME and remove it */
+/* INTPROTO */
+void
+menubar_remove(const char *name)
+{
+    bar_t          *bar;
+
+    if ((bar = menubar_find(name)) == NULL)
+	return;
+    CurrentBar = bar;
+
+    do {
+	menubar_clear();
+    /*
+     * pop a menubar, clean it up first
+     */
+	if (CurrentBar != NULL) {
+	    bar_t          *prev = CurrentBar->prev;
+	    bar_t          *next = CurrentBar->next;
+
+	    if (prev == next && prev == CurrentBar) {	/* only 1 left */
+		prev = NULL;
+		Nbars = 0;	/* safety */
+	    } else {
+		next->prev = prev;
+		prev->next = next;
+		Nbars--;
+	    }
+
+	    FREE(CurrentBar);
+	    CurrentBar = prev;
+	}
+    }
+    while (CurrentBar && !strcmp(name, "*"));
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+action_decode(FILE *fp, action_t *act)
+{
+    unsigned char  *str;
+    short           len;
+
+    if (act == NULL || (len = act->len) == 0 || (str = act->str) == NULL)
+	return;
+
+    if (act->type == MenuTerminalAction) {
+	fprintf(fp, "^@");
+    /* can strip trailing ^G from XTerm sequence */
+	if (str[0] == 033 && str[1] == ']' && str[len - 1] == 007)
+	    len--;
+    } else if (str[0] == 033) {
+	switch (str[1]) {
+	case '[':
+	case ']':
+	    break;
+
+	case 'x':
+	/* can strip trailing '\r' from M-x sequence */
+	    if (str[len - 1] == '\r')
+		len--;
+	/* FALLTHROUGH */
+
+	default:
+	    fprintf(fp, "M-");	/* meta prefix */
+	    str++;
+	    len--;
+	    break;
+	}
+    }
+/*
+ * control character form is preferred, since backslash-escaping
+ * can be really ugly looking when the backslashes themselves also
+ * have to be escaped to avoid Shell (or whatever scripting
+ * language) interpretation
+ */
+    while (len > 0) {
+	unsigned char   ch = *str++;
+
+	switch (ch) {
+	case 033:
+	    fprintf(fp, "\\E");
+	    break;		/* escape */
+	case '\r':
+	    fprintf(fp, "\\r");
+	    break;		/* carriage-return */
+	case '\\':
+	    fprintf(fp, "\\\\");
+	    break;		/* backslash */
+	case '^':
+	    fprintf(fp, "\\^");
+	    break;		/* caret */
+	case 127:
+	    fprintf(fp, "^?");
+	default:
+	    if (ch <= 31)
+		fprintf(fp, "^%c", ('@' + ch));
+	    else if (ch > 127)
+		fprintf(fp, "\\%o", ch);
+	    else
+		fprintf(fp, "%c", ch);
+	    break;
+	}
+	len--;
+    }
+    fprintf(fp, "\n");
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+menu_dump(FILE *fp, menu_t *menu)
+{
+    menuitem_t     *item;
+
+/* create a new menu and clear it */
+    fprintf(fp, (menu->parent ? "./%s/*\n" : "/%s/*\n"), menu->name);
+
+    for (item = menu->head; item != NULL; item = item->next) {
+	switch (item->entry.type) {
+	case MenuSubMenu:
+	    if (item->entry.submenu.menu == NULL)
+		fprintf(fp, "> %s == NULL\n", item->name);
+	    else
+		menu_dump(fp, item->entry.submenu.menu);
+	    break;
+
+	case MenuLabel:
+	    fprintf(fp, "{%s}\n",
+		    (strlen(item->name) ? item->name : "-"));
+	    break;
+
+	case MenuTerminalAction:
+	case MenuAction:
+	    fprintf(fp, "{%s}", item->name);
+	    if (item->name2 != NULL && strlen(item->name2))
+		fprintf(fp, "{%s}", item->name2);
+	    fprintf(fp, "\t");
+	    action_decode(fp, &(item->entry.action));
+	    break;
+	}
+    }
+
+    fprintf(fp, (menu->parent ? "../\n" : "/\n\n"));
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+menubar_dump(FILE *fp)
+{
+    bar_t          *bar = CurrentBar;
+    time_t          t;
+
+    if (bar == NULL || fp == NULL)
+	return;
+    time(&t);
+
+    fprintf(fp,
+	    "# " APL_SUBCLASS " (%s)  Pid: %u\n# Date: %s\n\n",
+	    rs[Rs_name], (unsigned int)getpid(), ctime(&t));
+
+/* dump in reverse order */
+    bar = CurrentBar->prev;
+    do {
+	menu_t         *menu;
+	int             i;
+
+	fprintf(fp, "[menu:%s]\n", bar->name);
+
+	if (bar->title != NULL)
+	    fprintf(fp, "[title:%s]\n", bar->title);
+
+	for (i = 0; i < NARROWS; i++) {
+	    switch (bar->arrows[i].type) {
+	    case MenuTerminalAction:
+	    case MenuAction:
+		fprintf(fp, "<%c>", Arrows[i].name);
+		action_decode(fp, &(bar->arrows[i]));
+		break;
+	    }
+	}
+	fprintf(fp, "\n");
+
+	for (menu = bar->head; menu != NULL; menu = menu->next)
+	    menu_dump(fp, menu);
+
+	fprintf(fp, "\n[done:%s]\n\n", bar->name);
+	bar = bar->prev;
+    }
+    while (bar != CurrentBar->prev);
+}
+#endif
+#endif				/* (MENUBAR_MAX > 1) */
+
+/*
+ * read in menubar commands from FILENAME
+ * ignore all input before the tag line [menu] or [menu:???]
+ *
+ * Note that since File_find () is used, FILENAME can be semi-colon
+ * delimited such that the second part can refer to a tag
+ * so that a large `database' of menus can be collected together
+ *
+ * FILENAME = "file"
+ * FILENAME = "file;"
+ *      read `file' starting with first [menu] or [menu:???] line
+ *
+ * FILENAME = "file;tag"
+ *      read `file' starting with [menu:tag]
+ */
+/* EXTPROTO */
+void
+menubar_read(const char *filename)
+{
+#ifdef MENUBAR
+/* read in a menu from a file */
+    FILE           *fp;
+    char            buffer[256];
+    char           *p, *file, *tag = NULL;
+
+    file = (char *) File_find(filename, ".menu");
+    if (file == NULL)
+	return;
+    fp = fopen(file, "rb");
+    FREE(file);
+    if (fp == NULL)
+	return;
+
+#if (MENUBAR_MAX > 1)
+/* semi-colon delimited */
+    if ((tag = strchr(filename, ';')) != NULL) {
+	tag++;
+	if (*tag == '\0')
+	    tag = NULL;
+    }
+#endif				/* (MENUBAR_MAX > 1) */
+#ifdef DEBUG_MENU
+    fprintf(stderr, "[read:%s]\n", p);
+    if (tag)
+	fprintf(stderr, "looking for [menu:%s]\n", tag);
+#endif
+
+    while ((p = fgets(buffer, sizeof(buffer), fp)) != NULL) {
+	int             n;
+
+	if ((n = Str_match(p, "[menu")) != 0) {
+	    if (tag) {
+	    /* looking for [menu:tag] */
+		if (p[n] == ':' && p[n + 1] != ']') {
+		    n++;
+		    n += Str_match(p + n, tag);
+		    if (p[n] == ']') {
+#ifdef DEBUG_MENU
+			fprintf(stderr, "[menu:%s]\n", tag);
+#endif
+			break;
+		    }
+		}
+	    } else if (p[n] == ':' || p[n] == ']')
+		break;
+	}
+    }
+
+/* found [menu], [menu:???] tag */
+    while (p != NULL) {
+	int             n;
+
+#ifdef DEBUG_MENU
+	fprintf(stderr, "read line = %s\n", p);
+#endif
+
+    /* looking for [done:tag] or [done:] */
+	if ((n = Str_match(p, "[done")) != 0) {
+	    if (p[n] == ']') {
+		menu_readonly = 1;
+		break;
+	    } else if (p[n] == ':') {
+		n++;
+		if (p[n] == ']') {
+		    menu_readonly = 1;
+		    break;
+		} else if (tag) {
+		    n += Str_match(p + n, tag);
+		    if (p[n] == ']') {
+#ifdef DEBUG_MENU
+			fprintf(stderr, "[done:%s]\n", tag);
+#endif
+			menu_readonly = 1;
+			break;
+		    }
+		} else {
+		/* what? ... skip this line */
+		    p[0] = COMMENT_CHAR;
+		}
+	    }
+	}
+    /*
+     * remove leading/trailing space
+     * and strip-off leading/trailing quotes
+     * skip blank or comment lines
+     */
+	(void) Str_trim(p);
+	if (*p && *p != '#') {
+	    menu_readonly = 0;	/* if case we read another file */
+	    menubar_dispatch(p);
+	}
+    /* get another line */
+	p = fgets(buffer, sizeof(buffer), fp);
+    }
+
+    fclose(fp);
+#endif
+}
+
+/*
+ * user interface for building/deleting and otherwise managing menus
+ */
+/* EXTPROTO */
+void
+menubar_dispatch(char *str)
+{
+#ifdef MENUBAR
+    static menu_t  *BuildMenu = NULL;	/* the menu currently being built */
+    int             n, cmd;
+    char           *path, *name, *name2;
+
+    if (menubar_visible() && ActiveMenu != NULL)
+	menubar_expose();
+    else
+	ActiveMenu = NULL;
+
+    cmd = *str;
+    switch (cmd) {
+    case '.':
+    case '/':			/* absolute & relative path */
+    case MENUITEM_BEG:		/* menuitem */
+    /* add `+' prefix for these cases */
+	cmd = '+';
+	break;
+
+    case '+':
+    case '-':
+	str++;			/* skip cmd character */
+	break;
+
+    case '<':
+#if (MENUBAR_MAX > 1)
+	if (CurrentBar == NULL)
+	    break;
+#endif				/* (MENUBAR_MAX > 1) */
+	if (str[1] && str[2] == '>')	/* arrow commands */
+	    menuarrow_add(str);
+	break;
+
+    case '[':			/* extended command */
+	while (str[0] == '[') {
+	    char           *next = (++str);	/* skip leading '[' */
+
+	    if (str[0] == ':') {	/* [:command:] */
+		do {
+		    next++;
+		    if ((next = strchr(next, ':')) == NULL)
+			return;	/* parse error */
+		}
+		while (next[1] != ']');
+	    /* remove and skip ':]' */
+		*next = '\0';
+		next += 2;
+	    } else {
+		if ((next = strchr(next, ']')) == NULL)
+		    return;	/* parse error */
+	    /* remove and skip ']' */
+		*next = '\0';
+		next++;
+	    }
+
+	    if (str[0] == ':') {
+		int             saved;
+
+	    /* try and dispatch it, regardless of read/write status */
+		saved = menu_readonly;
+		menu_readonly = 0;
+		menubar_dispatch(str + 1);
+		menu_readonly = saved;
+	    }
+	/* these ones don't require menu stacking */
+	    else if (!strcmp(str, "clear")) {
+		menubar_clear();
+	    } else if (!strcmp(str, "done") || Str_match(str, "done:")) {
+		menu_readonly = 1;
+	    } else if (!strcmp(str, "show")) {
+		map_menuBar(1);
+		menu_readonly = 1;
+	    } else if (!strcmp(str, "hide")) {
+		map_menuBar(0);
+		menu_readonly = 1;
+	    } else if ((n = Str_match(str, "read:")) != 0) {
+	    /* read in a menu from a file */
+		str += n;
+		menubar_read(str);
+	    } else if ((n = Str_match(str, "title:")) != 0) {
+		str += n;
+		if (CurrentBar != NULL && !menu_readonly) {
+		    if (*str) {
+			name = REALLOC(CurrentBar->title, strlen(str) + 1);
+			if (name != NULL) {
+			    STRCPY(name, str);
+			    CurrentBar->title = name;
+			}
+			menubar_expose();
+		    } else {
+			FREE(CurrentBar->title);
+			CurrentBar->title = NULL;
+		    }
+		}
+	    } else if ((n = Str_match(str, "pixmap:")) != 0) {
+		str += n;
+		xterm_seq(XTerm_Pixmap, str);
+	    }
+#if (MENUBAR_MAX > 1)
+	    else if ((n = Str_match(str, "rm")) != 0) {
+		str += n;
+		switch (str[0]) {
+		case ':':
+		    str++;
+		    menubar_remove(str);
+		    break;
+
+		case '\0':
+		    menubar_remove(str);
+		    break;
+
+		case '*':
+		    menubar_remove(str);
+		    break;
+		}
+		menu_readonly = 1;
+	    } else if ((n = Str_match(str, "menu")) != 0) {
+		str += n;
+		switch (str[0]) {
+		case ':':
+		    str++;
+		/* add/access menuBar */
+		    if (*str != '\0' && *str != '*')
+			menubar_push(str);
+		    break;
+		default:
+		    if (CurrentBar == NULL) {
+			menubar_push("default");
+		    }
+		}
+
+		if (CurrentBar != NULL)
+		    menu_readonly = 0;	/* allow menu build commands */
+	    } else if (!strcmp(str, "dump")) {
+	    /* dump current menubars to a file */
+		FILE           *fp;
+
+	    /* enough space to hold the results */
+		char            buffer[32];
+
+		sprintf(buffer, "/tmp/" APL_SUBCLASS "-%u",
+			(unsigned int)getpid());
+
+		if ((fp = fopen(buffer, "wb")) != NULL) {
+		    xterm_seq(XTerm_title, buffer);
+		    menubar_dump(fp);
+		    fclose(fp);
+		}
+	    } else if (!strcmp(str, "next")) {
+		if (CurrentBar) {
+		    CurrentBar = CurrentBar->next;
+		    menu_readonly = 1;
+		}
+	    } else if (!strcmp(str, "prev")) {
+		if (CurrentBar) {
+		    CurrentBar = CurrentBar->prev;
+		    menu_readonly = 1;
+		}
+	    } else if (!strcmp(str, "swap")) {
+	    /* swap the top 2 menus */
+		if (CurrentBar) {
+		    bar_t          *prev = CurrentBar->prev;
+		    bar_t          *next = CurrentBar->next;
+
+		    prev->next = next;
+		    next->prev = prev;
+
+		    CurrentBar->next = prev;
+		    CurrentBar->prev = prev->prev;
+
+		    prev->prev->next = CurrentBar;
+		    prev->prev = CurrentBar;
+
+		    CurrentBar = prev;
+		    menu_readonly = 1;
+		}
+	    }
+#endif				/* (MENUBAR_MAX > 1) */
+	    str = next;
+
+	    BuildMenu = ActiveMenu = NULL;
+	    menubar_expose();
+#ifdef DEBUG_MENUBAR_STACKING
+	    fprintf(stderr, "menus are read%s\n", menu_readonly ? "only" : "/write");
+#endif
+	}
+	return;
+	break;
+    }
+
+#if (MENUBAR_MAX > 1)
+    if (CurrentBar == NULL)
+	return;
+    if (menu_readonly) {
+#ifdef DEBUG_MENUBAR_STACKING
+	fprintf(stderr, "menus are read%s\n", menu_readonly ? "only" : "/write");
+#endif
+	return;
+    }
+#endif				/* (MENUBAR_MAX > 1) */
+
+    switch (cmd) {
+    case '+':
+    case '-':
+	path = name = str;
+
+	name2 = NULL;
+    /* parse STR, allow spaces inside (name)  */
+	if (path[0] != '\0') {
+	    name = strchr(path, MENUITEM_BEG);
+	    str = strchr(path, MENUITEM_END);
+	    if (name != NULL || str != NULL) {
+		if (name == NULL || str == NULL || str <= (name + 1)
+		    || (name > path && name[-1] != '/')) {
+		    print_error("menu error <%s>\n", path);
+		    break;
+		}
+		if (str[1] == MENUITEM_BEG) {
+		    name2 = (str + 2);
+		    str = strchr(name2, MENUITEM_END);
+
+		    if (str == NULL) {
+			print_error("menu error <%s>\n", path);
+			break;
+		    }
+		    name2[-2] = '\0';	/* remove prev MENUITEM_END */
+		}
+		if (name > path && name[-1] == '/')
+		    name[-1] = '\0';
+
+		*name++ = '\0';	/* delimit */
+		*str++ = '\0';	/* delimit */
+
+		while (isspace(*str))
+		    str++;	/* skip space */
+	    }
+#ifdef DEBUG_MENU
+	    fprintf(stderr, "`%c' path = <%s>, name = <%s>, name2 = <%s>, action = <%s>\n",
+		    cmd,
+		    (path ? path : "(nil)"),
+		    (name ? name : "(nil)"),
+		    (name2 ? name2 : "(nil)"),
+		    (str ? str : "(nil)")
+		);
+#endif
+	}
+    /* process the different commands */
+	switch (cmd) {
+	case '+':		/* add/replace existing menu or menuitem */
+	    if (path[0] != '\0') {
+		int             len;
+
+		path = menu_find_base(&BuildMenu, path);
+		len = strlen(path);
+
+	    /* don't allow menus called `*' */
+		if (path[0] == '*') {
+		    menu_clear(BuildMenu);
+		    break;
+		} else if (len >= 2 && !strcmp((path + len - 2), "/*")) {
+		    path[len - 2] = '\0';
+		}
+		if (path[0] != '\0')
+		    BuildMenu = menu_add(BuildMenu, path);
+	    }
+	    if (name != NULL && name[0] != '\0')
+		menuitem_add(BuildMenu,
+			     (strcmp(name, SEPARATOR_NAME) ? name : ""),
+			     name2, str);
+	    break;
+
+	case '-':		/* delete menu entry */
+	    if (!strcmp(path, "/*") && (name == NULL || name[0] == '\0')) {
+		menubar_clear();
+		BuildMenu = NULL;
+		menubar_expose();
+		break;
+	    } else if (path[0] != '\0') {
+		int             len;
+		menu_t         *menu = BuildMenu;
+
+		path = menu_find_base(&menu, path);
+		len = strlen(path);
+
+	    /* submenu called `*' clears all menu items */
+		if (path[0] == '*') {
+		    menu_clear(menu);
+		    break;	/* done */
+		} else if (len >= 2 && !strcmp(&path[len - 2], "/*")) {
+		/* done */
+		    break;
+		} else if (path[0] != '\0') {
+		    BuildMenu = NULL;
+		    break;
+		} else {
+		    BuildMenu = menu;
+		}
+	    }
+	    if (BuildMenu != NULL) {
+		if (name == NULL || name[0] == '\0') {
+		    BuildMenu = menu_delete(BuildMenu);
+		} else {
+		    menuitem_t     *item;
+
+		    item = menuitem_find(BuildMenu,
+				         strcmp(name, SEPARATOR_NAME) ? name
+								      : "");
+
+		    if (item != NULL && item->entry.type != MenuSubMenu) {
+			menuitem_free(BuildMenu, item);
+
+		    /* fix up the width */
+			BuildMenu->width = 0;
+			for (item = BuildMenu->head;
+			     item != NULL;
+			     item = item->next) {
+			    if (BuildMenu->width < (item->len + item->len2))
+				BuildMenu->width = (item->len + item->len2);
+			}
+		    }
+		}
+		menubar_expose();
+	    }
+	    break;
+	}
+	break;
+    }
+#endif
+}
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+draw_Arrows(int name, int state)
+{
+    GC              top, bot;
+
+    int             i;
+
+#ifdef MENU_SHADOW_IN
+    state = -state;
+#endif
+    switch (state) {
+    case +1:
+	top = topShadowGC;
+	bot = botShadowGC;
+	break;			/* SHADOW_OUT */
+    case -1:
+	top = botShadowGC;
+	bot = topShadowGC;
+	break;			/* SHADOW_IN */
+    default:
+	top = bot = neutralGC;
+	break;			/* neutral */
+    }
+
+    if (!Arrows_x)
+	return;
+
+    for (i = 0; i < NARROWS; i++) {
+	const int       w = Width2Pixel(1);
+	const int       y = (menuBar_TotalHeight() - w) / 2;
+	int             x = Arrows_x + (5 * Width2Pixel(i)) / 4;
+
+	if (!name || name == Arrows[i].name)
+	    Draw_Triangle(menuBar.win, top, bot, x, y, w,
+			  Arrows[i].name);
+    }
+    XFlush(Xdisplay);
+}
+#endif
+
+/* EXTPROTO */
+void
+menubar_expose(void)
+{
+#ifdef MENUBAR
+    menu_t         *menu;
+    int             x;
+
+    if (!menubar_visible() || menuBar.win == 0)
+	return;
+
+    if (menubarGC == None) {
+    /* Create the graphics context */
+	XGCValues       gcvalue;
+
+	gcvalue.font = TermWin.font->fid;
+
+	gcvalue.foreground = (Xdepth <= 2 ?
+			      PixColors[Color_fg] :
+			      PixColors[Color_Black]);
+	menubarGC = XCreateGC(Xdisplay, menuBar.win,
+			      GCForeground | GCFont,
+			      &gcvalue);
+
+	gcvalue.foreground = PixColors[Color_scroll];
+	neutralGC = XCreateGC(Xdisplay, menuBar.win,
+			      GCForeground,
+			      &gcvalue);
+
+	gcvalue.foreground = PixColors[Color_bottomShadow];
+	botShadowGC = XCreateGC(Xdisplay, menuBar.win,
+				GCForeground | GCFont,
+				&gcvalue);
+
+	gcvalue.foreground = PixColors[Color_topShadow];
+	topShadowGC = XCreateGC(Xdisplay, menuBar.win,
+				GCForeground,
+				&gcvalue);
+    }
+/* make sure the font is correct */
+    XSetFont(Xdisplay, menubarGC, TermWin.font->fid);
+    XSetFont(Xdisplay, botShadowGC, TermWin.font->fid);
+    XClearWindow(Xdisplay, menuBar.win);
+
+    menu_hide_all();
+
+    x = 0;
+    if (CurrentBar != NULL) {
+	for (menu = CurrentBar->head; menu != NULL; menu = menu->next) {
+	    int             len = menu->len;
+
+	    x = (menu->x + menu->len + HSPACE);
+
+#ifdef DEBUG_MENU_LAYOUT
+	    print_menu_descendants(menu);
+#endif
+
+	    if (x >= TermWin.ncol)
+		len = (TermWin.ncol - (menu->x + HSPACE));
+
+	    drawbox_menubar(menu->x, len, +1);
+
+	    XDrawString(Xdisplay,
+			menuBar.win, menubarGC,
+			(Width2Pixel(menu->x) + Width2Pixel(HSPACE) / 2),
+			menuBar_height() - SHADOW,
+			menu->name, len);
+
+	    if (x >= TermWin.ncol)
+		break;
+	}
+    }
+    drawbox_menubar(x, TermWin.ncol, (CurrentBar ? +1 : -1));
+
+/* add the menuBar title, if it exists and there's plenty of room */
+    Arrows_x = 0;
+    if (x < TermWin.ncol) {
+	const char     *str;
+	int             len, ncol = TermWin.ncol;
+	char            title[256];
+
+	if (x < (ncol - (NARROWS + 1))) {
+	    ncol -= (NARROWS + 1);
+	    Arrows_x = Width2Pixel(ncol);
+	}
+	draw_Arrows(0, +1);
+
+	str = (CurrentBar && CurrentBar->title) ? CurrentBar->title
+						: "%n-%v";
+	for (len = 0; str[0] && len < sizeof(title) - 1; str++) {
+	    const char     *s = NULL;
+
+	    switch (str[0]) {
+	    case '%':
+		str++;
+		switch (str[0]) {
+		case 'n':
+		    s = rs[Rs_name];
+		    break;	/* resource name */
+		case 'v':
+		    s = VERSION;
+		    break;	/* version number */
+		case '%':
+		    s = "%";
+		    break;	/* literal '%' */
+		}
+		if (s != NULL)
+		    while (*s && len < sizeof(title) - 1)
+			title[len++] = *s++;
+		break;
+
+	    default:
+		title[len++] = str[0];
+		break;
+	    }
+	}
+	title[len] = '\0';
+
+	ncol -= (x + len + HSPACE);
+	if (len > 0 && ncol >= 0)
+	    XDrawString(Xdisplay,
+			menuBar.win, menubarGC,
+			Width2Pixel(x) + Width2Pixel(ncol + HSPACE) / 2,
+			menuBar_height() - SHADOW,
+			title, len);
+    }
+#endif
+}
+
+/* EXTPROTO */
+int
+menubar_mapping(int map)
+{
+#ifdef MENUBAR
+    int             change = 0;
+
+    if (map && !menubar_visible()) {
+	menuBar.state = 1;
+	if (menuBar.win == 0)
+	    return 0;
+	XMapWindow(Xdisplay, menuBar.win);
+	change = 1;
+    } else if (!map && menubar_visible()) {
+	menubar_expose();
+	menuBar.state = 0;
+	XUnmapWindow(Xdisplay, menuBar.win);
+	change = 1;
+    } else
+	menubar_expose();
+
+    return change;
+#endif
+}
+
+#ifdef MENUBAR
+/* INTPROTO */
+int
+menu_select(XButtonEvent *ev)
+{
+    menuitem_t     *thisitem, *item = NULL;
+    int             this_y, y;
+
+    Window          unused_root, unused_child;
+    int             unused_root_x, unused_root_y;
+    unsigned int    unused_mask;
+
+    if (ActiveMenu == NULL)
+	return 0;
+
+    XQueryPointer(Xdisplay, ActiveMenu->win,
+		  &unused_root, &unused_child,
+		  &unused_root_x, &unused_root_y,
+		  &(ev->x), &(ev->y),
+		  &unused_mask);
+
+    if (ActiveMenu->parent != NULL && (ev->x < 0 || ev->y < 0)) {
+	menu_hide();
+	return 1;
+    }
+/* determine the menu item corresponding to the Y index */
+    y = SHADOW;
+    if (ev->x >= 0
+	&& ev->x <= (ActiveMenu->w - SHADOW)) {
+	for (item = ActiveMenu->head; item != NULL; item = item->next) {
+	    int             h = HEIGHT_TEXT + 2 * SHADOW;
+
+	    if (isSeparator(item->name))
+		h = HEIGHT_SEPARATOR;
+	    else if (ev->y >= y && ev->y < (y + h))
+		break;
+	    y += h;
+	}
+    }
+    if (item == NULL && ev->type == ButtonRelease) {
+	menu_hide_all();
+	return 0;
+    }
+    thisitem = item;
+    this_y = y - SHADOW;
+
+/* erase the last item */
+    if (ActiveMenu->item != NULL) {
+	if (ActiveMenu->item != thisitem) {
+	    for (y = 0, item = ActiveMenu->head;
+		 item != NULL;
+		 item = item->next) {
+		int             h;
+
+		if (isSeparator(item->name))
+		    h = HEIGHT_SEPARATOR;
+		else if (item == ActiveMenu->item) {
+		/* erase old menuitem */
+		    drawbox_menuitem(y, 0);	/* No Shadow */
+		    if (item->entry.type == MenuSubMenu)
+			drawtriangle(ActiveMenu->w, y, +1);
+		    break;
+		} else
+		    h = HEIGHT_TEXT + 2 * SHADOW;
+		y += h;
+	    }
+	} else {
+	    switch (ev->type) {
+	    case ButtonRelease:
+		switch (item->entry.type) {
+		case MenuLabel:
+		case MenuSubMenu:
+		    menu_hide_all();
+		    break;
+
+		case MenuAction:
+		case MenuTerminalAction:
+		    drawbox_menuitem(this_y, -1);
+		/*
+		 * use select for timing
+		 * remove menu before sending keys to the application
+		 */
+		    {
+			struct timeval  tv;
+
+			tv.tv_sec = 0;
+			tv.tv_usec = MENU_DELAY_USEC;
+			select(0, NULL, NULL, NULL, &tv);
+		    }
+		    menu_hide_all();
+#ifndef DEBUG_MENU
+		    action_dispatch(&(item->entry.action));
+#else				/* DEBUG_MENU */
+		    fprintf(stderr, "%s: %s\n", item->name, item->entry.action.str);
+#endif				/* DEBUG_MENU */
+		    break;
+		}
+		break;
+
+	    default:
+		if (item->entry.type == MenuSubMenu)
+		    goto DoMenu;
+		break;
+	    }
+	    return 0;
+	}
+    }
+  DoMenu:
+    ActiveMenu->item = thisitem;
+    y = this_y;
+    if (thisitem != NULL) {
+	item = ActiveMenu->item;
+	if (item->entry.type != MenuLabel)
+	    drawbox_menuitem(y, +1);
+	if (item->entry.type == MenuSubMenu) {
+	    int             x;
+
+	    drawtriangle(ActiveMenu->w, y, -1);
+
+	    x = ev->x + (ActiveMenu->parent ?
+			 ActiveMenu->x :
+			 Width2Pixel(ActiveMenu->x));
+
+	    if (x >= item->entry.submenu.menu->x) {
+		ActiveMenu = item->entry.submenu.menu;
+		menu_show();
+		return 1;
+	    }
+	}
+    }
+    return 0;
+}
+#endif
+
+#ifdef MENUBAR
+/* INTPROTO */
+void
+menubar_select(XButtonEvent *ev)
+{
+    menu_t         *menu = NULL;
+
+/* determine the pulldown menu corresponding to the X index */
+    if (ev->y >= 0 && ev->y <= menuBar_height() && CurrentBar != NULL) {
+	for (menu = CurrentBar->head; menu != NULL; menu = menu->next) {
+	    int             x = Width2Pixel(menu->x);
+	    int             w = Width2Pixel(menu->len + HSPACE);
+
+	    if ((ev->x >= x && ev->x < x + w))
+		break;
+	}
+    }
+    switch (ev->type) {
+    case ButtonRelease:
+	menu_hide_all();
+	break;
+
+    case ButtonPress:
+	if (menu == NULL && Arrows_x && ev->x >= Arrows_x) {
+	    int             i;
+
+	    for (i = 0; i < NARROWS; i++) {
+		if (ev->x >= (Arrows_x + (Width2Pixel(4 * i + i)) / 4)
+		    && ev->x < (Arrows_x + (Width2Pixel(4 * i + i + 4)) / 4)) {
+		    draw_Arrows(Arrows[i].name, -1);
+		/*
+		 * use select for timing
+		 */
+		    {
+			struct timeval  tv;
+
+			tv.tv_sec = 0;
+			tv.tv_usec = MENU_DELAY_USEC;
+			select(0, NULL, NULL, NULL, &tv);
+		    }
+		    draw_Arrows(Arrows[i].name, +1);
+#ifdef DEBUG_MENUARROWS
+		    fprintf(stderr, "'%c': ", Arrows[i].name);
+
+		    if (CurrentBar == NULL
+			|| (CurrentBar->arrows[i].type != MenuAction
+			    && CurrentBar->arrows[i].type != MenuTerminalAction)) {
+			if (Arrows[i].str != NULL && Arrows[i].str[0])
+			    fprintf(stderr, "(default) \\033%s\n",
+				    &(Arrows[i].str[2]));
+		    } else {
+			fprintf(stderr, "%s\n", CurrentBar->arrows[i].str);
+		    }
+#else				/* DEBUG_MENUARROWS */
+		    if (CurrentBar == NULL
+			|| action_dispatch(&(CurrentBar->arrows[i]))) {
+			if (Arrows[i].str != NULL
+			    && Arrows[i].str[0] != 0)
+			    tt_write((Arrows[i].str + 1),
+				     Arrows[i].str[0]);
+		    }
+#endif				/* DEBUG_MENUARROWS */
+		    return;
+		}
+	    }
+	}
+    /* FALLTHROUGH */
+
+    default:
+    /*
+     * press menubar or move to a new entry
+     */
+	if (menu != NULL && menu != ActiveMenu) {
+	    menu_hide_all();	/* pop down old menu */
+	    ActiveMenu = menu;
+	    menu_show();	/* pop up new menu */
+	}
+	break;
+    }
+}
+#endif
+
+/*
+ * general dispatch routine,
+ * it would be nice to have `sticky' menus
+ */
+/* EXTPROTO */
+void
+menubar_control(XButtonEvent *ev)
+{
+#ifdef MENUBAR
+    switch (ev->type) {
+    case ButtonPress:
+	if (ev->button == Button1)
+	    menubar_select(ev);
+	break;
+
+    case ButtonRelease:
+	if (ev->button == Button1)
+	    menu_select(ev);
+	break;
+
+    case MotionNotify:
+	while (XCheckTypedWindowEvent(Xdisplay, TermWin.parent[0],
+				      MotionNotify,
+				      (XEvent *) ev)) ;
+
+	if (ActiveMenu)
+	    while (menu_select(ev)) ;
+	else
+	    ev->y = -1;
+	if (ev->y < 0) {
+	    Window          unused_root, unused_child;
+	    int             unused_root_x, unused_root_y;
+	    unsigned int    unused_mask;
+
+	    XQueryPointer(Xdisplay, menuBar.win,
+			  &unused_root, &unused_child,
+			  &unused_root_x, &unused_root_y,
+			  &(ev->x), &(ev->y),
+			  &unused_mask);
+	    menubar_select(ev);
+	}
+	break;
+    }
+#endif
+}
+
+/* EXTPROTO */
+void
+map_menuBar(int map)
+{
+#ifdef MENUBAR
+    if (menubar_mapping(map))
+	resize_all_windows();
+#endif
+}
+
+/* EXTPROTO */
+void
+create_menuBar(Cursor cursor)
+{
+#ifdef MENUBAR
+/* menuBar: size doesn't matter */
+    menuBar.win = XCreateSimpleWindow(Xdisplay, TermWin.parent[0],
+				      0, 0,
+				      1, 1,
+				      0,
+				      PixColors[Color_fg],
+				      PixColors[Color_scroll]);
+    XDefineCursor(Xdisplay, menuBar.win, cursor);
+    XSelectInput(Xdisplay, menuBar.win,
+		 (ExposureMask | ButtonPressMask | ButtonReleaseMask |
+		  Button1MotionMask));
+
+#endif
+}
+
+/* EXTPROTO */
+void
+Resize_menuBar(int x, int y, unsigned int width, unsigned int height)
+{
+#ifdef MENUBAR
+    XMoveResizeWindow(Xdisplay, menuBar.win, x, y, width, height);
+#endif
+}
+
+/*----------------------- end-of-file (C source) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/menubar.extpro work/main.d/rxvt-2.6.4/src/menubar.extpro
--- tmp/rxvt-2.6.4/src/menubar.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/menubar.extpro	2001-11-01 21:28:28.000000000 -0300
@@ -0,0 +1,8 @@
+void             menubar_read            __PROTO((const char *filename));
+void             menubar_dispatch        __PROTO((char *str));
+void             menubar_expose          __PROTO((void));
+int              menubar_mapping         __PROTO((int map));
+void             menubar_control         __PROTO((XButtonEvent *ev));
+void             map_menuBar             __PROTO((int map));
+void             create_menuBar          __PROTO((Cursor cursor));
+void             Resize_menuBar          __PROTO((int x, int y, unsigned int width, unsigned int height));
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/menubar.h work/main.d/rxvt-2.6.4/src/menubar.h
--- tmp/rxvt-2.6.4/src/menubar.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/menubar.h	1998-10-24 07:22:45.000000000 -0300
@@ -0,0 +1,81 @@
+typedef struct {
+    short           type;	/* must not be changed; first element */
+    short           len;	/* strlen (str) */
+    unsigned char  *str;	/* action to take */
+} action_t;
+
+typedef struct {
+    short           type;	/* must not be changed; first element */
+    struct menu_t  *menu;	/* sub-menu */
+} submenu_t;
+
+typedef struct menuitem_t {
+    struct menuitem_t *prev;	/* prev menu-item */
+    struct menuitem_t *next;	/* next menu-item */
+    char           *name;	/* character string displayed */
+    char           *name2;	/* character string displayed (right) */
+    short           len;	/* strlen (name) */
+    short           len2;	/* strlen (name) */
+    union {
+	short           type;	/* must not be changed; first element */
+	action_t        action;
+	submenu_t       submenu;
+    } entry;
+} menuitem_t;
+
+enum menuitem_t_action {
+    MenuLabel,
+    MenuAction,
+    MenuTerminalAction,
+    MenuSubMenu
+};
+
+typedef struct menu_t {
+    struct menu_t  *parent;	/* parent menu */
+    struct menu_t  *prev;	/* prev menu */
+    struct menu_t  *next;	/* next menu */
+    menuitem_t     *head;	/* double-linked list */
+    menuitem_t     *tail;	/* double-linked list */
+    menuitem_t     *item;	/* current item */
+    char           *name;	/* menu name */
+    short           len;	/* strlen (name) */
+    short           width;	/* maximum menu width [chars] */
+    Window          win;	/* window of the menu */
+    short           x;		/* x location [pixels] (chars if parent == NULL) */
+    short           y;		/* y location [pixels] */
+    short           w, h;	/* window width, height [pixels] */
+} menu_t;
+
+typedef struct bar_t {
+    menu_t         *head, *tail;	/* double-linked list of menus */
+    char           *title;	/* title to put in the empty menuBar */
+#if (MENUBAR_MAX > 1)
+# define MAXNAME 16
+    char            name[MAXNAME];	/* name to use to refer to menubar */
+    struct bar_t   *next, *prev;	/* circular linked-list */
+#endif				/* (MENUBAR_MAX > 1) */
+#define NARROWS	4
+    action_t        arrows[NARROWS];
+} bar_t;
+
+/* #define DEBUG_MENU */
+/* #define DEBUG_MENU_LAYOUT */
+/* #define DEBUG_MENUBAR_STACKING */
+
+#define HSPACE		1	/* one space */
+#define isSeparator(name)	((name)[0] == '\0')
+#define HEIGHT_SEPARATOR	(SHADOW + 1)
+#define HEIGHT_TEXT		(Height2Pixel(1) + 2)
+
+#define MENU_DELAY_USEC	250000	/* 1/4 sec */
+
+
+#define SEPARATOR_NAME		"-"
+#define MENUITEM_BEG		'{'
+#define MENUITEM_END		'}'
+#define COMMENT_CHAR		'#'
+
+#define DOT	"."
+#define DOTS	".."
+
+#include "menubar.intpro"	/* PROTOS for internal routines */
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/menubar.intpro work/main.d/rxvt-2.6.4/src/menubar.intpro
--- tmp/rxvt-2.6.4/src/menubar.intpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/menubar.intpro	2001-11-01 21:28:30.000000000 -0300
@@ -0,0 +1,31 @@
+menuitem_t     * menuitem_find           __PROTO((const menu_t *menu, const char *name));
+void             menuitem_free           __PROTO((menu_t *menu, menuitem_t *item));
+int              action_type             __PROTO((action_t *action, unsigned char *str));
+int              action_dispatch         __PROTO((action_t *action));
+int              menuarrow_find          __PROTO((char name));
+void             menuarrow_free          __PROTO((char name));
+void             menuarrow_add           __PROTO((char *string));
+menuitem_t     * menuitem_add            __PROTO((menu_t *menu, const char *name, const char *name2, const char *action));
+char           * menu_find_base          __PROTO((menu_t **menu, char *path));
+menu_t         * menu_delete             __PROTO((menu_t *menu));
+menu_t         * menu_add                __PROTO((menu_t *parent, char *path));
+void             drawbox_menubar         __PROTO((int x, int len, int state));
+void             drawtriangle            __PROTO((int x, int y, int state));
+void             drawbox_menuitem        __PROTO((int y, int state));
+void             print_menu_ancestors    __PROTO((menu_t *menu));
+void             print_menu_descendants  __PROTO((menu_t *menu));
+void             menu_show               __PROTO((void));
+void             menu_display            __PROTO((void (*update) (void)));
+void             menu_hide_all           __PROTO((void));
+void             menu_hide               __PROTO((void));
+void             menu_clear              __PROTO((menu_t *menu));
+void             menubar_clear           __PROTO((void));
+bar_t          * menubar_find            __PROTO((const char *name));
+int              menubar_push            __PROTO((const char *name));
+void             menubar_remove          __PROTO((const char *name));
+void             action_decode           __PROTO((FILE *fp, action_t *act));
+void             menu_dump               __PROTO((FILE *fp, menu_t *menu));
+void             menubar_dump            __PROTO((FILE *fp));
+void             draw_Arrows             __PROTO((int name, int state));
+int              menu_select             __PROTO((XButtonEvent *ev));
+void             menubar_select          __PROTO((XButtonEvent *ev));
Binary files tmp/rxvt-2.6.4/src/menubar.o and work/main.d/rxvt-2.6.4/src/menubar.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/misc.c work/main.d/rxvt-2.6.4/src/misc.c
--- tmp/rxvt-2.6.4/src/misc.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/misc.c	1999-05-05 19:49:34.000000000 -0300
@@ -0,0 +1,404 @@
+/*--------------------------------*-C-*---------------------------------*
+ * File:	misc.c
+ *----------------------------------------------------------------------*
+ * $Id: misc.c,v 1.21 1999/05/05 22:49:34 mason Exp $
+ *
+ * All portions of code are copyright by their respective author/s.
+ * Copyright (C) 1996      mj olesen <olesen@me.QueensU.CA> Queen's Univ at Kingston
+ * Copyright (C) 1997,1998 Oezguer Kesim <kesim@math.fu-berlin.de>
+ * Copyright (C) 1998      Geoff Wing <gcw@pobox.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *----------------------------------------------------------------------*/
+
+#include "rxvt.h"		/* NECESSARY */
+#include "misc.intpro"		/* PROTOS for internal routines */
+
+/*----------------------------------------------------------------------*/
+/* EXTPROTO */
+const char     *
+my_basename(const char *str)
+{
+    const char     *base = strrchr(str, '/');
+
+    return (base ? base + 1 : str);
+}
+
+/*
+ * Print an error message
+ */
+/* EXTPROTO */
+void
+print_error(const char *fmt,...)
+{
+    va_list         arg_ptr;
+
+    va_start(arg_ptr, fmt);
+    fprintf(stderr, APL_NAME ": ");
+    vfprintf(stderr, fmt, arg_ptr);
+    fprintf(stderr, "\n");
+    va_end(arg_ptr);
+}
+
+/*
+ * check that the first characters of S1 match S2
+ *
+ * No Match
+ *      return: 0
+ * Match
+ *      return: strlen (S2)
+ */
+/* EXTPROTO */
+int
+Str_match(const char *s1, const char *s2)
+{
+    int             n;
+
+    if (s1 == NULL || s2 == NULL)
+	return 0;
+    for (n = 0; *s2; n++)
+	if (*s1++ != *s2++)
+	    return 0;
+    return n;
+}
+
+/* EXTPROTO */
+const char     *
+Str_skip_space(const char *str)
+{
+    if (str)
+	while (*str && isspace(*str))
+	    str++;
+    return str;
+}
+
+/*
+ * remove leading/trailing space and strip-off leading/trailing quotes.
+ * in place.
+ */
+/* EXTPROTO */
+char           *
+Str_trim(char *str)
+{
+    char           *r, *s;
+    int             n;
+
+    if (!str)
+	return NULL;
+    if (!*str)			/* shortcut */
+	return str;
+
+/* skip leading spaces */
+    for (s = str; *s && isspace(*s); s++) ;
+/* goto end of string */
+    for (n = 0, r = s; *r++; n++) ;
+    r -= 2;
+/* dump return */
+    if (n > 0 && *r == '\n')
+	n--, r--;
+/* backtrack along trailing spaces */
+    for (; n > 0 && isspace(*r); r--, n--) ;
+/* skip matching leading/trailing quotes */
+    if (*s == '"' && *r == '"' && n > 1) {
+	s++;
+	n -= 2;
+    }
+/* copy back over: forwards copy */
+    for (r = str; n; n--)
+	*r++ = *s++;
+    *r = '\0';
+
+    return str;
+}
+
+/*
+ * in-place interpretation of string:
+ *
+ *      backslash-escaped:      "\a\b\E\e\n\r\t", "\octal"
+ *      Ctrl chars:     ^@ .. ^_, ^?
+ *
+ *      Emacs-style:    "M-" prefix
+ *
+ * Also,
+ *      "M-x" prefixed strings, append "\r" if needed
+ *      "\E]" prefixed strings (XTerm escape sequence) append "\a" if needed
+ *
+ * returns the converted string length
+ */
+/* EXTPROTO */
+int
+Str_escaped(char *str)
+{
+    char            ch, *s, *d;
+    int             i, num, append = 0;
+
+    if (!str || !*str)
+	return 0;
+
+    d = s = str;
+
+    if (*s == 'M' && s[1] == '-') {
+    /* Emacs convenience, replace leading `M-..' with `\E..' */
+	*d++ = '\033';
+	s += 2;
+	if (toupper(*s) == 'X')
+	/* append carriage-return for `M-xcommand' */
+	    for (*d++ = 'x', append = '\r', s++; isspace(*s); s++) ;
+    }
+    for ( ; (ch = *s++); ) {
+	if (ch == '\\') {
+	    switch ((ch = *s++)) {
+	    case '0':	/* octal */
+	    case '1':	/* octal */
+	    case '2':	/* octal */
+	    case '3':	/* octal */
+	    case '4':	/* octal */
+	    case '5':	/* octal */
+	    case '6':	/* octal */
+	    case '7':	/* octal */
+		num = ch - '0';
+		for (i = 0; i < 2; i++, s++) {
+		    ch = *s;
+		    if (ch < '0' || ch > '7')
+			break;
+		    num = num * 8 + ch - '0';
+		}
+		ch = (char) num;
+		break;
+	    case 'a':	/* bell */
+	        ch = 007;
+	        break;
+	    case 'b':	/* backspace */
+	        ch = '\b';
+	        break;
+	    case 'E':	/* escape */
+	    case 'e':
+	        ch = 033;
+	        break;
+	    case 'n':	/* newline */
+	        ch = '\n';
+	        break;
+	    case 'r':	/* carriage-return */
+	        ch = '\r';
+	        break;
+	    case 't':	/* tab */
+	        ch = '\t';
+	        break;
+	    }
+	} else if (ch == '^') {
+	    ch = *s++;
+	    ch = toupper(ch);
+	    ch = (ch == '?' ? 127 : (ch - '@'));
+	}
+	*d++ = ch;
+    }
+
+/* ESC] is an XTerm escape sequence, must be ^G terminated */
+    if (*str == '\0' && str[1] == '\033' && str[2] == ']')
+	append = 007;
+
+/* add trailing character as required */
+    if (append && d[-1] != append)
+	*d++ = append;
+    *d = '\0';
+
+    return (d - str);
+}
+
+/*----------------------------------------------------------------------*
+ * file searching
+ */
+
+/* #define DEBUG_SEARCH_PATH */
+
+#if defined (XPM_BACKGROUND) || (MENUBAR_MAX)
+/*
+ * search for FILE in the current working directory, and within the
+ * colon-delimited PATHLIST, adding the file extension EXT if required.
+ *
+ * FILE is either semi-colon or zero terminated
+ */
+/* INTPROTO */
+char           *
+File_search_path(const char *pathlist, const char *file, const char *ext)
+{
+    int             maxpath, len;
+    const char     *p, *path;
+    char	    name[256];
+
+    if (!access(file, R_OK))	/* found (plain name) in current directory */
+	return strdup(file);
+
+/* semi-colon delimited */
+    if ((p = strchr(file, ';')))
+	len = (p - file);
+    else
+	len = strlen(file);
+
+#ifdef DEBUG_SEARCH_PATH
+    getcwd(name, sizeof(name));
+    fprintf(stderr, "pwd: \"%s\"\n", name);
+    fprintf(stderr, "find: \"%.*s\"\n", len, file);
+#endif
+
+/* leave room for an extra '/' and trailing '\0' */
+    maxpath = sizeof(name) - (len + (ext ? strlen(ext) : 0) + 2);
+    if (maxpath <= 0)
+	return NULL;
+
+/* check if we can find it now */
+    STRNCPY(name, file, len);
+    name[len] = '\0';
+
+    if (!access(name, R_OK))
+	return strdup(name);
+    if (ext) {
+	strcat(name, ext);
+	if (!access(name, R_OK))
+	    return strdup(name);
+    }
+    for (path = pathlist; path != NULL && *path != '\0'; path = p) {
+	int             n;
+
+    /* colon delimited */
+	if ((p = strchr(path, ':')) == NULL)
+	    p = strchr(path, '\0');
+
+	n = (p - path);
+	if (*p != '\0')
+	    p++;
+
+	if (n > 0 && n <= maxpath) {
+	    STRNCPY(name, path, n);
+	    if (name[n - 1] != '/')
+		name[n++] = '/';
+	    name[n] = '\0';
+	    strncat(name, file, len);
+
+	    if (!access(name, R_OK))
+		return strdup(name);
+	    if (ext) {
+		strcat(name, ext);
+		if (!access(name, R_OK))
+		    return strdup(name);
+	    }
+	}
+    }
+    return NULL;
+}
+
+/* EXTPROTO */
+char           *
+File_find(const char *file, const char *ext)
+{
+    char           *f;
+
+    if (file == NULL || *file == '\0')
+	return NULL;
+
+/* search environment variables here too */
+    if ((f = File_search_path(rs[Rs_path], file, ext)) == NULL)
+#ifdef PATH_ENV
+	if ((f = File_search_path(getenv(PATH_ENV), file, ext)) == NULL)
+#endif
+	    f = File_search_path(getenv("PATH"), file, ext);
+
+#ifdef DEBUG_SEARCH_PATH
+    if (f)
+	fprintf(stderr, "found: \"%s\"\n", f);
+#endif
+
+    return f;
+}
+#endif				/* defined (XPM_BACKGROUND) || (MENUBAR_MAX) */
+
+/*----------------------------------------------------------------------*
+ * miscellaneous drawing routines
+ */
+
+/*
+ * Draw top/left and bottom/right border shadows around windows
+ */
+#if (! defined(NEXT_SCROLLBAR) && ! defined(XTERM_SCROLLBAR)) || defined(MENUBAR)
+/* EXTPROTO */
+void
+Draw_Shadow(Window win, GC topShadow, GC botShadow, int x, int y, int w, int h)
+{
+    int             x1, y1, w1, h1, shadow;
+
+    shadow = (w == 0 || h == 0) ? 1 : SHADOW;
+    w1 = w + x - 1;
+    h1 = h + y - 1;
+    x1 = x;
+    y1 = y;
+    for (; shadow-- > 0; x1++, y1++, w1--, h1--) {
+        XDrawLine(Xdisplay, win, topShadow, x1, y1, w1, y1);
+        XDrawLine(Xdisplay, win, topShadow, x1, y1, x1, h1);
+    }
+
+    shadow = (w == 0 || h == 0) ? 1 : SHADOW;
+    w1 = w + x - 1;
+    h1 = h + y - 1;
+    x1 = x + 1;
+    y1 = y + 1;
+    for (; shadow-- > 0; x1++, y1++, w1--, h1--) {
+        XDrawLine(Xdisplay, win, botShadow, w1, h1, w1, y1);
+        XDrawLine(Xdisplay, win, botShadow, w1, h1, x1, h1);
+    }
+}
+#endif
+
+/* button shapes */
+#ifdef MENUBAR
+/* EXTPROTO */
+void
+Draw_Triangle(Window win, GC topShadow, GC botShadow, int x, int y, int w, int type)
+{
+    switch (type) {
+    case 'r':			/* right triangle */
+	XDrawLine(Xdisplay, win, topShadow, x, y, x, y + w);
+	XDrawLine(Xdisplay, win, topShadow, x, y, x + w, y + w / 2);
+	XDrawLine(Xdisplay, win, botShadow, x, y + w, x + w, y + w / 2);
+	break;
+
+    case 'l':			/* right triangle */
+	XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x + w, y);
+	XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x, y + w / 2);
+	XDrawLine(Xdisplay, win, topShadow, x, y + w / 2, x + w, y);
+	break;
+
+    case 'd':			/* down triangle */
+	XDrawLine(Xdisplay, win, topShadow, x, y, x + w / 2, y + w);
+	XDrawLine(Xdisplay, win, topShadow, x, y, x + w, y);
+	XDrawLine(Xdisplay, win, botShadow, x + w, y, x + w / 2, y + w);
+	break;
+
+    case 'u':			/* up triangle */
+	XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x + w / 2, y);
+	XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x, y + w);
+	XDrawLine(Xdisplay, win, topShadow, x, y + w, x + w / 2, y);
+	break;
+#if 0
+    case 's':			/* square */
+	XDrawLine(Xdisplay, win, topShadow, x + w, y, x, y);
+	XDrawLine(Xdisplay, win, topShadow, x, y, x, y + w);
+	XDrawLine(Xdisplay, win, botShadow, x, y + w, x + w, y + w);
+	XDrawLine(Xdisplay, win, botShadow, x + w, y + w, x + w, y);
+	break;
+#endif
+    }
+}
+#endif
+/*----------------------- end-of-file (C source) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/misc.extpro work/main.d/rxvt-2.6.4/src/misc.extpro
--- tmp/rxvt-2.6.4/src/misc.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/misc.extpro	2001-11-01 21:28:28.000000000 -0300
@@ -0,0 +1,9 @@
+const char     * my_basename             __PROTO((const char *str));
+void             print_error             __PROTO((const char *fmt,...));
+int              Str_match               __PROTO((const char *s1, const char *s2));
+const char     * Str_skip_space          __PROTO((const char *str));
+char           * Str_trim                __PROTO((char *str));
+int              Str_escaped             __PROTO((char *str));
+char           * File_find               __PROTO((const char *file, const char *ext));
+void             Draw_Shadow             __PROTO((Window win, GC topShadow, GC botShadow, int x, int y, int w, int h));
+void             Draw_Triangle           __PROTO((Window win, GC topShadow, GC botShadow, int x, int y, int w, int type));
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/misc.intpro work/main.d/rxvt-2.6.4/src/misc.intpro
--- tmp/rxvt-2.6.4/src/misc.intpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/misc.intpro	2001-11-01 21:28:30.000000000 -0300
@@ -0,0 +1 @@
+char           * File_search_path        __PROTO((const char *pathlist, const char *file, const char *ext));
Binary files tmp/rxvt-2.6.4/src/misc.o and work/main.d/rxvt-2.6.4/src/misc.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/netdisp.c work/main.d/rxvt-2.6.4/src/netdisp.c
--- tmp/rxvt-2.6.4/src/netdisp.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/netdisp.c	1998-11-12 01:51:12.000000000 -0300
@@ -0,0 +1,106 @@
+/*--------------------------------*-C-*---------------------------------*
+ * File:	netdisp.c
+ *----------------------------------------------------------------------*
+ * $Id: netdisp.c,v 1.9 1998/11/12 04:51:12 mason Exp $
+ *
+ * All portions of code are copyright by their respective author/s.
+ * Copyright (C) 1996      Chuck Blake <cblake@BBN.COM>
+ *				- original version
+ * Copyright (C) 1997      mj olesen <olesen@me.queensu.ca>
+ * Copyright (C) 1997,1998 Oezguer Kesim <kesim@math.fu-berlin.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *----------------------------------------------------------------------*/
+/*----------------------------------------------------------------------*
+ * support for resolving the actual IP number of the host for remote
+ * DISPLAYs.  When the display is local (i.e. :0), we add support for
+ * sending the first non-loopback interface IP number as the DISPLAY
+ * instead of just sending the incorrect ":0".  This way telnet/rlogin
+ * shells can actually get the correct information into DISPLAY for
+ * xclients.
+ *----------------------------------------------------------------------*/
+
+#include "rxvt.h"		/* NECESSARY */
+
+#ifdef DISPLAY_IS_IP
+#include "netdisp.h"
+
+/*----------------------------------------------------------------------*/
+/* return a pointer to a static buffer */
+/* EXTPROTO */
+char           *
+network_display(const char *display)
+{
+    static char     ipaddress[32] = "";
+    char            buffer[1024], *rval = NULL;
+    struct ifconf   ifc;
+    struct ifreq   *ifr;
+    int             i, skfd;
+
+    if (display[0] != ':' && strncmp(display, "unix:", 5))
+	return (char *) display;		/* nothing to do */
+
+    ifc.ifc_len = sizeof(buffer);	/* Get names of all ifaces */
+    ifc.ifc_buf = buffer;
+
+    if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+	perror("socket");
+	return NULL;
+    }
+    if (ioctl(skfd, SIOCGIFCONF, &ifc) < 0) {
+	perror("SIOCGIFCONF");
+	close(skfd);
+	return NULL;
+    }
+    for (i = 0, ifr = ifc.ifc_req;
+	 i < (ifc.ifc_len / sizeof(struct ifreq));
+
+	 i++, ifr++) {
+	struct ifreq    ifr2;
+
+	STRCPY(ifr2.ifr_name, ifr->ifr_name);
+	if (ioctl(skfd, SIOCGIFADDR, &ifr2) >= 0) {
+	    unsigned long   addr;
+	    struct sockaddr_in *p_addr;
+
+	    p_addr = (struct sockaddr_in *)&(ifr2.ifr_addr);
+	    addr = htonl((unsigned long)p_addr->sin_addr.s_addr);
+
+	/*
+	 * not "0.0.0.0" or "127.0.0.1" - so format the address
+	 */
+	    if (addr && addr != 0x7F000001) {
+		char           *colon = strchr(display, ':');
+
+		if (colon == NULL)
+		    colon = ":0.0";
+
+		sprintf(ipaddress, "%d.%d.%d.%d%s",
+			(int)((addr >> 030) & 0xFF),
+			(int)((addr >> 020) & 0xFF),
+			(int)((addr >> 010) & 0xFF),
+			(int)(addr & 0xFF), colon);
+
+		rval = ipaddress;
+		break;
+	    }
+	}
+    }
+
+    close(skfd);
+    return rval;
+}
+#endif				/* DISPLAY_IS_IP */
+/*----------------------- end-of-file (C source) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/netdisp.extpro work/main.d/rxvt-2.6.4/src/netdisp.extpro
--- tmp/rxvt-2.6.4/src/netdisp.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/netdisp.extpro	2001-11-01 21:28:29.000000000 -0300
@@ -0,0 +1 @@
+char           * network_display         __PROTO((const char *display));
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/netdisp.h work/main.d/rxvt-2.6.4/src/netdisp.h
--- tmp/rxvt-2.6.4/src/netdisp.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/netdisp.h	1998-10-24 07:22:45.000000000 -0300
@@ -0,0 +1,18 @@
+/* On Solaris link with -lsocket and -lnsl */
+#include <sys/types.h>
+#include <sys/socket.h>
+
+/* these next two are probably only on Sun (not Solaris) */
+#ifdef HAVE_SYS_SOCKIO_H
+#include <sys/sockio.h>
+#endif
+#ifdef HAVE_SYS_BYTEORDER_H
+#include <sys/byteorder.h>
+#endif
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+
+#include "netdisp.intpro"	/* PROTOS for internal routines */
Binary files tmp/rxvt-2.6.4/src/netdisp.o and work/main.d/rxvt-2.6.4/src/netdisp.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/protos.h work/main.d/rxvt-2.6.4/src/protos.h
--- tmp/rxvt-2.6.4/src/protos.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/protos.h	1998-10-24 07:22:45.000000000 -0300
@@ -0,0 +1,23 @@
+/* Include prototypes for all files */
+/*
+ * $Id: protos.h,v 1.7 1998/10/24 10:22:45 mason Exp $
+ */
+#include "command.extpro"
+#include "graphics.extpro"
+#include "grkelot.extpro"
+#ifdef UTMP_SUPPORT
+#include "logging.extpro"
+#endif
+#include "main.extpro"
+#include "menubar.extpro"
+#include "misc.extpro"
+#ifdef DISPLAY_IS_IP
+#include "netdisp.extpro"
+#endif
+#ifndef NO_RMEMSET
+#include "rmemset.extpro"
+#endif
+#include "screen.extpro"
+#include "scrollbar.extpro"
+#include "xdefaults.extpro"
+#include "xpm.extpro"
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/rmemset.c work/main.d/rxvt-2.6.4/src/rmemset.c
--- tmp/rxvt-2.6.4/src/rmemset.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/rmemset.c	1999-05-05 06:31:49.000000000 -0300
@@ -0,0 +1,73 @@
+/*---------------------------------------------------------------------------*
+ * File:	rmemset.c
+ *---------------------------------------------------------------------------*
+ * $Id: rmemset.c,v 1.17 1999/05/05 09:31:49 mason Exp $
+ *
+ * Copyright (C) 1997,1998 Geoff Wing <gcw@pobox.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *--------------------------------------------------------------------------*/
+/*--------------------------------------------------------------------------*
+ * Fast memset()
+ * presumptions:
+ *   1) intp_t write the best
+ *   2) SIZEOF_INT_P= power of 2
+ *--------------------------------------------------------------------------*/
+
+#include "rxvt.h"		/* NECESSARY */
+#include "rmemset.intpro"	/* PROTOS for internal routines */
+
+#ifndef NO_RMEMSET
+/* EXTPROTO */
+void
+rmemset(void *p, unsigned char c, intp_t len)
+{
+    u_intp_t        i, val, *rp;
+    unsigned char  *lp;
+
+    if (len < 16)		/* probably not worth all the calculations */
+	lp = p;
+    else {
+/* write out preceding characters so we align on an integer boundary */
+	if ((i = ((-(u_intp_t)p) & (SIZEOF_INT_P - 1))) == 0)
+	    rp = p;
+	else {
+	    len -= i;
+	    for (lp = p; i--;)
+		*lp++ = c;
+	    rp = (u_intp_t *)lp;
+	}
+
+/* do the fast writing */
+	val = (c << 8) + c;
+#if SIZEOF_INT_P >= 4
+	val |= (val << 16);
+#endif
+#if SIZEOF_INT_P >= 8
+	val |= (val << 32);
+#endif
+#if SIZEOF_INT_P == 16
+	val |= (val << 64);
+#endif
+	for (i = len / SIZEOF_INT_P; i--;)
+	    *rp++ = val;
+	len &= (SIZEOF_INT_P - 1);
+	lp = (unsigned char *)rp;
+    }
+/* write trailing characters */
+    for (; len--;)
+	*lp++ = c;
+}
+#endif
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/rmemset.extpro work/main.d/rxvt-2.6.4/src/rmemset.extpro
--- tmp/rxvt-2.6.4/src/rmemset.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/rmemset.extpro	2001-11-01 21:28:29.000000000 -0300
@@ -0,0 +1 @@
+void             rmemset                 __PROTO((void *p, unsigned char c, intp_t len));
Binary files tmp/rxvt-2.6.4/src/rmemset.o and work/main.d/rxvt-2.6.4/src/rmemset.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/rsizes.h work/main.d/rxvt-2.6.4/src/rsizes.h
--- tmp/rxvt-2.6.4/src/rsizes.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/rsizes.h	2007-01-15 18:03:53.000000000 -0300
@@ -0,0 +1,22 @@
+/*
+ * If we haven't pulled in typedef's like int16_t , then do them ourself
+ */
+
+/* type of (normal and unsigned) basic sizes */
+/* e.g. typedef short int16_t */
+
+/* e.g. typedef unsigned short u_int16_t */
+
+/* e.g. typedef int int32_t */
+
+/* e.g. typedef unsigned int u_int32_t */
+
+/* e.g. typedef long int64_t */
+
+/* e.g. typedef unsigned long u_int64_t */
+
+
+/* whatever normal size corresponds to a integer pointer */
+#define intp_t int32_t
+/* whatever normal size corresponds to a unsigned integer pointer */
+#define u_intp_t u_int32_t
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/rsizes.h.in work/main.d/rxvt-2.6.4/src/rsizes.h.in
--- tmp/rxvt-2.6.4/src/rsizes.h.in	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/rsizes.h.in	1998-11-26 03:38:41.000000000 -0300
@@ -0,0 +1,22 @@
+/*
+ * If we haven't pulled in typedef's like int16_t , then do them ourself
+ */
+
+/* type of (normal and unsigned) basic sizes */
+/* e.g. typedef short int16_t */
+@rxvt_int16_typedef@
+/* e.g. typedef unsigned short u_int16_t */
+@rxvt_u_int16_typedef@
+/* e.g. typedef int int32_t */
+@rxvt_int32_typedef@
+/* e.g. typedef unsigned int u_int32_t */
+@rxvt_u_int32_typedef@
+/* e.g. typedef long int64_t */
+@rxvt_int64_typedef@
+/* e.g. typedef unsigned long u_int64_t */
+@rxvt_u_int64_typedef@
+
+/* whatever normal size corresponds to a integer pointer */
+@rxvt_intp_define@
+/* whatever normal size corresponds to a unsigned integer pointer */
+@rxvt_u_intp_define@
Binary files tmp/rxvt-2.6.4/src/rxvt and work/main.d/rxvt-2.6.4/src/rxvt differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/rxvtgrx.h work/main.d/rxvt-2.6.4/src/rxvtgrx.h
--- tmp/rxvt-2.6.4/src/rxvtgrx.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/rxvtgrx.h	1998-04-20 04:27:05.000000000 -0300
@@ -0,0 +1,54 @@
+/*--------------------------------*-C-*---------------------------------*
+ * File:	rxvtgrx.h
+ * $Id: rxvtgrx.h,v 1.2 1998/04/20 07:27:05 mason Exp $
+ *
+ * Stuff for text alignment for rxvt special graphics mode
+ *
+ * alignment
+ * Top:
+ *	text is placed so that the specified point is at the top of the
+ *	capital letters
+ * Center:
+ *	text is placed so that the specified point is equidistant from the
+ *	bottom of descenders and the top of the capital letters
+ * Bottom:
+ *	text is placed so that the bottom of descenders is on the specified
+ *	point
+ * Base:
+ *	text is placed so that the bottom of the characters with no descenders
+ *	is on the specified point
+ * Caps_Center:
+ *	text is placed so that the specified point is equidistant from the
+ *	bottom and tops of capital letters
+ *----------------------------------------------------------------------*/
+#ifndef _RXVTGRX_H
+#define _RXVTGRX_H
+
+#define GRX_SCALE		10000
+
+#define RIGHT_TEXT		0x10
+#define HCENTER_TEXT		0x20
+#define LEFT_TEXT		0x30
+#define HORIZONTAL_ALIGNMENT	0x70
+
+#define TOP_TEXT		0x01
+#define VCENTER_TEXT		0x02
+#define BOTTOM_TEXT		0x03
+#define BASE_TEXT		0x04
+#define VCAPS_CENTER_TEXT	0x05
+#define VERTICAL_ALIGNMENT	0x0F
+
+#if 0	/* this would be nicer */
+# define TXT_RIGHT		'r'
+# define TXT_CENTER		'c'
+# define TXT_LEFT		'l'
+
+# define TXT_TOP		't'
+# define TXT_VCENTER		'v'
+# define TXT_BOTTOM		'b'
+# define TXT_BASE		'_'
+# define TXT_VCAPS_CENTER	'C'
+#endif
+
+#endif	/* whole file */
+/*----------------------- end-of-file (C header) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/rxvt.h work/main.d/rxvt-2.6.4/src/rxvt.h
--- tmp/rxvt-2.6.4/src/rxvt.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/rxvt.h	1999-11-11 08:56:32.000000000 -0300
@@ -0,0 +1,803 @@
+/*
+ * $Id: rxvt.h,v 1.40.2.8 1999/11/11 11:56:32 mason Exp $
+ */
+
+#ifndef _RXVT_H			/* include once only */
+#define _RXVT_H
+
+#include "../config.h"
+
+/* sort out conflicts in feature.h */
+#undef  MULTICHAR_SET		/* a glyph is only ever defined by 1 char */
+#ifdef KANJI
+# define MULTICHAR_SET		/* a glyph is defined by 1 or 2 chars     */
+# undef ZH			/* remove Chinese big5 support            */
+# undef ZHCN			/* remove Chinese gb support	          */
+# undef GREEK_SUPPORT		/* Kanji/Greek together is too weird      */
+# undef DEFINE_XTERM_COLOR	/* since kterm-color doesn't exist?       */
+#endif
+#ifdef ZH 
+# define MULTICHAR_SET		/* a glyph is defined by 1 or 2 chars     */
+# undef KANJI			/* can't put Chinese/Kanji together       */
+# undef ZHCN
+# undef GREEK_SUPPORT		
+# undef DEFINE_XTERM_COLOR
+#endif
+#ifdef ZHCN
+# define MULTICHAR_SET		/* a glyph is defined by 1 or 2 chars     */
+# undef KANJI
+# undef ZH
+# undef GREEK_SUPPORT
+#endif
+
+#include "feature.h"
+
+/*
+ *****************************************************************************
+ * SYSTEM HACKS
+ *****************************************************************************
+ */
+/* Consistent defines - please report on the necessity
+ * @ Unixware: defines (__svr4__)
+ */
+#if defined (SVR4) && !defined (__svr4__)
+# define __svr4__
+#endif
+#if defined (sun) && !defined (__sun__)
+# define __sun__
+#endif
+
+/*
+ * sun <sys/ioctl.h> isn't properly protected?
+ * anyway, it causes problems when <termios.h> is also included
+ */
+#if defined (__sun__)
+# undef HAVE_SYS_IOCTL_H
+#endif
+
+/*
+ * Solaris defines SRIOCSREDIR in sys/strredir.h .
+ * Needed for displaying console messages under solaris
+ */
+#if defined(__sun) && defined(__SVR4)
+#include <sys/strredir.h>
+#endif
+
+/*
+ *****************************************************************************
+ * INCLUDES
+ *****************************************************************************
+ */
+
+#include <stdio.h>
+#include <ctype.h>
+#include <errno.h>
+#include <signal.h>
+
+#ifdef HAVE_STDARG_H
+# include <stdarg.h>
+#endif
+#ifdef HAVE_STDLIB_H
+# include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+#ifdef HAVE_FCNTL_H
+# include <fcntl.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_UTIL_H
+# include <util.h>
+#endif
+#ifdef HAVE_ASSERT_H
+# include <assert.h>
+#endif
+#if defined (HAVE_SYS_IOCTL_H) && !defined (__sun__)
+/* seems to cause problems when <termios.h> is also included on some suns */
+# include <sys/ioctl.h>
+#endif
+#ifdef TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# ifdef HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SELECT_H
+# include <sys/select.h>
+#endif
+
+#include <sys/wait.h>
+#include <sys/stat.h>
+
+#include <X11/Intrinsic.h>	/* Xlib, Xutil, Xresource, Xfuncproto */
+#include <X11/cursorfont.h>
+#include <X11/keysym.h>
+
+#include "rsizes.h"		/* we've pulled in <sys/types.h> - presumed */
+#ifndef HAVE_XPOINTER
+typedef char           *XPointer;
+#endif
+
+#ifdef RXVT_GRAPHICS
+# include "rxvtgrx.h"
+#endif
+#ifdef GREEK_SUPPORT
+# include "grkelot.h"
+#endif
+
+/*
+ *****************************************************************************
+ * STRUCTURES AND TYPEDEFS
+ *****************************************************************************
+ */
+/* Sanitize menubar info */
+#ifndef MENUBAR
+# undef MENUBAR_MAX
+#endif
+#ifndef MENUBAR_MAX
+# define MENUBAR_MAX	0
+#endif
+
+typedef struct {
+    short           state;
+    Window          win;
+} menuBar_t;
+
+/* If we're using either the fancy scrollbar or menu bars, keep the
+ * scrollColor resource.
+ */
+#if !defined(XTERM_SCROLLBAR) || defined(MENUBAR)
+# define KEEP_SCROLLCOLOR 1
+#else
+# undef KEEP_SCROLLCOLOR
+#endif
+
+#ifdef TRANSPARENT
+# define KNOW_PARENTS		4
+#else
+# define KNOW_PARENTS		1
+#endif
+
+typedef struct {
+    int16_t         width,	/* window width [pixels]                    */
+		    height,	/* window height [pixels]                   */
+		    fwidth,	/* font width [pixels]                      */
+		    fheight,	/* font height [pixels]                     */
+		    fprop,	/* font is proportional                     */
+		    bprop,	/* treat bold font as proportional          */
+		    mprop,	/* treat multichar font as proportional     */
+		    ncol, nrow,	/* window size [characters]                 */
+		    focus,	/* window has focus                         */
+		    mapped,	/* window state mapped?                     */
+		    saveLines;	/* number of lines that fit in scrollback   */
+    u_int16_t       nscrolled,	/* number of line actually scrolled         */
+		    view_start;	/* scrollback view starts here              */
+    Window          parent[KNOW_PARENTS], /* parent[0] is our window        */
+		    vt;		/* vt100 window                             */
+    GC              gc;		/* GC for drawing text                      */
+    XFontStruct    *font;	/* main font structure                      */
+#ifndef NO_BOLDFONT
+    XFontStruct    *boldFont;	/* bold font                                */
+#endif
+#ifdef MULTICHAR_SET
+    XFontStruct    *mfont;	/* Multichar font structure                 */
+#endif
+    XFontSet       fontset;
+#ifdef XPM_BACKGROUND
+    Pixmap          pixmap;
+#ifdef XPM_BUFFERING
+    Pixmap          buf_pixmap;
+#endif
+#endif
+} TermWin_t;
+
+typedef struct {
+    short           beg, end;	/* beg/end of slider sub-window */
+    short           top, bot;	/* top/bot of slider */
+    short           state;	/* scrollbar state */
+    Window          win;
+} scrollBar_t;
+
+
+typedef struct grcmd_t {
+    char            cmd;
+    short           color;
+    short           ncoords;
+    int            *coords;
+    unsigned char  *text;
+    struct grcmd_t *next;
+} grcmd_t;
+
+typedef struct grwin_t {
+    Window          win;
+    int             x, y;
+    unsigned int    w, h;
+    short           screen;
+    grcmd_t        *graphics;
+    struct grwin_t *prev, *next;
+} grwin_t;
+
+typedef struct {
+    int16_t         row, col;
+} row_col_t;
+
+
+#ifndef min
+# define min(a,b)	(((a) < (b)) ? (a) : (b))
+# define max(a,b)	(((a) > (b)) ? (a) : (b))
+#endif
+
+#define MAX_IT(current, other)	if ((other) > (current)) (current) = (other)
+#define MIN_IT(current, other)	if ((other) < (current)) (current) = (other)
+#define SWAP_IT(one, two, tmp)				\
+    do {						\
+	(tmp) = (one); (one) = (two); (two) = (tmp);	\
+    } while (0)
+
+/*
+ *****************************************************************************
+ * NORMAL DEFINES
+ *****************************************************************************
+ */
+
+#if defined (NO_OLD_SELECTION) && defined(NO_NEW_SELECTION)
+# error if you disable both selection styles, how can you select, silly?
+#endif
+
+
+#ifndef XPM_BACKGROUND
+# undef XPM_BUFFERING		 /* disable what can't be used */
+#endif
+
+#define APL_CLASS	"XTerm"	/* class name */
+#define APL_SUBCLASS	"Rxvt"	/* also check resources under this name */
+#define APL_NAME	"rxvt"	/* normal name */
+
+/* COLORTERM, TERM environment variables */
+#define COLORTERMENV	"rxvt"
+#ifdef XPM_BACKGROUND
+# define COLORTERMENVFULL COLORTERMENV "-xpm"
+#else
+# define COLORTERMENVFULL COLORTERMENV
+#endif
+#ifndef TERMENV
+# ifdef KANJI
+#  define TERMENV	"kterm"
+# else
+#  define TERMENV	"xterm"
+# endif
+#endif
+
+#if defined (NO_MOUSE_REPORT) && !defined (NO_MOUSE_REPORT_SCROLLBAR)
+# define NO_MOUSE_REPORT_SCROLLBAR
+#endif
+
+#ifdef NO_RESOURCES
+# undef USE_XGETDEFAULT
+#endif
+
+/* now look for other badly set stuff */
+
+#if !defined (EACCESS) && defined(EAGAIN)
+# define EACCESS EAGAIN
+#endif
+
+#ifndef EXIT_SUCCESS			/* missing from <stdlib.h> */
+# define EXIT_SUCCESS		0	/* exit function success */
+# define EXIT_FAILURE		1	/* exit function failure */
+#endif
+
+#define menuBar_esc		10
+#define scrollBar_esc		30
+#define menuBar_margin		2	/* margin below text */
+
+/* gap between text and window edges (could be configurable) */
+#define TermWin_internalBorder	2
+
+/* width of scrollBar, menuBar shadow, must be 1 or 2 */
+#ifdef HALFSHADOW
+# define SHADOW 1
+#else
+# define SHADOW 2
+#endif
+
+#ifdef NEXT_SCROLLBAR
+# undef SB_WIDTH
+# define SB_WIDTH		19
+# define SB_PADDING		1
+# define SB_BORDER_WIDTH	1
+# define SB_BEVEL_WIDTH_UPPER_LEFT	1
+# define SB_BEVEL_WIDTH_LOWER_RIGHT	2
+# define SB_LEFT_PADDING	(SB_PADDING + SB_BORDER_WIDTH)
+# define SB_MARGIN_SPACE	(SB_PADDING * 2)
+# define SB_BUTTON_WIDTH	(SB_WIDTH - SB_MARGIN_SPACE - SB_BORDER_WIDTH)
+# define SB_BUTTON_HEIGHT	(SB_BUTTON_WIDTH)
+# define SB_BUTTON_SINGLE_HEIGHT	(SB_BUTTON_HEIGHT + SB_PADDING)
+# define SB_BUTTON_BOTH_HEIGHT		(SB_BUTTON_SINGLE_HEIGHT * 2)
+# define SB_BUTTON_TOTAL_HEIGHT		(SB_BUTTON_BOTH_HEIGHT + SB_PADDING)
+# define SB_BUTTON_BEVEL_X	(SB_LEFT_PADDING)
+# define SB_BUTTON_FACE_X	(SB_BUTTON_BEVEL_X + SB_BEVEL_WIDTH_UPPER_LEFT)
+# define SB_THUMB_MIN_HEIGHT	(SB_BUTTON_WIDTH - (SB_PADDING * 2))
+ /*
+  *    +-------------+
+  *    |             | <---< SB_PADDING
+  *    | ::::::::::: |
+  *    | ::::::::::: |
+  *   '''''''''''''''''
+  *   ,,,,,,,,,,,,,,,,,
+  *    | ::::::::::: |
+  *    | ::::::::::: |
+  *    |  +---------------< SB_BEVEL_WIDTH_UPPER_LEFT
+  *    |  | :::::::: |
+  *    |  V :::: vv-------< SB_BEVEL_WIDTH_LOWER_RIGHT
+  *    | +---------+ |
+  *    | | ......%%| |
+  *    | | ......%%| |
+  *    | | ..()..%%| |
+  *    | | ......%%| |
+  *    | | %%%%%%%%| |
+  *    | +---------+ | <.........................
+  *    |             | <---< SB_PADDING         :
+  *    | +---------+ | <-+..........            :---< SB_BUTTON_TOTAL_HEIGHT
+  *    | | ......%%| |   |         :            :
+  *    | | ../\..%%| |   |---< SB_BUTTON_HEIGHT :
+  *    | | %%%%%%%%| |   |         :            :
+  *    | +---------+ | <-+         :            :
+  *    |             |             :            :
+  *    | +---------+ | <-+         :---< SB_BUTTON_BOTH_HEIGHT
+  *    | | ......%%| |   |         :            :
+  *    | | ..\/..%%| |   |         :            :
+  *    | | %%%%%%%%| |   |---< SB_BUTTON_SINGLE_HEIGHT
+  *    | +---------+ |   |         :            :
+  *    |             |   |         :            :
+  *    +-------------+ <-+.........:............:
+  *    ^^|_________| :
+  *    ||     |      :
+  *    ||     +---< SB_BUTTON_WIDTH
+  *    ||            :
+  *    |+------< SB_PADDING
+  *    |:            :
+  *    +----< SB_BORDER_WIDTH
+  *     :            :
+  *     :............:
+  *           |
+  *           +---< SB_WIDTH
+  */
+#else
+# ifdef XTERM_SCROLLBAR
+#  undef  SB_WIDTH
+#  define SB_WIDTH		15
+# else
+#  if !defined (SB_WIDTH) || (SB_WIDTH < 8)
+#   undef SB_WIDTH
+#   define SB_WIDTH		11	/* scrollBar width */
+#  endif
+# endif				/* XTERM_SCROLLBAR */
+#endif
+
+#define NO_REFRESH		0	/* Window not visible at all!        */
+#define FAST_REFRESH		(1<<1)  /* Fully exposed window              */
+#define SLOW_REFRESH		(1<<2)	/* Partially exposed window          */
+#define SMOOTH_REFRESH		(1<<3)	/* Do sync'ing to make it smooth     */
+
+#ifdef NO_SECONDARY_SCREEN
+# define NSCREENS		0
+#else
+# define NSCREENS		1
+#endif
+
+#define IGNORE			0
+#define SAVE			's'
+#define RESTORE			'r'
+
+/* special (internal) prefix for font commands */
+#define FONT_CMD		'#'
+#define FONT_DN			"#-"
+#define FONT_UP			"#+"
+
+/* flags for scr_gotorc() */
+#define C_RELATIVE		1	/* col movement is relative */
+#define R_RELATIVE		2	/* row movement is relative */
+#define RELATIVE		(R_RELATIVE|C_RELATIVE)
+
+/* modes for scr_insdel_chars(), scr_insdel_lines() */
+#define INSERT			-1	/* don't change these values */
+#define DELETE			+1
+#define ERASE			+2
+
+/* modes for scr_page() - scroll page. used by scrollbar window */
+enum {
+    UP,
+    DN,
+    NO_DIR
+};
+
+/* arguments for scr_change_screen() */
+enum {
+    PRIMARY,
+    SECONDARY
+};
+
+/* all basic bit-flags in first/lower 16 bits */
+
+#define RS_None			0		/* Normal */
+#define RS_fgMask		0x0000001Fu	/* 32 colors */
+#define RS_bgMask		0x000003E0u	/* 32 colors */
+#define RS_Bold			0x00000400u	/* bold */
+#define RS_Blink		0x00000800u	/* blink */
+#define RS_RVid			0x00001000u	/* reverse video */
+#define RS_Uline		0x00002000u	/* underline */
+#define RS_acsFont		0x00004000u	/* ACS graphics char set */
+#define RS_ukFont		0x00008000u	/* UK character set */
+#define RS_fontMask		(RS_acsFont|RS_ukFont)
+#define RS_baseattrMask		(RS_Bold|RS_Blink|RS_RVid|RS_Uline)
+
+/* all other bit-flags in upper 16 bits */
+
+#ifdef MULTICHAR_SET
+# define RS_multi0		0x10000000u	/* only multibyte characters */
+# define RS_multi1		0x20000000u	/* multibyte 1st byte */
+# define RS_multi2		(RS_multi0|RS_multi1)	/* multibyte 2nd byte */
+# define RS_multiMask		(RS_multi0|RS_multi1)	/* multibyte mask */
+#else
+# define RS_multiMask		0
+#endif
+
+#define RS_attrMask		(RS_baseattrMask|RS_fontMask|RS_multiMask)
+
+#define	Opt_console		(1LU<<0)
+#define Opt_loginShell		(1LU<<1)
+#define Opt_iconic		(1LU<<2)
+#define Opt_visualBell		(1LU<<3)
+#define Opt_mapAlert		(1LU<<4)
+#define Opt_reverseVideo	(1LU<<5)
+#define Opt_utmpInhibit		(1LU<<6)
+#define Opt_scrollBar		(1LU<<7)
+#define Opt_scrollBar_right	(1LU<<8)
+#define Opt_scrollBar_floating	(1LU<<9)
+#define Opt_meta8		(1LU<<10)
+#define Opt_scrollTtyOutput	(1LU<<11)
+#define Opt_scrollKeypress	(1LU<<12)
+#define Opt_transparent		(1LU<<13)
+/* place holder used for parsing command-line options */
+#define Opt_Reverse		(1LU<<30)
+#define Opt_Boolean		(1LU<<31)
+
+/*
+ * XTerm escape sequences: ESC ] Ps;Pt BEL
+ */
+#define XTerm_name		0
+#define XTerm_iconName		1
+#define XTerm_title		2
+#define XTerm_logfile		46	/* not implemented */
+#define XTerm_font		50
+
+/*
+ * rxvt extensions of XTerm escape sequences: ESC ] Ps;Pt BEL
+ */
+#define XTerm_Menu		10	/* set menu item */
+#define XTerm_Pixmap		20	/* new bg pixmap */
+#define XTerm_restoreFG		39	/* change default fg color */
+#define XTerm_restoreBG		49	/* change default bg color */
+
+#define restoreFG		39	/* restore default fg color */
+#define restoreBG		49	/* restore default bg color */
+
+/* Words starting with `Color_' are colours.  Others are counts */
+
+enum colour_list {
+    Color_fg = 0,
+    Color_bg,
+    minCOLOR,				/* 2 */
+    Color_Black = minCOLOR,
+    Color_Red3,
+    Color_Green3,
+    Color_Yellow3,
+    Color_Blue3,
+    Color_Magenta3,
+    Color_Cyan3,
+    maxCOLOR,				/* minCOLOR + 7 */
+#ifndef NO_BRIGHTCOLOR
+    Color_AntiqueWhite = maxCOLOR,
+    minBrightCOLOR,			/* maxCOLOR + 1 */
+    Color_Grey25 = minBrightCOLOR,
+    Color_Red,
+    Color_Green,
+    Color_Yellow,
+    Color_Blue,
+    Color_Magenta,
+    Color_Cyan,
+    maxBrightCOLOR,			/* minBrightCOLOR + 7 */
+    Color_White = maxBrightCOLOR,
+#else
+    Color_White = maxCOLOR,
+#endif
+#ifndef NO_CURSORCOLOR
+    Color_cursor,
+    Color_cursor2,
+#endif
+    Color_pointer,
+    Color_border,
+#ifndef NO_BOLDUNDERLINE
+    Color_BD,
+    Color_UL,
+#endif
+#ifdef KEEP_SCROLLCOLOR
+    Color_scroll,
+    Color_trough,
+#endif
+    NRS_COLORS,				/* */
+#ifdef KEEP_SCROLLCOLOR
+    Color_topShadow = NRS_COLORS,
+    Color_bottomShadow,
+    TOTAL_COLORS			/* upto 28 */
+#else
+    TOTAL_COLORS = NRS_COLORS		/* */
+#endif
+};
+
+#define DEFAULT_RSTYLE		(RS_None | (Color_fg) | (Color_bg<<5))
+
+/*
+ * This resource list should match xdefaults.c
+ * - though not necessarily in order
+ */
+enum Rs_resource_list {
+    Rs_display_name = 0, 
+    Rs_term_name,
+    Rs_geometry,
+    Rs_reverseVideo,
+    Rs_color,
+    Rs_font = Rs_color + NRS_COLORS,
+    Rs_iconName = Rs_font + NFONTS,
+#ifdef MULTICHAR_SET
+    Rs_mfont,
+    Rs_multichar_encoding = Rs_mfont + NFONTS,
+#endif
+    Rs_name,
+    Rs_title,
+#if defined (XPM_BACKGROUND) || (MENUBAR_MAX)
+    Rs_path,
+#endif
+#ifdef XPM_BACKGROUND
+    Rs_backgroundPixmap,
+#endif
+#if (MENUBAR_MAX)
+    Rs_menu,
+#endif
+#ifndef NO_BOLDFONT
+    Rs_boldFont,
+#endif
+#ifdef GREEK_SUPPORT
+    Rs_greek_keyboard,
+#endif
+    Rs_loginShell,
+    Rs_scrollBar,
+    Rs_scrollBar_right,
+    Rs_scrollBar_floating,
+    Rs_scrollTtyOutput,
+    Rs_scrollKeypress,
+    Rs_saveLines,
+    Rs_utmpInhibit,
+    Rs_visualBell,
+#if ! defined(NO_MAPALERT) && defined(MAPALERT_OPTION)
+    Rs_mapAlert,
+#endif
+#ifdef META8_OPTION
+    Rs_meta8,
+#endif
+#ifndef NO_BACKSPACE_KEY
+    Rs_backspace_key,
+#endif
+#ifndef NO_DELETE_KEY
+    Rs_delete_key,
+#endif
+    Rs_selectstyle,
+#ifdef PRINTPIPE
+    Rs_print_pipe,
+#endif
+#ifdef USE_XIM
+    Rs_preeditType,
+    Rs_inputMethod,
+#endif
+#if defined (HOTKEY_CTRL) || defined (HOTKEY_META)
+    Rs_bigfont_key,
+    Rs_smallfont_key,
+#endif
+#ifdef TRANSPARENT
+    Rs_transparent,
+#endif
+    Rs_cutchars,
+    Rs_modifier,
+    TOTAL_RS
+} ;
+
+/*
+ * number of graphics points
+ * divisible by 2 (num lines)
+ * divisible by 4 (num rect)
+ */
+#define	NGRX_PTS	1000
+
+/*
+ *****************************************************************************
+ * MACRO DEFINES
+ *****************************************************************************
+ */
+#define STRCPY(a, b)		strcpy ((char *)(a), (const char *) (b))
+#define STRNCPY(a, b, c)	strncpy ((char *)(a), (const char *) (b), (c))
+#ifdef NO_RMEMSET
+# define MEMSET(a, b, c)	memset ((a), (b), (c))
+#else
+# define MEMSET(a, b, c)	rmemset ((a), (b), (intp_t) (c))
+#endif
+
+#define MALLOC(sz)		malloc (sz)
+#define CALLOC(type, n)		calloc ((n), sizeof(type))
+#define REALLOC(mem, sz)	((mem) ? realloc ((mem), (sz)) : malloc(sz))
+#define FREE(ptr)		free (ptr)
+
+/* convert pixel dimensions to row/column values */
+#define Pixel2Col(x)		Pixel2Width((x) - TermWin_internalBorder)
+#define Pixel2Row(y)		Pixel2Height((y) - TermWin_internalBorder)
+#define Pixel2Width(x)		((x) / TermWin.fwidth)
+#define Pixel2Height(y)		((y) / TermWin.fheight)
+#define Col2Pixel(col)		(Width2Pixel(col) + TermWin_internalBorder)
+#define Row2Pixel(row)		(Height2Pixel(row) + TermWin_internalBorder)
+#define Width2Pixel(n)		((n) * TermWin.fwidth)
+#define Height2Pixel(n)		((n) * TermWin.fheight)
+
+#define TermWin_TotalWidth()	(TermWin.width  + 2 * TermWin_internalBorder)
+#define TermWin_TotalHeight()	(TermWin.height + 2 * TermWin_internalBorder)
+
+#define Xscreen			DefaultScreen(Xdisplay)
+#define Xroot			DefaultRootWindow(Xdisplay)
+
+/* how to build & extract colors and attributes */
+#define GET_FGCOLOR(r)		(((r) & RS_fgMask))
+#define GET_BGCOLOR(r)		(((r) & RS_bgMask)>>5)
+#define GET_ATTR(r)		(((r) & RS_attrMask))
+#define GET_BGATTR(r)							\
+    (((r) & RS_RVid) ? (((r) & (RS_attrMask & ~RS_RVid))		\
+			| (((r) & RS_fgMask)<<5))			\
+		     : ((r) & (RS_attrMask | RS_bgMask)))
+#define SET_FGCOLOR(r,fg)	(((r) & ~RS_fgMask)  | (fg))
+#define SET_BGCOLOR(r,bg)	(((r) & ~RS_bgMask)  | ((bg)<<5))
+#define SET_ATTR(r,a)		(((r) & ~RS_attrMask)| (a))
+
+#define scrollbar_visible()	(scrollBar.state)
+#define scrollbar_isMotion()	(scrollBar.state == 'm')
+#define scrollbar_isUp()	(scrollBar.state == 'U')
+#define scrollbar_isDn()	(scrollBar.state == 'D')
+#define scrollbar_isUpDn()	isupper (scrollBar.state)
+#define isScrollbarWindow(w)	(scrollbar_visible() && (w) == scrollBar.win)
+
+#define scrollbar_setNone()	scrollBar.state = 1
+#define scrollbar_setMotion()	scrollBar.state = 'm'
+#define scrollbar_setUp()	scrollBar.state = 'U'
+#define scrollbar_setDn()	scrollBar.state = 'D'
+
+#ifdef NEXT_SCROLLBAR
+# define scrollbar_dnval()	(scrollBar.end + (SB_WIDTH + 1))
+# define scrollbar_upButton(y)	((y) > scrollBar.end \
+				 && (y) <= scrollbar_dnval())
+# define scrollbar_dnButton(y)	((y) > scrollbar_dnval())
+# define SCROLL_MINHEIGHT	SB_THUMB_MIN_HEIGHT
+#else
+# define scrollbar_upButton(y)	((y) < scrollBar.beg)
+# define scrollbar_dnButton(y)	((y) > scrollBar.end)
+# define SCROLL_MINHEIGHT	10
+#endif
+
+#define scrollbar_above_slider(y)	((y) < scrollBar.top)
+#define scrollbar_below_slider(y)	((y) > scrollBar.bot)
+#define scrollbar_position(y)		((y) - scrollBar.beg)
+#define scrollbar_size()		(scrollBar.end - scrollBar.beg - SCROLL_MINHEIGHT)
+
+#if (MENUBAR_MAX > 1)
+/* rendition style flags */
+# define menubar_visible()	(menuBar.state)
+# define menuBar_height()	(TermWin.fheight + SHADOW)
+# define menuBar_TotalHeight()	(menuBar_height() + SHADOW + menuBar_margin)
+# define isMenuBarWindow(w)	((w) == menuBar.win)
+#else
+# define isMenuBarWindow(w)	(0)
+# define menuBar_height()	(0)
+# define menuBar_TotalHeight()	(0)
+# define menubar_visible()	(0)
+#endif
+
+#ifdef XPM_BACKGROUND
+# define XPMClearArea(a, b, c, d, e, f, g)	XClearArea((a), (b), (c), (d), (e), (f), (g))
+#else
+# define XPMClearArea(a, b, c, d, e, f, g)
+#endif
+
+#define Gr_ButtonPress(x,y)	Gr_ButtonReport ('P',(x),(y))
+#define Gr_ButtonRelease(x,y)	Gr_ButtonReport ('R',(x),(y))
+/*
+ *****************************************************************************
+ * VARIABLES
+ *****************************************************************************
+ */
+#ifdef INTERN
+# define EXTERN
+#else
+# define EXTERN extern
+#endif
+
+#ifdef PREFER_24BIT
+EXTERN Colormap     Xcmap;
+EXTERN int          Xdepth;
+EXTERN Visual      *Xvisual;
+#else
+# define Xcmap			DefaultColormap(Xdisplay,Xscreen)
+# define Xdepth			DefaultDepth(Xdisplay,Xscreen)
+# define Xvisual		DefaultVisual(Xdisplay,Xscreen)
+# ifdef DEBUG_DEPTH
+#  undef Xdepth
+#  define Xdepth		DEBUG_DEPTH
+# endif
+#endif
+
+EXTERN TermWin_t	TermWin;
+EXTERN scrollBar_t	scrollBar;
+EXTERN menuBar_t	menuBar;
+EXTERN Display	       *Xdisplay;
+EXTERN unsigned long	Options;
+EXTERN XSizeHints       szHint;
+EXTERN int		sb_shadow;
+EXTERN Pixel		PixColors[TOTAL_COLORS];
+#ifdef INEXPENSIVE_LOCAL_X_CALLS
+EXTERN int              display_is_local;
+#endif
+EXTERN short		want_refresh;
+
+EXTERN const char      *rs[TOTAL_RS];
+
+#ifndef NO_BACKSPACE_KEY
+EXTERN const char      *key_backspace;
+#endif
+#ifndef NO_DELETE_KEY
+EXTERN const char      *key_delete;
+#endif
+#ifndef NO_BRIGHTCOLOR
+EXTERN unsigned int	colorfgbg;
+#endif
+#ifdef KEYSYM_RESOURCE
+EXTERN const unsigned char *KeySym_map[256];
+#endif
+#if defined (HOTKEY_CTRL) || defined (HOTKEY_META)
+EXTERN KeySym		ks_bigfont;
+EXTERN KeySym		ks_smallfont;
+#endif
+
+/*
+ *****************************************************************************
+ * PROTOTYPES
+ *****************************************************************************
+ */
+#include "screen.h"
+
+#ifdef PROTOTYPES
+# define __PROTO(p)	p
+#else
+# define __PROTO(p)	()
+#endif
+#include "protos.h"
+
+#ifdef DEBUG_MALLOC
+# include "dmalloc.h"		/* This comes last */
+#endif
+
+#endif				/* _RXVT_H */
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/screen.c work/main.d/rxvt-2.6.4/src/screen.c
--- tmp/rxvt-2.6.4/src/screen.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/screen.c	2000-11-17 00:20:09.000000000 -0300
@@ -0,0 +1,3505 @@
+/*--------------------------------*-C-*--------------------------------------*
+ * File:	screen.c
+ *---------------------------------------------------------------------------*
+ * $Id: screen.c,v 1.76.2.17 2000/11/17 03:20:09 gcw Exp $
+ *
+ * Copyright (C) 1997,1998 Geoff Wing <gcw@pobox.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *--------------------------------------------------------------------------*/
+/*
+ * We handle _all_ screen updates and selections
+ */
+
+#define INTERN_SCREEN
+#include "rxvt.h"		/* NECESSARY */
+#include "screen.intpro"	/* PROTOS for internal routines */
+
+#include <X11/Xatom.h>
+#include <X11/Xmd.h>		/* get the typedef for CARD32 */
+
+/* ------------------------------------------------------------------------- */
+static char     charsets[4];
+static short    current_screen;
+static rend_t   rstyle;
+static short    rvideo;
+
+#ifdef MULTICHAR_SET
+short           multi_byte;	/* set ==> currently using 2 bytes per glyph */
+short           lost_multi;	/* set ==> we only got half a glyph */
+enum {
+    SBYTE, WBYTE
+} chstat;
+
+#define RESET_CHSTAT			\
+    if (chstat == WBYTE)		\
+	chstat = SBYTE, lost_multi = 1
+#else
+# define RESET_CHSTAT
+#endif
+
+typedef enum {
+    EUCJ, SJIS,			/* KANJI methods */
+    BIG5, CNS,			/* BIG5 methods: CNS not implemented */
+    GB				/* GB method */
+} ENC_METHOD;
+
+#ifdef MULTICHAR_SET
+ENC_METHOD      encoding_method;
+#endif
+
+/* ------------------------------------------------------------------------- */
+#define PROP_SIZE		4096
+#define TABSIZE			8	/* default tab size */
+
+#ifdef DEBUG_SCREEN
+# define D_SCREEN(x)		fprintf x ; fputc('\n', stderr)
+#else
+# define D_SCREEN(x)
+#endif
+#ifdef DEBUG_SELECT
+# define D_SELECT(x)		fprintf x ; fputc('\n', stderr)
+#else
+# define D_SELECT(x)
+#endif
+
+/* ------------------------------------------------------------------------- *
+ *             GENERAL SCREEN AND SELECTION UPDATE ROUTINES                  *
+ * ------------------------------------------------------------------------- */
+#define ZERO_SCROLLBACK						\
+    if ((Options & Opt_scrollTtyOutput) == Opt_scrollTtyOutput)	\
+	TermWin.view_start = 0
+#define CHECK_SELECTION(x)					\
+    if (selection.op)						\
+	selection_check(x)
+#define CLEAR_SELECTION						\
+    selection.beg.row = selection.beg.col			\
+	= selection.end.row = selection.end.col = 0
+#define CLEAR_ALL_SELECTION					\
+    selection.beg.row = selection.beg.col			\
+	= selection.mark.row = selection.mark.col		\
+	= selection.end.row = selection.end.col = 0
+
+#define ROW_AND_COL_IS_AFTER(A, B, C, D)				\
+    (((A) > (C)) || (((A) == (C)) && ((B) > (D))))
+#define ROW_AND_COL_IS_BEFORE(A, B, C, D)				\
+    (((A) < (C)) || (((A) == (C)) && ((B) < (D))))
+#define ROW_AND_COL_IN_ROW_AFTER(A, B, C, D)				\
+    (((A) == (C)) && ((B) > (D)))
+#define ROW_AND_COL_IN_ROW_AT_OR_AFTER(A, B, C, D)			\
+    (((A) == (C)) && ((B) >= (D)))
+#define ROW_AND_COL_IN_ROW_BEFORE(A, B, C, D)				\
+    (((A) == (C)) && ((B) < (D)))
+#define ROW_AND_COL_IN_ROW_AT_OR_BEFORE(A, B, C, D)			\
+    (((A) == (C)) && ((B) <= (D)))
+
+/* these must be row_col_t */
+#define ROWCOL_IS_AFTER(X, Y)						\
+    ROW_AND_COL_IS_AFTER((X).row, (X).col, (Y).row, (Y).col)
+#define ROWCOL_IS_BEFORE(X, Y)						\
+    ROW_AND_COL_IS_BEFORE((X).row, (X).col, (Y).row, (Y).col)
+#define ROWCOL_IN_ROW_AFTER(X, Y)					\
+    ROW_AND_COL_IN_ROW_AFTER((X).row, (X).col, (Y).row, (Y).col)
+#define ROWCOL_IN_ROW_BEFORE(X, Y)					\
+    ROW_AND_COL_IN_ROW_BEFORE((X).row, (X).col, (Y).row, (Y).col)
+#define ROWCOL_IN_ROW_AT_OR_AFTER(X, Y)					\
+    ROW_AND_COL_IN_ROW_AT_OR_AFTER((X).row, (X).col, (Y).row, (Y).col)
+#define ROWCOL_IN_ROW_AT_OR_BEFORE(X, Y)				\
+    ROW_AND_COL_IN_ROW_AT_OR_BEFORE((X).row, (X).col, (Y).row, (Y).col)
+
+/*
+ * CLEAR_ROWS : clear <num> rows starting from row <row>
+ * CLEAR_CHARS: clear <num> chars starting from pixel position <x,y>
+ * ERASE_ROWS : set <num> rows starting from row <row> to the foreground colour
+ */
+#if defined(XPM_BACKGROUND) && defined(XPM_BUFFERING)
+
+#define drawBuffer	(TermWin.buf_pixmap)
+
+#define CLEAR_ROWS(row, num)						\
+    if (TermWin.mapped)							\
+	XCopyArea(Xdisplay, TermWin.pixmap, drawBuffer, TermWin.gc,	\
+		  Col2Pixel(0), Row2Pixel(row),				\
+		  TermWin.width, Height2Pixel(num),			\
+		  Col2Pixel(0), Row2Pixel(row))
+
+#define CLEAR_CHARS(x, y, num)						\
+    if (TermWin.mapped)							\
+	XCopyArea(Xdisplay, TermWin.pixmap, drawBuffer, TermWin.gc,	\
+		  x, y, Width2Pixel(num), Height2Pixel(1), x, y)
+
+#else				/* XPM_BUFFERING && XPM_BACKGROUND */
+
+#define drawBuffer	(TermWin.vt)
+
+#define CLEAR_ROWS(row, num)						\
+    if (TermWin.mapped)							\
+	XClearArea(Xdisplay, drawBuffer, Col2Pixel(0), Row2Pixel(row),	\
+		   TermWin.width, Height2Pixel(num), 0)
+
+#define CLEAR_CHARS(x, y, num)						\
+    if (TermWin.mapped)							\
+	XClearArea(Xdisplay, drawBuffer, x, y,				\
+		   Width2Pixel(num), Height2Pixel(1), 0)
+
+#endif				/* XPM_BUFFERING && XPM_BACKGROUND */
+
+#define ERASE_ROWS(row, num)						\
+    XFillRectangle(Xdisplay, drawBuffer, TermWin.gc,			\
+		   Col2Pixel(0), Row2Pixel(row),			\
+		   TermWin.width, Height2Pixel(num))
+
+/* ------------------------------------------------------------------------- *
+ *                        SCREEN `COMMON' ROUTINES                           *
+ * ------------------------------------------------------------------------- */
+/* Fill part/all of a line with blanks. */
+/* INTPROTO */
+void
+blank_line(text_t * et, rend_t * er, int width, rend_t efs)
+{
+    MEMSET(et, ' ', width);
+    for (; width--;)
+	*er++ = efs;
+}
+
+/* ------------------------------------------------------------------------- */
+/* Fill a full line with blanks - make sure it is allocated first */
+/* INTPROTO */
+void
+blank_screen_mem(text_t ** tp, rend_t ** rp, int row, rend_t efs, char keepr)
+{
+    int             width = TermWin.ncol;
+    rend_t         *er;
+
+    if (tp[row] == NULL) {
+	tp[row] = MALLOC(sizeof(text_t) * TermWin.ncol);
+	rp[row] = MALLOC(sizeof(rend_t) * TermWin.ncol);
+    }
+    if (!keepr)
+	efs &= ~(RS_Uline);
+    MEMSET(tp[row], ' ', width);
+    for (er = rp[row]; width--;)
+	*er++ = efs;
+}
+
+/* ------------------------------------------------------------------------- *
+ *                          SCREEN INITIALISATION                            *
+ * ------------------------------------------------------------------------- */
+static int      prev_nrow = -1, prev_ncol = -1;
+
+/* EXTPROTO */
+void
+scr_reset(void)
+{
+    int             i, j, k, total_rows, prev_total_rows;
+    rend_t          setrstyle;
+
+    D_SCREEN((stderr, "scr_reset()"));
+
+    TermWin.view_start = 0;
+    RESET_CHSTAT;
+
+    if (TermWin.ncol == prev_ncol && TermWin.nrow == prev_nrow)
+	return;
+
+    want_refresh = 1;
+
+    if (TermWin.ncol <= 0)
+	TermWin.ncol = 80;
+    if (TermWin.nrow <= 0)
+	TermWin.nrow = 24;
+#ifdef DEBUG_STRICT
+    assert(TermWin.saveLines >= 0);
+#else				/* drive with your eyes closed */
+    MAX_IT(TermWin.saveLines, 0);
+#endif
+
+    total_rows = TermWin.nrow + TermWin.saveLines;
+    prev_total_rows = prev_nrow + TermWin.saveLines;
+
+    screen.tscroll = 0;
+    screen.bscroll = (TermWin.nrow - 1);
+
+    if (prev_nrow == -1) {
+/*
+ * A: first time called so just malloc everything : don't rely on realloc
+ *    Note: this is still needed so that all the scrollback lines are NULL
+ */
+	screen.text = CALLOC(text_t *, total_rows);
+	buf_text = CALLOC(text_t *, total_rows);
+	drawn_text = CALLOC(text_t *, TermWin.nrow);
+	swap.text = CALLOC(text_t *, TermWin.nrow);
+
+	screen.tlen = CALLOC(int16_t, total_rows);
+	buf_tlen = CALLOC(int16_t, total_rows);
+	swap.tlen = CALLOC(int16_t, TermWin.nrow);
+
+	screen.rend = CALLOC(rend_t *, total_rows);
+	buf_rend = CALLOC(rend_t *, total_rows);
+	drawn_rend = CALLOC(rend_t *, TermWin.nrow);
+	swap.rend = CALLOC(rend_t *, TermWin.nrow);
+
+	for (i = 0; i < TermWin.nrow; i++) {
+	    j = i + TermWin.saveLines;
+	    blank_screen_mem(screen.text, screen.rend, j, DEFAULT_RSTYLE, 1);
+	    blank_screen_mem(swap.text, swap.rend, i, DEFAULT_RSTYLE, 1);
+	    screen.tlen[j] = swap.tlen[i] = 0;
+	    blank_screen_mem(drawn_text, drawn_rend, i, DEFAULT_RSTYLE, 1);
+	}
+	TermWin.nscrolled = 0;	/* no saved lines */
+	screen.flags = swap.flags = Screen_DefaultFlags;
+	save.cur.row = save.cur.col = 0;
+	save.charset = 0;
+	save.charset_char = 'B';
+	rstyle = save.rstyle = DEFAULT_RSTYLE;
+	selection.text = NULL;
+	selection.len = 0;
+	selection.op = SELECTION_CLEAR;
+	selection.screen = PRIMARY;
+	selection.clicks = 0;
+	CLEAR_ALL_SELECTION;
+	MEMSET(charsets, 'B', sizeof(charsets));
+	current_screen = PRIMARY;
+	rvideo = 0;
+#ifdef MULTICHAR_SET
+	multi_byte = 0;
+	lost_multi = 0;
+	chstat = SBYTE;
+# ifdef ZH
+	encoding_method = BIG5;
+# else 
+#  ifdef ZHCN
+	encoding_method = GB;
+#  endif
+# endif
+#endif
+
+    } else {
+/*
+ * B1: add or delete rows as appropriate
+ */
+	setrstyle = DEFAULT_RSTYLE | (rvideo ? RS_RVid : 0);
+
+	if (TermWin.nrow < prev_nrow) {
+	/* delete rows */
+	    k = min(TermWin.nscrolled, prev_nrow - TermWin.nrow);
+	    scroll_text(0, prev_nrow - 1, k, 1);
+	    for (i = TermWin.nrow; i < prev_nrow; i++) {
+		j = i + TermWin.saveLines;
+		if (screen.text[j])
+		    FREE(screen.text[j]);
+		if (screen.rend[j])
+		    FREE(screen.rend[j]);
+		if (swap.text[i])
+		    FREE(swap.text[i]);
+		if (swap.rend[i])
+		    FREE(swap.rend[i]);
+		FREE(drawn_text[i]);
+		FREE(drawn_rend[i]);
+	    }
+	/* we have fewer rows so fix up cursor position */
+	    MIN_IT(screen.cur.row, TermWin.nrow - 1);
+	    MIN_IT(swap.cur.row, TermWin.nrow - 1);
+
+	    scr_reset_realloc();	/* REALLOC _last_ */
+
+	} else if (TermWin.nrow > prev_nrow) {
+	/* add rows */
+	    scr_reset_realloc();	/* REALLOC _first_ */
+
+	    k = min(TermWin.nscrolled, TermWin.nrow - prev_nrow);
+	    for (i = prev_total_rows; i < total_rows - k; i++) {
+		screen.tlen[i] = 0;
+		screen.text[i] = NULL;
+		blank_screen_mem(screen.text, screen.rend, i, setrstyle, 1);
+	    }
+	    for (i = total_rows - k; i < total_rows; i++) {
+		screen.tlen[i] = 0;
+		screen.text[i] = NULL;
+		screen.rend[i] = NULL;
+	    }
+	    for (i = prev_nrow; i < TermWin.nrow; i++) {
+		swap.tlen[i] = 0;
+		swap.text[i] = NULL;
+		drawn_text[i] = NULL;
+		blank_screen_mem(swap.text, swap.rend, i, setrstyle, 1);
+		blank_screen_mem(drawn_text, drawn_rend, i, setrstyle, 1);
+	    }
+	    if (k > 0) {
+		scroll_text(0, TermWin.nrow - 1, -k, 1);
+		screen.cur.row += k;
+		TermWin.nscrolled -= k;
+		for (i = TermWin.saveLines - TermWin.nscrolled; k--; i--)
+		    if (screen.text[i] == NULL) {
+			blank_screen_mem(screen.text, screen.rend, i,
+					 setrstyle, 1);
+			screen.tlen[i] = 0;
+		    }
+	    }
+#ifdef DEBUG_STRICT
+	    assert(screen.cur.row < TermWin.nrow);
+	    assert(swap.cur.row < TermWin.nrow);
+#else				/* drive with your eyes closed */
+	    MIN_IT(screen.cur.row, TermWin.nrow - 1);
+	    MIN_IT(swap.cur.row, TermWin.nrow - 1);
+#endif
+	}
+/* B2: resize columns */
+	if (TermWin.ncol != prev_ncol) {
+	    for (i = 0; i < total_rows; i++) {
+		if (screen.text[i]) {
+		    screen.text[i] = REALLOC(screen.text[i],
+					     TermWin.ncol * sizeof(text_t));
+		    screen.rend[i] = REALLOC(screen.rend[i],
+					     TermWin.ncol * sizeof(rend_t));
+		    MIN_IT(screen.tlen[i], TermWin.ncol);
+		    if (TermWin.ncol > prev_ncol)
+			blank_line(&(screen.text[i][prev_ncol]),
+				   &(screen.rend[i][prev_ncol]),
+				   TermWin.ncol - prev_ncol, setrstyle);
+		}
+	    }
+	    for (i = 0; i < TermWin.nrow; i++) {
+		drawn_text[i] = REALLOC(drawn_text[i],
+					TermWin.ncol * sizeof(text_t));
+		drawn_rend[i] = REALLOC(drawn_rend[i],
+					TermWin.ncol * sizeof(rend_t));
+		if (swap.text[i]) {
+		    swap.text[i] = REALLOC(swap.text[i],
+					   TermWin.ncol * sizeof(text_t));
+		    swap.rend[i] = REALLOC(swap.rend[i],
+					   TermWin.ncol * sizeof(rend_t));
+		    MIN_IT(swap.tlen[i], TermWin.ncol);
+		    if (TermWin.ncol > prev_ncol)
+			blank_line(&(swap.text[i][prev_ncol]),
+				   &(swap.rend[i][prev_ncol]),
+				   TermWin.ncol - prev_ncol, setrstyle);
+		}
+		if (TermWin.ncol > prev_ncol)
+		    blank_line(&(drawn_text[i][prev_ncol]),
+			       &(drawn_rend[i][prev_ncol]),
+			       TermWin.ncol - prev_ncol, setrstyle);
+	    }
+	    MIN_IT(screen.cur.col, TermWin.ncol - 1);
+	    MIN_IT(swap.cur.col, TermWin.ncol - 1);
+	}
+	if (tabs)
+	    FREE(tabs);
+    }
+
+    tabs = MALLOC(TermWin.ncol * sizeof(char));
+
+    for (i = 0; i < TermWin.ncol; i++)
+	tabs[i] = (i % TABSIZE == 0) ? 1 : 0;
+
+    prev_nrow = TermWin.nrow;
+    prev_ncol = TermWin.ncol;
+
+    tt_resize();
+}
+
+/* INTPROTO */
+void
+scr_reset_realloc(void)
+{
+    int             total_rows;
+
+    total_rows = TermWin.nrow + TermWin.saveLines;
+/* *INDENT-OFF* */
+    screen.text = REALLOC(screen.text, total_rows   * sizeof(text_t *));
+    buf_text    = REALLOC(buf_text   , total_rows   * sizeof(text_t *));
+    drawn_text  = REALLOC(drawn_text , TermWin.nrow * sizeof(text_t *));
+    swap.text   = REALLOC(swap.text  , TermWin.nrow * sizeof(text_t *));
+
+    screen.tlen = REALLOC(screen.tlen, total_rows   * sizeof(int16_t));
+    buf_tlen    = REALLOC(buf_tlen   , total_rows   * sizeof(int16_t));
+    swap.tlen   = REALLOC(swap.tlen  , total_rows   * sizeof(int16_t));
+
+    screen.rend = REALLOC(screen.rend, total_rows   * sizeof(rend_t *));
+    buf_rend    = REALLOC(buf_rend   , total_rows   * sizeof(rend_t *));
+    drawn_rend  = REALLOC(drawn_rend , TermWin.nrow * sizeof(rend_t *));
+    swap.rend   = REALLOC(swap.rend  , TermWin.nrow * sizeof(rend_t *));
+/* *INDENT-ON* */
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Free everything.  That way malloc debugging can find leakage.
+ */
+/* EXTPROTO */
+void
+scr_release(void)
+{
+    int             i, total_rows;
+
+    total_rows = TermWin.nrow + TermWin.saveLines;
+    for (i = 0; i < total_rows; i++) {
+	if (screen.text[i]) {	/* then so is screen.rend[i] */
+	    FREE(screen.text[i]);
+	    FREE(screen.rend[i]);
+	}
+    }
+    for (i = 0; i < TermWin.nrow; i++) {
+	FREE(drawn_text[i]);
+	FREE(drawn_rend[i]);
+	FREE(swap.text[i]);
+	FREE(swap.rend[i]);
+    }
+    FREE(screen.text);
+    FREE(screen.tlen);
+    FREE(screen.rend);
+    FREE(drawn_text);
+    FREE(drawn_rend);
+    FREE(swap.text);
+    FREE(swap.tlen);
+    FREE(swap.rend);
+    FREE(buf_text);
+    FREE(buf_tlen);
+    FREE(buf_rend);
+    FREE(tabs);
+
+/* NULL these so if anything tries to use them, we'll know about it */
+    screen.text = drawn_text = swap.text = NULL;
+    screen.rend = drawn_rend = swap.rend = NULL;
+    screen.tlen = swap.tlen = buf_tlen = NULL;
+    buf_text = NULL;
+    buf_rend = NULL;
+    tabs = NULL;
+}
+
+/* ------------------------------------------------------------------------- */
+/* EXTPROTO */
+void
+scr_poweron(void)
+{
+    D_SCREEN((stderr, "scr_poweron()"));
+
+    MEMSET(charsets, 'B', sizeof(charsets));
+    rvideo = 0;
+    swap.tscroll = 0;
+    swap.bscroll = TermWin.nrow - 1;
+    screen.cur.row = screen.cur.col = swap.cur.row = swap.cur.col = 0;
+    screen.charset = swap.charset = 0;
+    screen.flags = swap.flags = Screen_DefaultFlags;
+
+    scr_cursor(SAVE);
+
+    scr_release();
+    prev_nrow = -1;
+    prev_ncol = -1;
+    scr_reset();
+
+    scr_clear();
+    scr_refresh(SLOW_REFRESH);
+    Gr_reset();
+}
+
+/* ------------------------------------------------------------------------- *
+ *                         PROCESS SCREEN COMMANDS                           *
+ * ------------------------------------------------------------------------- */
+/*
+ * Save and Restore cursor
+ * XTERM_SEQ: Save cursor   : ESC 7     
+ * XTERM_SEQ: Restore cursor: ESC 8
+ */
+/* EXTPROTO */
+void
+scr_cursor(int mode)
+{
+    D_SCREEN((stderr, "scr_cursor(%c)", mode));
+
+    switch (mode) {
+    case SAVE:
+	save.cur.row = screen.cur.row;
+	save.cur.col = screen.cur.col;
+	save.rstyle = rstyle;
+	save.charset = screen.charset;
+	save.charset_char = charsets[screen.charset];
+	break;
+    case RESTORE:
+	want_refresh = 1;
+	screen.cur.row = save.cur.row;
+	screen.cur.col = save.cur.col;
+	screen.flags &= ~Screen_WrapNext;
+	rstyle = save.rstyle;
+	screen.charset = save.charset;
+	charsets[screen.charset] = save.charset_char;
+	set_font_style();
+	break;
+    }
+/* boundary check in case screen size changed between SAVE and RESTORE */
+    MIN_IT(screen.cur.row, TermWin.nrow - 1);
+    MIN_IT(screen.cur.col, TermWin.ncol - 1);
+#ifdef DEBUG_STRICT
+    assert(screen.cur.row >= 0);
+    assert(screen.cur.col >= 0);
+#else				/* drive with your eyes closed */
+    MAX_IT(screen.cur.row, 0);
+    MAX_IT(screen.cur.col, 0);
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Swap between primary and secondary screens
+ * XTERM_SEQ: Primary screen  : ESC [ ? 4 7 h
+ * XTERM_SEQ: Secondary screen: ESC [ ? 4 7 l
+ */
+/* EXTPROTO */
+int
+scr_change_screen(int scrn)
+{
+    int             i, tmp;
+#if NSCREENS
+    int             offset;
+    text_t         *t0;
+    rend_t         *r0;
+    int16_t         l0;
+#endif
+
+    want_refresh = 1;
+
+    D_SCREEN((stderr, "scr_change_screen(%d)", scrn));
+
+    TermWin.view_start = 0;
+    RESET_CHSTAT;
+
+    if (current_screen == scrn)
+	return current_screen;
+
+    CHECK_SELECTION(2);		/* check for boundary cross */
+
+    SWAP_IT(current_screen, scrn, tmp);
+#if NSCREENS
+    offset = TermWin.saveLines;
+    for (i = TermWin.nrow; i--;) {
+	SWAP_IT(screen.text[i + offset], swap.text[i], t0);
+	SWAP_IT(screen.tlen[i + offset], swap.tlen[i], l0);
+	SWAP_IT(screen.rend[i + offset], swap.rend[i], r0);
+    }
+    SWAP_IT(screen.cur.row, swap.cur.row, l0);
+    SWAP_IT(screen.cur.col, swap.cur.col, l0);
+# ifdef DEBUG_STRICT
+    assert(screen.cur.row >= 0);
+    assert(screen.cur.col >= 0);
+    assert(screen.cur.row < TermWin.nrow);
+    assert(screen.cur.col < TermWin.ncol);
+# else				/* drive with your eyes closed */
+    MAX_IT(screen.cur.row, 0);
+    MAX_IT(screen.cur.col, 0);
+    MIN_IT(screen.cur.row, TermWin.nrow - 1);
+    MIN_IT(screen.cur.col, TermWin.ncol - 1);
+# endif
+    SWAP_IT(screen.charset, swap.charset, l0);
+    SWAP_IT(screen.flags, swap.flags, tmp);
+    screen.flags |= Screen_VisibleCursor;
+    swap.flags |= Screen_VisibleCursor;
+
+    if (Gr_Displayed()) {
+	Gr_scroll(0);
+	Gr_ChangeScreen();
+    }
+#else
+# ifdef SCROLL_ON_NO_SECONDARY
+    if (Gr_Displayed())
+	Gr_ClearScreen();
+    if (current_screen == PRIMARY) {
+	if (!Gr_Displayed())
+	    scroll_text(0, (TermWin.nrow - 1), TermWin.nrow, 0);
+	for (i = TermWin.saveLines; i < TermWin.nrow + TermWin.saveLines; i++)
+	    if (screen.text[i] == NULL) {
+		blank_screen_mem(screen.text, screen.rend, i, DEFAULT_RSTYLE,
+				 0);
+		screen.tlen[i] = 0;
+	    }
+    }
+# endif
+#endif
+    return scrn;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Change the colour for following text
+ */
+/* EXTPROTO */
+void
+scr_color(unsigned int color, unsigned int Intensity)
+{
+    if (color == restoreFG)
+	color = Color_fg;
+    else if (color == restoreBG)
+	color = Color_bg;
+    else {
+	if (Xdepth <= 2) {	/* Monochrome - ignore colour changes */
+	    switch (Intensity) {
+	    case RS_Bold:
+		color = Color_fg;
+		break;
+	    case RS_Blink:
+		color = Color_bg;
+		break;
+	    }
+	} else {
+#ifndef NO_BRIGHTCOLOR
+	    if ((rstyle & Intensity) && color >= minCOLOR && color <= maxCOLOR)
+		color += (minBrightCOLOR - minCOLOR);
+	    else if (color >= minBrightCOLOR && color <= maxBrightCOLOR) {
+		if (rstyle & Intensity)
+		    return;
+		color -= (minBrightCOLOR - minCOLOR);
+	    }
+#endif
+	}
+    }
+    switch (Intensity) {
+    case RS_Bold:
+	rstyle = SET_FGCOLOR(rstyle, color);
+	break;
+    case RS_Blink:
+	rstyle = SET_BGCOLOR(rstyle, color);
+	break;
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Change the rendition style for following text
+ */
+/* EXTPROTO */
+void
+scr_rendition(int set, int style)
+{
+    unsigned int    color;
+    rend_t          font_attr;
+
+    if (set) {
+/* A: Set style */
+	rstyle |= style;
+	switch (style) {
+	case RS_RVid:
+	    if (rvideo)
+		rstyle &= ~RS_RVid;
+	    break;
+#ifndef NO_BRIGHTCOLOR
+	case RS_Bold:
+	    color = GET_FGCOLOR(rstyle);
+	    scr_color((color == Color_fg ? GET_FGCOLOR(colorfgbg) : color),
+		      RS_Bold);
+	    break;
+	case RS_Blink:
+	    color = GET_BGCOLOR(rstyle);
+	    scr_color((color == Color_bg ? GET_BGCOLOR(colorfgbg) : color),
+		      RS_Blink);
+	    break;
+#endif
+	}
+    } else {
+/* B: Unset style */
+	font_attr = rstyle & RS_fontMask;
+	rstyle &= ~style;
+
+	switch (style) {
+	case ~RS_None:		/* default fg/bg colours */
+	    rstyle = DEFAULT_RSTYLE | font_attr;
+	/* FALLTHROUGH */
+	case RS_RVid:
+	    if (rvideo)
+		rstyle |= RS_RVid;
+	    break;
+#ifndef NO_BRIGHTCOLOR
+	case RS_Bold:
+	    color = GET_FGCOLOR(rstyle);
+	    if (color >= minBrightCOLOR && color <= maxBrightCOLOR) {
+		scr_color(color, RS_Bold);
+		if ((rstyle & RS_fgMask) == (colorfgbg & RS_fgMask))
+		    scr_color(restoreFG, RS_Bold);
+	    }
+	    break;
+	case RS_Blink:
+	    color = GET_BGCOLOR(rstyle);
+	    if (color >= minBrightCOLOR && color <= maxBrightCOLOR) {
+		scr_color(color, RS_Blink);
+		if ((rstyle & RS_bgMask) == (colorfgbg & RS_bgMask))
+		    scr_color(restoreBG, RS_Blink);
+	    }
+	    break;
+#endif
+	}
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Scroll text between <row1> and <row2> inclusive, by <count> lines
+ * count positive ==> scroll up
+ * count negative ==> scroll down
+ * spec == 0 for normal routines
+ */
+/* INTPROTO */
+int
+scroll_text(int row1, int row2, int count, int spec)
+{
+    int             i, j;
+
+    want_refresh = 1;
+    D_SCREEN((stderr, "scroll_text(%d,%d,%d,%d): %s", row1, row2, count, spec, (current_screen == PRIMARY) ? "Primary" : "Secondary"));
+
+    if (count == 0 || (row1 > row2))
+	return 0;
+
+    if ((count > 0) && (row1 == 0) && (current_screen == PRIMARY)) {
+	TermWin.nscrolled += count;
+	MIN_IT(TermWin.nscrolled, TermWin.saveLines);
+    } else if (!spec)
+	row1 += TermWin.saveLines;
+    row2 += TermWin.saveLines;
+
+    if (selection.op && current_screen == selection.screen) {
+	i = selection.beg.row + TermWin.saveLines;
+	j = selection.end.row + TermWin.saveLines;
+	if ((i < row1 && j > row1)
+	    || (i < row2 && j > row2)
+	    || (i - count < row1 && i >= row1)
+	    || (i - count > row2 && i <= row2)
+	    || (j - count < row1 && j >= row1)
+	    || (j - count > row2 && j <= row2)) {
+	    CLEAR_ALL_SELECTION;
+	    selection.op = SELECTION_CLEAR;	/* XXX: too aggressive? */
+	} else if (j >= row1 && j <= row2) {
+	/* move selected region too */
+	    selection.beg.row -= count;
+	    selection.end.row -= count;
+	    selection.mark.row -= count;
+	}
+    }
+    CHECK_SELECTION(0);		/* _after_ TermWin.nscrolled update */
+
+    if (count > 0) {
+/* A: scroll up */
+
+	MIN_IT(count, row2 - row1 + 1);
+/* A1: Copy lines that will get clobbered by the rotation */
+	for (i = 0, j = row1; i < count; i++, j++) {
+	    buf_text[i] = screen.text[j];
+	    buf_tlen[i] = screen.tlen[j];
+	    buf_rend[i] = screen.rend[j];
+	}
+/* A2: Rotate lines */
+	for (j = row1; (j + count) <= row2; j++) {
+	    screen.text[j] = screen.text[j + count];
+	    screen.tlen[j] = screen.tlen[j + count];
+	    screen.rend[j] = screen.rend[j + count];
+	}
+/* A3: Resurrect lines */
+	for (i = 0; i < count; i++, j++) {
+	    screen.text[j] = buf_text[i];
+	    screen.tlen[j] = buf_tlen[i];
+	    screen.rend[j] = buf_rend[i];
+	}
+    } else if (count < 0) {
+/* B: scroll down */
+
+	count = min(-count, row2 - row1 + 1);
+/* B1: Copy lines that will get clobbered by the rotation */
+	for (i = 0, j = row2; i < count; i++, j--) {
+	    buf_text[i] = screen.text[j];
+	    buf_tlen[i] = screen.tlen[j];
+	    buf_rend[i] = screen.rend[j];
+	}
+/* B2: Rotate lines */
+	for (j = row2; (j - count) >= row1; j--) {
+	    screen.text[j] = screen.text[j - count];
+	    screen.tlen[j] = screen.tlen[j - count];
+	    screen.rend[j] = screen.rend[j - count];
+	}
+/* B3: Resurrect lines */
+	for (i = 0, j = row1; i < count; i++, j++) {
+	    screen.text[j] = buf_text[i];
+	    screen.tlen[j] = buf_tlen[i];
+	    screen.rend[j] = buf_rend[i];
+	}
+	count = -count;
+    }
+    if (Gr_Displayed())
+	Gr_scroll(count);
+    return count;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * A safe scroll text routine
+ */
+/* EXTPROTO */
+void
+scr_scroll_text(int count)
+{
+    int             row, erow;
+
+    if (count == 0)
+	return;
+    count = scroll_text(screen.tscroll, screen.bscroll, count, 0);
+/* XXX: Ummm, no?  care needed with [bt]scroll, yes? */
+    if (count > 0) {
+	row = TermWin.nrow - count + TermWin.saveLines;
+	erow = TermWin.nrow + TermWin.saveLines;
+    } else {
+	row = TermWin.saveLines;
+	erow = TermWin.saveLines - count;
+    }
+    for (; row < erow; row++)
+	if (screen.text[row] == NULL)
+	    blank_screen_mem(screen.text, screen.rend, row, rstyle, 0);
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Add text given in <str> of length <len> to screen struct
+ */
+/* EXTPROTO */
+void
+scr_add_lines(const unsigned char *str, int nlines, int len)
+{
+    char            c;
+    int             i, j, row, last_col, checksel, clearsel;
+    text_t         *stp;
+    rend_t         *srp;
+
+    if (len <= 0)		/* sanity */
+	return;
+
+    want_refresh = 1;
+    last_col = TermWin.ncol;
+
+    D_SCREEN((stderr, "scr_add_lines(*,%d,%d)", nlines, len));
+    ZERO_SCROLLBACK;
+    if (nlines > 0) {
+	nlines += (screen.cur.row - screen.bscroll);
+	if ((nlines > 0)
+	    && (screen.tscroll == 0)
+	    && (screen.bscroll == (TermWin.nrow - 1))) {
+	/* _at least_ this many lines need to be scrolled */
+	    scroll_text(screen.tscroll, screen.bscroll, nlines, 0);
+	    for (i = nlines, j = screen.bscroll + TermWin.saveLines; i--; j--) {
+		blank_screen_mem(screen.text, screen.rend, j, rstyle, 0);
+		screen.tlen[j] = 0;
+	    }
+	    screen.cur.row -= nlines;
+	}
+    }
+#ifdef DEBUG_STRICT
+    assert(screen.cur.col < last_col);
+    assert(screen.cur.row < TermWin.nrow);
+    assert(screen.cur.row >= -TermWin.nscrolled);
+#else				/* drive with your eyes closed */
+    MIN_IT(screen.cur.col, last_col - 1);
+    MIN_IT(screen.cur.row, TermWin.nrow - 1);
+    MAX_IT(screen.cur.row, -TermWin.nscrolled);
+#endif
+    row = screen.cur.row + TermWin.saveLines;
+
+    checksel = (selection.op && current_screen == selection.screen) ? 1 : 0;
+    clearsel = 0;
+
+    stp = screen.text[row];
+    srp = screen.rend[row];
+
+#ifdef MULTICHAR_SET
+    if (lost_multi && screen.cur.col > 0
+	&& ((srp[screen.cur.col - 1] & RS_multiMask) == RS_multi1)
+	&& *str != '\n' && *str != '\r' && *str != '\t')
+	chstat = WBYTE;
+#endif
+
+    for (i = 0; i < len;) {
+	c = str[i++];
+	switch (c) {
+	case '\t':
+	    scr_tab(1);
+	    continue;
+	case '\n':
+	    if (screen.tlen[row] != -1)		/* XXX: think about this */
+		MAX_IT(screen.tlen[row], screen.cur.col);
+	    screen.flags &= ~Screen_WrapNext;
+	    if (screen.cur.row == screen.bscroll) {
+		scroll_text(screen.tscroll, screen.bscroll, 1, 0);
+		j = screen.bscroll + TermWin.saveLines;
+		blank_screen_mem(screen.text, screen.rend, j,
+				 rstyle, 0);
+		screen.tlen[j] = 0;
+	    } else if (screen.cur.row < (TermWin.nrow - 1))
+		row = (++screen.cur.row) + TermWin.saveLines;
+	    stp = screen.text[row];	/* _must_ refresh */
+	    srp = screen.rend[row];	/* _must_ refresh */
+	    RESET_CHSTAT;
+	    continue;
+	case '\r':
+	    if (screen.tlen[row] != -1)		/* XXX: think about this */
+		MAX_IT(screen.tlen[row], screen.cur.col);
+	    screen.flags &= ~Screen_WrapNext;
+	    screen.cur.col = 0;
+	    RESET_CHSTAT;
+	    continue;
+	default:
+#ifdef MULTICHAR_SET
+	    rstyle &= ~RS_multiMask;
+	    if (chstat == WBYTE) {
+		rstyle |= RS_multi2;	/* multibyte 2nd byte */
+		chstat = SBYTE;
+		if ((encoding_method == EUCJ) || (encoding_method == GB))
+		    c |= 0x80;	/* maybe overkill, but makes it selectable */
+	    } else if (chstat == SBYTE) {
+		if (multi_byte || (c & 0x80)) {	/* multibyte 1st byte */
+		    rstyle |= RS_multi1;
+		    chstat = WBYTE;
+		    if ((encoding_method == EUCJ) || (encoding_method == GB))
+			c |= 0x80; /* maybe overkill, but makes selectable */
+		}
+	    } else
+#endif
+	    if (c == 127)
+		continue;	/* yummmm..... */
+	    break;
+	}
+
+	if (checksel
+	    && !ROWCOL_IS_BEFORE(screen.cur, selection.beg)
+	    && ROWCOL_IS_BEFORE(screen.cur, selection.end)) {
+	    checksel = 0;
+	    clearsel = 1;
+	}
+	if (screen.flags & Screen_WrapNext) {
+	    screen.tlen[row] = -1;
+	    if (screen.cur.row == screen.bscroll) {
+		scroll_text(screen.tscroll, screen.bscroll, 1, 0);
+		j = screen.bscroll + TermWin.saveLines;
+		blank_screen_mem(screen.text, screen.rend, j, rstyle, 0);
+		screen.tlen[j] = 0;
+	    } else if (screen.cur.row < (TermWin.nrow - 1))
+		row = (++screen.cur.row) + TermWin.saveLines;
+	    stp = screen.text[row];	/* _must_ refresh */
+	    srp = screen.rend[row];	/* _must_ refresh */
+	    screen.cur.col = 0;
+	    screen.flags &= ~Screen_WrapNext;
+	}
+	if (screen.flags & Screen_Insert)
+	    scr_insdel_chars(1, INSERT);
+#ifdef MULTICHAR_SET
+	if ((rstyle & RS_multiMask) == RS_multi1
+	    && screen.cur.col > 0
+	    && (srp[screen.cur.col - 1] & RS_multiMask) == RS_multi1) {
+	    stp[screen.cur.col - 1] = ' ';
+	    srp[screen.cur.col - 1] &= ~RS_multiMask;
+	} else if ((rstyle & RS_multiMask) == RS_multi2
+	    && screen.cur.col < (last_col - 1)
+	    && (srp[screen.cur.col + 1] & RS_multiMask) == RS_multi2) {
+	    stp[screen.cur.col + 1] = ' ';
+	    srp[screen.cur.col + 1] &= ~RS_multiMask;
+	}
+#endif
+	stp[screen.cur.col] = c;
+	srp[screen.cur.col] = rstyle;
+	if (screen.cur.col < (last_col - 1))
+	    screen.cur.col++;
+	else {
+	    screen.tlen[row] = last_col;
+	    if (screen.flags & Screen_Autowrap)
+		screen.flags |= Screen_WrapNext;
+	    else
+		screen.flags &= ~Screen_WrapNext;
+	}
+    }
+    if (screen.tlen[row] != -1)	/* XXX: think about this */
+	MAX_IT(screen.tlen[row], screen.cur.col);
+
+/*
+ * If we wrote anywhere in the selected area, kill the selection
+ * XXX: should we kill the mark too?  Possibly, but maybe that 
+ *      should be a similar check.
+ */
+    if (clearsel)
+	CLEAR_SELECTION;
+
+#ifdef DEBUG_STRICT
+    assert(screen.cur.row >= 0);
+#else				/* drive with your eyes closed */
+    MAX_IT(screen.cur.row, 0);
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Process Backspace.  Move back the cursor back a position, wrap if have to
+ * XTERM_SEQ: CTRL-H
+ */
+/* EXTPROTO */
+void
+scr_backspace(void)
+{
+    RESET_CHSTAT;
+    want_refresh = 1;
+    if (screen.cur.col == 0) {
+	if (screen.cur.row > 0) {
+#ifdef SUPPORT_BROKEN_APPS_WHICH_RELY_ON_UNDEFINED_BW_BEHAVIOUR_AS_XTERM
+	    screen.flags &= ~Screen_WrapNext;
+#else
+	    screen.cur.col = TermWin.ncol - 1;
+	    screen.cur.row--;
+#endif
+	} else
+	    screen.flags &= ~Screen_WrapNext;
+    } else if (screen.flags & Screen_WrapNext) {
+	screen.flags &= ~Screen_WrapNext;
+    } else
+	scr_gotorc(0, -1, RELATIVE);
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Process Horizontal Tab
+ * count: +ve = forward; -ve = backwards
+ * XTERM_SEQ: CTRL-I
+ */
+/* EXTPROTO */
+void
+scr_tab(int count)
+{
+    int             i, x;
+
+    want_refresh = 1;
+    RESET_CHSTAT;
+    x = screen.cur.col;
+    if (count == 0)
+	return;
+    else if (count > 0) {
+	for (i = x + 1; i < TermWin.ncol; i++) {
+	    if (tabs[i]) {
+		x = i;
+		if (!--count)
+		    break;
+	    }
+	}
+	if (count)
+	    x = TermWin.ncol - 1;
+    } else if (count < 0) {
+	for (i = x - 1; i >= 0; i--) {
+	    if (tabs[i]) {
+		x = i;
+		if (!++count)
+		    break;
+	    }
+	}
+	if (count)
+	    x = 0;
+    }
+    if (x != screen.cur.col)
+	scr_gotorc(0, x, R_RELATIVE);
+}
+/* ------------------------------------------------------------------------- */
+/*
+ * Process DEC Back Index
+ * XTERM_SEQ: ESC 6
+ * Move cursor left in row.  If we're at the left boundary, shift everything
+ * in that row right.  Clear left column.
+ */
+#ifndef NO_FRILLS
+/* EXTPROTO */
+void
+scr_backindex(void)
+{
+    int             i, row;
+    text_t         *t0;
+    rend_t         *r0;
+
+    want_refresh = 1;
+    if (screen.cur.col > 0)
+	scr_gotorc(0, screen.cur.col - 1, R_RELATIVE);
+    else {
+	row = screen.cur.row + TermWin.saveLines;
+	if (screen.tlen[row] == 0)
+	    return;		/* um, yeah? */
+	else if (screen.tlen[row] < TermWin.ncol - 1)
+	    screen.tlen[row]++;
+	t0 = screen.text[row];
+	r0 = screen.rend[row];
+	for (i = TermWin.ncol; i-- > 1;) {
+	    t0[i] = t0[i - 1];
+	    r0[i] = r0[i - 1];
+	}
+	t0[0] = ' ';
+	r0[0] = DEFAULT_RSTYLE;
+/* TODO: Multi check on last character */
+    }
+}
+#endif
+/* ------------------------------------------------------------------------- */
+/*
+ * Process DEC Forward Index
+ * XTERM_SEQ: ESC 9
+ * Move cursor right in row.  If we're at the right boundary, shift everything
+ * in that row left.  Clear right column.
+ */
+#ifndef NO_FRILLS
+/* EXTPROTO */
+void
+scr_forwardindex(void)
+{
+    int             i, row;
+    text_t         *t0;
+    rend_t         *r0;
+
+    want_refresh = 1;
+    if (screen.cur.col < TermWin.ncol - 1)
+	scr_gotorc(0, screen.cur.col + 1, R_RELATIVE);
+    else {
+	row = screen.cur.row + TermWin.saveLines;
+	if (screen.tlen[row] == 0)
+	    return;		/* um, yeah? */
+	else if (screen.tlen[row] > 0)
+	    screen.tlen[row]--;
+	else
+	    screen.tlen[row] = TermWin.ncol - 1;
+	t0 = screen.text[row];
+	r0 = screen.rend[row];
+	for (i = 0; i < TermWin.ncol - 2; i++) {
+	    t0[i] = t0[i + 1];
+	    r0[i] = r0[i + 1];
+	}
+	t0[i] = ' ';
+	r0[i] = DEFAULT_RSTYLE;
+/* TODO: Multi check on first character */
+    }
+}
+#endif
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Goto Row/Column
+ */
+/* EXTPROTO */
+void
+scr_gotorc(int row, int col, int relative)
+{
+    want_refresh = 1;
+    ZERO_SCROLLBACK;
+    RESET_CHSTAT;
+    if (Gr_Displayed())
+	Gr_scroll(0);
+
+    D_SCREEN((stderr, "scr_gotorc(r:%d,c:%d,%d): from (r:%d,c:%d)", row, col, relative, screen.cur.row, screen.cur.col));
+
+    screen.cur.col = ((relative & C_RELATIVE) ? (screen.cur.col + col) : col);
+    MAX_IT(screen.cur.col, 0);
+    MIN_IT(screen.cur.col, TermWin.ncol - 1);
+
+    if (screen.flags & Screen_WrapNext)
+	screen.flags &= ~Screen_WrapNext;
+    if (relative & R_RELATIVE) {
+	if (row > 0) {
+	    if (screen.cur.row <= screen.bscroll
+		&& (screen.cur.row + row) > screen.bscroll)
+		screen.cur.row = screen.bscroll;
+	    else
+		screen.cur.row += row;
+	} else if (row < 0) {
+	    if (screen.cur.row >= screen.tscroll
+		&& (screen.cur.row + row) < screen.tscroll)
+		screen.cur.row = screen.tscroll;
+	    else
+		screen.cur.row += row;
+	}
+    } else {
+	if (screen.flags & Screen_Relative) {	/* relative origin mode */
+	    screen.cur.row = row + screen.tscroll;
+	    MIN_IT(screen.cur.row, screen.bscroll);
+	} else
+	    screen.cur.row = row;
+    }
+    MAX_IT(screen.cur.row, 0);
+    MIN_IT(screen.cur.row, TermWin.nrow - 1);
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * direction  should be UP or DN
+ */
+/* EXTPROTO */
+void
+scr_index(int direction)
+{
+    int             dirn;
+
+    want_refresh = 1;
+    dirn = ((direction == UP) ? 1 : -1);
+    D_SCREEN((stderr, "scr_index(%d)", dirn));
+
+    ZERO_SCROLLBACK;
+    RESET_CHSTAT;
+    if (Gr_Displayed())
+	Gr_scroll(0);
+
+    if (screen.flags & Screen_WrapNext) {
+	screen.flags &= ~Screen_WrapNext;
+    }
+    if ((screen.cur.row == screen.bscroll && direction == UP)
+	|| (screen.cur.row == screen.tscroll && direction == DN)) {
+	scroll_text(screen.tscroll, screen.bscroll, dirn, 0);
+	if (direction == UP)
+	    dirn = screen.bscroll + TermWin.saveLines;
+	else
+	    dirn = screen.tscroll + TermWin.saveLines;
+	blank_screen_mem(screen.text, screen.rend, dirn, rstyle, 0);
+	screen.tlen[dirn] = 0;
+    } else
+	screen.cur.row += dirn;
+    MAX_IT(screen.cur.row, 0);
+    MIN_IT(screen.cur.row, TermWin.nrow - 1);
+    CHECK_SELECTION(0);
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Erase part or whole of a line
+ * XTERM_SEQ: Clear line to right: ESC [ 0 K
+ * XTERM_SEQ: Clear line to left : ESC [ 1 K
+ * XTERM_SEQ: Clear whole line   : ESC [ 2 K
+ */
+/* EXTPROTO */
+void
+scr_erase_line(int mode)
+{
+    int             row, col, num;
+
+    want_refresh = 1;
+    D_SCREEN((stderr, "scr_erase_line(%d) at screen row: %d", mode, screen.cur.row));
+    ZERO_SCROLLBACK;
+    RESET_CHSTAT;
+    if (Gr_Displayed())
+	Gr_scroll(0);
+    CHECK_SELECTION(1);
+
+    if (screen.flags & Screen_WrapNext)
+	screen.flags &= ~Screen_WrapNext;
+
+    row = TermWin.saveLines + screen.cur.row;
+    switch (mode) {
+    case 0:			/* erase to end of line */
+	col = screen.cur.col;
+	num = TermWin.ncol - col;
+	MIN_IT(screen.tlen[row], col);
+	if (ROWCOL_IN_ROW_AT_OR_AFTER(selection.beg, screen.cur)
+	    || ROWCOL_IN_ROW_AT_OR_AFTER(selection.end, screen.cur))
+	    CLEAR_SELECTION;
+	break;
+    case 1:			/* erase to beginning of line */
+	col = 0;
+	num = screen.cur.col + 1;
+	if (ROWCOL_IN_ROW_AT_OR_BEFORE(selection.beg, screen.cur)
+	    || ROWCOL_IN_ROW_AT_OR_BEFORE(selection.end, screen.cur))
+	    CLEAR_SELECTION;
+	break;
+    case 2:			/* erase whole line */
+	col = 0;
+	num = TermWin.ncol;
+	screen.tlen[row] = 0;
+	if (selection.beg.row <= screen.cur.row
+	    && selection.end.row >= screen.cur.row)
+	    CLEAR_SELECTION;
+	break;
+    default:
+	return;
+    }
+    if (screen.text[row])
+	blank_line(&(screen.text[row][col]), &(screen.rend[row][col]), num,
+		   rstyle & ~RS_Uline);
+    else
+	blank_screen_mem(screen.text, screen.rend, row, rstyle, 0);
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Erase part of whole of the screen
+ * XTERM_SEQ: Clear screen after cursor : ESC [ 0 J
+ * XTERM_SEQ: Clear screen before cursor: ESC [ 1 J
+ * XTERM_SEQ: Clear whole screen        : ESC [ 2 J
+ */
+/* EXTPROTO */
+void
+scr_erase_screen(int mode)
+{
+    int             row, num, row_offset;
+    rend_t          ren;
+    long            gcmask;
+    XGCValues       gcvalue;
+
+    want_refresh = 1;
+    D_SCREEN((stderr, "scr_erase_screen(%d) at screen row: %d", mode, screen.cur.row));
+    ZERO_SCROLLBACK;
+    RESET_CHSTAT;
+    row_offset = TermWin.saveLines;
+
+    switch (mode) {
+    case 0:			/* erase to end of screen */
+	CHECK_SELECTION(1);
+	scr_erase_line(0);
+	row = screen.cur.row + 1;	/* possible OOB */
+	num = TermWin.nrow - row;
+	break;
+    case 1:			/* erase to beginning of screen */
+	CHECK_SELECTION(3);
+	scr_erase_line(1);
+	row = 0;		/* possible OOB */
+	num = screen.cur.row;
+	break;
+    case 2:			/* erase whole screen */
+	CHECK_SELECTION(3);
+	Gr_ClearScreen();
+	row = 0;
+	num = TermWin.nrow;
+	break;
+    default:
+	return;
+    }
+    if (selection.op && current_screen == selection.screen
+	&& ((selection.beg.row >= row && selection.beg.row <= row + num)
+	    || (selection.end.row >= row && selection.end.row <= row + num)))
+	CLEAR_SELECTION;
+    if (row >= 0 && row < TermWin.nrow) {	/* check OOB */
+	MIN_IT(num, (TermWin.nrow - row));
+	if (rstyle & (RS_RVid | RS_Uline))
+	    ren = (rend_t)~RS_None;
+	else if (GET_BGCOLOR(rstyle) == Color_bg) {
+	    ren = DEFAULT_RSTYLE;
+	    CLEAR_ROWS(row, num);
+	} else {
+	    ren = (rstyle & (RS_fgMask | RS_bgMask));
+	    gcvalue.foreground = PixColors[GET_BGCOLOR(ren)];
+	    gcmask = GCForeground;
+	    XChangeGC(Xdisplay, TermWin.gc, gcmask, &gcvalue);
+	    ERASE_ROWS(row, num);
+	    gcvalue.foreground = PixColors[Color_fg];
+	    XChangeGC(Xdisplay, TermWin.gc, gcmask, &gcvalue);
+	}
+	for (; num--; row++) {
+	    blank_screen_mem(screen.text, screen.rend, row + row_offset,
+			     rstyle, 0);
+	    screen.tlen[row + row_offset] = 0;
+	    blank_line(drawn_text[row], drawn_rend[row], TermWin.ncol, ren);
+	}
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Fill the screen with `E's
+ * XTERM_SEQ: Screen Alignment Test: ESC # 8
+ */
+/* EXTPROTO */
+void
+scr_E(void)
+{
+    int             i, j;
+    text_t         *t;
+    rend_t         *r, fs;
+
+    want_refresh = 1;
+    ZERO_SCROLLBACK;
+    RESET_CHSTAT;
+    CHECK_SELECTION(3);
+
+    fs = rstyle;
+    for (i = TermWin.saveLines; i < TermWin.nrow + TermWin.saveLines; i++) {
+	t = screen.text[i];
+	r = screen.rend[i];
+	for (j = 0; j < TermWin.ncol; j++) {
+	    *t++ = 'E';
+	    *r++ = fs;
+	}
+	screen.tlen[i] = TermWin.ncol;	/* make the `E's selectable */
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Insert/Delete <count> lines
+ */
+/* EXTPROTO */
+void
+scr_insdel_lines(int count, int insdel)
+{
+    int             end;
+
+    ZERO_SCROLLBACK;
+    RESET_CHSTAT;
+    if (Gr_Displayed())
+	Gr_scroll(0);
+    CHECK_SELECTION(1);
+
+    if (screen.cur.row > screen.bscroll)
+	return;
+
+    end = screen.bscroll - screen.cur.row + 1;
+    if (count > end) {
+	if (insdel == DELETE)
+	    return;
+	else if (insdel == INSERT)
+	    count = end;
+    }
+    if (screen.flags & Screen_WrapNext)
+	screen.flags &= ~Screen_WrapNext;
+
+    scroll_text(screen.cur.row, screen.bscroll, insdel * count, 0);
+
+/* fill the inserted or new lines with rstyle. TODO: correct for delete? */
+    if (insdel == DELETE)
+	end = screen.bscroll + TermWin.saveLines;
+    else if (insdel == INSERT)
+	end = screen.cur.row + count - 1 + TermWin.saveLines;
+    for (; count--;) {
+	blank_screen_mem(screen.text, screen.rend, end, rstyle, 0);
+	screen.tlen[end--] = 0;
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Insert/Delete <count> characters from the current position
+ */
+/* EXTPROTO */
+void
+scr_insdel_chars(int count, int insdel)
+{
+    int             col, row;
+    rend_t          tr;
+
+    want_refresh = 1;
+    ZERO_SCROLLBACK;
+#if 0
+    RESET_CHSTAT;
+#endif
+    if (Gr_Displayed())
+	Gr_scroll(0);
+
+    if (count <= 0)
+	return;
+
+    CHECK_SELECTION(1);
+    MIN_IT(count, (TermWin.ncol - screen.cur.col));
+
+    row = screen.cur.row + TermWin.saveLines;
+    screen.flags &= ~Screen_WrapNext;
+
+    switch (insdel) {
+    case INSERT:
+	for (col = TermWin.ncol - 1; (col - count) >= screen.cur.col; col--) {
+	    screen.text[row][col] = screen.text[row][col - count];
+	    screen.rend[row][col] = screen.rend[row][col - count];
+	}
+	if (screen.tlen[row] != -1) {
+	    screen.tlen[row] += count;
+	    MIN_IT(screen.tlen[row], TermWin.ncol);
+	}
+	if (selection.op && current_screen == selection.screen
+	    && ROWCOL_IN_ROW_AT_OR_AFTER(selection.beg, screen.cur)) {
+	    if (selection.end.row != screen.cur.row
+		|| (selection.end.col + count >= TermWin.ncol))
+		CLEAR_SELECTION;
+	    else {		/* shift selection */
+		selection.beg.col += count;
+		selection.mark.col += count;	/* XXX: yes? */
+		selection.end.col += count;
+	    }
+	}
+	blank_line(&(screen.text[row][screen.cur.col]),
+		   &(screen.rend[row][screen.cur.col]),
+		   count, rstyle);
+	break;
+    case ERASE:
+	screen.cur.col += count;	/* don't worry if > TermWin.ncol */
+	CHECK_SELECTION(1);
+	screen.cur.col -= count;
+	blank_line(&(screen.text[row][screen.cur.col]),
+		   &(screen.rend[row][screen.cur.col]),
+		   count, rstyle);
+	break;
+    case DELETE:
+	tr = screen.rend[row][TermWin.ncol - 1]
+	    & (RS_fgMask | RS_bgMask | RS_baseattrMask);
+	for (col = screen.cur.col; (col + count) < TermWin.ncol; col++) {
+	    screen.text[row][col] = screen.text[row][col + count];
+	    screen.rend[row][col] = screen.rend[row][col + count];
+	}
+	blank_line(&(screen.text[row][TermWin.ncol - count]),
+		   &(screen.rend[row][TermWin.ncol - count]),
+		   count, tr);
+	if (screen.tlen[row] == -1)	/* break line continuation */
+	    screen.tlen[row] = TermWin.ncol;
+	screen.tlen[row] -= count;
+	MAX_IT(screen.tlen[row], 0);
+	if (selection.op && current_screen == selection.screen
+	    && ROWCOL_IN_ROW_AT_OR_AFTER(selection.beg, screen.cur)) {
+	    if (selection.end.row != screen.cur.row
+		|| (screen.cur.col >= selection.beg.col - count)
+		|| selection.end.col >= TermWin.ncol)
+		CLEAR_SELECTION;
+	    else {
+	    /* shift selection */
+		selection.beg.col -= count;
+		selection.mark.col -= count;	/* XXX: yes? */
+		selection.end.col -= count;
+	    }
+	}
+	break;
+    }
+#if 0
+    if ((screen.rend[row][0] & RS_multiMask) == RS_multi2) {
+	screen.rend[row][0] &= ~RS_multiMask;
+	screen.text[row][0] = ' ';
+    }
+    if ((screen.rend[row][TermWin.ncol - 1] & RS_multiMask) == RS_multi1) {
+	screen.rend[row][TermWin.ncol - 1] &= ~RS_multiMask;
+	screen.text[row][TermWin.ncol - 1] = ' ';
+    }
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Set the scrolling region
+ * XTERM_SEQ: Set region <top> - <bot> inclusive: ESC [ <top> ; <bot> r
+ */
+/* EXTPROTO */
+void
+scr_scroll_region(int top, int bot)
+{
+    MAX_IT(top, 0);
+    MIN_IT(bot, TermWin.nrow - 1);
+    if (top > bot)
+	return;
+    screen.tscroll = top;
+    screen.bscroll = bot;
+    scr_gotorc(0, 0, 0);
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Make the cursor visible/invisible
+ * XTERM_SEQ: Make cursor visible  : ESC [ ? 25 h
+ * XTERM_SEQ: Make cursor invisible: ESC [ ? 25 l
+ */
+/* EXTPROTO */
+void
+scr_cursor_visible(int mode)
+{
+    want_refresh = 1;
+    if (mode)
+	screen.flags |= Screen_VisibleCursor;
+    else
+	screen.flags &= ~Screen_VisibleCursor;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Set/unset automatic wrapping
+ * XTERM_SEQ: Set Wraparound  : ESC [ ? 7 h
+ * XTERM_SEQ: Unset Wraparound: ESC [ ? 7 l
+ */
+/* EXTPROTO */
+void
+scr_autowrap(int mode)
+{
+    if (mode)
+	screen.flags |= Screen_Autowrap;
+    else
+	screen.flags &= ~Screen_Autowrap;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Set/unset margin origin mode
+ * Absolute mode: line numbers are counted relative to top margin of screen
+ *      and the cursor can be moved outside the scrolling region.
+ * Relative mode: line numbers are relative to top margin of scrolling region
+ *      and the cursor cannot be moved outside.
+ * XTERM_SEQ: Set Absolute: ESC [ ? 6 h
+ * XTERM_SEQ: Set Relative: ESC [ ? 6 l
+ */
+/* EXTPROTO */
+void
+scr_relative_origin(int mode)
+{
+    if (mode)
+	screen.flags |= Screen_Relative;
+    else
+	screen.flags &= ~Screen_Relative;
+    scr_gotorc(0, 0, 0);
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Set insert/replace mode
+ * XTERM_SEQ: Set Insert mode : ESC [ ? 4 h
+ * XTERM_SEQ: Set Replace mode: ESC [ ? 4 l
+ */
+/* EXTPROTO */
+void
+scr_insert_mode(int mode)
+{
+    if (mode)
+	screen.flags |= Screen_Insert;
+    else
+	screen.flags &= ~Screen_Insert;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Set/Unset tabs
+ * XTERM_SEQ: Set tab at current column  : ESC H
+ * XTERM_SEQ: Clear tab at current column: ESC [ 0 g
+ * XTERM_SEQ: Clear all tabs             : ESC [ 3 g
+ */
+/* EXTPROTO */
+void
+scr_set_tab(int mode)
+{
+    if (mode < 0)
+	MEMSET(tabs, 0, TermWin.ncol * sizeof(char));
+
+    else if (screen.cur.col < TermWin.ncol)
+	tabs[screen.cur.col] = (mode ? 1 : 0);
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Set reverse/normal video
+ * XTERM_SEQ: Reverse video: ESC [ ? 5 h
+ * XTERM_SEQ: Normal video : ESC [ ? 5 l
+ */
+/* EXTPROTO */
+void
+scr_rvideo_mode(int mode)
+{
+    int             i, j;
+    rend_t         *r;
+
+    if (rvideo != mode) {
+	rvideo = mode;
+	rstyle ^= RS_RVid;
+
+	for (i = 0; i < TermWin.nrow; i++) {
+	    r = screen.rend[TermWin.saveLines + i];
+	    for (j = 0; j < TermWin.ncol; j++)
+		*r++ ^= RS_RVid;
+	}
+	scr_refresh(SLOW_REFRESH);
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Report current cursor position
+ * XTERM_SEQ: Report position: ESC [ 6 n
+ */
+/* EXTPROTO */
+void
+scr_report_position(void)
+{
+    tt_printf("\033[%d;%dR", screen.cur.row + 1, screen.cur.col + 1);
+}
+
+/* ------------------------------------------------------------------------- *
+ *                                  FONTS                                    * 
+ * ------------------------------------------------------------------------- */
+
+/*
+ * Set font style
+ */
+/* INTPROTO */
+void
+set_font_style(void)
+{
+    rstyle &= ~RS_fontMask;
+    switch (charsets[screen.charset]) {
+    case '0':			/* DEC Special Character & Line Drawing Set */
+	rstyle |= RS_acsFont;
+	break;
+    case 'A':			/* United Kingdom (UK) */
+	rstyle |= RS_ukFont;
+	break;
+    case 'B':			/* United States (USASCII) */
+	break;
+    case '<':			/* Multinational character set */
+	break;
+    case '5':			/* Finnish character set */
+	break;
+    case 'C':			/* Finnish character set */
+	break;
+    case 'K':			/* German character set */
+	break;
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Choose a font
+ * XTERM_SEQ: Invoke G0 character set: CTRL-O
+ * XTERM_SEQ: Invoke G1 character set: CTRL-N
+ * XTERM_SEQ: Invoke G2 character set: ESC N
+ * XTERM_SEQ: Invoke G3 character set: ESC O
+ */
+/* EXTPROTO */
+void
+scr_charset_choose(int set)
+{
+    screen.charset = set;
+    set_font_style();
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Set a font
+ * XTERM_SEQ: Set G0 character set: ESC ( <C>
+ * XTERM_SEQ: Set G1 character set: ESC ) <C>
+ * XTERM_SEQ: Set G2 character set: ESC * <C>
+ * XTERM_SEQ: Set G3 character set: ESC + <C>
+ * See set_font_style for possible values for <C>
+ */
+/* EXTPROTO */
+void
+scr_charset_set(int set, unsigned int ch)
+{
+#ifdef MULTICHAR_SET
+    multi_byte = (set < 0);
+    set = abs(set);
+#endif
+    charsets[set] = (unsigned char)ch;
+    set_font_style();
+}
+
+/* ------------------------------------------------------------------------- *
+ *          MULTIPLE-CHARACTER FONT SET MANIPULATION FUNCTIONS               * 
+ * ------------------------------------------------------------------------- */
+#ifdef MULTICHAR_SET
+#ifdef KANJI
+static void     (*multichar_decode) (unsigned char *str, int len) = eucj2jis;
+#else				/* then we must be BIG5 to get in here */
+# ifdef ZH
+static void     (*multichar_decode) (unsigned char *str, int len) = big5dummy;
+# else
+#  ifdef ZHCN		/* The GB fonts are in iso-2022 encoding (JIS). */
+static void	(*multichar_decode) (unsigned char *str, int len) = gb2jis;
+#  endif
+# endif
+#endif
+
+/* INTPROTO */
+void
+eucj2jis(unsigned char *str, int len)
+{
+    register int    i;
+
+    for (i = 0; i < len; i++)
+	str[i] &= 0x7F;
+}
+
+/* ------------------------------------------------------------------------- */
+/* INTPROTO */
+void
+sjis2jis(unsigned char *str, int len)
+{
+    register int    i;
+    unsigned char  *high, *low;
+
+    for (i = 0; i < len; i += 2, str += 2) {
+	high = str;
+	low = str + 1;
+	(*high) -= (*high > 0x9F ? 0xB1 : 0x71);
+	*high = (*high) * 2 + 1;
+	if (*low > 0x9E) {
+	    *low -= 0x7E;
+	    (*high)++;
+	} else {
+	    if (*low > 0x7E)
+		(*low)--;
+	    *low -= 0x1F;
+	}
+    }
+}
+
+/* INTPROTO */
+void
+big5dummy(unsigned char *str, int len)
+{
+}
+
+/* INTPROTO */
+void
+gb2jis(unsigned char *str, int len)
+{
+    register int i;
+
+    for(i = 0; i < len; i++)
+	str[i] &= 0x7F;
+}
+
+/* EXTPROTO */
+void
+set_multichar_encoding(const char *str)
+{
+    if (str && *str) {
+	if (!strcasecmp(str, "sjis")) {
+	    encoding_method = SJIS;	/* Kanji SJIS */
+	    multichar_decode = sjis2jis;
+	} else if (!strcasecmp(str, "eucj")) {
+	    encoding_method = EUCJ;	/* Kanji EUCJ */
+	    multichar_decode = eucj2jis;
+	}
+    }
+}
+#endif				/* MULTICHAR_SET */
+
+/* ------------------------------------------------------------------------- *
+ *                           GRAPHICS COLOURS                                * 
+ * ------------------------------------------------------------------------- */
+
+#ifdef RXVT_GRAPHICS
+/* EXTPROTO */
+int
+scr_get_fgcolor(void)
+{
+    return GET_FGCOLOR(rstyle);
+}
+
+/* ------------------------------------------------------------------------- */
+/* EXTPROTO */
+int
+scr_get_bgcolor(void)
+{
+    return GET_BGCOLOR(rstyle);
+}
+#endif
+
+/* ------------------------------------------------------------------------- *
+ *                        MAJOR SCREEN MANIPULATION                          * 
+ * ------------------------------------------------------------------------- */
+
+/*
+ * Refresh an area
+ */
+enum {
+    PART_BEG = 0,
+    PART_END,
+#if defined(XPM_BACKGROUND) && defined(XPM_BUFFERING)
+    FULL_BEG,
+    FULL_END,
+#endif
+    RC_COUNT
+};
+/* EXTPROTO */
+void
+scr_expose(int x, int y, int width, int height)
+{
+    int             i;
+    row_col_t       rc[RC_COUNT];
+
+    if (drawn_text == NULL)	/* sanity check */
+	return;
+
+/* round down */
+    rc[PART_BEG].col = Pixel2Col(x);
+    rc[PART_BEG].row = Pixel2Row(y);
+/* round up */
+    rc[PART_END].col = Pixel2Width(x + width + TermWin.fwidth - 1);
+    rc[PART_END].row = Pixel2Row(y + height + TermWin.fheight - 1);
+
+#if defined(XPM_BACKGROUND) && defined(XPM_BUFFERING)
+/* round down */
+    rc[FULL_END].col = Pixel2Width(x + width);
+    rc[FULL_END].row = Pixel2Row(y + height);
+/* round up */
+    rc[FULL_BEG].col = Pixel2Col(x + TermWin.fwidth - 1);
+    rc[FULL_BEG].row = Pixel2Row(y + TermWin.fheight - 1);
+#endif
+
+/* sanity checks */
+    for (i = PART_BEG; i < RC_COUNT; i++) {
+	MAX_IT(rc[i].col, 0);
+	MAX_IT(rc[i].row, 0);
+	MIN_IT(rc[i].col, TermWin.ncol - 1);
+	MIN_IT(rc[i].row, TermWin.nrow - 1);
+    }
+
+    D_SCREEN((stderr, "scr_expose(x:%d, y:%d, w:%d, h:%d) area (c:%d,r:%d)-(c:%d,r:%d)", x, y, width, height, rc[PART_BEG}.col, rc[PART_BEG].row, rc[PART_END].col, rc[PART_END].row));
+
+#if defined(XPM_BACKGROUND) && defined(XPM_BUFFERING)
+/* supposedly we're exposed - so `clear' the fully exposed clear areas */
+    x = Col2Pixel(rc[FULL_BEG].col);
+    y = Row2Pixel(rc[FULL_BEG].row);
+    width = Width2Pixel(rc[FULL_END].col - rc[FULL_BEG].col + 1);
+    height = Height2Pixel(rc[FULL_END].row - rc[FULL_BEG].row + 1);
+    XCopyArea(Xdisplay, TermWin.pixmap, drawBuffer, TermWin.gc,
+	      x, y, width, height, x, y);
+#endif
+
+    for (i = rc[PART_BEG].row; i <= rc[PART_END].row; i++)
+	MEMSET(&(drawn_text[i][rc[PART_BEG].col]), 0,
+	       rc[PART_END].col - rc[PART_BEG].col + 1);
+
+    scr_refresh(SLOW_REFRESH);
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Refresh the entire screen
+ */
+/* EXTPROTO */
+void
+scr_touch(void)
+{
+    scr_expose(0, 0, TermWin.width, TermWin.height);
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Move the display so that the line represented by scrollbar value Y is at
+ * the top of the screen
+ */
+/* EXTPROTO */
+int
+scr_move_to(int y, int len)
+{
+    int             start;
+
+    want_refresh = 1;
+    start = TermWin.view_start;
+    if (y >= len)
+	TermWin.view_start = 0;
+    else {
+	TermWin.view_start = ((len - y)
+			      * (TermWin.nrow - 1 + TermWin.nscrolled) / len);
+	if (TermWin.view_start < TermWin.nrow)
+	    TermWin.view_start = 0;
+	else
+	    TermWin.view_start -= (TermWin.nrow - 1);
+    }
+    D_SCREEN((stderr, "scr_move_to(%d, %d) view_start:%d", y, len, TermWin.view_start));
+
+    MIN_IT(TermWin.view_start, TermWin.nscrolled);
+
+    if (Gr_Displayed())
+	Gr_scroll(0);
+    return (TermWin.view_start - start);
+}
+/* ------------------------------------------------------------------------- */
+/*
+ * Page the screen up/down nlines
+ * direction  should be UP or DN
+ */
+/* EXTPROTO */
+int
+scr_page(int direction, int nlines)
+{
+    u_int16_t       start;
+
+    D_SCREEN((stderr, "scr_page(%s, %d) view_start:%d", ((direction == UP) ? "UP" : "DN"), nlines, TermWin.view_start));
+
+    start = TermWin.view_start;
+    MAX_IT(nlines, 1);
+    MIN_IT(nlines, TermWin.nrow);
+    if (direction == UP)
+	TermWin.view_start = TermWin.view_start < TermWin.nscrolled - nlines
+			     ? TermWin.view_start + nlines
+			     : TermWin.nscrolled;
+    else
+	TermWin.view_start = TermWin.view_start > nlines 
+			     ? TermWin.view_start - nlines
+			     : 0;
+
+    if (Gr_Displayed())
+	Gr_scroll(0);
+    if (TermWin.view_start != start)
+	want_refresh = 1;
+    return (int)(TermWin.view_start - start);
+}
+
+/* ------------------------------------------------------------------------- */
+/* EXTPROTO */
+void
+scr_bell(void)
+{
+#ifndef NO_MAPALERT
+# ifdef MAPALERT_OPTION
+    if (Options & Opt_mapAlert)
+# endif
+	XMapWindow(Xdisplay, TermWin.parent[0]);
+#endif
+    if (Options & Opt_visualBell) {
+	scr_rvideo_mode(!rvideo);	/* scr_refresh() also done */
+	scr_rvideo_mode(!rvideo);	/* scr_refresh() also done */
+    } else
+	XBell(Xdisplay, 0);
+}
+
+/* ------------------------------------------------------------------------- */
+/* ARGSUSED */
+/* EXTPROTO */
+void
+scr_printscreen(int fullhist)
+{
+#ifdef PRINTPIPE
+    int             i, r, nrows, row_offset;
+    text_t         *t;
+    FILE           *fd;
+
+    if ((fd = popen_printer()) == NULL)
+	return;
+    nrows = TermWin.nrow;
+    row_offset = TermWin.saveLines;
+    if (!fullhist)
+	row_offset -= TermWin.view_start;
+    else {
+	nrows += TermWin.nscrolled;
+	row_offset -= TermWin.nscrolled;
+    }
+
+    for (r = 0; r < nrows; r++) {
+	t = screen.text[r + row_offset];
+	for (i = TermWin.ncol - 1; i >= 0; i--)
+	    if (!isspace(t[i]))
+		break;
+	fprintf(fd, "%.*s\n", (i + 1), t);
+    }
+    pclose_printer(fd);
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Refresh the screen
+ * drawn_text/drawn_rend contain the screen information before the update.
+ * screen.text/screen.rend contain what the screen will change to.
+ */
+
+#define DRAW_STRING(Func, x, y, str, len)				\
+    Func(Xdisplay, drawBuffer, TermWin.gc, (x), (y), (str), (len))
+
+#if defined (NO_BRIGHTCOLOR) || defined (VERYBOLD)
+# define MONO_BOLD(x)   ((x) & (RS_Bold|RS_Blink))
+#else
+# define MONO_BOLD(x)	(((x) & RS_Bold) && fore == Color_fg)
+#endif
+
+#define FONT_WIDTH(X, Y)						\
+    (X)->per_char[(Y) - (X)->min_char_or_byte2].width
+#define FONT_RBEAR(X, Y)						\
+    (X)->per_char[(Y) - (X)->min_char_or_byte2].rbearing
+
+/* EXTPROTO */
+void
+scr_refresh(int type)
+{
+    int             i, j,	/* tmp                                       */
+                    col, row,	/* column/row we're processing               */
+                    scrrow,	/* screen row offset                         */
+                    row_offset,	/* basic offset in screen structure          */
+                    currow,	/* cursor row at appropriate offset          */
+                    boldlast,	/* last character in some row was bold       */
+                    len, wlen,	/* text length screen/buffer                 */
+                    fprop,	/* proportional font used                    */
+                    rvid,	/* reverse video this position               */
+                    rend,	/* rendition                                 */
+                    fore, back,	/* desired foreground/background             */
+                    wbyte,	/* we're in multibyte                        */
+		    fontdiff,	/* current font size different to base font  */
+                    morecur = 0, xpixel,	/* x offset for start of drawing (font)      */
+                    ypixel,	/* y offset for start of drawing (font)      */
+		    ypixelc;	/* y offset for top of drawing               */
+    long            gcmask,	/* Graphics Context mask                     */
+                    gcmaskf;
+    static int      focus = -1;	/* screen in focus?                          */
+    unsigned long   ltmp;
+    rend_t          rt1, rt2;	/* tmp rend values                           */
+#ifndef NO_CURSORCOLOR
+    rend_t          ccol1,	/* Cursor colour                             */
+                    ccol2,	/* Cursor colour2                            */
+                    cc1;	/* store colours at cursor position(s)       */
+# ifdef MULTICHAR_SET
+    rend_t          cc2;	/* store colours at cursor position(s)       */
+# endif
+#endif
+    rend_t         *drp, *srp;	/* drawn-rend-pointer, screen-rend-pointer   */
+    text_t         *dtp, *stp;	/* drawn-text-pointer, screen-text-pointer   */
+    XGCValues       gcvalue;	/* Graphics Context values                   */
+    XFontStruct    *wf;		/* which font are we in                      */
+    static char    *buffer = NULL;
+    static int      currmaxcol = 0;
+#ifdef MULTICHAR_SET
+    static int      oldcursormulti = 0;
+#endif
+    static row_col_t oldcursor = {-1, -1};
+				/* is there an old outline cursor on screen? */
+#ifndef NO_BOLDFONT
+    int             bfont = 0;	/* we've changed font to bold font           */
+#endif
+    int             (*draw_string) (), (*draw_image_string) ();
+
+    if (type == NO_REFRESH)
+	return;
+    if (!TermWin.mapped)
+	return;
+
+/*
+ * A: set up vars
+ */
+    if (currmaxcol < TermWin.ncol) {
+	currmaxcol = TermWin.ncol;
+	if (buffer)
+	    buffer = REALLOC(buffer, (sizeof(char) * (currmaxcol + 1)));
+
+	else
+	    buffer = MALLOC((sizeof(char) * (currmaxcol + 1)));
+    }
+    row_offset = TermWin.saveLines - TermWin.view_start;
+    fprop = TermWin.fprop;
+    gcvalue.foreground = PixColors[Color_fg];
+    gcvalue.background = PixColors[Color_bg];
+/*
+ * always go back to the base font - it's much safer
+ */
+    wbyte = 0;
+    XSetFont(Xdisplay, TermWin.gc, TermWin.font->fid);
+    draw_string = XDrawString;
+    draw_image_string = XDrawImageString;
+    boldlast = 0;
+
+/*
+ * B: reverse any characters which are selected
+ */
+    scr_reverse_selection();
+
+#ifndef NO_BOLDOVERSTRIKE
+/*
+ * C: Bold Overstrike pixel dropping avoidance.  Do this before the main
+ *    refresh.  Do a pass across each line at the start, require a refresh of
+ *    anything that will need to be refreshed due to pixels being dropped
+ *    into our area by a previous character which has now been changed.
+ */
+    for (row = 0; row < TermWin.nrow; row++) {
+	scrrow = row + row_offset;
+	stp = screen.text[scrrow];
+	srp = screen.rend[scrrow];
+	dtp = drawn_text[row];
+	drp = drawn_rend[row];
+# ifndef NO_BOLDFONT
+	if (TermWin.boldFont == NULL) {
+# endif
+	    wf = TermWin.font;
+	    j = wbyte;
+	    for (col = TermWin.ncol - 2; col >= 0; col--) {
+# if ! defined (NO_BRIGHTCOLOR) && ! defined (VERYBOLD)
+		fore = GET_FGCOLOR(drp[col]);
+# endif
+		if (!MONO_BOLD(drp[col]))
+		    continue;
+		if (dtp[col] == stp[col]
+		    && drp[col] == srp[col])
+		    continue;
+		if (wbyte) {
+		    ;		/* TODO: handle multibyte */
+		    continue;	/* don't go past here */
+		}
+		if (dtp[col] == ' ') {	/* TODO: check character set? */
+		    continue;
+		}
+		if (wf->per_char == NULL
+		    || dtp[col] < wf->min_char_or_byte2
+		    || dtp[col] > wf->max_char_or_byte2
+		    || FONT_WIDTH(wf, dtp[col]) == FONT_RBEAR(wf, dtp[col])) {
+		    dtp[col + 1] = 0;
+# if defined(MULTICHAR_SET) && ! defined(NO_BOLDOVERSTRIKE_MULTI)
+		    if ((srp[col] & RS_multiMask) == RS_multi2) {
+			col--;
+			wbyte = 1;
+			continue;
+		    }
+# endif
+		}
+	    }
+# if ! defined (NO_BRIGHTCOLOR) && ! defined (VERYBOLD)
+	    fore = GET_FGCOLOR(srp[TermWin.ncol - 1]);
+# endif
+	    if (MONO_BOLD(srp[TermWin.ncol - 1]))
+		boldlast = 1;
+	    wbyte = j;
+# ifndef NO_BOLDFONT
+	}
+# endif
+    }
+#endif				/* ! NO_BOLDOVERSTRIKE */
+
+/*
+ * D: set the cursor character(s)
+ */
+    currow = screen.cur.row + TermWin.saveLines;
+    if (focus != TermWin.focus)
+	focus = TermWin.focus;
+    if (screen.flags & Screen_VisibleCursor && focus) {
+	srp = &(screen.rend[currow][screen.cur.col]);
+	*srp ^= RS_RVid;
+#ifndef NO_CURSORCOLOR
+	cc1 = *srp & (RS_fgMask | RS_bgMask);
+	if (Xdepth <= 2 || !rs[Rs_color + Color_cursor])
+	    ccol1 = Color_fg;
+	else
+	    ccol1 = Color_cursor;
+	if (Xdepth <= 2 || !rs[Rs_color + Color_cursor2])
+	    ccol2 = Color_bg;
+	else
+	    ccol2 = Color_cursor2;
+	*srp = SET_FGCOLOR(*srp, ccol1);
+	*srp = SET_BGCOLOR(*srp, ccol2);
+#endif
+#ifdef MULTICHAR_SET
+	rt1 = *srp & RS_multiMask;
+	if (rt1 == RS_multi1) {
+	    if (screen.cur.col < TermWin.ncol - 2
+		&& ((srp[1] & RS_multiMask) == RS_multi2))
+		morecur = 1;
+	} else if (rt1 == RS_multi2) {
+	    if (screen.cur.col > 0
+		&& ((srp[-1] & RS_multiMask) == RS_multi1))
+		morecur = -1;
+	}
+	if (morecur) {
+	    srp += morecur;
+	    *srp ^= RS_RVid;
+	}
+# ifndef NO_CURSORCOLOR
+	if (morecur) {
+	    cc2 = *srp & (RS_fgMask | RS_bgMask);
+	    *srp = SET_FGCOLOR(*srp, ccol1);
+	    *srp = SET_BGCOLOR(*srp, ccol2);
+	}
+# endif
+#endif
+    }
+    i = 0;
+    if (oldcursor.row != -1) {
+    /* make sure no outline cursor is left around */
+	if (screen.cur.row + TermWin.view_start != oldcursor.row
+	    || screen.cur.col != oldcursor.col) {
+	    if (oldcursor.row < TermWin.nrow && oldcursor.col < TermWin.ncol) {
+		drawn_text[oldcursor.row][oldcursor.col] = 0;
+#ifdef MULTICHAR_SET
+		if (oldcursormulti) {
+		    col = oldcursor.col + oldcursormulti;
+		    if (col < TermWin.ncol)
+			drawn_text[oldcursor.row][col] = 0;
+		}
+#endif
+	    }
+	    if (focus || !(screen.flags & Screen_VisibleCursor))
+		oldcursor.row = -1;
+	    else
+		i = 1;
+	}
+    } else if (!focus)
+	i = 1;
+    if (i) {
+	if (screen.cur.row + TermWin.view_start >= TermWin.nrow)
+	    oldcursor.row = -1;
+	else {
+	    oldcursor.row = screen.cur.row + TermWin.view_start;
+	    oldcursor.col = screen.cur.col;
+#ifdef MULTICHAR_SET
+	    oldcursormulti = morecur;
+#endif
+	}
+    }
+/*
+ * E: OK, now the real pass
+ */
+    for (row = 0; row < TermWin.nrow; row++) {
+	scrrow = row + row_offset;
+	stp = screen.text[scrrow];
+	srp = screen.rend[scrrow];
+	dtp = drawn_text[row];
+	drp = drawn_rend[row];
+	for (col = 0; col < TermWin.ncol; col++) {
+	/* compare new text with old - if exactly the same then continue */
+	    rt1 = srp[col];	/* screen rendition */
+	    rt2 = drp[col];	/* drawn rendition  */
+	    if ((stp[col] == dtp[col])	/* must match characters to skip */
+		&& ((rt1 == rt2)	/* either rendition the same or  */
+		    || ((stp[col] == ' ')		/* space w/ no bg change */
+		        && (GET_BGATTR(rt1) == GET_BGATTR(rt2))))) {
+#ifdef MULTICHAR_SET
+	    /* if first byte is Kanji then compare second bytes */
+		if ((rt1 & RS_multiMask) != RS_multi1)
+		    continue;
+		else if (stp[col + 1] == dtp[col + 1]) {
+		/* assume no corrupt characters on the screen */
+		    col++;
+		    continue;
+		}
+#else
+		continue;
+#endif
+	    }
+	/* redraw one or more characters */
+	    dtp[col] = stp[col];
+	    rend = drp[col] = srp[col];
+
+	    len = 0;
+	    buffer[len++] = stp[col];
+	    ypixelc = Row2Pixel(row);
+	    ypixel = ypixelc + TermWin.font->ascent;
+	    xpixel = Col2Pixel(col);
+	    fontdiff = 0;
+	    wlen = 1;
+
+/*
+ * Find out the longest string we can write out at once
+ */
+	    if (fprop == 0) {	/* Fixed width font */
+#ifdef MULTICHAR_SET
+		if (((rend & RS_multiMask) == RS_multi1)
+		    && col < TermWin.ncol - 1
+		    && ((srp[col + 1]) & RS_multiMask) == RS_multi2) {
+		    if (!wbyte) {
+			wbyte = 1;
+			XSetFont(Xdisplay, TermWin.gc, TermWin.mfont->fid);
+		    fontdiff = TermWin.mprop;
+			draw_string = XDrawString16;
+			draw_image_string = XDrawImageString16;
+		    }
+		/* double stepping - we're in Kanji mode */
+		    for (; ++col < TermWin.ncol;) {
+		    /* XXX: could check sanity on 2nd byte */
+			dtp[col] = stp[col];
+			drp[col] = srp[col];
+			buffer[len++] = stp[col];
+			col++;
+			if ((col == TermWin.ncol) || (srp[col] != rend))
+			    break;
+			if ((stp[col] == dtp[col])
+			    && (srp[col] == drp[col])
+			    && (stp[col + 1] == dtp[col + 1]))
+			    break;
+			if (len == currmaxcol)
+			    break;
+			dtp[col] = stp[col];
+			drp[col] = srp[col];
+			buffer[len++] = stp[col];
+		    }
+		    col--;
+		    if (buffer[0] & 0x80)
+			multichar_decode(buffer, len);
+		    wlen = len / 2;
+		} else {
+		    if (rend & RS_multi1) {
+		    /* corrupt character - you're outta there */
+			rend &= ~RS_multiMask;
+			drp[col] = rend;	/* TODO check: may also want */
+			dtp[col] = ' ';		/* to poke into stp/srp      */
+			buffer[0] = ' ';
+		    }
+		    if (wbyte) {
+			wbyte = 0;
+			XSetFont(Xdisplay, TermWin.gc, TermWin.font->fid);
+			draw_string = XDrawString;
+			draw_image_string = XDrawImageString;
+		    }
+#endif
+		/* single stepping - `normal' mode */
+		    for (j = 0; ++col < TermWin.ncol - 1;) {
+			if (rend != srp[col])
+			    break;
+			if (len == currmaxcol)
+			    break;
+			if ((stp[col] == dtp[col]) && (srp[col] == drp[col])) {
+#ifdef INEXPENSIVE_LOCAL_X_CALLS
+			    if (display_is_local)
+				break;
+#endif
+			    j++;
+			} else {
+			    j = 0;
+			    dtp[col] = stp[col];
+			    drp[col] = srp[col];
+			}
+			buffer[len++] = stp[col];
+		    }
+		    col--;	/* went one too far.  move back */
+		    len -= j;	/* dump any matching trailing chars */
+		    wlen = len;
+#ifdef MULTICHAR_SET
+		}
+#endif
+	    }
+	    buffer[len] = '\0';
+
+/*
+ * Determine the attributes for the string
+ */
+	    fore = GET_FGCOLOR(rend);
+	    back = GET_BGCOLOR(rend);
+	    rend = GET_ATTR(rend);
+	    gcmask = 0;
+	    rvid = (rend & RS_RVid) ? 1 : 0;
+
+	    switch (rend & RS_fontMask) {
+	    case RS_acsFont:
+		for (i = 0; i < len; i++)
+		    if (buffer[i] == 0x5f)
+			buffer[i] = 0x7f;
+		    else if (buffer[i] > 0x5f && buffer[i] < 0x7f)
+			buffer[i] -= 0x5f;
+		break;
+	    case RS_ukFont:
+		for (i = 0; i < len; i++)
+		    if (buffer[i] == '#')
+			buffer[i] = 0x1e;
+		break;
+	    }
+	    if (rvid)
+		SWAP_IT(fore, back, i);
+	    if (back != Color_bg) {
+		gcvalue.background = PixColors[back];
+		gcmask |= GCBackground;
+	    }
+	    if (fore != Color_fg) {
+		gcvalue.foreground = PixColors[fore];
+		gcmask |= GCForeground;
+	    }
+#ifndef NO_BOLDUNDERLINE
+	    else if (rend & RS_Bold) {
+		if (Xdepth > 2 && rs[Rs_color + Color_BD]
+		    && PixColors[fore] != PixColors[Color_BD]
+		    && PixColors[back] != PixColors[Color_BD]) {
+		    gcvalue.foreground = PixColors[Color_BD];
+		    gcmask |= GCForeground;
+# ifndef VERYBOLD
+		    rend &= ~RS_Bold;	/* we've taken care of it */
+# endif
+		}
+	    } else if (rend & RS_Uline) {
+		if (Xdepth > 2 && rs[Rs_color + Color_UL]
+		    && PixColors[fore] != PixColors[Color_UL]
+		    && PixColors[back] != PixColors[Color_UL]) {
+		    gcvalue.foreground = PixColors[Color_UL];
+		    gcmask |= GCForeground;
+		    rend &= ~RS_Uline;	/* we've taken care of it */
+		}
+	    }
+#endif
+	    if (gcmask)
+		XChangeGC(Xdisplay, TermWin.gc, gcmask, &gcvalue);
+#ifndef NO_BOLDFONT
+	    if (!wbyte && MONO_BOLD(rend) && TermWin.boldFont != NULL) {
+		bfont = 1;
+		XSetFont(Xdisplay, TermWin.gc, TermWin.boldFont->fid);
+		fontdiff = TermWin.bprop;
+		rend &= ~RS_Bold;	/* we've taken care of it */
+	    } else if (bfont) {
+		bfont = 0;
+		XSetFont(Xdisplay, TermWin.gc, TermWin.font->fid);
+	    }
+#endif
+/*
+ * Actually do the drawing of the string here
+ */
+	    if (back == Color_bg) {
+		CLEAR_CHARS(xpixel, ypixelc, len);
+		DRAW_STRING(draw_string, xpixel, ypixel, buffer, wlen);
+	    } else {
+		if (fprop || fontdiff) {
+		    gcmaskf = GCForeground;
+		    ltmp = gcvalue.foreground;
+		    gcvalue.foreground = gcvalue.background;
+		    XChangeGC(Xdisplay, TermWin.gc, gcmaskf, &gcvalue);
+		    XFillRectangle(Xdisplay, drawBuffer, TermWin.gc,
+				   xpixel, ypixelc,
+				   Width2Pixel(len), Height2Pixel(1));
+		    gcvalue.foreground = ltmp;
+		    XChangeGC(Xdisplay, TermWin.gc, gcmaskf, &gcvalue);
+		    DRAW_STRING(draw_string, xpixel, ypixel, buffer, wlen);
+		} else
+		    DRAW_STRING(draw_image_string, xpixel, ypixel, buffer, wlen);
+	    }
+
+#ifndef NO_BOLDOVERSTRIKE
+# ifdef NO_BOLDOVERSTRIKE_MULTI
+	    if (!wbyte)
+# endif
+		if (MONO_BOLD(rend))
+		    DRAW_STRING(draw_string, xpixel + 1, ypixel, buffer, wlen);
+#endif
+	    if ((rend & RS_Uline) && (TermWin.font->descent > 1))
+		XDrawLine(Xdisplay, drawBuffer, TermWin.gc,
+			  xpixel, ypixel + 1,
+			  xpixel + Width2Pixel(len) - 1, ypixel + 1);
+	    if (gcmask) {	/* restore normal colours */
+		gcvalue.foreground = PixColors[Color_fg];
+		gcvalue.background = PixColors[Color_bg];
+		XChangeGC(Xdisplay, TermWin.gc, gcmask, &gcvalue);
+	    }
+	}
+    }
+
+/*
+ * F: cleanup cursor and display outline cursor in necessary
+ */
+    if (screen.flags & Screen_VisibleCursor) {
+	if (focus) {
+	    srp = &(screen.rend[currow][screen.cur.col]);
+	    *srp ^= RS_RVid;
+#ifndef NO_CURSORCOLOR
+	    *srp = (*srp & ~(RS_fgMask | RS_bgMask)) | cc1;
+#endif
+	    if (morecur) {
+		srp += morecur;
+		*srp ^= RS_RVid;
+#if defined(MULTICHAR_SET) && ! defined(NO_CURSORCOLOR)
+		*srp = (*srp & ~(RS_fgMask | RS_bgMask)) | cc2;
+#endif
+	    }
+	} else if (oldcursor.row >= 0) {
+	    col = oldcursor.col + morecur;
+	    wbyte = morecur ? 1 : 0;
+#ifndef NO_CURSORCOLOR
+	    gcmask = 0;
+	    if (Xdepth > 2 && rs[Rs_color + Color_cursor]) {
+		gcvalue.foreground = PixColors[Color_cursor];
+		gcmask = GCForeground;
+		XChangeGC(Xdisplay, TermWin.gc, gcmask, &gcvalue);
+		gcvalue.foreground = PixColors[Color_fg];
+	    }
+#endif
+	    XDrawRectangle(Xdisplay, drawBuffer, TermWin.gc,
+			   Col2Pixel(col), Row2Pixel(oldcursor.row),
+			   Width2Pixel(1 + wbyte) - 1,
+			   Height2Pixel(1) - 1);
+#ifndef NO_CURSORCOLOR
+	    if (gcmask)		/* restore normal colours */
+		XChangeGC(Xdisplay, TermWin.gc, gcmask, &gcvalue);
+#endif
+	}
+    }
+/*
+ * G: cleanup selection
+ */
+    scr_reverse_selection();
+
+/*
+ * H: other general cleanup
+ */
+#if defined(XPM_BACKGROUND) && defined(XPM_BUFFERING)
+    XClearWindow(Xdisplay, TermWin.vt);
+#else
+    if (boldlast)		/* clear the whole screen height */
+	XClearArea(Xdisplay, TermWin.vt, TermWin_TotalWidth() - 2, 0,
+		   1, TermWin_TotalHeight() - 1, 0);
+#endif
+    if (type & SMOOTH_REFRESH)
+	XSync(Xdisplay, False);
+
+    want_refresh = 0;		/* screen is current */
+}
+
+/* EXTPROTO */
+void
+scr_clear(void)
+{
+    if (!TermWin.mapped)
+	return;
+#ifdef TRANSPARENT
+    if (Options & Opt_transparent) {
+	int             i;
+
+	for (i = KNOW_PARENTS; i--;)
+	    if (TermWin.parent[i] != None)
+		XClearWindow(Xdisplay, TermWin.parent[i]);
+    }
+#endif
+    XClearWindow(Xdisplay, TermWin.vt);
+}
+
+/* ------------------------------------------------------------------------- */
+/* INTPROTO */
+void
+scr_reverse_selection(void)
+{
+    int             i, col, row, end_row;
+    rend_t         *srp;
+
+    end_row = TermWin.saveLines - TermWin.view_start;
+    if (selection.op && current_screen == selection.screen) {
+	i = selection.beg.row + TermWin.saveLines;
+	row = selection.end.row + TermWin.saveLines;
+	if (i >= end_row)
+	    col = selection.beg.col;
+	else {
+	    col = 0;
+	    i = end_row;
+	}
+	end_row += TermWin.nrow;
+	for (; i < row && i < end_row; i++, col = 0)
+	    for (srp = screen.rend[i]; col < TermWin.ncol; col++)
+		srp[col] ^= RS_RVid;
+	if (i == row && i < end_row)
+	    for (srp = screen.rend[i]; col < selection.end.col; col++)
+		srp[col] ^= RS_RVid;
+    }
+}
+
+/* ------------------------------------------------------------------------- *
+ *                           CHARACTER SELECTION                             * 
+ * ------------------------------------------------------------------------- */
+
+/*
+ * -TermWin.nscrolled <= (selection row) <= TermWin.nrow - 1
+ */
+/* INTPROTO */
+void
+selection_check(int check_more)
+{
+    row_col_t       pos;
+
+    if ((selection.beg.row < -TermWin.nscrolled)
+	|| (selection.beg.row >= TermWin.nrow)
+	|| (selection.mark.row < -TermWin.nscrolled)
+	|| (selection.mark.row >= TermWin.nrow)
+	|| (selection.end.row < -TermWin.nscrolled)
+	|| (selection.end.row >= TermWin.nrow))
+	CLEAR_ALL_SELECTION;
+
+    if (check_more == 1 && current_screen == selection.screen) {
+    /* check for cursor position */
+	pos.row = screen.cur.row;
+	pos.col = screen.cur.col;
+	if (!ROWCOL_IS_BEFORE(pos, selection.beg)
+	    && ROWCOL_IS_BEFORE(pos, selection.end))
+	    CLEAR_SELECTION;
+    } else if (check_more == 2) {
+	pos.row = 0;
+	pos.col = 0;
+	if (ROWCOL_IS_BEFORE(selection.beg, pos)
+	    && ROWCOL_IS_AFTER(selection.end, pos))
+	    CLEAR_SELECTION;
+    } else if (check_more == 3) {
+	pos.row = 0;
+	pos.col = 0;
+	if (ROWCOL_IS_AFTER(selection.end, pos))
+	    CLEAR_SELECTION;
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Paste a selection direct to the command
+ */
+/* INTPROTO */
+void
+PasteIt(const unsigned char *data, unsigned int nitems)
+{
+    int             num;
+    const unsigned char *p;
+    const unsigned char cr = '\r';
+
+    for (p = data, num = 0; nitems--; p++)
+	if (*p != '\n')
+	    num++;
+	else {
+	    tt_write(data, num);
+	    tt_write(&cr, 1);
+	    data += (num + 1);
+	    num = 0;
+	}
+    if (num)
+	tt_write(data, num);
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Respond to a notification that a primary selection has been sent
+ * EXT: SelectionNotify
+ */
+/* EXTPROTO */
+void
+selection_paste(Window win, unsigned int prop, int Delete)
+{
+    long            nread;
+    unsigned long   bytes_after;
+    XTextProperty   ct;
+#ifdef MULTICHAR_SET
+    int             dummy_count;
+    char          **cl;
+#endif
+
+    D_SELECT((stderr, "selection_paste(%08x, %u, %d)", win, prop, Delete));
+    if (prop == None)
+	return;
+    for (nread = 0, bytes_after = 1; bytes_after > 0; nread += ct.nitems) {
+	if ((XGetWindowProperty(Xdisplay, win, prop, (nread / 4), PROP_SIZE,
+				Delete, AnyPropertyType, &ct.encoding,
+				&ct.format, &ct.nitems, &bytes_after,
+				&ct.value) != Success)) {
+	    XFree(ct.value);
+	    return;
+	}
+	if (ct.value == NULL)
+	    continue;
+#ifdef MULTICHAR_SET
+	if (XmbTextPropertyToTextList(Xdisplay, &ct, &cl,
+				      &dummy_count) == Success && cl) {
+	    PasteIt(cl[0], strlen(cl[0]));
+	    XFreeStringList(cl);
+	} else
+#endif
+	PasteIt(ct.value, ct.nitems);
+	XFree(ct.value);
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Request the current primary selection
+ * EXT: button 2 release
+ */
+/* EXTPROTO */
+void
+selection_request(Time tm, int x, int y)
+{
+    Atom            prop;
+#ifdef MULTICHAR_SET
+    Atom            ct;
+#endif
+
+    D_SELECT((stderr, "selection_request(%ld, %d, %d)", tm, x, y));
+    if (x < 0 || x >= TermWin.width || y < 0 || y >= TermWin.height)
+	return;			/* outside window */
+
+    if (selection.text != NULL)
+	PasteIt(selection.text, selection.len);		/* internal selection */
+    else if (XGetSelectionOwner(Xdisplay, XA_PRIMARY) == None)
+	selection_paste(Xroot, XA_CUT_BUFFER0, False);
+    else {
+	prop = XInternAtom(Xdisplay, "VT_SELECTION", False);
+#ifdef MULTICHAR_SET
+	ct = XInternAtom(Xdisplay, "COMPOUND_TEXT", False);
+	XConvertSelection(Xdisplay, XA_PRIMARY, ct, prop, TermWin.vt, tm);
+#else
+	XConvertSelection(Xdisplay, XA_PRIMARY, XA_STRING, prop, TermWin.vt,
+			  tm);
+#endif
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Clear all selected text
+ * EXT: SelectionClear
+ */
+/* EXTPROTO */
+void
+selection_clear(void)
+{
+    D_SELECT((stderr, "selection_clear()"));
+
+    want_refresh = 1;
+    if (selection.text)
+	FREE(selection.text);
+    selection.text = NULL;
+    selection.len = 0;
+    CLEAR_SELECTION;
+}
+
+/* ------------------------------------------------------------------------- */
+/* 
+ * Copy a selection into the cut buffer
+ * EXT: button 1 or 3 release
+ */
+/* EXTPROTO */
+void
+selection_make(Time tm)
+{
+    int             i, col, end_col, row, end_row;
+    unsigned char  *new_selection_text;
+    char           *str;
+    text_t         *t;
+
+    D_SELECT((stderr, "selection_make(): selection.op=%d, selection.clicks=%d", selection.op, selection.clicks));
+    switch (selection.op) {
+    case SELECTION_CONT:
+	break;
+    case SELECTION_INIT:
+	CLEAR_SELECTION;
+    /* FALLTHROUGH */
+    case SELECTION_BEGIN:
+	selection.op = SELECTION_DONE;
+    /* FALLTHROUGH */
+    default:
+	return;
+    }
+    selection.op = SELECTION_DONE;
+
+    if (selection.clicks == 4)
+	return;			/* nothing selected, go away */
+
+    i = (selection.end.row - selection.beg.row + 1) * (TermWin.ncol + 1) + 1;
+    str = MALLOC(i * sizeof(char));
+
+    new_selection_text = (unsigned char *)str;
+
+    col = max(selection.beg.col, 0);
+    row = selection.beg.row + TermWin.saveLines;
+    end_row = selection.end.row + TermWin.saveLines;
+/*
+ * A: rows before end row
+ */
+    for (; row < end_row; row++) {
+	t = &(screen.text[row][col]);
+	if ((end_col = screen.tlen[row]) == -1)
+	    end_col = TermWin.ncol;
+	for (; col < end_col; col++)
+	    *str++ = *t++;
+	col = 0;
+	if (screen.tlen[row] != -1)
+	    *str++ = '\n';
+    }
+/*
+ * B: end row
+ */
+    t = &(screen.text[row][col]);
+    end_col = screen.tlen[row];
+    if (end_col == -1 || selection.end.col <= end_col)
+	end_col = selection.end.col;
+    MIN_IT(end_col, TermWin.ncol);	/* CHANGE */
+    for (; col < end_col; col++)
+	*str++ = *t++;
+#ifndef NO_OLD_SELECTION
+    if (selection_style == OLD_SELECT)
+	if (end_col == TermWin.ncol)
+	    *str++ = '\n';
+#endif
+#ifndef NO_NEW_SELECTION
+    if (selection_style != OLD_SELECT)
+	if (end_col != selection.end.col)
+	    *str++ = '\n';
+#endif
+    *str = '\0';
+    if ((i = strlen((char *)new_selection_text)) == 0) {
+	FREE(new_selection_text);
+	return;
+    }
+    selection.len = i;
+    if (selection.text)
+	FREE(selection.text);
+    selection.text = new_selection_text;
+
+    XSetSelectionOwner(Xdisplay, XA_PRIMARY, TermWin.vt, tm);
+    if (XGetSelectionOwner(Xdisplay, XA_PRIMARY) != TermWin.vt)
+	print_error("can't get primary selection");
+    XChangeProperty(Xdisplay, Xroot, XA_CUT_BUFFER0, XA_STRING, 8,
+		    PropModeReplace, selection.text, selection.len);
+    D_SELECT((stderr, "selection_make(): selection.len=%d", selection.len));
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Mark or select text based upon number of clicks: 1, 2, or 3
+ * EXT: button 1 press
+ */
+/* EXTPROTO */
+void
+selection_click(int clicks, int x, int y)
+{
+/*    int             r, c;
+ *   row_col_t             ext_beg, ext_end;
+ */
+
+    D_SELECT((stderr, "selection_click(%d, %d, %d)", clicks, x, y));
+
+    clicks = ((clicks - 1) % 3) + 1;
+    selection.clicks = clicks;	/* save clicks so extend will work */
+
+    selection_start_colrow(Pixel2Col(x), Pixel2Row(y));
+    if (clicks == 2 || clicks == 3)
+	selection_extend_colrow(selection.mark.col,
+				selection.mark.row + TermWin.view_start,
+				0,	/* button 3     */
+				1,	/* button press */
+				0);	/* click change */
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Mark a selection at the specified col/row
+ */
+/* INTPROTO */
+void
+selection_start_colrow(int col, int row)
+{
+    want_refresh = 1;
+    selection.mark.col = col;
+    selection.mark.row = row - TermWin.view_start;
+    MAX_IT(selection.mark.row, -TermWin.nscrolled);
+    MIN_IT(selection.mark.row, TermWin.nrow - 1);
+    MAX_IT(selection.mark.col, 0);
+    MIN_IT(selection.mark.col, TermWin.ncol - 1);
+
+    if (selection.op) {		/* clear the old selection */
+	selection.beg.row = selection.end.row = selection.mark.row;
+	selection.beg.col = selection.end.col = selection.mark.col;
+    }
+    selection.op = SELECTION_INIT;
+    selection.screen = current_screen;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Word select: select text for 2 clicks
+ * We now only find out the boundary in one direction
+ */
+
+/* what do we want: spaces/tabs are delimiters or cutchars or non-cutchars */
+#define DELIMIT_TEXT(x) \
+    (((x) == ' ' || (x) == '\t') ? 2 : (strchr(rs[Rs_cutchars], (x)) != NULL))
+#ifdef MULTICHAR_SET
+# define DELIMIT_REND(x)	(((x) & RS_multiMask) ? 1 : 0)
+#else
+# define DELIMIT_REND(x)	1
+#endif
+
+/* INTPROTO */
+void
+selection_delimit_word(int dirn, const row_col_t * mark, row_col_t * ret)
+{
+    int             col, row, dirnadd, tcol, trow, w1, w2;
+    row_col_t       bound;
+    text_t         *stp;
+    rend_t         *srp;
+
+    if (selection.clicks != 2)
+	return;			/* Go away: we only handle double clicks */
+
+    if (dirn == UP) {
+	bound.row = TermWin.saveLines - TermWin.nscrolled - 1;
+	bound.col = 0;
+	dirnadd = -1;
+    } else {
+	bound.row = TermWin.saveLines + TermWin.nrow;
+	bound.col = TermWin.ncol - 1;
+	dirnadd = 1;
+    }
+    row = mark->row + TermWin.saveLines;
+    col = mark->col;
+    MAX_IT(col, 0);
+/* find the edge of a word */
+    stp = &(screen.text[row][col]);
+    w1 = DELIMIT_TEXT(*stp);
+
+    if (selection_style != NEW_SELECT) {
+	if (w1 == 1) {
+	    stp += dirnadd;
+	    if (DELIMIT_TEXT(*stp) == 1)
+		goto Old_Word_Selection_You_Die;
+	    col += dirnadd;
+	}
+	w1 = 0;
+    }
+    srp = (&screen.rend[row][col]);
+    w2 = DELIMIT_REND(*srp);
+
+    for (;;) {
+	for (; col != bound.col; col += dirnadd) {
+	    stp += dirnadd;
+	    if (DELIMIT_TEXT(*stp) != w1)
+		break;
+	    srp += dirnadd;
+	    if (DELIMIT_REND(*srp) != w2)
+		break;
+	}
+	if ((col == bound.col) && (row != bound.row)) {
+	    if (screen.tlen[(row - (dirn == UP))] == -1) {
+		trow = row + dirnadd;
+		tcol = (dirn == UP) ? (TermWin.ncol - 1) : 0;
+		if (screen.text[trow] == NULL)
+		    break;
+		stp = &(screen.text[trow][tcol]);
+		srp = &(screen.rend[trow][tcol]);
+		if (DELIMIT_TEXT(*stp) != w1 || DELIMIT_REND(*srp) != w2)
+		    break;
+		row = trow;
+		col = tcol;
+		continue;
+	    }
+	}
+	break;
+    }
+  Old_Word_Selection_You_Die:
+    D_SELECT((stderr, "selection_delimit_word(%s,...) @ (r:%3d, c:%3d) has boundary (r:%3d, c:%3d)", (dirn == UP ? "up	" : "down"), mark->row, mark->col, row - TermWin.saveLines, col));
+
+    if (dirn == DN)
+	col++;			/* put us on one past the end */
+
+/* Poke the values back in */
+    ret->row = row - TermWin.saveLines;
+    ret->col = col;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Extend the selection to the specified x/y pixel location
+ * EXT: button 3 press; button 1 or 3 drag
+ * flag == 0 ==> button 1
+ * flag == 1 ==> button 3 press
+ * flag == 2 ==> button 3 motion
+ */
+/* EXTPROTO */
+void
+selection_extend(int x, int y, int flag)
+{
+    int             col, row;
+
+    col = Pixel2Col(x);
+    row = Pixel2Row(y);
+    MAX_IT(row, 0);
+    MIN_IT(row, TermWin.nrow - 1);
+    MAX_IT(col, 0);
+    MIN_IT(col, TermWin.ncol);
+#ifndef NO_NEW_SELECTION
+/*
+ * If we're selecting characters (single click) then we must check first
+ * if we are at the same place as the original mark.  If we are then
+ * select nothing.  Otherwise, if we're to the right of the mark, you have to
+ * be _past_ a character for it to be selected.
+ */
+    if (selection_style != OLD_SELECT) {
+	if (((selection.clicks % 3) == 1) && !flag
+	    && (col == selection.mark.col
+		&& (row == selection.mark.row + TermWin.view_start))) {
+	/* select nothing */
+	    selection.beg.row = selection.end.row = 0;
+	    selection.beg.col = selection.end.col = 0;
+	    selection.clicks = 4;
+	    D_SELECT((stderr, "selection_extend() selection.clicks = 4"));
+	    return;
+	}
+    }
+#endif
+    if (selection.clicks == 4)
+	selection.clicks = 1;
+    selection_extend_colrow(col, row,
+			    !!flag,	/* ? button 3      */
+			    flag == 1 ? 1 : 0,	/* ? button press  */
+			    0);	/* no click change */
+}
+
+#ifdef MULTICHAR_SET
+/* INTPROTO */
+void
+selection_adjust_kanji(void)
+{
+    int             c, r;
+
+    if (selection.beg.col > 0) {
+	r = selection.beg.row + TermWin.saveLines;
+	c = selection.beg.col;
+	if (((screen.rend[r][c] & RS_multiMask) == RS_multi2)
+	    && ((screen.rend[r][c - 1] & RS_multiMask) == RS_multi1))
+	    selection.beg.col--;
+    }
+    if (selection.end.col < TermWin.ncol) {
+	r = selection.end.row + TermWin.saveLines;
+	c = selection.end.col;
+	if (((screen.rend[r][c - 1] & RS_multiMask) == RS_multi1)
+	    && ((screen.rend[r][c] & RS_multiMask) == RS_multi2))
+	    selection.end.col++;
+    }
+}
+#endif				/* MULTICHAR_SET */
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Extend the selection to the specified col/row
+ */
+/* INTPROTO */
+void
+selection_extend_colrow(int col, int row, int button3, int buttonpress, int clickchange)
+{
+    int             end_col;
+    row_col_t       pos;
+    enum {
+	LEFT, RIGHT
+    } closeto =     RIGHT;
+
+    D_SELECT((stderr, "selection_extend_colrow(c:%d, r:%d, %d, %d) clicks:%d", col, row, button3, buttonpress, selection.clicks));
+    D_SELECT((stderr, "selection_extend_colrow() ENT  b:(r:%d,c:%d) m:(r:%d,c:%d), e:(r:%d,c:%d)", selection.beg.row, selection.beg.col, selection.mark.row, selection.mark.col, selection.end.row, selection.end.col));
+
+    want_refresh = 1;
+    switch (selection.op) {
+    case SELECTION_INIT:
+	CLEAR_SELECTION;
+	selection.op = SELECTION_BEGIN;
+    /* FALLTHROUGH */
+    case SELECTION_BEGIN:
+	if (row != selection.mark.row || col != selection.mark.col
+	    || (!button3 && buttonpress))
+	    selection.op = SELECTION_CONT;
+	break;
+    case SELECTION_DONE:
+	selection.op = SELECTION_CONT;
+    /* FALLTHROUGH */
+    case SELECTION_CONT:
+	break;
+    case SELECTION_CLEAR:
+	selection_start_colrow(col, row);
+    /* FALLTHROUGH */
+    default:
+	return;
+    }
+
+    pos.col = col;
+    pos.row = row;
+
+    pos.row -= TermWin.view_start;	/* adjust for scroll */
+
+#ifndef NO_OLD_SELECTION
+/*
+ * This mimics some of the selection behaviour of version 2.20 and before.
+ * There are no ``selection modes'', button3 is always character extension.
+ * Note: button3 drag is always available, c.f. v2.20
+ * Selection always terminates (left or right as appropriate) at the mark.
+ */
+    if (selection_style == OLD_SELECT) {
+	static int      hate_those_clicks = 0;	/* a.k.a. keep mark position */
+
+	if (selection.clicks == 1 || button3) {
+	    if (hate_those_clicks) {
+		hate_those_clicks = 0;
+		if (selection.clicks == 1) {
+		    selection.beg.row = selection.mark.row;
+		    selection.beg.col = selection.mark.col;
+		} else {
+		    selection.mark.row = selection.beg.row;
+		    selection.mark.col = selection.beg.col;
+		}
+	    }
+	    if (ROWCOL_IS_BEFORE(pos, selection.mark)) {
+		selection.end.row = selection.mark.row;
+		selection.end.col = selection.mark.col + 1;
+		selection.beg.row = pos.row;
+		selection.beg.col = pos.col;
+	    } else {
+		selection.beg.row = selection.mark.row;
+		selection.beg.col = selection.mark.col;
+		selection.end.row = pos.row;
+		selection.end.col = pos.col + 1;
+	    }
+# ifdef MULTICHAR_SET
+	    selection_adjust_kanji();
+# endif				/* MULTICHAR_SET */
+	} else if (selection.clicks == 2) {
+	    selection_delimit_word(UP, &(selection.mark), &(selection.beg));
+	    selection_delimit_word(DN, &(selection.mark), &(selection.end));
+	    hate_those_clicks = 1;
+	} else if (selection.clicks == 3) {
+	    selection.beg.row = selection.end.row = selection.mark.row;
+	    selection.beg.col = 0;
+	    selection.end.col = TermWin.ncol;
+	    hate_those_clicks = 1;
+	}
+	D_SELECT((stderr, "selection_extend_colrow() EXIT b:(r:%d,c:%d) m:(r:%d,c:%d), e:(r:%d,c:%d)", selection.beg.row, selection.beg.col, selection.mark.row, selection.mark.col, selection.end.row, selection.end.col));
+	return;
+    }
+#endif				/* ! NO_OLD_SELECTION */
+#ifndef NO_NEW_SELECTION
+/* selection_style must not be OLD_SELECT to get here */
+/*
+ * This is mainly xterm style selection with a couple of differences, mainly
+ * in the way button3 drag extension works.
+ * We're either doing: button1 drag; button3 press; or button3 drag
+ *  a) button1 drag : select around a midpoint/word/line - that point/word/line
+ *     is always at the left/right edge of the selection.
+ *  b) button3 press: extend/contract character/word/line at whichever edge of
+ *     the selection we are closest to.
+ *  c) button3 drag : extend/contract character/word/line - we select around
+ *     a point/word/line which is either the start or end of the selection
+ *     and it was decided by whichever point/word/line was `fixed' at the 
+ *     time of the most recent button3 press
+ */
+    if (button3 && buttonpress) {	/* button3 press */
+    /*
+     * first determine which edge of the selection we are closest to
+     */
+	if (ROWCOL_IS_BEFORE(pos, selection.beg)
+	    || (!ROWCOL_IS_AFTER(pos, selection.end)
+		&& (((pos.col - selection.beg.col)
+		     + ((pos.row - selection.beg.row) * TermWin.ncol))
+		    < ((selection.end.col - pos.col)
+		       + ((selection.end.row - pos.row) * TermWin.ncol)))))
+	    closeto = LEFT;
+	if (closeto == LEFT) {
+	    selection.beg.row = pos.row;
+	    selection.beg.col = pos.col;
+	    selection.mark.row = selection.end.row;
+	    selection.mark.col = selection.end.col - (selection.clicks == 2);
+	} else {
+	    selection.end.row = pos.row;
+	    selection.end.col = pos.col;
+	    selection.mark.row = selection.beg.row;
+	    selection.mark.col = selection.beg.col;
+	}
+    } else {			/* button1 drag or button3 drag */
+	if (ROWCOL_IS_AFTER(selection.mark, pos)) {
+	    if ((selection.mark.row == selection.end.row)
+		&& (selection.mark.col == selection.end.col)
+		&& clickchange && selection.clicks == 2)
+		selection.mark.col--;
+	    selection.beg.row = pos.row;
+	    selection.beg.col = pos.col;
+	    selection.end.row = selection.mark.row;
+	    selection.end.col = selection.mark.col + (selection.clicks == 2);
+	} else {
+	    selection.beg.row = selection.mark.row;
+	    selection.beg.col = selection.mark.col;
+	    selection.end.row = pos.row;
+	    selection.end.col = pos.col;
+	}
+    }
+
+    if (selection.clicks == 1) {
+	end_col = screen.tlen[selection.beg.row + TermWin.saveLines];
+	if (end_col != -1 && selection.beg.col > end_col) {
+#if 1
+	    selection.beg.col = TermWin.ncol;
+#else
+	    if (selection.beg.row != selection.end.row)
+		selection.beg.col = TermWin.ncol;
+	    else
+		selection.beg.col = selection.mark.col;
+#endif
+	}
+	end_col = screen.tlen[selection.end.row + TermWin.saveLines];
+	if (end_col != -1 && selection.end.col > end_col)
+	    selection.end.col = TermWin.ncol;
+
+# ifdef MULTICHAR_SET
+	selection_adjust_kanji();
+# endif				/* MULTICHAR_SET */
+    } else if (selection.clicks == 2) {
+	if (ROWCOL_IS_AFTER(selection.end, selection.beg))
+	    selection.end.col--;
+	selection_delimit_word(UP, &(selection.beg), &(selection.beg));
+	selection_delimit_word(DN, &(selection.end), &(selection.end));
+    } else if (selection.clicks == 3) {
+	if (ROWCOL_IS_AFTER(selection.mark, selection.beg))
+	    selection.mark.col++;
+	selection.beg.col = 0;
+	selection.end.col = TermWin.ncol;
+    }
+    if (button3 && buttonpress) {	/* mark may need to be changed */
+	if (closeto == LEFT) {
+	    selection.mark.row = selection.end.row;
+	    selection.mark.col = selection.end.col - (selection.clicks == 2);
+	} else {
+	    selection.mark.row = selection.beg.row;
+	    selection.mark.col = selection.beg.col;
+	}
+    }
+    D_SELECT((stderr, "selection_extend_colrow() EXIT b:(r:%d,c:%d) m:(r:%d,c:%d), e:(r:%d,c:%d)", selection.beg.row, selection.beg.col, selection.mark.row, selection.mark.col, selection.end.row, selection.end.col));
+#endif				/* ! NO_NEW_SELECTION */
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Double click on button 3 when already selected
+ * EXT: button 3 double click
+ */
+/* EXTPROTO */
+void
+selection_rotate(int x, int y)
+{
+    selection.clicks = selection.clicks % 3 + 1;
+    selection_extend_colrow(Pixel2Col(x), Pixel2Row(y), 1, 0, 1);
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * On some systems, the Atom typedef is 64 bits wide.  We need to have a type
+ * that is exactly 32 bits wide, because a format of 64 is not allowed by
+ * the X11 protocol.
+ */
+typedef CARD32  Atom32;
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Respond to a request for our current selection
+ * EXT: SelectionRequest
+ */
+/* EXTPROTO */
+void
+selection_send(const XSelectionRequestEvent * rq)
+{
+    XEvent          ev;
+    Atom32          target_list[4];
+    Atom            target;
+    static Atom     xa_targets = None;
+    static Atom     xa_compound_text = None;
+    static Atom     xa_text = None;
+    XTextProperty   ct;
+    XICCEncodingStyle style;
+    char           *cl[4];
+
+    if (xa_text == None)
+	xa_text = XInternAtom(Xdisplay, "TEXT", False);
+    if (xa_compound_text == None)
+	xa_compound_text = XInternAtom(Xdisplay, "COMPOUND_TEXT", False);
+    if (xa_targets == None)
+	xa_targets = XInternAtom(Xdisplay, "TARGETS", False);
+
+    ev.xselection.type = SelectionNotify;
+    ev.xselection.property = None;
+    ev.xselection.display = rq->display;
+    ev.xselection.requestor = rq->requestor;
+    ev.xselection.selection = rq->selection;
+    ev.xselection.target = rq->target;
+    ev.xselection.time = rq->time;
+
+    if (rq->target == xa_targets) {
+	target_list[0] = (Atom32) xa_targets;
+	target_list[1] = (Atom32) XA_STRING;
+	target_list[2] = (Atom32) xa_text;
+	target_list[3] = (Atom32) xa_compound_text;
+	XChangeProperty(Xdisplay, rq->requestor, rq->property, rq->target,
+			(8 * sizeof(target_list[0])), PropModeReplace,
+			(unsigned char *)target_list,
+			(sizeof(target_list) / sizeof(target_list[0])));
+	ev.xselection.property = rq->property;
+    } else if (rq->target == XA_STRING
+	       || rq->target == xa_compound_text
+	       || rq->target == xa_text) {
+	if (rq->target == XA_STRING) {
+	    style = XStringStyle;
+	    target = XA_STRING;
+	} else {
+	    target = xa_compound_text;
+	    style = (rq->target == xa_compound_text) ? XCompoundTextStyle
+		: XStdICCTextStyle;
+	}
+	cl[0] = selection.text;
+	XmbTextListToTextProperty(Xdisplay, cl, 1, style, &ct);
+	XChangeProperty(Xdisplay, rq->requestor, rq->property,
+			target, 8, PropModeReplace,
+			ct.value, ct.nitems);
+	ev.xselection.property = rq->property;
+    }
+    XSendEvent(Xdisplay, rq->requestor, False, 0, &ev);
+}
+
+/* ------------------------------------------------------------------------- *
+ *                              MOUSE ROUTINES                               * 
+ * ------------------------------------------------------------------------- */
+
+/*
+ * return col/row values corresponding to x/y pixel values
+ */
+/* EXTPROTO */
+void
+pixel_position(int *x, int *y)
+{
+    *x = Pixel2Col(*x);
+/* MAX_IT(*x, 0); MIN_IT(*x, TermWin.ncol - 1); */
+    *y = Pixel2Row(*y);
+/* MAX_IT(*y, 0); MIN_IT(*y, TermWin.nrow - 1); */
+}
+
+/* ------------------------------------------------------------------------- */
+/* ARGSUSED */
+/* INTPROTO */
+void
+mouse_tracking(int report, int x, int y, int firstrow, int lastrow)
+{
+/* TODO */
+}
+
+/* ------------------------------------------------------------------------- *
+ *                              DEBUG ROUTINES                               * 
+ * ------------------------------------------------------------------------- */
+/* ARGSUSED */
+/* INTPROTO */
+void
+debug_PasteIt(unsigned char *data, int nitems)
+{
+/* TODO */
+}
+
+/* ------------------------------------------------------------------------- */
+#if 0
+/* INTPROTO */
+void
+debug_colors(void)
+{
+    int             color;
+    const char     *name[] =
+    { "fg", "bg",
+      "black", "red", "green", "yellow", "blue", "magenta", "cyan", "white" };
+
+    fprintf(stderr, "Color ( ");
+    if (rstyle & RS_RVid)
+	fprintf(stderr, "rvid ");
+    if (rstyle & RS_Bold)
+	fprintf(stderr, "bold ");
+    if (rstyle & RS_Blink)
+	fprintf(stderr, "blink ");
+    if (rstyle & RS_Uline)
+	fprintf(stderr, "uline ");
+    fprintf(stderr, "): ");
+
+    color = GET_FGCOLOR(rstyle);
+#ifndef NO_BRIGHTCOLOR
+    if (color >= minBrightCOLOR && color <= maxBrightCOLOR) {
+	color -= (minBrightCOLOR - minCOLOR);
+	fprintf(stderr, "bright ");
+    }
+#endif
+    fprintf(stderr, "%s on ", name[color]);
+
+    color = GET_BGCOLOR(rstyle);
+#ifndef NO_BRIGHTCOLOR
+    if (color >= minBrightCOLOR && color <= maxBrightCOLOR) {
+	color -= (minBrightCOLOR - minCOLOR);
+	fprintf(stderr, "bright ");
+    }
+#endif
+    fprintf(stderr, "%s\n", name[color]);
+}
+#endif
+
+#ifdef USE_XIM
+/* EXTPROTO */
+void
+setPosition(XPoint * pos)
+{
+    XWindowAttributes xwa;
+
+    XGetWindowAttributes(Xdisplay, TermWin.vt, &xwa);
+    pos->x = Col2Pixel(screen.cur.col) + xwa.x;
+    pos->y = Height2Pixel((screen.cur.row + 1)) + xwa.y;
+}
+#endif
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/screen.extpro work/main.d/rxvt-2.6.4/src/screen.extpro
--- tmp/rxvt-2.6.4/src/screen.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/screen.extpro	2001-11-01 21:28:29.000000000 -0300
@@ -0,0 +1,51 @@
+void             scr_reset               __PROTO((void));
+void             scr_release             __PROTO((void));
+void             scr_poweron             __PROTO((void));
+void             scr_cursor              __PROTO((int mode));
+int              scr_change_screen       __PROTO((int scrn));
+void             scr_color               __PROTO((unsigned int color, unsigned int Intensity));
+void             scr_rendition           __PROTO((int set, int style));
+void             scr_scroll_text         __PROTO((int count));
+void             scr_add_lines           __PROTO((const unsigned char *str, int nlines, int len));
+void             scr_backspace           __PROTO((void));
+void             scr_tab                 __PROTO((int count));
+void             scr_backindex           __PROTO((void));
+void             scr_forwardindex        __PROTO((void));
+void             scr_gotorc              __PROTO((int row, int col, int relative));
+void             scr_index               __PROTO((int direction));
+void             scr_erase_line          __PROTO((int mode));
+void             scr_erase_screen        __PROTO((int mode));
+void             scr_E                   __PROTO((void));
+void             scr_insdel_lines        __PROTO((int count, int insdel));
+void             scr_insdel_chars        __PROTO((int count, int insdel));
+void             scr_scroll_region       __PROTO((int top, int bot));
+void             scr_cursor_visible      __PROTO((int mode));
+void             scr_autowrap            __PROTO((int mode));
+void             scr_relative_origin     __PROTO((int mode));
+void             scr_insert_mode         __PROTO((int mode));
+void             scr_set_tab             __PROTO((int mode));
+void             scr_rvideo_mode         __PROTO((int mode));
+void             scr_report_position     __PROTO((void));
+void             scr_charset_choose      __PROTO((int set));
+void             scr_charset_set         __PROTO((int set, unsigned int ch));
+void             set_multichar_encoding  __PROTO((const char *str));
+int              scr_get_fgcolor         __PROTO((void));
+int              scr_get_bgcolor         __PROTO((void));
+void             scr_expose              __PROTO((int x, int y, int width, int height));
+void             scr_touch               __PROTO((void));
+int              scr_move_to             __PROTO((int y, int len));
+int              scr_page                __PROTO((int direction, int nlines));
+void             scr_bell                __PROTO((void));
+void             scr_printscreen         __PROTO((int fullhist));
+void             scr_refresh             __PROTO((int type));
+void             scr_clear               __PROTO((void));
+void             selection_paste         __PROTO((Window win, unsigned int prop, int Delete));
+void             selection_request       __PROTO((Time tm, int x, int y));
+void             selection_clear         __PROTO((void));
+void             selection_make          __PROTO((Time tm));
+void             selection_click         __PROTO((int clicks, int x, int y));
+void             selection_extend        __PROTO((int x, int y, int flag));
+void             selection_rotate        __PROTO((int x, int y));
+void             selection_send          __PROTO((const XSelectionRequestEvent * rq));
+void             pixel_position          __PROTO((int *x, int *y));
+void             setPosition             __PROTO((XPoint * pos));
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/screen.h work/main.d/rxvt-2.6.4/src/screen.h
--- tmp/rxvt-2.6.4/src/screen.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/screen.h	1998-11-25 13:34:13.000000000 -0300
@@ -0,0 +1,125 @@
+/*
+ * $Id: screen.h,v 1.8 1998/11/25 16:34:13 mason Exp $
+ */
+
+#ifndef _SCREEN_H		/* include once only */
+#define _SCREEN_H
+
+typedef unsigned char text_t;
+
+#if defined(MULTICHAR_SET)
+#define rend_t		u_int32_t
+#else
+#define rend_t		u_int16_t
+#endif
+
+/*
+ * screen accounting:
+ * screen_t elements
+ *   text:      Contains all text information including the scrollback buffer.
+ *              Each line is length TermWin.ncol
+ *   tlen:      The length of the line or -1 for wrapped lines.
+ *   rend:      Contains rendition information: font, bold, colour, etc.
+ * * Note: Each line for both text and rend are only allocated on demand, and
+ *         text[x] is allocated <=> rend[x] is allocated  for all x.
+ *   row:       Cursor row position                   : 0 <= row < TermWin.nrow
+ *   col:       Cursor column position                : 0 <= col < TermWin.ncol
+ *   tscroll:   Scrolling region top row inclusive    : 0 <= row < TermWin.nrow
+ *   bscroll:   Scrolling region bottom row inclusive : 0 <= row < TermWin.nrow
+ *
+ * selection_t elements
+ *   clicks:    1, 2 or 3 clicks - 4 indicates a special condition of 1 where
+ *              nothing is selected
+ *   beg:       row/column of beginning of selection  : never past mark
+ *   mark:      row/column of initial click           : never past end
+ *   end:       row/column of one character past end of selection
+ * * Note: -TermWin.nscrolled <= beg.row <= mark.row <= end.row < TermWin.nrow
+ * * Note: col == -1 ==> we're left of screen
+ *
+ * TermWin.saveLines:
+ *              Maximum number of lines in the scrollback buffer.
+ *              This is fixed for each rxvt instance.
+ * TermWin.nscrolled:
+ *              Actual number of lines we've used of the scrollback buffer
+ *              0 <= TermWin.nscrolled <= TermWin.saveLines
+ * TermWin.view_start:  
+ *              Offset back into the scrollback buffer for out current view
+ *              0 <= TermWin.view_start <= TermWin.nscrolled
+ *
+ * Layout of text/rend information in the screen_t text/rend structures:
+ *   Rows [0] ... [TermWin.saveLines - 1]
+ *     scrollback region : we're only here if TermWin.view_start != 0
+ *   Rows [TermWin.saveLines] ... [TermWin.saveLines + TermWin.nrow - 1]
+ *     normal `unscrolled' screen region
+ */
+typedef struct {
+    text_t        **text;	/* _all_ the text                            */
+    int16_t	   *tlen;	/* length of each text line                  */
+    rend_t        **rend;	/* rendition, uses RS_ flags                 */
+    row_col_t       cur;	/* cursor position on the screen             */
+    int16_t         tscroll,	/* top of settable scroll region             */
+                    bscroll,	/* bottom of settable scroll region          */
+		    charset;	/* character set number [0..3]               */
+    unsigned int    flags;	/* see below                                 */
+} screen_t;
+
+typedef struct {
+    row_col_t	    cur;	/* cursor position                           */
+    int16_t	    charset;	/* character set number [0..3]               */
+    char            charset_char;
+    rend_t          rstyle;	/* rendition style                           */
+} save_t;
+
+typedef struct {
+    unsigned char  *text;	/* selected text                             */
+    int             len;	/* length of selected text                   */
+    enum {
+	SELECTION_CLEAR = 0,	/* nothing selected                          */
+	SELECTION_INIT,		/* marked a point                            */
+	SELECTION_BEGIN,	/* started a selection                       */
+	SELECTION_CONT,		/* continued selection                       */
+	SELECTION_DONE		/* selection put in CUT_BUFFER0              */
+    } op;			/* current operation                         */
+    short           screen;	/* screen being used                         */
+    short           clicks;	/* number of clicks                          */
+    row_col_t       beg, mark, end;
+} selection_t;
+
+typedef enum {
+    OLD_SELECT, OLD_WORD_SELECT, NEW_SELECT
+} sstyle_t;
+
+/* ------------------------------------------------------------------------- */
+
+/* screen_t flags */
+#define Screen_Relative		(1<<0)	/* relative origin mode flag         */
+#define Screen_VisibleCursor	(1<<1)	/* cursor visible?                   */
+#define Screen_Autowrap		(1<<2)	/* auto-wrap flag                    */
+#define Screen_Insert		(1<<3)	/* insert mode (vs. overstrike)      */
+#define Screen_WrapNext		(1<<4)	/* need to wrap for next char?       */
+#define Screen_DefaultFlags	(Screen_VisibleCursor|Screen_Autowrap)
+
+/* ------------------------------------------------------------------------- *
+ *                             MODULE VARIABLES                              *
+ * ------------------------------------------------------------------------- */
+
+#ifdef INTERN_SCREEN
+# define EXTSCR
+#else
+# define EXTSCR	extern
+#endif
+
+/* This tells what's actually on the screen */
+EXTSCR text_t    **drawn_text;
+EXTSCR rend_t    **drawn_rend;
+EXTSCR text_t    **buf_text;
+EXTSCR rend_t    **buf_rend;
+EXTSCR int16_t    *buf_tlen;
+EXTSCR char       *tabs;	/* a 1 for a location with a tab-stop */
+EXTSCR screen_t    screen;
+EXTSCR screen_t    swap;
+EXTSCR save_t      save;
+EXTSCR selection_t selection;
+EXTSCR sstyle_t    selection_style;
+
+#endif				/* repeat inclusion protection */
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/screen.intpro work/main.d/rxvt-2.6.4/src/screen.intpro
--- tmp/rxvt-2.6.4/src/screen.intpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/screen.intpro	2001-11-01 21:28:31.000000000 -0300
@@ -0,0 +1,19 @@
+void             blank_line              __PROTO((text_t * et, rend_t * er, int width, rend_t efs));
+void             blank_screen_mem        __PROTO((text_t ** tp, rend_t ** rp, int row, rend_t efs, char keepr));
+void             scr_reset_realloc       __PROTO((void));
+int              scroll_text             __PROTO((int row1, int row2, int count, int spec));
+void             set_font_style          __PROTO((void));
+void             eucj2jis                __PROTO((unsigned char *str, int len));
+void             sjis2jis                __PROTO((unsigned char *str, int len));
+void             big5dummy               __PROTO((unsigned char *str, int len));
+void             gb2jis                  __PROTO((unsigned char *str, int len));
+void             scr_reverse_selection   __PROTO((void));
+void             selection_check         __PROTO((int check_more));
+void             PasteIt                 __PROTO((const unsigned char *data, unsigned int nitems));
+void             selection_start_colrow  __PROTO((int col, int row));
+void             selection_delimit_word  __PROTO((int dirn, const row_col_t * mark, row_col_t * ret));
+void             selection_adjust_kanji  __PROTO((void));
+void             selection_extend_colrow __PROTO((int col, int row, int button3, int buttonpress, int clickchange));
+void             mouse_tracking          __PROTO((int report, int x, int y, int firstrow, int lastrow));
+void             debug_PasteIt           __PROTO((unsigned char *data, int nitems));
+void             debug_colors            __PROTO((void));
Binary files tmp/rxvt-2.6.4/src/screen.o and work/main.d/rxvt-2.6.4/src/screen.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/scrollbar.c work/main.d/rxvt-2.6.4/src/scrollbar.c
--- tmp/rxvt-2.6.4/src/scrollbar.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/scrollbar.c	1999-09-20 15:39:41.000000000 -0300
@@ -0,0 +1,611 @@
+/*--------------------------------*-C-*---------------------------------*
+ * File:	scrollbar.c
+ *----------------------------------------------------------------------*
+ * $Id: scrollbar.c,v 1.19.2.3 1999/09/20 18:39:41 mason Exp $
+ *
+ * Copyright (C) 1997,1998 mj olesen <olesen@me.QueensU.CA>
+ * Copyright (C) 1998      Alfredo K. Kojima <kojima@windowmaker.org>
+ *				- N*XTstep like scrollbars
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *----------------------------------------------------------------------*/
+
+#include "rxvt.h"		/* NECESSARY */
+#include "scrollbar.intpro"	/* PROTOS for internal routines */
+
+/*----------------------------------------------------------------------*
+ */
+#ifndef NEXT_SCROLLBAR
+static GC       scrollbarGC;
+
+#ifdef XTERM_SCROLLBAR		/* bitmap scrollbar */
+static GC       ShadowGC;
+
+static char     sb_bits[] =
+{0xaa, 0x0a, 0x55, 0x05};	/* 12x2 bitmap */
+
+#if (SB_WIDTH != 15)
+Error, check scrollbar width(SB_WIDTH).It must be 15 for XTERM_SCROLLBAR
+#endif
+
+#else				/* XTERM_SCROLLBAR */
+static GC       topShadowGC, botShadowGC;
+
+/* draw triangular button with a shadow of SHADOW (1 or 2) pixels */
+/* INTPROTO */
+void
+Draw_button(int x, int y, int state, int dirn)
+{
+    const unsigned int sz = (SB_WIDTH), sz2 = (SB_WIDTH / 2);
+    XPoint          pt[3];
+    GC              top, bot;
+
+    switch (state) {
+    case +1:
+	top = topShadowGC;
+	bot = botShadowGC;
+	break;
+    case -1:
+	top = botShadowGC;
+	bot = topShadowGC;
+	break;
+    default:
+	top = bot = scrollbarGC;
+	break;
+    }
+
+/* fill triangle */
+    pt[0].x = x;
+    pt[1].x = x + sz - 1;
+    pt[2].x = x + sz2;
+    if (dirn == UP) {
+	pt[0].y = pt[1].y = y + sz - 1;
+	pt[2].y = y;
+    } else {
+	pt[0].y = pt[1].y = y;
+	pt[2].y = y + sz - 1;
+    }
+    XFillPolygon(Xdisplay, scrollBar.win, scrollbarGC,
+		 pt, 3, Convex, CoordModeOrigin);
+
+/* draw base */
+    XDrawLine(Xdisplay, scrollBar.win, (dirn == UP ? bot : top),
+	      pt[0].x, pt[0].y, pt[1].x, pt[1].y);
+
+/* draw shadow on left */
+    pt[1].x = x + sz2 - 1;
+    pt[1].y = y + (dirn == UP ? 0 : sz - 1);
+    XDrawLine(Xdisplay, scrollBar.win, top,
+	      pt[0].x, pt[0].y, pt[1].x, pt[1].y);
+
+#if (SHADOW > 1)
+/* doubled */
+    pt[0].x++;
+    if (dirn == UP) {
+	pt[0].y--;
+	pt[1].y++;
+    } else {
+	pt[0].y++;
+	pt[1].y--;
+    }
+    XDrawLine(Xdisplay, scrollBar.win, top,
+	      pt[0].x, pt[0].y, pt[1].x, pt[1].y);
+#endif
+/* draw shadow on right */
+    pt[1].x = x + sz - 1;
+/* pt[2].x = x + sz2; */
+    pt[1].y = y + (dirn == UP ? sz - 1 : 0);
+    pt[2].y = y + (dirn == UP ? 0 : sz - 1);
+    XDrawLine(Xdisplay, scrollBar.win, bot,
+	      pt[2].x, pt[2].y, pt[1].x, pt[1].y);
+#if (SHADOW > 1)
+/* doubled */
+    pt[1].x--;
+    if (dirn == UP) {
+	pt[2].y++;
+	pt[1].y--;
+    } else {
+	pt[2].y--;
+	pt[1].y++;
+    }
+    XDrawLine(Xdisplay, scrollBar.win, bot,
+	      pt[2].x, pt[2].y, pt[1].x, pt[1].y);
+#endif
+}
+#endif				/* ! XTERM_SCROLLBAR */
+
+#else				/* ! NEXT_SCROLLBAR */
+/*
+ * N*XTSTEP like scrollbar - written by Alfredo K. Kojima
+ */
+static GC       blackGC, whiteGC, grayGC, darkGC, stippleGC;
+static Pixmap   dimple, upArrow, downArrow, upArrowHi, downArrowHi;
+
+const char *const SCROLLER_DIMPLE[] =
+{
+    ".%###.",
+    "%#%%%%",
+    "#%%...",
+    "#%..  ",
+    "#%.   ",
+    ".%.  ."
+};
+
+#define SCROLLER_DIMPLE_WIDTH   6
+#define SCROLLER_DIMPLE_HEIGHT  6
+
+const char *const SCROLLER_ARROW_UP[] =
+{
+    ".............",
+    ".............",
+    "......%......",
+    "......#......",
+    ".....%#%.....",
+    ".....###.....",
+    "....%###%....",
+    "....#####....",
+    "...%#####%...",
+    "...#######...",
+    "..%#######%..",
+    ".............",
+    "............."
+};
+
+const char *const SCROLLER_ARROW_DOWN[] =
+{
+    ".............",
+    ".............",
+    "..%#######%..",
+    "...#######...",
+    "...%#####%...",
+    "....#####....",
+    "....%###%....",
+    ".....###.....",
+    ".....%#%.....",
+    "......#......",
+    "......%......",
+    ".............",
+    "............."
+};
+
+const char *const HI_SCROLLER_ARROW_UP[] =
+{
+    "             ",
+    "             ",
+    "      %      ",
+    "      %      ",
+    "     %%%     ",
+    "     %%%     ",
+    "    %%%%%    ",
+    "    %%%%%    ",
+    "   %%%%%%%   ",
+    "   %%%%%%%   ",
+    "  %%%%%%%%%  ",
+    "             ",
+    "             "
+};
+
+const char *const HI_SCROLLER_ARROW_DOWN[] =
+{
+    "             ",
+    "             ",
+    "  %%%%%%%%%  ",
+    "   %%%%%%%   ",
+    "   %%%%%%%   ",
+    "    %%%%%    ",
+    "    %%%%%    ",
+    "     %%%     ",
+    "     %%%     ",
+    "      %      ",
+    "      %      ",
+    "             ",
+    "             "
+};
+
+#define ARROW_WIDTH   13
+#define ARROW_HEIGHT  13
+
+#define stp_width 8
+#define stp_height 8
+const unsigned char stp_bits[] =
+    { 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa };
+
+/* INTPROTO */
+Pixmap
+renderPixmap(const char *const *data, int width, int height)
+{
+    int             x, y;
+    Pixmap          d;
+
+    d = XCreatePixmap(Xdisplay, scrollBar.win, width, height, Xdepth);
+
+    for (y = 0; y < height; y++) {
+	for (x = 0; x < width; x++) {
+	    switch (data[y][x]) {
+	    case ' ':
+	    case 'w':
+		XDrawPoint(Xdisplay, d, whiteGC, x, y);
+		break;
+	    case '.':
+	    case 'l':
+		XDrawPoint(Xdisplay, d, grayGC, x, y);
+		break;
+	    case '%':
+	    case 'd':
+		XDrawPoint(Xdisplay, d, darkGC, x, y);
+		break;
+	    case '#':
+	    case 'b':
+	    default:
+		XDrawPoint(Xdisplay, d, blackGC, x, y);
+		break;
+	    }
+	}
+    }
+    return d;
+}
+
+/* INTPROTO */
+void
+init_scrollbar_stuff(void)
+{
+    XGCValues       gcvalue;
+    XColor          xcol;
+    Pixmap          stipple;
+    unsigned long   light, dark;
+
+    gcvalue.graphics_exposures = False;
+
+    gcvalue.foreground = BlackPixelOfScreen(DefaultScreenOfDisplay(Xdisplay));
+    blackGC = XCreateGC(Xdisplay, scrollBar.win, GCForeground | GCGraphicsExposures,
+			&gcvalue);
+
+    gcvalue.foreground = WhitePixelOfScreen(DefaultScreenOfDisplay(Xdisplay));
+    whiteGC = XCreateGC(Xdisplay, scrollBar.win, GCForeground | GCGraphicsExposures,
+			&gcvalue);
+
+    xcol.red = 0xaeba;
+    xcol.green = 0xaaaa;
+    xcol.blue = 0xaeba;
+    if (!XAllocColor(Xdisplay, Xcmap, &xcol)) {
+	print_error("can't allocate %s", "light gray");
+	xcol.pixel = PixColors[Color_AntiqueWhite];
+    }
+    light = gcvalue.foreground = xcol.pixel;
+    grayGC = XCreateGC(Xdisplay, scrollBar.win, GCForeground | GCGraphicsExposures,
+		       &gcvalue);
+
+    xcol.red = 0x51aa;
+    xcol.green = 0x5555;
+    xcol.blue = 0x5144;
+    if (!XAllocColor(Xdisplay, Xcmap, &xcol)) {
+	print_error("can't allocate %s", "dark gray");
+	xcol.pixel = PixColors[Color_Grey25];
+    }
+    dark = gcvalue.foreground = xcol.pixel;
+    darkGC = XCreateGC(Xdisplay, scrollBar.win, GCForeground | GCGraphicsExposures,
+		       &gcvalue);
+
+    stipple = XCreateBitmapFromData(Xdisplay, scrollBar.win,
+				    stp_bits, stp_width, stp_height);
+
+    gcvalue.foreground = dark;
+    gcvalue.background = light;
+    gcvalue.fill_style = FillStippled;
+    gcvalue.stipple = stipple;
+
+/*    XSetWindowBackground(Xdisplay, scrollBar.win, PixColors[Color_Red]); */
+
+    stippleGC = XCreateGC(Xdisplay, scrollBar.win, GCForeground | GCBackground
+			  | GCStipple | GCFillStyle | GCGraphicsExposures,
+			  &gcvalue);
+
+    dimple = renderPixmap(SCROLLER_DIMPLE, SCROLLER_DIMPLE_WIDTH,
+			  SCROLLER_DIMPLE_HEIGHT);
+
+    upArrow = renderPixmap(SCROLLER_ARROW_UP, ARROW_WIDTH, ARROW_HEIGHT);
+    downArrow = renderPixmap(SCROLLER_ARROW_DOWN, ARROW_WIDTH, ARROW_HEIGHT);
+    upArrowHi = renderPixmap(HI_SCROLLER_ARROW_UP, ARROW_WIDTH, ARROW_HEIGHT);
+    downArrowHi = renderPixmap(HI_SCROLLER_ARROW_DOWN, ARROW_WIDTH, ARROW_HEIGHT);
+
+    scrollbar_show(1);
+}
+
+/* Draw bevel & arrows */
+/* INTPROTO */
+void
+drawBevel(Drawable d, int x, int y, int w, int h)
+{
+    XDrawLine(Xdisplay, d, whiteGC, x, y, x + w - 1, y);
+    XDrawLine(Xdisplay, d, whiteGC, x, y, x, y + h - 1);
+
+    XDrawLine(Xdisplay, d, blackGC, x + w - 1, y, x + w - 1, y + h - 1);
+    XDrawLine(Xdisplay, d, blackGC, x, y + h - 1, x + w - 1, y + h - 1);
+
+    XDrawLine(Xdisplay, d, darkGC, x + 1, y + h - 2, x + w - 2, y + h - 2);
+    XDrawLine(Xdisplay, d, darkGC, x + w - 2, y + 1, x + w - 2, y + h - 2);
+}
+
+#endif				/* ! NEXT_SCROLLBAR */
+
+/* EXTPROTO */
+int
+scrollbar_show(int update)
+{
+    static int      scrollbar_len;	/* length of slider */
+    static int      last_top, last_bot, last_state;
+#ifndef NEXT_SCROLLBAR
+    static short    sb_width;		/* old (drawn) values */
+    int             xsb = 0;
+
+    if (!scrollbar_visible())
+	return 0;
+
+    if (scrollbarGC == None) {
+	XGCValues       gcvalue;
+
+#ifdef XTERM_SCROLLBAR
+	sb_width = SB_WIDTH - 1;
+	gcvalue.stipple = XCreateBitmapFromData(Xdisplay, scrollBar.win,
+						sb_bits, 12, 2);
+	if (!gcvalue.stipple) {
+	    print_error("can't create bitmap");
+	    exit(EXIT_FAILURE);
+	}
+	gcvalue.fill_style = FillOpaqueStippled;
+	gcvalue.foreground = PixColors[Color_fg];
+	gcvalue.background = PixColors[Color_bg];
+
+	scrollbarGC = XCreateGC(Xdisplay, scrollBar.win,
+				GCForeground | GCBackground |
+				GCFillStyle | GCStipple,
+				&gcvalue);
+	gcvalue.foreground = PixColors[Color_border];
+	ShadowGC = XCreateGC(Xdisplay, scrollBar.win, GCForeground, &gcvalue);
+#else				/* XTERM_SCROLLBAR */
+	sb_width = SB_WIDTH;
+
+	gcvalue.foreground = PixColors[Color_trough];
+	if (sb_shadow) {
+	    XSetWindowBackground(Xdisplay, scrollBar.win, gcvalue.foreground);
+	    XClearWindow(Xdisplay, scrollBar.win);
+	}
+	gcvalue.foreground = (Xdepth <= 2 ? PixColors[Color_fg]
+			      : PixColors[Color_scroll]);
+	scrollbarGC = XCreateGC(Xdisplay, scrollBar.win, GCForeground,
+				&gcvalue);
+
+	gcvalue.foreground = PixColors[Color_topShadow];
+	topShadowGC = XCreateGC(Xdisplay, scrollBar.win,
+				GCForeground,
+				&gcvalue);
+
+	gcvalue.foreground = PixColors[Color_bottomShadow];
+	botShadowGC = XCreateGC(Xdisplay, scrollBar.win,
+				GCForeground,
+				&gcvalue);
+#endif				/* XTERM_SCROLLBAR */
+    }
+    if (update) {
+	int             top = (TermWin.nscrolled - TermWin.view_start);
+	int             bot = top + (TermWin.nrow - 1);
+	int             len = max((TermWin.nscrolled + (TermWin.nrow - 1)), 1);
+	int             adj = ((bot - top) * scrollbar_size()) % len;
+
+	scrollBar.top = (scrollBar.beg + (top * scrollbar_size()) / len);
+        scrollbar_len = (((bot - top) * scrollbar_size()) / len +
+			 SCROLL_MINHEIGHT + ((adj > 0) ? 1 : 0));
+	scrollBar.bot = (scrollBar.top + scrollbar_len);
+    /* no change */
+	if ((scrollBar.top == last_top) && (scrollBar.bot == last_bot)
+	    && ((scrollBar.state == last_state) || (!scrollbar_isUpDn())))
+	    return 0;
+    }
+/* instead of XClearWindow (Xdisplay, scrollBar.win); */
+#ifdef XTERM_SCROLLBAR
+    xsb = (Options & Opt_scrollBar_right) ? 1 : 0;
+#endif
+    if (last_top < scrollBar.top)
+	XClearArea(Xdisplay, scrollBar.win,
+		   sb_shadow + xsb, last_top,
+		   sb_width, (scrollBar.top - last_top),
+		   False);
+
+    if (scrollBar.bot < last_bot)
+	XClearArea(Xdisplay, scrollBar.win,
+		   sb_shadow + xsb, scrollBar.bot,
+		   sb_width, (last_bot - scrollBar.bot),
+		   False);
+
+    last_top = scrollBar.top;
+    last_bot = scrollBar.bot;
+
+/* scrollbar slider */
+#ifdef XTERM_SCROLLBAR
+    XFillRectangle(Xdisplay, scrollBar.win, scrollbarGC,
+		   xsb + 1, scrollBar.top,
+		   sb_width - 2, scrollbar_len);
+
+    XDrawLine(Xdisplay, scrollBar.win, ShadowGC,
+	      xsb ? 0 : sb_width, scrollBar.beg, xsb ? 0 : sb_width,
+	      scrollBar.end);
+#else
+#ifdef SB_BORDER
+    {
+	int             xofs;
+
+	if (Options & Opt_scrollBar_right)
+	    xofs = 0;
+	else
+	    xofs = (sb_shadow) ? SB_WIDTH : SB_WIDTH - 1;
+
+	XDrawLine(Xdisplay, scrollBar.win, botShadowGC,
+		  xofs, 0, xofs, scrollBar.end + SB_WIDTH);
+    }
+#endif
+    XFillRectangle(Xdisplay, scrollBar.win, scrollbarGC,
+		   sb_shadow, scrollBar.top,
+		   sb_width, scrollbar_len);
+
+    if (sb_shadow)
+    /* trough shadow */
+	Draw_Shadow(scrollBar.win,
+		    botShadowGC, topShadowGC,
+		    0, 0,
+		    (sb_width + 2 * sb_shadow),
+		    (scrollBar.end + (sb_width + 1) + sb_shadow));
+/* shadow for scrollbar slider */
+    Draw_Shadow(scrollBar.win,
+		topShadowGC, botShadowGC,
+		sb_shadow, scrollBar.top, sb_width,
+		scrollbar_len);
+
+/*
+ * Redraw scrollbar arrows
+ */
+    Draw_button(sb_shadow, sb_shadow,
+		(scrollbar_isUp()? -1 : +1), UP);
+    Draw_button(sb_shadow, (scrollBar.end + 1),
+		(scrollbar_isDn()? -1 : +1), DN);
+#endif				/* XTERM_SCROLLBAR */
+    last_top = scrollBar.top;
+    last_bot = scrollBar.bot;
+    last_state = scrollBar.state;
+
+#else				/* NEXT_SCROLLBAR */
+    Pixmap          buffer;
+    int             height = scrollBar.end + SB_BUTTON_TOTAL_HEIGHT + SB_PADDING;
+
+    if (blackGC == NULL)
+	init_scrollbar_stuff();
+
+    if (update) {
+	int             top = (TermWin.nscrolled - TermWin.view_start);
+	int             bot = top + (TermWin.nrow - 1);
+	int             len = max((TermWin.nscrolled + (TermWin.nrow - 1)), 1);
+	int             adj = ((bot - top) * scrollbar_size()) % len;
+
+	scrollBar.top = (scrollBar.beg + (top * scrollbar_size()) / len);
+        scrollbar_len = (((bot - top) * scrollbar_size()) / len +
+			 SCROLL_MINHEIGHT + ((adj > 0) ? 1 : 0));
+	scrollBar.bot = (scrollBar.top + scrollbar_len);
+    /* no change */
+	if ((scrollBar.top == last_top) && (scrollBar.bot == last_bot)
+	    && ((scrollBar.state == last_state) || (!scrollbar_isUpDn())))
+	    return 0;
+    }
+/* create double buffer */
+    buffer = XCreatePixmap(Xdisplay, scrollBar.win, SB_WIDTH + 1, height, Xdepth);
+
+    last_top = scrollBar.top;
+    last_bot = scrollBar.bot;
+    last_state = scrollBar.state;
+
+/* draw the background */
+    XFillRectangle(Xdisplay, buffer, grayGC, 0, 0, SB_WIDTH + 1, height);
+    XDrawRectangle(Xdisplay, buffer, blackGC, 0, -SB_BORDER_WIDTH,
+		   SB_WIDTH, height + SB_BORDER_WIDTH);
+
+    if (TermWin.nscrolled > 0) {
+	XFillRectangle(Xdisplay, buffer, stippleGC,
+		       SB_LEFT_PADDING, SB_PADDING,
+		       SB_BUTTON_WIDTH,
+		       height - SB_BUTTON_TOTAL_HEIGHT - SB_PADDING);
+	XFillRectangle(Xdisplay, buffer, grayGC,
+		       SB_LEFT_PADDING, scrollBar.top + SB_PADDING,
+		       SB_BUTTON_WIDTH, scrollbar_len);
+	drawBevel(buffer, SB_BUTTON_BEVEL_X, scrollBar.top + SB_PADDING,
+		  SB_BUTTON_WIDTH, scrollbar_len);
+	drawBevel(buffer, SB_BUTTON_BEVEL_X, height - SB_BUTTON_BOTH_HEIGHT,
+		  SB_BUTTON_WIDTH, SB_BUTTON_HEIGHT);
+	drawBevel(buffer, SB_BUTTON_BEVEL_X, height - SB_BUTTON_SINGLE_HEIGHT,
+		  SB_BUTTON_WIDTH, SB_BUTTON_HEIGHT);
+
+	XCopyArea(Xdisplay, dimple, buffer, whiteGC, 0, 0,
+		  SCROLLER_DIMPLE_WIDTH, SCROLLER_DIMPLE_HEIGHT,
+		  (SB_WIDTH - SCROLLER_DIMPLE_WIDTH) / 2,
+		  scrollBar.top + SB_BEVEL_WIDTH_UPPER_LEFT +
+		  (scrollbar_len - SCROLLER_DIMPLE_HEIGHT) / 2);
+
+	if (scrollbar_isUp())
+	    XCopyArea(Xdisplay, upArrowHi, buffer, whiteGC, 0, 0,
+		      ARROW_WIDTH, ARROW_HEIGHT,
+		      SB_BUTTON_FACE_X,
+		      height - (SB_BUTTON_BOTH_HEIGHT - SB_BEVEL_WIDTH_UPPER_LEFT));
+	else
+	    XCopyArea(Xdisplay, upArrow, buffer, whiteGC, 0, 0,
+		      ARROW_WIDTH, ARROW_HEIGHT,
+		      SB_BUTTON_FACE_X,
+		      height - (SB_BUTTON_BOTH_HEIGHT - SB_BEVEL_WIDTH_UPPER_LEFT));
+
+	if (scrollbar_isDn())
+	    XCopyArea(Xdisplay, downArrowHi, buffer, whiteGC, 0, 0,
+		      ARROW_WIDTH, ARROW_HEIGHT,
+		      SB_BUTTON_FACE_X,
+		      height - (SB_BUTTON_SINGLE_HEIGHT - SB_BEVEL_WIDTH_UPPER_LEFT));
+	else
+	    XCopyArea(Xdisplay, downArrow, buffer, whiteGC, 0, 0,
+		      ARROW_WIDTH, ARROW_HEIGHT,
+		      SB_BUTTON_FACE_X,
+		      height - (SB_BUTTON_SINGLE_HEIGHT - SB_BEVEL_WIDTH_UPPER_LEFT));
+    } else {
+	XFillRectangle(Xdisplay, buffer, stippleGC,
+		       SB_LEFT_PADDING, SB_PADDING,
+		       SB_BUTTON_WIDTH, height - SB_MARGIN_SPACE);
+    }
+
+    if (Options & Opt_scrollBar_right)
+	XCopyArea(Xdisplay, buffer, scrollBar.win, grayGC, 0, 0,
+		  SB_WIDTH + SB_BORDER_WIDTH, height, 0, 0);
+    else
+	XCopyArea(Xdisplay, buffer, scrollBar.win, grayGC, 0, 0,
+		  SB_WIDTH + SB_BORDER_WIDTH, height, -SB_BORDER_WIDTH, 0);
+
+    XFreePixmap(Xdisplay, buffer);
+#endif				/* ! NEXT_SCROLLBAR */
+    return 1;
+}
+
+/* EXTPROTO */
+int
+scrollbar_mapping(int map)
+{
+    int             change = 0;
+
+    if (map && !scrollbar_visible()) {
+	scrollBar.state = 1;
+	if (scrollBar.win == 0)
+	    return 0;
+	XMapWindow(Xdisplay, scrollBar.win);
+	change = 1;
+    } else if (!map && scrollbar_visible()) {
+	scrollBar.state = 0;
+	XUnmapWindow(Xdisplay, scrollBar.win);
+	change = 1;
+    }
+    return change;
+}
+
+/* EXTPROTO */
+void
+map_scrollBar(int map)
+{
+    if (scrollbar_mapping(map)) {
+	resize_all_windows();
+	scr_touch();
+    }
+}
+
+/*----------------------- end-of-file (C source) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/scrollbar.extpro work/main.d/rxvt-2.6.4/src/scrollbar.extpro
--- tmp/rxvt-2.6.4/src/scrollbar.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/scrollbar.extpro	2001-11-01 21:28:29.000000000 -0300
@@ -0,0 +1,3 @@
+int              scrollbar_show          __PROTO((int update));
+int              scrollbar_mapping       __PROTO((int map));
+void             map_scrollBar           __PROTO((int map));
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/scrollbar.intpro work/main.d/rxvt-2.6.4/src/scrollbar.intpro
--- tmp/rxvt-2.6.4/src/scrollbar.intpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/scrollbar.intpro	2001-11-01 21:28:31.000000000 -0300
@@ -0,0 +1,4 @@
+void             Draw_button             __PROTO((int x, int y, int state, int dirn));
+Pixmap           renderPixmap            __PROTO((const char *const *data, int width, int height));
+void             init_scrollbar_stuff    __PROTO((void));
+void             drawBevel               __PROTO((Drawable d, int x, int y, int w, int h));
Binary files tmp/rxvt-2.6.4/src/scrollbar.o and work/main.d/rxvt-2.6.4/src/scrollbar.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/version.h work/main.d/rxvt-2.6.4/src/version.h
--- tmp/rxvt-2.6.4/src/version.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/version.h	2001-11-01 21:13:10.000000000 -0300
@@ -0,0 +1,3 @@
+#define VERSION "2.6.4"
+#define DATE	"02 NOVEMBER 2001"
+#define LSMDATE	"02NOV01"
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/xdefaults.c work/main.d/rxvt-2.6.4/src/xdefaults.c
--- tmp/rxvt-2.6.4/src/xdefaults.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/xdefaults.c	2000-07-05 03:51:45.000000000 -0300
@@ -0,0 +1,913 @@
+/*--------------------------------*-C-*---------------------------------*
+ * File:	xdefaults.c
+ *----------------------------------------------------------------------*
+ * $Id: xdefaults.c,v 1.34.2.5 2000/07/05 06:51:45 gcw Exp $
+ *
+ * All portions of code are copyright by their respective author/s.
+ * Copyright (C) 1994      Robert Nation <nation@rocket.sanders.lockheed.com>
+ *				- original version
+ * Copyright (C) 1997,1998 mj olesen <olesen@me.queensu.ca>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *----------------------------------------------------------------------*/
+/*----------------------------------------------------------------------*
+ * get resources from ~/.Xdefaults or ~/.Xresources with the memory-saving
+ * default or with XGetDefault() (#define USE_XGETDEFAULT)
+ *
+ * Coding style:
+ *	resource strings are indicated by an `Rs_' prefix followed by
+ *	the resource name.
+ *	eg, `Rs_saveLines' is the resource string corresponding to
+ *	    the `saveLines' resource
+ *----------------------------------------------------------------------*/
+
+#include "rxvt.h"		/* NECESSARY */
+#include "version.h"
+#include "xdefaults.intpro"	/* PROTOS for internal routines */
+
+/* #define DEBUG_RESOURCES */
+
+/*{{{ monolithic option/resource structure: */
+/*
+ * `string' options MUST have a usage argument
+ * `switch' and `boolean' options have no argument
+ * if there's no desc(ription), it won't appear in usage()
+ */
+
+/* INFO() - descriptive information only */
+#define INFO(opt, arg, desc)				\
+    {0, NULL, NULL, opt, arg, desc}
+
+/* STRG() - command-line option, with/without resource */
+#define STRG(p, kw, opt, arg, desc)			\
+    {0, &(rs[p]), kw, opt, arg, desc}
+
+/* RSTRG() - resource/long-option */
+#define RSTRG(p, kw, arg)				\
+    {0, &(rs[p]), kw, NULL, arg, NULL}
+
+/* BOOL() - regular boolean `-/+' flag */
+#define BOOL(p, kw, opt, flag, desc)			\
+    {(Opt_Boolean|flag), &(rs[p]), kw, opt, NULL, desc}
+
+/* SWCH() - `-' flag */
+#define SWCH(opt, flag, desc)				\
+    {(flag), NULL, NULL, opt, NULL, desc}
+
+/* convenient macros */
+#define optList_strlen(i)						\
+    (optList[i].flag ? 0 : (optList[i].arg ? strlen (optList[i].arg) : 1))
+#define optList_isBool(i)						\
+    (optList[i].flag & Opt_Boolean)
+#define optList_isReverse(i)						\
+    (optList[i].flag & Opt_Reverse)
+#define optList_size()							\
+    (sizeof(optList) / sizeof(optList[0]))
+
+static const struct {
+    const unsigned long flag;	/* Option flag */
+    const char    **dp;		/* data pointer */
+    const char     *kw;		/* keyword */
+    const char     *opt;	/* option */
+    const char     *arg;	/* argument */
+    const char     *desc;	/* description */
+} optList[] = {
+    STRG(Rs_display_name, NULL, "d", NULL, NULL),	/* short form */
+    STRG(Rs_display_name, NULL, "display", "string", "X server to contact"),
+    STRG(Rs_term_name, "termName", "tn", "string",
+         "value of the TERM environment variable"),
+    STRG(Rs_geometry, NULL, "g", NULL, NULL),	/* short form */
+    STRG(Rs_geometry, "geometry", "geometry", "geometry",
+         "size (in characters) and position"),
+    SWCH("C", Opt_console, "intercept console messages"),
+    SWCH("iconic", Opt_iconic, "start iconic"),
+    SWCH("ic", Opt_iconic, NULL),	/* short form */
+    BOOL(Rs_reverseVideo, "reverseVideo", "rv", Opt_reverseVideo,
+         "reverse video"),
+    BOOL(Rs_loginShell, "loginShell", "ls", Opt_loginShell, "login shell"),
+    BOOL(Rs_scrollBar, "scrollBar", "sb", Opt_scrollBar, "scrollbar"),
+    BOOL(Rs_scrollBar_right, "scrollBar_right", "sr", Opt_scrollBar_right,
+         "scrollbar right"),
+    BOOL(Rs_scrollBar_floating, "scrollBar_floating", "st",
+         Opt_scrollBar_floating, "scrollbar without a trough"),
+    BOOL(Rs_scrollTtyOutput, "scrollTtyOutput", NULL,
+         Opt_scrollTtyOutput, NULL),
+    BOOL(Rs_scrollTtyOutput, NULL, "si", Opt_Reverse | Opt_scrollTtyOutput,
+	 "scroll-on-tty-output inhibit"),
+    BOOL(Rs_scrollKeypress, "scrollTtyKeypress", "sk",
+         Opt_scrollKeypress, "scroll-on-keypress"),
+#ifdef TRANSPARENT
+    BOOL(Rs_transparent, "inheritPixmap", "ip",
+	 Opt_transparent, "inherit parent pixmap"),
+    SWCH("tr", Opt_transparent, NULL),
+#endif
+    BOOL(Rs_utmpInhibit, "utmpInhibit", "ut", Opt_utmpInhibit,
+         "utmp inhibit"),
+    BOOL(Rs_visualBell, "visualBell", "vb", Opt_visualBell, "visual bell"),
+#if ! defined(NO_MAPALERT) && defined(MAPALERT_OPTION)
+    BOOL(Rs_mapAlert, "mapAlert", NULL, Opt_mapAlert, NULL),
+#endif
+#ifdef META8_OPTION
+    BOOL(Rs_meta8, "meta8", NULL, Opt_meta8, NULL),
+#endif
+    STRG(Rs_color + Color_bg, "background", "bg", "color", "background color"),
+    STRG(Rs_color + Color_fg, "foreground", "fg", "color", "foreground color"),
+    RSTRG(Rs_color + minCOLOR + 0, "color0", "color"),
+    RSTRG(Rs_color + minCOLOR + 1, "color1", "color"),
+    RSTRG(Rs_color + minCOLOR + 2, "color2", "color"),
+    RSTRG(Rs_color + minCOLOR + 3, "color3", "color"),
+    RSTRG(Rs_color + minCOLOR + 4, "color4", "color"),
+    RSTRG(Rs_color + minCOLOR + 5, "color5", "color"),
+    RSTRG(Rs_color + minCOLOR + 6, "color6", "color"),
+    RSTRG(Rs_color + minCOLOR + 7, "color7", "color"),
+#ifndef NO_BRIGHTCOLOR
+    RSTRG(Rs_color + minBrightCOLOR + 0, "color8", "color"),
+    RSTRG(Rs_color + minBrightCOLOR + 1, "color9", "color"),
+    RSTRG(Rs_color + minBrightCOLOR + 2, "color10", "color"),
+    RSTRG(Rs_color + minBrightCOLOR + 3, "color11", "color"),
+    RSTRG(Rs_color + minBrightCOLOR + 4, "color12", "color"),
+    RSTRG(Rs_color + minBrightCOLOR + 5, "color13", "color"),
+    RSTRG(Rs_color + minBrightCOLOR + 6, "color14", "color"),
+    RSTRG(Rs_color + minBrightCOLOR + 7, "color15", "color"),
+#endif				/* NO_BRIGHTCOLOR */
+#ifndef NO_BOLDUNDERLINE
+    RSTRG(Rs_color + Color_BD, "colorBD", "color"),
+    RSTRG(Rs_color + Color_UL, "colorUL", "color"),
+#endif				/* NO_BOLDUNDERLINE */
+#ifdef KEEP_SCROLLCOLOR
+    RSTRG(Rs_color + Color_scroll, "scrollColor", "color"),
+    RSTRG(Rs_color + Color_trough, "troughColor", "color"),
+#endif				/* KEEP_SCROLLCOLOR */
+#if defined (XPM_BACKGROUND) || (MENUBAR_MAX)
+    RSTRG(Rs_path, "path", "search path"),
+#endif				/* defined (XPM_BACKGROUND) || (MENUBAR_MAX) */
+#ifdef XPM_BACKGROUND
+    STRG(Rs_backgroundPixmap, "backgroundPixmap",
+         "pixmap", "file[;geom]", "background pixmap"),
+#endif				/* XPM_BACKGROUND */
+#if (MENUBAR_MAX)
+    RSTRG(Rs_menu, "menu", "name[;tag]"),
+#endif
+#ifndef NO_BOLDFONT
+    STRG(Rs_boldFont, "boldFont", "fb", "fontname", "bold text font"),
+#endif
+    STRG(Rs_font, "font", "fn", "fontname", "normal text font"),
+/* fonts: command-line option = resource name */
+#if NFONTS > 1
+    RSTRG(Rs_font + 1, "font1", "fontname"),
+#endif
+#if NFONTS > 2
+    RSTRG(Rs_font + 2, "font2", "fontname"),
+#endif
+#if NFONTS > 3
+    RSTRG(Rs_font + 3, "font3", "fontname"),
+#endif
+#if NFONTS > 4
+    RSTRG(Rs_font + 4, "font4", "fontname"),
+#endif
+#if NFONTS > 5
+    RSTRG(Rs_font + 5, "font5", "fontname"),
+#endif
+#if NFONTS > 6
+    RSTRG(Rs_font + 6, "font6", "fontname"),
+#endif
+#if NFONTS > 7
+    RSTRG(Rs_font + 7, "font7", "fontname"),
+#endif
+#ifdef MULTICHAR_SET
+    STRG(Rs_mfont, "mfont", "fm", "fontname", "multichar font"),
+
+/* fonts: command-line option = resource name */
+# if NFONTS > 1
+    RSTRG(Rs_mfont + 1, "mfont1", "fontname"),
+# endif
+# if NFONTS > 2
+    RSTRG(Rs_mfont + 2, "mfont2", "fontname"),
+# endif
+# if NFONTS > 3
+    RSTRG(Rs_mfont + 3, "mfont3", "fontname"),
+# endif
+# if NFONTS > 4
+    RSTRG(Rs_mfont + 4, "mfont4", "fontname"),
+# endif
+# if NFONTS > 5
+    RSTRG(Rs_mfont + 5, "mfont5", "fontname"),
+# endif
+# if NFONTS > 6
+    RSTRG(Rs_mfont + 6, "mfont6", "fontname"),
+# endif
+# if NFONTS > 7
+    RSTRG(Rs_mfont + 7, "mfont7", "fontname"),
+# endif
+#endif				/* MULTICHAR_SET */
+#ifdef MULTICHAR_SET
+    STRG(Rs_multichar_encoding, "multichar_encoding", "km", "mode",
+         "multiple-character font encoding; mode = eucj | sjis | big5 | gb"),
+#endif				/* MULTICHAR_SET */
+#ifdef USE_XIM
+    STRG(Rs_preeditType, "preeditType", "pt", "style",
+         "input style of input method; style = OverTheSpot | OffTheSpot | Root"),
+    STRG(Rs_inputMethod, "inputMethod", "im", "name",
+         "name of input method"),
+#endif                         /* USE_XIM */
+#ifdef GREEK_SUPPORT
+    STRG(Rs_greek_keyboard, "greek_keyboard", "grk", "mode",
+         "greek keyboard mapping; mode = iso | ibm"),
+#endif
+    STRG(Rs_name, NULL, "name", "string",
+         "client instance, icon, and title strings"),
+    STRG(Rs_title, "title", "title", "string", "title name for window"),
+    STRG(Rs_title, NULL, "T", NULL, NULL),	/* short form */
+    STRG(Rs_iconName, "iconName", "n", "string", "icon name for window"),
+#ifndef NO_CURSORCOLOR
+    STRG(Rs_color + Color_cursor, "cursorColor", "cr", "color",
+         "cursor color"),
+/* command-line option = resource name */
+    RSTRG(Rs_color + Color_cursor2, "cursorColor2", "color"),
+#endif				/* NO_CURSORCOLOR */
+    STRG(Rs_color + Color_pointer, "pointerColor", "pr", "color",
+         "pointer color"),
+    STRG(Rs_color + Color_border, "borderColor", "bd", "color",
+         "border color"),
+    STRG(Rs_saveLines, "saveLines", "sl", "number",
+         "number of scrolled lines to save"),
+#ifndef NO_BACKSPACE_KEY
+    RSTRG(Rs_backspace_key, "backspacekey", "string"),
+#endif
+#ifndef NO_DELETE_KEY
+    RSTRG(Rs_delete_key, "deletekey", "string"),
+#endif
+    RSTRG(Rs_selectstyle, "selectstyle", "string"),
+#ifdef PRINTPIPE
+    RSTRG(Rs_print_pipe, "print-pipe", "string"),
+#endif
+#if defined (HOTKEY_CTRL) || defined (HOTKEY_META)
+    RSTRG(Rs_bigfont_key, "bigfont_key", "keysym"),
+    RSTRG(Rs_smallfont_key, "smallfont_key", "keysym"),
+#endif
+    STRG(Rs_modifier, "modifier", "mod", "modifier", "alt | meta | hyper | super | mod1 | ... | mod5"),
+    INFO("xrm", "string", "X resource"),
+#ifdef CUTCHAR_RESOURCE
+    RSTRG(Rs_cutchars, "cutchars", "string"),
+#endif				/* CUTCHAR_RESOURCE */
+    INFO("e", "command arg ...", "command to execute")
+};
+
+#undef INFO
+#undef STRG
+#undef RSTRG
+#undef SWCH
+#undef BOOL
+/*}}} */
+
+/*{{{ usage: */
+/*----------------------------------------------------------------------*/
+/* EXTPROTO */
+void
+usage(int type)
+{
+    int             i, col;
+
+#define INDENT 30
+    fprintf(stderr, "\nUsage v%s : (", VERSION);
+#ifdef XPM_BACKGROUND
+# ifdef XPM_BUFFERING
+    fprintf(stderr, "XPM-buffer,");
+# else
+    fprintf(stderr, "XPM,");
+# endif
+#endif
+#ifdef UTMP_SUPPORT
+    fprintf(stderr, "utmp,");
+#endif
+#ifdef MENUBAR
+    fprintf(stderr, "menubar,");
+#endif
+#ifdef KANJI
+    fprintf(stderr, "Kanji,");
+#endif
+#ifdef ZH
+    fprintf(stderr, "Chinese,");
+#endif
+#ifdef ZHCN
+    fprintf(stderr, "Chinese(GB),");
+#endif
+#ifdef XTERM_SCROLLBAR
+    fprintf(stderr, "XTerm-scrollbar,");
+#endif
+#ifdef GREEK_SUPPORT
+    fprintf(stderr, "Greek,");
+#endif
+#ifdef RXVT_GRAPHICS
+    fprintf(stderr, "graphics,");
+#endif
+#ifdef NO_BACKSPACE_KEY
+    fprintf(stderr, "no backspace,");
+#endif
+#ifdef NO_DELETE_KEY
+    fprintf(stderr, "no delete,");
+#endif
+#ifdef NO_RESOURCES
+    fprintf(stderr, "NoResources");
+#else
+# ifdef USE_XGETDEFAULT
+    fprintf(stderr, "XGetDefaults");
+# else
+    fprintf(stderr, ".Xdefaults");
+# endif
+#endif
+
+    fprintf(stderr, ")\n%s", APL_NAME);
+    switch (type) {
+    case 0:			/* brief listing */
+	fprintf(stderr, " [-help]\n");
+	col = 3;
+	for (i = 0; i < optList_size(); i++) {
+	    if (optList[i].desc != NULL) {
+		int             len = 2;
+
+		if (!optList_isBool(i)) {
+		    len = optList_strlen(i);
+		    if (len > 0)
+			len++;	/* account for space */
+		}
+		len += 4 + strlen(optList[i].opt);
+
+		col += len;
+		if (col > 79) {	/* assume regular width */
+		    fprintf(stderr, "\n");
+		    col = 3 + len;
+		}
+		fprintf(stderr, " [-");
+		if (optList_isBool(i))
+		    fprintf(stderr, "/+");
+		fprintf(stderr, "%s", optList[i].opt);
+		if (optList_strlen(i))
+		    fprintf(stderr, " %s]", optList[i].arg);
+		else
+		    fprintf(stderr, "]");
+	    }
+	}
+	fprintf(stderr, "\n\n");
+	break;
+
+    case 1:			/* full command-line listing */
+	fprintf(stderr,
+		" [options] [-e command args]\n\n"
+		"where options include:\n");
+
+	for (i = 0; i < optList_size(); i++)
+	    if (optList[i].desc != NULL)
+		fprintf(stderr, "    %s%s %-*s%s%s\n",
+			(optList_isBool(i) ? "-/+" : "-"),
+			optList[i].opt,
+			(INDENT - strlen(optList[i].opt)
+			 + (optList_isBool(i) ? 0 : 2)),
+			(optList[i].arg ? optList[i].arg : ""),
+			(optList_isBool(i) ? "turn on/off " : ""),
+			optList[i].desc);
+	fprintf(stderr, "\n    --help to list long-options\n\n");
+	break;
+
+    case 2:			/* full resource listing */
+	fprintf(stderr,
+		" [options] [-e command args]\n\n"
+		"where resources (long-options) include:\n");
+
+	for (i = 0; i < optList_size(); i++)
+	    if (optList[i].kw != NULL)
+		fprintf(stderr, "    %s: %*s\n",
+			optList[i].kw,
+			(INDENT - strlen(optList[i].kw)),
+			(optList_isBool(i) ? "boolean" : optList[i].arg));
+
+#ifdef KEYSYM_RESOURCE
+	fprintf(stderr, "    " "keysym.sym" ": %*s\n",
+		(INDENT - strlen("keysym.sym")), "keysym");
+#endif
+	fprintf(stderr, "\n    -help to list options\n\n");
+	break;
+    }
+    exit(EXIT_FAILURE);
+    /* NOTREACHED */
+}
+/*}}} */
+
+/*{{{ get command-line options before getting resources */
+/* EXTPROTO */
+void
+get_options(int argc, const char * const *argv)
+{
+    int             i, bad_option = 0;
+    static const char On[3] = "ON", Off[4] = "OFF";
+
+    for (i = 1; i < argc; i++) {
+	int             entry, longopt = 0;
+	const char     *flag, *opt;
+	
+	opt = argv[i];
+#ifdef DEBUG_RESOURCES
+	fprintf(stderr, "argv[%d] = %s: ", i, opt);
+#endif
+	if (*opt == '-') {
+	    flag = On;
+	    if (*++opt == '-')
+		longopt = *opt++;	/* long option */
+	} else if (*opt == '+') {
+	    flag = Off;
+	    if (*++opt == '+')
+		longopt = *opt++;	/* long option */
+	} else {
+	    bad_option = 1;
+	    print_error("bad option \"%s\"", opt);
+	    continue;
+	}
+
+	if (!strcmp(opt, "help"))
+	    usage(longopt ? 2 : 1);
+	if (!strcmp(opt, "h"))
+	    usage(0);
+
+    /* feature: always try to match long-options */
+	for (entry = 0; entry < optList_size(); entry++)
+	    if ((optList[entry].kw && !strcmp(opt, optList[entry].kw))
+		|| (!longopt
+		    && optList[entry].opt && !strcmp(opt, optList[entry].opt)))
+		break;
+
+	if (entry < optList_size()) {
+	    if (optList_isReverse(entry))
+		flag = flag == On ? Off : On;
+	    if (optList_strlen(entry)) {	/* string value */
+		const char     *str = argv[++i];
+
+#ifdef DEBUG_RESOURCES
+		fprintf(stderr, "string (%s,%s) = ",
+			optList[entry].opt ? optList[entry].opt : "nil",
+			optList[entry].kw ? optList[entry].kw : "nil");
+#endif
+		if (flag == On && str && optList[entry].dp) {
+#ifdef DEBUG_RESOURCES
+		    fprintf(stderr, "\"%s\"\n", str);
+#endif
+		    *(optList[entry].dp) = str;
+
+		/* special cases are handled in main.c:main() to allow
+		 * X resources to set these values before we settle for
+		 * default values
+		 */
+		}
+#ifdef DEBUG_RESOURCES
+		else
+		    fprintf(stderr, "???\n");
+#endif
+	    } else {		/* boolean value */
+#ifdef DEBUG_RESOURCES
+		fprintf(stderr, "boolean (%s,%s) = %s\n",
+			optList[entry].opt, optList[entry].kw, flag);
+#endif
+		if (flag == On)
+		    Options |= (optList[entry].flag);
+		else
+		    Options &= ~(optList[entry].flag);
+
+		if (optList[entry].dp)
+		    *(optList[entry].dp) = flag;
+	    }
+	} else
+#ifdef KEYSYM_RESOURCE
+	/* if (!strncmp (opt, "keysym.", strlen ("keysym."))) */
+	if (Str_match(opt, "keysym.")) {
+	    const char     *str = argv[++i];
+
+	/*
+	 * '7' is strlen("keysym.")
+	 */
+	    if (str != NULL)
+		parse_keysym(opt + 7, str);
+	} else
+#endif
+	{
+	/* various old-style options, just ignore
+	 * Obsolete since about Jan 96,
+	 * so they can probably eventually be removed
+	 */
+	    const char     *msg = "bad";
+
+	    if (longopt) {
+		opt--;
+		bad_option = 1;
+	    } else if (!strcmp(opt, "7") || !strcmp(opt, "8")
+#ifdef GREEK_SUPPORT
+	    /* obsolete 12 May 1996 (v2.17) */
+		       || !Str_match(opt, "grk")
+#endif
+		)
+		msg = "obsolete";
+	    else
+		bad_option = 1;
+
+	    print_error("%s option \"%s\"", msg, --opt);
+	}
+    }
+
+    if (bad_option)
+	usage(0);
+}
+/*}}} */
+
+#ifndef NO_RESOURCES
+/*----------------------------------------------------------------------*/
+/*{{{ string functions */
+/*
+ * a replacement for strcasecmp() to avoid linking an entire library
+ */
+/* INTPROTO */
+int
+my_strcasecmp(const char *s1, const char *s2)
+{
+    for ( /*nil */ ; (*s1 && *s2); s1++, s2++) {
+	register int    c1 = toupper(*s1);
+	register int    c2 = toupper(*s2);
+
+	if (c1 != c2)
+	    return (c1 - c2);
+    }
+    return (int)(*s1 - *s2);
+}
+
+/*}}} */
+
+# ifdef KEYSYM_RESOURCE
+/*
+ * Define key from XrmEnumerateDatabase.
+ *   quarks will be something like
+ *      "rxvt" "keysym" "0xFF01"
+ *   value will be a string
+ */
+/* ARGSUSED */
+/* INTPROTO */
+Bool
+define_key(XrmDatabase *database, XrmBindingList bindings, XrmQuarkList quarks, XrmRepresentation *type, XrmValue *value, XPointer closure)
+{
+    int             last;
+
+    for (last = 0; quarks[last] != NULLQUARK; last++)	/* look for last quark in list */
+	;
+    last--;
+    parse_keysym(XrmQuarkToString(quarks[last]), (char *)value->addr);
+    return False;
+}
+
+/*
+ * look for something like this (XK_Delete)
+ * rxvt*keysym.0xFFFF: "\177"
+ *
+ * arg will be
+ *      NULL for ~/.Xdefaults and
+ *      non-NULL for command-line options (need to allocate)
+ */
+#define NEWARGLIM	500	/* `reasonable' size */
+/* INTPROTO */
+int
+parse_keysym(const char *str, const char *arg)
+{
+    int             n, sym;
+    char           *key_string, *newarg = NULL;
+    char            newargstr[NEWARGLIM];
+
+    if (arg == NULL) {
+	if ((n = Str_match(str, "keysym.")) == 0)
+	    return 0;
+	str += n;		/* skip `keysym.' */
+    }
+/* some scanf() have trouble with a 0x prefix */
+    if (isdigit(str[0])) {
+	if (str[0] == '0' && toupper(str[1]) == 'X')
+	    str += 2;
+	if (arg) {
+	    if (sscanf(str, (strchr(str, ':') ? "%x:" : "%x"), &sym) != 1)
+		return -1;
+	} else {
+	    if (sscanf(str, "%x:", &sym) != 1)
+		return -1;
+
+	/* cue to ':', it's there since sscanf() worked */
+	    STRNCPY(newargstr, strchr(str, ':') + 1, NEWARGLIM - 1);
+	    newargstr[NEWARGLIM - 1] = '\0';
+	    newarg = Str_trim(newargstr);
+	}
+    } else {
+    /*
+     * convert keysym name to keysym number
+     */
+	STRNCPY(newargstr, str, NEWARGLIM - 1);
+	newargstr[NEWARGLIM - 1] = '\0';
+	if (arg == NULL) {
+	    if ((newarg = strchr(newargstr, ':')) == NULL)
+		return -1;
+	    *newarg++ = '\0';	/* terminate keysym name */
+	    (void) Str_trim(newarg);
+	}
+	if ((sym = XStringToKeysym(newargstr)) == None)
+	    return -1;
+    }
+
+    if (sym < 0xFF00 || sym > 0xFFFF)	/* we only do extended keys */
+	return -1;
+    sym &= 0xFF;
+    if (KeySym_map[sym] != NULL)	/* already set ? */
+	return -1;
+
+    if (newarg == NULL) {
+	STRNCPY(newargstr, arg, NEWARGLIM - 1);
+	newargstr[NEWARGLIM - 1] = '\0';
+	newarg = newargstr;
+    }
+    if (strlen(newargstr) == 0
+	|| (n = Str_escaped(newargstr)) == 0)
+	return -1;
+    MIN_IT(n, 255);
+    key_string = MALLOC((n + 1) * sizeof(char));
+    key_string[0] = n;
+    STRNCPY(key_string + 1, newarg, n);
+    KeySym_map[sym] = (unsigned char *) key_string;
+
+    return 1;
+}
+# endif				/* KEYSYM_RESOURCE */
+
+# ifndef USE_XGETDEFAULT
+/*{{{ get_xdefaults() */
+/*
+ * the matching algorithm used for memory-save fake resources
+ */
+/* INTPROTO */
+void
+get_xdefaults(FILE *stream, const char *name)
+{
+    unsigned int    len;
+    char           *str, buffer[256];
+
+    if (stream == NULL)
+	return;
+    len = strlen(name);
+    while ((str = fgets(buffer, sizeof(buffer), stream)) != NULL) {
+	unsigned int    entry, n;
+
+	while (*str && isspace(*str))
+	    str++;		/* leading whitespace */
+
+	if ((str[len] != '*' && str[len] != '.')
+	    || (len && strncmp(str, name, len)))
+	    continue;
+	str += (len + 1);	/* skip `name*' or `name.' */
+
+# ifdef KEYSYM_RESOURCE
+	if (!parse_keysym(str, NULL))
+# endif				/* KEYSYM_RESOURCE */
+	    for (entry = 0; entry < optList_size(); entry++) {
+		const char     *kw = optList[entry].kw;
+
+		if (kw == NULL)
+		    continue;
+		n = strlen(kw);
+		if (str[n] == ':' && Str_match(str, kw)) {
+		/* skip `keyword:' */
+		    str += (n + 1);
+		    (void) Str_trim(str);
+		    n = strlen(str);
+		    if (n && *(optList[entry].dp) == NULL) {
+		    /* not already set */
+			int             s;
+			char           *p = MALLOC((n + 1) * sizeof(char));
+
+			STRCPY(p, str);
+			*(optList[entry].dp) = p;
+			if (optList_isBool(entry)) {
+			    s = my_strcasecmp(p, "TRUE") == 0
+				|| my_strcasecmp(p, "YES") == 0
+				|| my_strcasecmp(p, "ON") == 0
+				|| my_strcasecmp(p, "1") == 0;
+			    if (optList_isReverse(entry))
+				s = !s;
+			    if (s)
+				Options |= (optList[entry].flag);
+			    else
+				Options &= ~(optList[entry].flag);
+			}
+		    }
+		    break;
+		}
+	    }
+    }
+    rewind(stream);
+}
+/*}}} */
+# endif				/* ! USE_XGETDEFAULT */
+#endif				/* NO_RESOURCES */
+
+/*{{{ read the resources files */
+/*
+ * using XGetDefault() or the hand-rolled replacement
+ */
+/* ARGSUSED */
+/* EXTPROTO */
+void
+extract_resources(Display *display, const char *name)
+{
+#ifndef NO_RESOURCES
+# ifdef USE_XGETDEFAULT
+/*
+ * get resources using the X library function
+ */
+    int             entry;
+
+#  ifdef XrmEnumOneLevel
+    XrmName         name_prefix[3];
+    XrmClass        class_prefix[3];
+    char           *displayResource;
+    XrmDatabase     database;
+    char           *screenResource;
+    XrmDatabase     screenDatabase;
+
+/*
+ * Get screen-specific resources (X11R5) and merge into common resources.
+ */
+    database = NULL;
+    screenDatabase = NULL;
+    displayResource = XResourceManagerString(display);
+    if (displayResource != NULL)
+	database = XrmGetStringDatabase(displayResource);
+    screenResource = XScreenResourceString(DefaultScreenOfDisplay(display));
+    if (screenResource != NULL)
+	screenDatabase = XrmGetStringDatabase(screenResource);
+    XrmMergeDatabases(screenDatabase, &database);
+    XrmSetDatabase(display, database);
+#  endif
+
+    for (entry = 0; entry < optList_size(); entry++) {
+	int             s;
+	char           *p;
+	const char     *kw = optList[entry].kw;
+
+	if (kw == NULL || *(optList[entry].dp) != NULL)
+	    continue;		/* previously set */
+	if ((p = XGetDefault(display, name, kw)) != NULL
+	    || (p = XGetDefault(display, APL_SUBCLASS, kw)) != NULL
+	    || (p = XGetDefault(display, APL_CLASS, kw)) != NULL) {
+	    *optList[entry].dp = p;
+
+	    if (optList_isBool(entry)) {
+		s = my_strcasecmp(p, "TRUE") == 0
+		    || my_strcasecmp(p, "YES") == 0
+		    || my_strcasecmp(p, "ON") == 0
+		    || my_strcasecmp(p, "1") == 0;
+		if (optList_isReverse(entry))
+		    s = !s;
+		if (s)
+		    Options |= (optList[entry].flag);
+		else
+		    Options &= ~(optList[entry].flag);
+	    }
+	}
+    }
+
+/*
+ * [R5 or later]: enumerate the resource database
+ */
+#  ifdef XrmEnumOneLevel
+#   ifdef KEYSYM_RESOURCE
+    name_prefix[0] = XrmStringToName(name);
+    name_prefix[1] = XrmStringToName("keysym");
+    name_prefix[2] = NULLQUARK;
+    class_prefix[0] = XrmStringToName(APL_SUBCLASS);
+    class_prefix[1] = XrmStringToName("Keysym");
+    class_prefix[2] = NULLQUARK;
+    XrmEnumerateDatabase(XrmGetDatabase(display),
+			 name_prefix,
+			 class_prefix,
+			 XrmEnumOneLevel,
+			 define_key,
+			 NULL);
+    name_prefix[0] = XrmStringToName(APL_CLASS);
+    name_prefix[1] = XrmStringToName("keysym");
+    class_prefix[0] = XrmStringToName(APL_CLASS);
+    class_prefix[1] = XrmStringToName("Keysym");
+    XrmEnumerateDatabase(XrmGetDatabase(display),
+			 name_prefix,
+			 class_prefix,
+			 XrmEnumOneLevel,
+			 define_key,
+			 NULL);
+#   endif
+#  endif
+
+# else				/* USE_XGETDEFAULT */
+/* get resources the hard way, but save lots of memory */
+    const char     *const fname[] = { ".Xdefaults", ".Xresources" };
+    FILE           *fd = NULL;
+    char           *home;
+
+    if ((home = getenv("HOME")) != NULL) {
+	int             i, len = strlen(home) + 2;
+	char           *f = NULL;
+
+	for (i = 0; i < (sizeof(fname) / sizeof(fname[0])); i++) {
+	    f = REALLOC(f, (len + strlen(fname[i])) * sizeof(char));
+
+	    sprintf(f, "%s/%s", home, fname[i]);
+
+	    if ((fd = fopen(f, "r")) != NULL)
+		break;
+	}
+	FREE(f);
+    }
+/*
+ * The normal order to match resources is the following:
+ * @ global resources (partial match, ~/.Xdefaults)
+ * @ application file resources (XAPPLOADDIR/Rxvt)
+ * @ class resources (~/.Xdefaults)
+ * @ private resources (~/.Xdefaults)
+ *
+ * However, for the hand-rolled resources, the matching algorithm
+ * checks if a resource string value has already been allocated
+ * and won't overwrite it with (in this case) a less specific
+ * resource value.
+ *
+ * This avoids multiple allocation.  Also, when we've called this
+ * routine command-line string options have already been applied so we
+ * needn't to allocate for those resources.
+ *
+ * So, search in resources from most to least specific.
+ *
+ * Also, use a special sub-class so that we can use either or both of
+ * "XTerm" and "Rxvt" as class names.
+ */
+
+    get_xdefaults(fd, name);
+    get_xdefaults(fd, APL_SUBCLASS);
+
+#  ifdef XAPPLOADDIR
+    {
+	FILE           *ad = fopen(XAPPLOADDIR "/" APL_SUBCLASS, "r");
+
+	if (ad != NULL) {
+	    get_xdefaults(ad, "");
+	    fclose(ad);
+	}
+    }
+#  endif				/* XAPPLOADDIR */
+
+    get_xdefaults(fd, APL_CLASS);
+    get_xdefaults(fd, "");	/* partial match */
+    if (fd != NULL)
+	fclose(fd);
+# endif				/* USE_XGETDEFAULT */
+#endif				/* NO_RESOURCES */
+
+/*
+ * even without resources, at least do this setup for command-line
+ * options and command-line long options
+ */
+#ifdef MULTICHAR_SET
+    set_multichar_encoding(rs[Rs_multichar_encoding]);
+#endif
+#ifdef GREEK_SUPPORT
+/* this could be a function in grkelot.c */
+/* void set_greek_keyboard (const char * str); */
+    if (rs[Rs_greek_keyboard]) {
+	if (!strcmp(rs[Rs_greek_keyboard], "iso"))
+	    greek_setmode(GREEK_ELOT928);	/* former -grk9 */
+	else if (!strcmp(rs[Rs_greek_keyboard], "ibm"))
+	    greek_setmode(GREEK_IBM437);	/* former -grk4 */
+    }
+#endif				/* GREEK_SUPPORT */
+
+#if defined (HOTKEY_CTRL) || defined (HOTKEY_META)
+    {
+	KeySym          sym;
+
+	if (rs[Rs_bigfont_key]
+	    && ((sym = XStringToKeysym(rs[Rs_bigfont_key])) != 0))
+	    ks_bigfont = sym;
+	if (rs[Rs_smallfont_key]
+	    && ((sym = XStringToKeysym(rs[Rs_smallfont_key])) != 0))
+	    ks_smallfont = sym;
+    }
+#endif
+}
+/*}}} */
+/*----------------------- end-of-file (C source) -----------------------*/
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/xdefaults.extpro work/main.d/rxvt-2.6.4/src/xdefaults.extpro
--- tmp/rxvt-2.6.4/src/xdefaults.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/xdefaults.extpro	2001-11-01 21:28:29.000000000 -0300
@@ -0,0 +1,3 @@
+void             usage                   __PROTO((int type));
+void             get_options             __PROTO((int argc, const char * const *argv));
+void             extract_resources       __PROTO((Display *display, const char *name));
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/xdefaults.intpro work/main.d/rxvt-2.6.4/src/xdefaults.intpro
--- tmp/rxvt-2.6.4/src/xdefaults.intpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/xdefaults.intpro	2001-11-01 21:28:31.000000000 -0300
@@ -0,0 +1,4 @@
+int              my_strcasecmp           __PROTO((const char *s1, const char *s2));
+Bool             define_key              __PROTO((XrmDatabase *database, XrmBindingList bindings, XrmQuarkList quarks, XrmRepresentation *type, XrmValue *value, XPointer closure));
+int              parse_keysym            __PROTO((const char *str, const char *arg));
+void             get_xdefaults           __PROTO((FILE *stream, const char *name));
Binary files tmp/rxvt-2.6.4/src/xdefaults.o and work/main.d/rxvt-2.6.4/src/xdefaults.o differ
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/xpm.c work/main.d/rxvt-2.6.4/src/xpm.c
--- tmp/rxvt-2.6.4/src/xpm.c	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/xpm.c	1999-03-11 11:09:21.000000000 -0300
@@ -0,0 +1,452 @@
+/*--------------------------------*-C-*---------------------------------*
+ * File:	xpm.c
+ *----------------------------------------------------------------------*
+ * $Id: xpm.c,v 1.28 1999/03/11 14:09:21 mason Exp $
+ *
+ * All portions of code are copyright by their respective author/s.
+ * Copyright (C) 1997      Carsten Haitzler <raster@zip.com.au>
+ * Copyright (C) 1997,1998 Oezguer Kesim <kesim@math.fu-berlin.de>
+ * Copyright (C) 1998      Geoff Wing <gcw@pobox.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *---------------------------------------------------------------------*/
+
+#include "rxvt.h"		/* NECESSARY */
+#include "xpm.intpro"		/* PROTOS for internal routines */
+
+#ifdef XPM_BACKGROUND
+# ifdef XPM_INC_X11
+#  include <X11/xpm.h>
+# else
+#  include <xpm.h>
+# endif
+#endif
+
+typedef struct {
+    short           w, h, x, y;
+    Pixmap          pixmap;
+} bgPixmap_t;
+
+static bgPixmap_t bgPixmap = { 0, 0, 50, 50, None } ;
+
+/* the originally loaded pixmap and its scaling */
+#ifdef XPM_BACKGROUND
+static XpmAttributes xpmAttr;
+#endif
+
+/*
+ * These GEOM strings indicate absolute size/position:
+ * @ `WxH+X+Y'
+ * @ `WxH+X'    -> Y = X
+ * @ `WxH'      -> Y = X = 50
+ * @ `W+X+Y'    -> H = W
+ * @ `W+X'      -> H = W, Y = X
+ * @ `W'        -> H = W, X = Y = 50
+ * @ `0xH'      -> H *= H/100, X = Y = 50 (W unchanged)
+ * @ `Wx0'      -> W *= W/100, X = Y = 50 (H unchanged)
+ * @ `=+X+Y'    -> (H, W unchanged)
+ * @ `=+X'      -> Y = X (H, W unchanged)
+ *
+ * These GEOM strings adjust position relative to current position:
+ * @ `+X+Y'
+ * @ `+X'       -> Y = X
+ *
+ * And this GEOM string is for querying current scale/position:
+ * @ `?'
+ */
+/* EXTPROTO */
+int
+scale_pixmap(const char *geom)
+{
+#ifdef XPM_BACKGROUND
+    int             w = 0, h = 0, x = 0, y = 0;
+    int             n, flags, changed = 0;
+    char           *p;
+    static char     str[] = "[1000x1000+1000+1000]";
+
+    if (geom == NULL)
+	return 0;
+    if (!strcmp(geom, "?")) {
+	sprintf(str, "[%dx%d+%d+%d]",	/* can't presume snprintf? */
+		(bgPixmap.w < 9999 ? bgPixmap.w : 9999),
+		(bgPixmap.h < 9999 ? bgPixmap.h : 9999),
+		(bgPixmap.x < 9999 ? bgPixmap.x : 9999),
+		(bgPixmap.y < 9999 ? bgPixmap.y : 9999));
+	xterm_seq(XTerm_title, str);
+	return 0;
+    }
+
+    if ((p = strchr(geom, ';')) == NULL)
+        p = strchr(geom, '\0');
+    n = (p - geom);
+    if (n >= sizeof(str) - 1)
+        return 0;
+    STRNCPY(str, geom, n);
+    str[n] = '\0';
+
+    flags = XParseGeometry(str, &x, &y, (unsigned int *) &w, (unsigned int *) &h);
+    if (!flags) {
+	flags |= WidthValue;
+	w = 0;
+    }				/* default is tile */
+    if (flags & WidthValue) {
+	if (!(flags & XValue))
+	    x = 50;
+
+	if (!(flags & HeightValue))
+	    h = w;
+
+	if (w && !h) {
+	    w = bgPixmap.w * ((float)w / 100);
+	    h = bgPixmap.h;
+	} else if (h && !w) {
+	    w = bgPixmap.w;
+	    h = bgPixmap.h * ((float)h / 100);
+	}
+	if (w > 1000)
+	    w = 1000;
+	if (h > 1000)
+	    h = 1000;
+
+	if (bgPixmap.w != w) {
+	    bgPixmap.w = w;
+	    changed++;
+	}
+	if (bgPixmap.h != h) {
+	    bgPixmap.h = h;
+	    changed++;
+	}
+    }
+    if (!(flags & YValue)) {
+	if (flags & XNegative)
+	    flags |= YNegative;
+	y = x;
+    }
+
+    if (!(flags & WidthValue) && geom[0] != '=') {
+	x += bgPixmap.x;
+	y += bgPixmap.y;
+    } else {
+	if (flags & XNegative)
+	    x += 100;
+	if (flags & YNegative)
+	    y += 100;
+    }
+    MIN_IT(x, 100);
+    MIN_IT(y, 100);
+    MAX_IT(x, 0);
+    MAX_IT(y, 0);
+    if (bgPixmap.x != x) {
+	bgPixmap.x = x;
+	changed++;
+    }
+    if (bgPixmap.y != y) {
+	bgPixmap.y = y;
+	changed++;
+    }
+    return changed;
+#else
+    return 0;
+#endif				/* XPM_BACKGROUND */
+}
+
+/* EXTPROTO */
+void
+resize_pixmap(void)
+{
+#ifdef XPM_BACKGROUND
+    XGCValues       gcvalue;
+    GC              gc;
+    int             tiled = 0;
+    unsigned int    width = TermWin_TotalWidth();
+    unsigned int    height = TermWin_TotalHeight();
+
+    if (TermWin.pixmap)
+	XFreePixmap(Xdisplay, TermWin.pixmap);
+
+# ifndef XPM_BUFFERING
+    if (bgPixmap.pixmap == None) {	/* So be it: I'm not using pixmaps */
+	TermWin.pixmap = None;
+	if (!(Options & Opt_transparent))
+	    XSetWindowBackground(Xdisplay, TermWin.vt, PixColors[Color_bg]);
+	return;
+    }
+# endif
+
+    gcvalue.foreground = PixColors[Color_bg];
+    gc = XCreateGC(Xdisplay, TermWin.vt, GCForeground, &gcvalue);
+
+    if (bgPixmap.pixmap) {	/* we have a specified pixmap */
+	int             w = bgPixmap.w, h = bgPixmap.h,
+			x = bgPixmap.x, y = bgPixmap.y;
+
+    /*
+     * don't zoom pixmap too much nor expand really small pixmaps
+     */
+	if (w > 1000 || h > 1000)
+	    w = 1;
+	else if (width > (10 * xpmAttr.width)
+		 || height > (10 * xpmAttr.height))
+	    w = 0;		/* tile */
+
+	if (w == 0) {
+	/* basic X tiling - let the X server do it */
+	    TermWin.pixmap = XCreatePixmap(Xdisplay, TermWin.vt,
+					   xpmAttr.width, xpmAttr.height,
+					   Xdepth);
+	    XCopyArea(Xdisplay, bgPixmap.pixmap, TermWin.pixmap,
+		      gc, 0, 0, xpmAttr.width, xpmAttr.height, 0, 0);
+	    tiled = 1;
+	} else {
+	    float           p, incr;
+	    Pixmap          tmp;
+
+	    TermWin.pixmap = XCreatePixmap(Xdisplay, TermWin.vt,
+					   width, height, Xdepth);
+	/*
+	 * horizontal scaling
+	 */
+	    incr = (float)xpmAttr.width;
+	    p = 0;
+
+	    if (w == 1) {	/* display one image, no horizontal scaling */
+		incr = width;
+		if (xpmAttr.width <= width) {
+		    w = xpmAttr.width;
+		    x = x * (width - w) / 100;	/* beware! order */
+		    w += x;
+		} else {
+		    x = 0;
+		    w = width;
+		}
+	    } else if (w < 10) { /* fit W images across screen */
+		incr *= w;
+		x = 0;
+		w = width;
+	    } else {
+		incr *= 100.0 / w;
+		if (w < 100) {	/* contract */
+		    w = (w * width) / 100;
+		    if (x >= 0) {	/* position */
+			float           pos;
+
+			pos = (float)x / 100 * width - (w / 2);
+
+			x = (width - w);
+			if (pos <= 0)
+			    x = 0;
+			else if (pos < x)
+			    x = pos;
+		    } else {
+			x = x * (width - w) / 100;	/* beware! order */
+		    }
+		    w += x;
+		} else {	/* expand */
+		    if (x > 0) {	/* position */
+			float           pos;
+
+			pos = (float)x / 100 * xpmAttr.width - (incr / 2);
+			p = xpmAttr.width - (incr);
+			if (pos <= 0)
+			    p = 0;
+			else if (pos < p)
+			    p = pos;
+		    }
+		    x = 0;
+		    w = width;
+		}
+	    }
+	    incr /= width;
+
+	    tmp = XCreatePixmap(Xdisplay, TermWin.vt,
+				width, xpmAttr.height, Xdepth);
+	    XFillRectangle(Xdisplay, tmp, gc, 0, 0, width, xpmAttr.height);
+
+	    for ( /*nil */ ; x < w; x++, p += incr) {
+		if (p >= xpmAttr.width)
+		    p = 0;
+		if (x < 0)
+		    continue;
+	    /* copy one column from the original pixmap to the tmp pixmap */
+		XCopyArea(Xdisplay, bgPixmap.pixmap, tmp, gc,
+			  (int)p, 0, 1, xpmAttr.height, x, 0);
+	    }
+
+	/*
+	 * vertical scaling
+	 */
+	    incr = (float)xpmAttr.height;
+	    p = 0;
+
+	    if (h == 1) {	/* display one image, no vertical scaling */
+		incr = height;
+		if (xpmAttr.height <= height) {
+		    h = xpmAttr.height;
+		    y = y * (height - h) / 100;	/* beware! order */
+		    h += y;
+		} else {
+		    y = 0;
+		    h = height;
+		}
+	    } else if (h < 10) { /* fit H images across screen */
+		incr *= h;
+		y = 0;
+		h = height;
+	    } else {
+		incr *= 100.0 / h;
+		if (h < 100) {	/* contract */
+		    h = (h * height) / 100;
+		    if (y >= 0) {	/* position */
+			float           pos;
+
+			pos = (float)y / 100 * height - (h / 2);
+
+			y = (height - h);
+			if (pos < 0.0f)
+			    y = 0;
+			else if (pos < y)
+			    y = pos;
+		    } else {
+			y = y * (height - h) / 100;	/* beware! order */
+		    }
+		    h += y;
+		} else {	/* expand */
+		    if (y > 0) {	/* position */
+			float           pos;
+
+			pos = (float)y / 100 * xpmAttr.height - (incr / 2);
+			p = xpmAttr.height - (incr);
+			if (pos < 0)
+			    p = 0;
+			else if (pos < p)
+			    p = pos;
+		    }
+		    y = 0;
+		    h = height;
+		}
+	    }
+	    incr /= height;
+
+	    if (y > 0)
+		XFillRectangle(Xdisplay, TermWin.pixmap, gc, 0, 0,
+			       width, y);
+	    if (h < height)
+		XFillRectangle(Xdisplay, TermWin.pixmap, gc, 0, h,
+			       width, height - h + 1);
+	    for ( /*nil */ ; y < h; y++, p += incr) {
+		if (p >= xpmAttr.height)
+		    p = 0;
+		if (y < 0)
+		    continue;
+	    /* copy one row from the tmp pixmap to the main pixmap */
+		XCopyArea(Xdisplay, tmp, TermWin.pixmap, gc,
+			  0, (int)p, width, 1, 0, y);
+	    }
+	    XFreePixmap(Xdisplay, tmp);
+	}
+    }
+
+# ifdef XPM_BUFFERING
+    if (TermWin.buf_pixmap)
+	XFreePixmap(Xdisplay, TermWin.buf_pixmap);
+    TermWin.buf_pixmap = XCreatePixmap(Xdisplay, TermWin.vt,
+				       width, height, Xdepth);
+    if (!bgPixmap.pixmap) { 	/* we don't have a specified pixmap */
+	TermWin.pixmap = XCreatePixmap(Xdisplay, TermWin.vt,
+				       width, height, Xdepth);
+	XFillRectangle(Xdisplay, TermWin.pixmap, gc,
+		       0, 0, width, height);
+    }
+    if (tiled == 0) {
+	XCopyArea(Xdisplay, TermWin.pixmap, TermWin.buf_pixmap, gc,
+		  0, 0, width, height, 0, 0);
+    } else {
+	int             i, j, w, h;
+
+	for (j = 0; j < height; j += xpmAttr.height) {
+	    h = (j + xpmAttr.height > height) ? (height - j): xpmAttr.height;
+	    for (i = 0; i < width; i += xpmAttr.width) {
+		w = (i + xpmAttr.width > width) ? (width - i): xpmAttr.width;
+		XCopyArea(Xdisplay, TermWin.pixmap, TermWin.buf_pixmap, gc,
+			  0, 0, w, h, i, j);
+	    }
+	}
+	XFreePixmap(Xdisplay, TermWin.pixmap);
+	TermWin.pixmap = XCreatePixmap(Xdisplay, TermWin.vt,
+				       width, height, Xdepth);
+	XCopyArea(Xdisplay, TermWin.buf_pixmap, TermWin.pixmap, gc,
+		  0, 0, width, height, 0, 0);
+    }
+    XSetWindowBackgroundPixmap(Xdisplay, TermWin.vt, TermWin.buf_pixmap);
+# else				/* XPM_BUFFERING */
+    XSetWindowBackgroundPixmap(Xdisplay, TermWin.vt, TermWin.pixmap);
+# endif				/* XPM_BUFFERING */
+    XFreeGC(Xdisplay, gc);
+
+    XClearWindow(Xdisplay, TermWin.vt);
+
+    XSync(Xdisplay, False);
+#endif				/* XPM_BACKGROUND */
+}
+
+/* EXTPROTO */
+Pixmap
+set_bgPixmap(const char *file)
+{
+#ifdef XPM_BACKGROUND
+    char           *f;
+
+    assert(file != NULL);
+
+    if (bgPixmap.pixmap != None) {
+	XFreePixmap(Xdisplay, bgPixmap.pixmap);
+	bgPixmap.pixmap = None;
+    }
+    XSetWindowBackground(Xdisplay, TermWin.vt, PixColors[Color_bg]);
+
+    if (*file != '\0') {
+/*      XWindowAttributes attr; */
+
+    /*
+     * we already have the required attributes
+     */
+/*      XGetWindowAttributes(Xdisplay, TermWin.vt, &attr); */
+
+	xpmAttr.closeness = 30000;
+	xpmAttr.colormap = Xcmap;
+	xpmAttr.visual = Xvisual;
+	xpmAttr.depth = Xdepth;
+	xpmAttr.valuemask = (XpmCloseness | XpmColormap | XpmVisual |
+			     XpmDepth | XpmSize | XpmReturnPixels);
+
+    /* search environment variables here too */
+	if ((f = (char *)File_find(file, ".xpm")) == NULL
+	    || XpmReadFileToPixmap(Xdisplay, Xroot, f,
+				   &bgPixmap.pixmap,
+				   NULL, &xpmAttr)) {
+	    char           *p;
+
+	/* semi-colon delimited */
+	    if ((p = strchr(file, ';')) == NULL)
+		p = strchr(file, '\0');
+
+	    print_error("couldn't load XPM file \"%.*s\"", (p - file), file);
+	}
+	FREE(f);
+    }
+    resize_pixmap();
+    return bgPixmap.pixmap;
+#endif				/* XPM_BACKGROUND */
+}
diff --speed-large-files --minimal -Nru tmp/rxvt-2.6.4/src/xpm.extpro work/main.d/rxvt-2.6.4/src/xpm.extpro
--- tmp/rxvt-2.6.4/src/xpm.extpro	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/rxvt-2.6.4/src/xpm.extpro	2001-11-01 21:28:29.000000000 -0300
@@ -0,0 +1,3 @@
+int              scale_pixmap            __PROTO((const char *geom));
+void             resize_pixmap           __PROTO((void));
+Pixmap           set_bgPixmap            __PROTO((const char *file));
Binary files tmp/rxvt-2.6.4/src/xpm.o and work/main.d/rxvt-2.6.4/src/xpm.o differ
diff --speed-large-files --minimal -Nru tmp/xcursor-transparent-theme-0.1.1/config.cache work/main.d/xcursor-transparent-theme-0.1.1/config.cache
--- tmp/xcursor-transparent-theme-0.1.1/config.cache	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/xcursor-transparent-theme-0.1.1/config.cache	2007-01-24 20:00:49.000000000 -0300
@@ -0,0 +1,21 @@
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+ac_cv_env_build_alias_set=set
+ac_cv_env_build_alias_value=i586-mandriva-linux-gnu
+ac_cv_env_host_alias_set=set
+ac_cv_env_host_alias_value=i586-castorbox-linux-gnu
+ac_cv_env_target_alias_set=
+ac_cv_env_target_alias_value=
+ac_cv_path_install=${ac_cv_path_install='//media/gar-castorbox/images/build/usr/bin/install -c'}
+ac_cv_prog_make_make_set=${ac_cv_prog_make_make_set=yes}
diff --speed-large-files --minimal -Nru tmp/xcursor-transparent-theme-0.1.1/config.h work/main.d/xcursor-transparent-theme-0.1.1/config.h
--- tmp/xcursor-transparent-theme-0.1.1/config.h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/xcursor-transparent-theme-0.1.1/config.h	2007-01-24 20:00:50.000000000 -0300
@@ -0,0 +1,23 @@
+/* config.h.  Generated by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Name of package */
+#define PACKAGE "xcursor-transparent-theme"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""
+
+/* Version number of package */
+#define VERSION "0.1.1"
diff --speed-large-files --minimal -Nru tmp/xcursor-transparent-theme-0.1.1/config.log work/main.d/xcursor-transparent-theme-0.1.1/config.log
--- tmp/xcursor-transparent-theme-0.1.1/config.log	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/xcursor-transparent-theme-0.1.1/config.log	2007-01-24 20:00:50.000000000 -0300
@@ -0,0 +1,156 @@
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by configure, which was
+generated by GNU Autoconf 2.57.  Invocation command line was
+
+  $ ./configure --prefix=//usr --exec_prefix=//usr --bindir=//usr/bin --sbindir=//usr/sbin --libexecdir=//usr/libexec --datadir=//usr/share --sysconfdir=//etc --sharedstatedir=//usr/share --localstatedir=//var --libdir=//usr/lib --infodir=//usr/info --includedir=//usr/include --oldincludedir=//usr/include --mandir=//usr/share/man --build=i586-mandriva-linux-gnu --host=i586-castorbox-linux-gnu --cache-file=config.cache --x-includes=/media/gar-castorbox/images/main//usr/include --x-libraries=/media/gar-castorbox/images/main//usr/lib --with-gnu-ld
+
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = devcsp.intra.csps.com.ar
+uname -m = i686
+uname -r = 2.6.17-9mdv
+uname -s = Linux
+uname -v = #1 SMP Wed Dec 27 12:38:36 EST 2006
+
+/usr/bin/uname -p = unknown
+/bin/uname -X     = unknown
+
+/bin/arch              = i686
+/usr/bin/arch -k       = unknown
+/usr/convex/getsysinfo = unknown
+hostinfo               = unknown
+/bin/machine           = unknown
+/usr/bin/oslevel       = unknown
+/bin/universe          = unknown
+
+PATH: //media/gar-castorbox/images/build/sbin
+PATH: //media/gar-castorbox/images/build/bin
+PATH: //media/gar-castorbox/images/build/usr/sbin
+PATH: //media/gar-castorbox/images/build/usr/bin
+PATH: //media/gar-castorbox/images/build/usr/lib/qt/bin
+PATH: //media/gar-castorbox/images/build/bin-build-system
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+configure:1110: creating cache config.cache
+configure:1228: checking for a BSD-compatible install
+configure:1282: result: //media/gar-castorbox/images/build/usr/bin/install -c
+configure:1293: checking whether build environment is sane
+configure:1336: result: yes
+configure:1351: checking whether make sets $(MAKE)
+configure:1371: result: yes
+configure:1403: checking for working aclocal-1.4
+configure:1414: result: missing
+configure:1418: checking for working autoconf
+configure:1425: result: found
+configure:1433: checking for working automake-1.4
+configure:1444: result: missing
+configure:1448: checking for working autoheader
+configure:1455: result: found
+configure:1463: checking for working makeinfo
+configure:1474: result: missing
+configure:1498: checking for a BSD-compatible install
+configure:1552: result: //media/gar-castorbox/images/build/usr/bin/install -c
+configure:1660: creating ./config.status
+
+## ---------------------- ##
+## Running config.status. ##
+## ---------------------- ##
+
+This file was extended by config.status, which was
+generated by GNU Autoconf 2.57.  Invocation command line was
+
+  CONFIG_FILES    = 
+  CONFIG_HEADERS  = 
+  CONFIG_LINKS    = 
+  CONFIG_COMMANDS = 
+  $ ./config.status 
+
+on devcsp.intra.csps.com.ar
+
+config.status:627: creating Makefile
+config.status:627: creating cursors/Makefile
+config.status:731: creating config.h
+config.status:916: executing default-1 commands
+
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+
+ac_cv_env_build_alias_set=set
+ac_cv_env_build_alias_value=i586-mandriva-linux-gnu
+ac_cv_env_host_alias_set=set
+ac_cv_env_host_alias_value=i586-castorbox-linux-gnu
+ac_cv_env_target_alias_set=
+ac_cv_env_target_alias_value=
+ac_cv_path_install='//media/gar-castorbox/images/build/usr/bin/install -c'
+ac_cv_prog_make_make_set=yes
+
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+
+ACLOCAL='/media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing aclocal-1.4'
+AUTOCONF='autoconf'
+AUTOHEADER='autoheader'
+AUTOMAKE='/media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing automake-1.4'
+DEFS='-DHAVE_CONFIG_H'
+ECHO_C=''
+ECHO_N='-n'
+ECHO_T=''
+INSTALL_DATA='${INSTALL} -m 644'
+INSTALL_PROGRAM='${INSTALL}'
+INSTALL_SCRIPT='${INSTALL}'
+LIBOBJS=''
+LIBS=''
+LTLIBOBJS=''
+MAKEINFO='/media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing makeinfo'
+PACKAGE='xcursor-transparent-theme'
+PACKAGE_BUGREPORT=''
+PACKAGE_NAME=''
+PACKAGE_STRING=''
+PACKAGE_TARNAME=''
+PACKAGE_VERSION=''
+PATH_SEPARATOR=':'
+SET_MAKE=''
+SHELL='/bin/sh'
+VERSION='0.1.1'
+bindir='//usr/bin'
+build_alias='i586-mandriva-linux-gnu'
+datadir='//usr/share'
+exec_prefix='//usr'
+host_alias='i586-castorbox-linux-gnu'
+includedir='//usr/include'
+infodir='//usr/info'
+libdir='//usr/lib'
+libexecdir='//usr/libexec'
+localstatedir='//var'
+mandir='//usr/share/man'
+oldincludedir='//usr/include'
+prefix='//usr'
+program_transform_name='s,x,x,'
+sbindir='//usr/sbin'
+sharedstatedir='//usr/share'
+sysconfdir='//etc'
+target_alias=''
+
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+
+#define PACKAGE "xcursor-transparent-theme"
+#define PACKAGE_BUGREPORT ""
+#define PACKAGE_NAME ""
+#define PACKAGE_STRING ""
+#define PACKAGE_TARNAME ""
+#define PACKAGE_VERSION ""
+#define VERSION "0.1.1"
+
+configure: exit 0
diff --speed-large-files --minimal -Nru tmp/xcursor-transparent-theme-0.1.1/config.status work/main.d/xcursor-transparent-theme-0.1.1/config.status
--- tmp/xcursor-transparent-theme-0.1.1/config.status	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/xcursor-transparent-theme-0.1.1/config.status	2007-01-24 20:00:49.000000000 -0300
@@ -0,0 +1,923 @@
+#! /bin/sh
+# Generated by configure.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=${CONFIG_SHELL-/bin/sh}
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+
+# Support unset when possible.
+if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.57.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+config_files=" Makefile cursors/Makefile"
+config_headers=" config.h"
+config_commands=" default-1"
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+  --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration commands:
+$config_commands
+
+Report bugs to <bug-autoconf@gnu.org>."
+ac_cs_version="\
+config.status
+configured by ./configure, generated by GNU Autoconf 2.57,
+  with options \"'--prefix=//usr' '--exec_prefix=//usr' '--bindir=//usr/bin' '--sbindir=//usr/sbin' '--libexecdir=//usr/libexec' '--datadir=//usr/share' '--sysconfdir=//etc' '--sharedstatedir=//usr/share' '--localstatedir=//var' '--libdir=//usr/lib' '--infodir=//usr/info' '--includedir=//usr/include' '--oldincludedir=//usr/include' '--mandir=//usr/share/man' '--build=i586-mandriva-linux-gnu' '--host=i586-castorbox-linux-gnu' '--cache-file=config.cache' '--x-includes=/media/gar-castorbox/images/main//usr/include' '--x-libraries=/media/gar-castorbox/images/main//usr/lib' '--with-gnu-ld' 'build_alias=i586-mandriva-linux-gnu' 'host_alias=i586-castorbox-linux-gnu'\"
+
+Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
+Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=.
+INSTALL="//media/gar-castorbox/images/build/usr/bin/install -c"
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+if $ac_cs_recheck; then
+  echo "running /bin/sh ./configure " '--prefix=//usr' '--exec_prefix=//usr' '--bindir=//usr/bin' '--sbindir=//usr/sbin' '--libexecdir=//usr/libexec' '--datadir=//usr/share' '--sysconfdir=//etc' '--sharedstatedir=//usr/share' '--localstatedir=//var' '--libdir=//usr/lib' '--infodir=//usr/info' '--includedir=//usr/include' '--oldincludedir=//usr/include' '--mandir=//usr/share/man' '--build=i586-mandriva-linux-gnu' '--host=i586-castorbox-linux-gnu' '--cache-file=config.cache' '--x-includes=/media/gar-castorbox/images/main//usr/include' '--x-libraries=/media/gar-castorbox/images/main//usr/lib' '--with-gnu-ld' 'build_alias=i586-mandriva-linux-gnu' 'host_alias=i586-castorbox-linux-gnu' $ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec /bin/sh ./configure '--prefix=//usr' '--exec_prefix=//usr' '--bindir=//usr/bin' '--sbindir=//usr/sbin' '--libexecdir=//usr/libexec' '--datadir=//usr/share' '--sysconfdir=//etc' '--sharedstatedir=//usr/share' '--localstatedir=//var' '--libdir=//usr/lib' '--infodir=//usr/info' '--includedir=//usr/include' '--oldincludedir=//usr/include' '--mandir=//usr/share/man' '--build=i586-mandriva-linux-gnu' '--host=i586-castorbox-linux-gnu' '--cache-file=config.cache' '--x-includes=/media/gar-castorbox/images/main//usr/include' '--x-libraries=/media/gar-castorbox/images/main//usr/lib' '--with-gnu-ld' 'build_alias=i586-mandriva-linux-gnu' 'host_alias=i586-castorbox-linux-gnu' $ac_configure_extra_args --no-create --no-recursion
+fi
+
+#
+# INIT-COMMANDS section.
+#
+
+
+
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+  "cursors/Makefile" ) CONFIG_FILES="$CONFIG_FILES cursors/Makefile" ;;
+  "default-1" ) CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
+  "config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t$/@;t t/; /@;t t$/s/[\\&,]/\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t$/,;t t/' >$tmp/subs.sed <<\CEOF
+s,@SHELL@,/bin/sh,;t t
+s,@PATH_SEPARATOR@,:,;t t
+s,@PACKAGE_NAME@,,;t t
+s,@PACKAGE_TARNAME@,,;t t
+s,@PACKAGE_VERSION@,,;t t
+s,@PACKAGE_STRING@,,;t t
+s,@PACKAGE_BUGREPORT@,,;t t
+s,@exec_prefix@,//usr,;t t
+s,@prefix@,//usr,;t t
+s,@program_transform_name@,s,x,x,,;t t
+s,@bindir@,//usr/bin,;t t
+s,@sbindir@,//usr/sbin,;t t
+s,@libexecdir@,//usr/libexec,;t t
+s,@datadir@,//usr/share,;t t
+s,@sysconfdir@,//etc,;t t
+s,@sharedstatedir@,//usr/share,;t t
+s,@localstatedir@,//var,;t t
+s,@libdir@,//usr/lib,;t t
+s,@includedir@,//usr/include,;t t
+s,@oldincludedir@,//usr/include,;t t
+s,@infodir@,//usr/info,;t t
+s,@mandir@,//usr/share/man,;t t
+s,@build_alias@,i586-mandriva-linux-gnu,;t t
+s,@host_alias@,i586-castorbox-linux-gnu,;t t
+s,@target_alias@,,;t t
+s,@DEFS@,-DHAVE_CONFIG_H,;t t
+s,@ECHO_C@,,;t t
+s,@ECHO_N@,-n,;t t
+s,@ECHO_T@,,;t t
+s,@LIBS@,,;t t
+s,@INSTALL_PROGRAM@,${INSTALL},;t t
+s,@INSTALL_SCRIPT@,${INSTALL},;t t
+s,@INSTALL_DATA@,${INSTALL} -m 644,;t t
+s,@PACKAGE@,xcursor-transparent-theme,;t t
+s,@VERSION@,0.1.1,;t t
+s,@ACLOCAL@,/media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing aclocal-1.4,;t t
+s,@AUTOCONF@,autoconf,;t t
+s,@AUTOMAKE@,/media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing automake-1.4,;t t
+s,@AUTOHEADER@,autoheader,;t t
+s,@MAKEINFO@,/media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing makeinfo,;t t
+s,@SET_MAKE@,,;t t
+s,@LIBOBJS@,,;t t
+s,@LTLIBOBJS@,,;t t
+CEOF
+
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+  	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+  	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+        cat >$tmp/stdin
+        ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$ac_file" : 'X\(//\)[^/]' \| \
+         X"$ac_file" : 'X\(//\)$' \| \
+         X"$ac_file" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$as_dir" : 'X\(//\)[^/]' \| \
+         X"$as_dir" : 'X\(//\)$' \| \
+         X"$as_dir" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
+# absolute.
+ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
+ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
+ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
+ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+                                     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+         # Absolute (can't be DOS-style, as IFS=:)
+         test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         echo $f;;
+      *) # Relative
+         if test -f "$f"; then
+           # Build tree
+           echo $f
+         elif test -f "$srcdir/$f"; then
+           # Source tree
+           echo $srcdir/$f
+         else
+           # /dev/null tree
+           { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  sed "/^[ 	]*VPATH[ 	]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[ 	]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[ 	]*$//;
+}
+
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+
+#
+# CONFIG_HEADER section.
+#
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s,^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
+ac_dB='[ 	].*$,\1#\2'
+ac_dC=' '
+ac_dD=',;t'
+# ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_uA='s,^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_uB='$,\1#\2define\3'
+ac_uC=' '
+ac_uD=',;t'
+
+for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+        cat >$tmp/stdin
+        ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  test x"$ac_file" != x- && { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+         # Absolute (can't be DOS-style, as IFS=:)
+         test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         echo $f;;
+      *) # Relative
+         if test -f "$f"; then
+           # Build tree
+           echo $f
+         elif test -f "$srcdir/$f"; then
+           # Source tree
+           echo $srcdir/$f
+         else
+           # /dev/null tree
+           { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  # Remove the trailing spaces.
+  sed 's/[ 	]*$//' $ac_file_inputs >$tmp/in
+
+  # Handle all the #define templates only if necessary.
+  if grep "^[ 	]*#[ 	]*define" $tmp/in >/dev/null; then
+  # If there are no defines, we may have an empty if/fi
+  :
+  cat >$tmp/defines.sed <<CEOF
+/^[ 	]*#[ 	]*define/!b
+t clr
+: clr
+${ac_dA}PACKAGE_NAME${ac_dB}PACKAGE_NAME${ac_dC}""${ac_dD}
+${ac_dA}PACKAGE_TARNAME${ac_dB}PACKAGE_TARNAME${ac_dC}""${ac_dD}
+${ac_dA}PACKAGE_VERSION${ac_dB}PACKAGE_VERSION${ac_dC}""${ac_dD}
+${ac_dA}PACKAGE_STRING${ac_dB}PACKAGE_STRING${ac_dC}""${ac_dD}
+${ac_dA}PACKAGE_BUGREPORT${ac_dB}PACKAGE_BUGREPORT${ac_dC}""${ac_dD}
+${ac_dA}PACKAGE${ac_dB}PACKAGE${ac_dC}"xcursor-transparent-theme"${ac_dD}
+${ac_dA}VERSION${ac_dB}VERSION${ac_dC}"0.1.1"${ac_dD}
+CEOF
+  sed -f $tmp/defines.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+
+  fi # grep
+
+  # Handle all the #undef templates
+  cat >$tmp/undefs.sed <<CEOF
+/^[ 	]*#[ 	]*undef/!b
+t clr
+: clr
+${ac_uA}PACKAGE_NAME${ac_uB}PACKAGE_NAME${ac_uC}""${ac_uD}
+${ac_uA}PACKAGE_TARNAME${ac_uB}PACKAGE_TARNAME${ac_uC}""${ac_uD}
+${ac_uA}PACKAGE_VERSION${ac_uB}PACKAGE_VERSION${ac_uC}""${ac_uD}
+${ac_uA}PACKAGE_STRING${ac_uB}PACKAGE_STRING${ac_uC}""${ac_uD}
+${ac_uA}PACKAGE_BUGREPORT${ac_uB}PACKAGE_BUGREPORT${ac_uC}""${ac_uD}
+${ac_uA}PACKAGE${ac_uB}PACKAGE${ac_uC}"xcursor-transparent-theme"${ac_uD}
+${ac_uA}VERSION${ac_uB}VERSION${ac_uC}"0.1.1"${ac_uD}
+s,^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
+CEOF
+  sed -f $tmp/undefs.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    echo "/* Generated by configure.  */" >$tmp/config.h
+  else
+    echo "/* $ac_file.  Generated by configure.  */" >$tmp/config.h
+  fi
+  cat $tmp/in >>$tmp/config.h
+  rm -f $tmp/in
+  if test x"$ac_file" != x-; then
+    if diff $ac_file $tmp/config.h >/dev/null 2>&1; then
+      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$ac_file" : 'X\(//\)[^/]' \| \
+         X"$ac_file" : 'X\(//\)$' \| \
+         X"$ac_file" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+      { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$as_dir" : 'X\(//\)[^/]' \| \
+         X"$as_dir" : 'X\(//\)$' \| \
+         X"$as_dir" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+      rm -f $ac_file
+      mv $tmp/config.h $ac_file
+    fi
+  else
+    cat $tmp/config.h
+    rm -f $tmp/config.h
+  fi
+done
+
+#
+# CONFIG_COMMANDS section.
+#
+for ac_file in : $CONFIG_COMMANDS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+  ac_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$ac_dest" : 'X\(//\)[^/]' \| \
+         X"$ac_dest" : 'X\(//\)$' \| \
+         X"$ac_dest" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
+# absolute.
+ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
+ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
+ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
+ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+
+  { echo "$as_me:$LINENO: executing $ac_dest commands" >&5
+echo "$as_me: executing $ac_dest commands" >&6;}
+  case $ac_dest in
+    default-1 ) test -z "$CONFIG_HEADERS" || echo timestamp > stamp-h ;;
+  esac
+done
+
+{ (exit 0); exit 0; }
diff --speed-large-files --minimal -Nru tmp/xcursor-transparent-theme-0.1.1/cursors/Makefile work/main.d/xcursor-transparent-theme-0.1.1/cursors/Makefile
--- tmp/xcursor-transparent-theme-0.1.1/cursors/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/xcursor-transparent-theme-0.1.1/cursors/Makefile	2007-01-24 20:00:50.000000000 -0300
@@ -0,0 +1,185 @@
+# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am
+
+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+SHELL = /bin/sh
+
+srcdir = .
+top_srcdir = ..
+
+prefix = //usr
+exec_prefix = //usr
+
+bindir = //usr/bin
+sbindir = //usr/sbin
+libexecdir = //usr/libexec
+datadir = //usr/share
+sysconfdir = //etc
+sharedstatedir = //usr/share
+localstatedir = //var
+libdir = //usr/lib
+infodir = //usr/info
+mandir = //usr/share/man
+includedir = //usr/include
+oldincludedir = /usr/include
+
+DESTDIR =
+
+pkgdatadir = $(datadir)/xcursor-transparent-theme
+pkglibdir = $(libdir)/xcursor-transparent-theme
+pkgincludedir = $(includedir)/xcursor-transparent-theme
+
+top_builddir = ..
+
+ACLOCAL = /media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing aclocal-1.4
+AUTOCONF = autoconf
+AUTOMAKE = /media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing automake-1.4
+AUTOHEADER = autoheader
+
+INSTALL = //media/gar-castorbox/images/build/usr/bin/install -c
+INSTALL_PROGRAM = ${INSTALL} $(AM_INSTALL_PROGRAM_FLAGS)
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_SCRIPT = ${INSTALL}
+transform = s,x,x,
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_alias = i586-castorbox-linux-gnu
+host_triplet = @host@
+CC = @CC@
+HAVE_LIB = @HAVE_LIB@
+LIB = @LIB@
+LTLIB = @LTLIB@
+MAKEINFO = /media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing makeinfo
+PACKAGE = xcursor-transparent-theme
+VERSION = 0.1.1
+
+CURSOR_NAMES =  	00008160000006810000408080010102 	028006030e0e7ebffc7f7070c0600140 	03b6e0fcb3499374a867c041f52298f0 	08e8e1c95fe2fc01f976f1e063a24ccd 	14fef782d02440884392942c11205230 	2870a09082c103050810ffdffffe0204 	3ecb610c1bf2410f44200f48c40d3599 	4498f0e0c1937ffe01fd06f973665830 	9d800788f1b08800ae810202380a0822 	c7088f0f3e6c8088236ef8e1e3e70000 	d9ce0ab605698f320427677b458ad60b 	e29285e634086352946a0e7090d73106 	fcf1c3c7cd4491d801f1e1c78f100000 	X_cursor 	arrow 	base_arrow_down 	base_arrow_up 	based_arrow_down 	based_arrow_up 	bd_double_arrow 	boat 	bottom_left_corner 	bottom_right_corner 	bottom_side 	bottom_tee 	center_ptr 	circle 	cross 	cross_reverse 	crossed_circle 	crosshair 	dot 	dot_box_mask 	dotbox 	double_arrow 	draft_large  	draft_small  	draped_box   	exchange     	fd_double_arrow 	fleur 	gumby 	h_double_arrow 	hand 	hand1 	hand2 	left_ptr 	left_ptr_watch 	left_side 	left_tee  	ll_angle  	lr_angle  	move      	pencil    	pirate    	plus      	question_arrow 	right_ptr      	right_side     	right_tee      	sailboat       	sb_down_arrow  	sb_h_double_arrow 	sb_left_arrow 	sb_right_arrow 	sb_up_arrow 	sb_v_double_arrow 	shuttle 	sizing  	target  	tcross  	top_left_arrow  	top_left_corner 	top_right_corner 	top_side 	top_tee 	trek 	ul_angle 	ur_angle 	v_double_arrow 	watcha 	xterm  
+
+
+CURSOR_DIR = $(datadir)/icons/xcursor-transparent/cursors
+CURSOR_REAL = transp
+EXTRA_DIST = $(CURSOR_REAL)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = ../config.h
+CONFIG_CLEAN_FILES = 
+DIST_COMMON =  Makefile.am Makefile.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP_ENV = --best
+all: all-redirect
+.SUFFIXES:
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.ac $(ACLOCAL_M4) 
+	cd $(top_srcdir) && $(AUTOMAKE) --gnu --include-deps cursors/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+tags: TAGS
+TAGS:
+
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = cursors
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  if test -d $$d/$$file; then \
+	    cp -pr $$d/$$file $(distdir)/$$file; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	    || cp -p $$d/$$file $(distdir)/$$file || :; \
+	  fi; \
+	done
+info-am:
+info: info-am
+dvi-am:
+dvi: dvi-am
+check-am: all-am
+check: check-am
+installcheck-am:
+installcheck: installcheck-am
+install-exec-am:
+install-exec: install-exec-am
+
+install-data-am: install-data-local
+install-data: install-data-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+install: install-am
+uninstall-am:
+uninstall: uninstall-am
+all-am: Makefile
+all-redirect: all-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install
+installdirs:
+
+
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+
+maintainer-clean-generic:
+mostlyclean-am:  mostlyclean-generic
+
+mostlyclean: mostlyclean-am
+
+clean-am:  clean-generic mostlyclean-am
+
+clean: clean-am
+
+distclean-am:  distclean-generic clean-am
+
+distclean: distclean-am
+
+maintainer-clean-am:  maintainer-clean-generic distclean-am
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+maintainer-clean: maintainer-clean-am
+
+.PHONY: tags distdir info-am info dvi-am dvi check check-am \
+installcheck-am installcheck install-exec-am install-exec \
+install-data-local install-data-am install-data install-am install \
+uninstall-am uninstall all-redirect all-am all installdirs \
+mostlyclean-generic distclean-generic clean-generic \
+maintainer-clean-generic clean mostlyclean distclean maintainer-clean
+
+
+install-data-local:
+	$(mkinstalldirs) $(DESTDIR)$(CURSOR_DIR); 
+	$(INSTALL_DATA) $(CURSOR_REAL) $(DESTDIR)$(CURSOR_DIR)/ 
+	for CURSOR in $(CURSOR_NAMES); do \
+		echo '-- Installing cursor '$$CURSOR; \
+		ln -s $(DESTDIR)$(CURSOR_DIR)/transp $(DESTDIR)$(CURSOR_DIR)/$$CURSOR; \
+	done
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --speed-large-files --minimal -Nru tmp/xcursor-transparent-theme-0.1.1/cursors/Makefile.am work/main.d/xcursor-transparent-theme-0.1.1/cursors/Makefile.am
--- tmp/xcursor-transparent-theme-0.1.1/cursors/Makefile.am	2003-10-30 09:13:59.000000000 -0300
+++ work/main.d/xcursor-transparent-theme-0.1.1/cursors/Makefile.am	2007-01-24 20:06:12.000000000 -0300
@@ -91,6 +91,6 @@
 	$(INSTALL_DATA) $(CURSOR_REAL) $(DESTDIR)$(CURSOR_DIR)/ 
 	for CURSOR in $(CURSOR_NAMES); do \
 		echo '-- Installing cursor '$$CURSOR; \
-		ln -s $(DESTDIR)$(CURSOR_DIR)/transp $(DESTDIR)$(CURSOR_DIR)/$$CURSOR; \
+		ln -s transp $(DESTDIR)$(CURSOR_DIR)/$$CURSOR; \
 	done
 
diff --speed-large-files --minimal -Nru tmp/xcursor-transparent-theme-0.1.1/cursors/Makefile.am~ work/main.d/xcursor-transparent-theme-0.1.1/cursors/Makefile.am~
--- tmp/xcursor-transparent-theme-0.1.1/cursors/Makefile.am~	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/xcursor-transparent-theme-0.1.1/cursors/Makefile.am~	2003-10-30 09:13:59.000000000 -0300
@@ -0,0 +1,96 @@
+CURSOR_NAMES = \
+	00008160000006810000408080010102 \
+	028006030e0e7ebffc7f7070c0600140 \
+	03b6e0fcb3499374a867c041f52298f0 \
+	08e8e1c95fe2fc01f976f1e063a24ccd \
+	14fef782d02440884392942c11205230 \
+	2870a09082c103050810ffdffffe0204 \
+	3ecb610c1bf2410f44200f48c40d3599 \
+	4498f0e0c1937ffe01fd06f973665830 \
+	9d800788f1b08800ae810202380a0822 \
+	c7088f0f3e6c8088236ef8e1e3e70000 \
+	d9ce0ab605698f320427677b458ad60b \
+	e29285e634086352946a0e7090d73106 \
+	fcf1c3c7cd4491d801f1e1c78f100000 \
+	X_cursor \
+	arrow \
+	base_arrow_down \
+	base_arrow_up \
+	based_arrow_down \
+	based_arrow_up \
+	bd_double_arrow \
+	boat \
+	bottom_left_corner \
+	bottom_right_corner \
+	bottom_side \
+	bottom_tee \
+	center_ptr \
+	circle \
+	cross \
+	cross_reverse \
+	crossed_circle \
+	crosshair \
+	dot \
+	dot_box_mask \
+	dotbox \
+	double_arrow \
+	draft_large  \
+	draft_small  \
+	draped_box   \
+	exchange     \
+	fd_double_arrow \
+	fleur \
+	gumby \
+	h_double_arrow \
+	hand \
+	hand1 \
+	hand2 \
+	left_ptr \
+	left_ptr_watch \
+	left_side \
+	left_tee  \
+	ll_angle  \
+	lr_angle  \
+	move      \
+	pencil    \
+	pirate    \
+	plus      \
+	question_arrow \
+	right_ptr      \
+	right_side     \
+	right_tee      \
+	sailboat       \
+	sb_down_arrow  \
+	sb_h_double_arrow \
+	sb_left_arrow \
+	sb_right_arrow \
+	sb_up_arrow \
+	sb_v_double_arrow \
+	shuttle \
+	sizing  \
+	target  \
+	tcross  \
+	top_left_arrow  \
+	top_left_corner \
+	top_right_corner \
+	top_side \
+	top_tee \
+	trek \
+	ul_angle \
+	ur_angle \
+	v_double_arrow \
+	watcha \
+	xterm  
+
+CURSOR_DIR = $(datadir)/icons/xcursor-transparent/cursors
+CURSOR_REAL = transp
+EXTRA_DIST = $(CURSOR_REAL)
+
+install-data-local:
+	$(mkinstalldirs) $(DESTDIR)$(CURSOR_DIR); 
+	$(INSTALL_DATA) $(CURSOR_REAL) $(DESTDIR)$(CURSOR_DIR)/ 
+	for CURSOR in $(CURSOR_NAMES); do \
+		echo '-- Installing cursor '$$CURSOR; \
+		ln -s $(DESTDIR)$(CURSOR_DIR)/transp $(DESTDIR)$(CURSOR_DIR)/$$CURSOR; \
+	done
+
diff --speed-large-files --minimal -Nru tmp/xcursor-transparent-theme-0.1.1/Makefile work/main.d/xcursor-transparent-theme-0.1.1/Makefile
--- tmp/xcursor-transparent-theme-0.1.1/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/xcursor-transparent-theme-0.1.1/Makefile	2007-01-24 20:00:50.000000000 -0300
@@ -0,0 +1,357 @@
+# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am
+
+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+SHELL = /bin/sh
+
+srcdir = .
+top_srcdir = .
+
+prefix = //usr
+exec_prefix = //usr
+
+bindir = //usr/bin
+sbindir = //usr/sbin
+libexecdir = //usr/libexec
+datadir = //usr/share
+sysconfdir = //etc
+sharedstatedir = //usr/share
+localstatedir = //var
+libdir = //usr/lib
+infodir = //usr/info
+mandir = //usr/share/man
+includedir = //usr/include
+oldincludedir = /usr/include
+
+DESTDIR =
+
+pkgdatadir = $(datadir)/xcursor-transparent-theme
+pkglibdir = $(libdir)/xcursor-transparent-theme
+pkgincludedir = $(includedir)/xcursor-transparent-theme
+
+top_builddir = .
+
+ACLOCAL = /media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing aclocal-1.4
+AUTOCONF = autoconf
+AUTOMAKE = /media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing automake-1.4
+AUTOHEADER = autoheader
+
+INSTALL = //media/gar-castorbox/images/build/usr/bin/install -c
+INSTALL_PROGRAM = ${INSTALL} $(AM_INSTALL_PROGRAM_FLAGS)
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_SCRIPT = ${INSTALL}
+transform = s,x,x,
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_alias = i586-castorbox-linux-gnu
+host_triplet = @host@
+CC = @CC@
+HAVE_LIB = @HAVE_LIB@
+LIB = @LIB@
+LTLIB = @LTLIB@
+MAKEINFO = /media/gar-castorbox/script/X11/xcursor-transparent/work/main.d/xcursor-transparent-theme-0.1.1/missing makeinfo
+PACKAGE = xcursor-transparent-theme
+VERSION = 0.1.1
+
+SUBDIRS = cursors
+EXTRA_DIST = .autoipkg 
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES = 
+DIST_COMMON =  README ./stamp-h.in AUTHORS COPYING ChangeLog INSTALL \
+Makefile.am Makefile.in NEWS TODO aclocal.m4 config.guess config.h.in \
+config.sub configure configure.ac install-sh ltmain.sh missing \
+mkinstalldirs
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP_ENV = --best
+all: all-redirect
+.SUFFIXES:
+$(srcdir)/Makefile.in: Makefile.am $(top_srcdir)/configure.ac $(ACLOCAL_M4) 
+	cd $(top_srcdir) && $(AUTOMAKE) --gnu --include-deps Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+$(ACLOCAL_M4):  configure.ac 
+	cd $(srcdir) && $(ACLOCAL)
+
+config.status: $(srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+$(srcdir)/configure: $(srcdir)/configure.ac $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)
+	cd $(srcdir) && $(AUTOCONF)
+
+config.h: stamp-h
+	@if test ! -f $@; then \
+		rm -f stamp-h; \
+		$(MAKE) stamp-h; \
+	else :; fi
+stamp-h: $(srcdir)/config.h.in $(top_builddir)/config.status
+	cd $(top_builddir) \
+	  && CONFIG_FILES= CONFIG_HEADERS=config.h \
+	     $(SHELL) ./config.status
+	@echo timestamp > stamp-h 2> /dev/null
+$(srcdir)/config.h.in: $(srcdir)/stamp-h.in
+	@if test ! -f $@; then \
+		rm -f $(srcdir)/stamp-h.in; \
+		$(MAKE) $(srcdir)/stamp-h.in; \
+	else :; fi
+$(srcdir)/stamp-h.in: $(top_srcdir)/configure.ac $(ACLOCAL_M4) 
+	cd $(top_srcdir) && $(AUTOHEADER)
+	@echo timestamp > $(srcdir)/stamp-h.in 2> /dev/null
+
+mostlyclean-hdr:
+
+clean-hdr:
+
+distclean-hdr:
+	-rm -f config.h
+
+maintainer-clean-hdr:
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+
+
+
+all-recursive install-data-recursive install-exec-recursive \
+installdirs-recursive install-recursive uninstall-recursive  \
+check-recursive installcheck-recursive info-recursive dvi-recursive:
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	dot_seen=no; \
+	rev=''; list='$(SUBDIRS)'; for subdir in $$list; do \
+	  rev="$$subdir $$rev"; \
+	  test "$$subdir" != "." || dot_seen=yes; \
+	done; \
+	test "$$dot_seen" = "no" && rev=". $$rev"; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	here=`pwd` && cd $(srcdir) \
+	  && mkid -f$$here/ID $$unique $(LISP)
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+   if test "$$subdir" = .; then :; else \
+	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
+   fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)config.h.in$$unique$(LISP)$$tags" \
+	  || (cd $(srcdir) && etags -o $$here/TAGS $(ETAGS_ARGS) $$tags config.h.in $$unique $(LISP))
+
+mostlyclean-tags:
+
+clean-tags:
+
+distclean-tags:
+	-rm -f TAGS ID
+
+maintainer-clean-tags:
+
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	-rm -rf $(distdir)
+	GZIP=$(GZIP_ENV) $(TAR) zxf $(distdir).tar.gz
+	mkdir $(distdir)/=build
+	mkdir $(distdir)/=inst
+	dc_install_base=`cd $(distdir)/=inst && pwd`; \
+	cd $(distdir)/=build \
+	  && ../configure --srcdir=.. --prefix=$$dc_install_base \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist
+	-rm -rf $(distdir)
+	@banner="$(distdir).tar.gz is ready for distribution"; \
+	dashes=`echo "$$banner" | sed s/./=/g`; \
+	echo "$$dashes"; \
+	echo "$$banner"; \
+	echo "$$dashes"
+dist: distdir
+	-chmod -R a+r $(distdir)
+	GZIP=$(GZIP_ENV) $(TAR) chozf $(distdir).tar.gz $(distdir)
+	-rm -rf $(distdir)
+dist-all: distdir
+	-chmod -R a+r $(distdir)
+	GZIP=$(GZIP_ENV) $(TAR) chozf $(distdir).tar.gz $(distdir)
+	-rm -rf $(distdir)
+distdir: $(DISTFILES)
+	-rm -rf $(distdir)
+	mkdir $(distdir)
+	-chmod 777 $(distdir)
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  if test -d $$d/$$file; then \
+	    cp -pr $$d/$$file $(distdir)/$$file; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	    || cp -p $$d/$$file $(distdir)/$$file || :; \
+	  fi; \
+	done
+	for subdir in $(SUBDIRS); do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d $(distdir)/$$subdir \
+	    || mkdir $(distdir)/$$subdir \
+	    || exit 1; \
+	    chmod 777 $(distdir)/$$subdir; \
+	    (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=../$(distdir) distdir=../$(distdir)/$$subdir distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+info-am:
+info: info-recursive
+dvi-am:
+dvi: dvi-recursive
+check-am: all-am
+check: check-recursive
+installcheck-am:
+installcheck: installcheck-recursive
+all-recursive-am: config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-recursive
+
+install-exec-am:
+install-exec: install-exec-recursive
+
+install-data-am:
+install-data: install-data-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+install: install-recursive
+uninstall-am:
+uninstall: uninstall-recursive
+all-am: Makefile config.h
+all-redirect: all-recursive-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install
+installdirs: installdirs-recursive
+installdirs-am:
+
+
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+
+maintainer-clean-generic:
+mostlyclean-am:  mostlyclean-hdr mostlyclean-tags mostlyclean-generic
+
+mostlyclean: mostlyclean-recursive
+
+clean-am:  clean-hdr clean-tags clean-generic mostlyclean-am
+
+clean: clean-recursive
+
+distclean-am:  distclean-hdr distclean-tags distclean-generic clean-am
+
+distclean: distclean-recursive
+	-rm -f config.status
+
+maintainer-clean-am:  maintainer-clean-hdr maintainer-clean-tags \
+		maintainer-clean-generic distclean-am
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f config.status
+
+.PHONY: mostlyclean-hdr distclean-hdr clean-hdr maintainer-clean-hdr \
+install-data-recursive uninstall-data-recursive install-exec-recursive \
+uninstall-exec-recursive installdirs-recursive uninstalldirs-recursive \
+all-recursive check-recursive installcheck-recursive info-recursive \
+dvi-recursive mostlyclean-recursive distclean-recursive clean-recursive \
+maintainer-clean-recursive tags tags-recursive mostlyclean-tags \
+distclean-tags clean-tags maintainer-clean-tags distdir info-am info \
+dvi-am dvi check check-am installcheck-am installcheck all-recursive-am \
+install-exec-am install-exec install-data-am install-data install-am \
+install uninstall-am uninstall all-redirect all-am all installdirs-am \
+installdirs mostlyclean-generic distclean-generic clean-generic \
+maintainer-clean-generic clean mostlyclean distclean maintainer-clean
+
+
+ipkg:
+	autoipkg
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --speed-large-files --minimal -Nru tmp/xcursor-transparent-theme-0.1.1/stamp-h work/main.d/xcursor-transparent-theme-0.1.1/stamp-h
--- tmp/xcursor-transparent-theme-0.1.1/stamp-h	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/xcursor-transparent-theme-0.1.1/stamp-h	2007-01-24 20:00:50.000000000 -0300
@@ -0,0 +1 @@
+timestamp
