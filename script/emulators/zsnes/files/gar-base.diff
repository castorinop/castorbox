diff --speed-large-files --minimal -Nru tmp/zsnes_1_51/src/initc.c work/main.d/zsnes_1_51/src/initc.c
--- tmp/zsnes_1_51/src/initc.c	2007-01-19 21:02:24.000000000 -0300
+++ work/main.d/zsnes_1_51/src/initc.c	2007-03-03 14:31:11.000000000 -0300
@@ -1035,6 +1035,7 @@
   }
 }
 
+char *cfgpath = 0;
 char *STCart2 = 0;
 unsigned char *sram2;
 extern unsigned char *sram;
diff --speed-large-files --minimal -Nru tmp/zsnes_1_51/src/initc.c~ work/main.d/zsnes_1_51/src/initc.c~
--- tmp/zsnes_1_51/src/initc.c~	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/zsnes_1_51/src/initc.c~	2007-01-19 21:02:24.000000000 -0300
@@ -0,0 +1,2886 @@
+/*
+Copyright (C) 1997-2007 ZSNES Team ( zsKnight, _Demo_, pagefault, Nach )
+
+http://www.zsnes.com
+http://sourceforge.net/projects/zsnes
+https://zsnes.bountysource.com
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+version 2 as published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+
+#ifdef __UNIXSDL__
+#include "gblhdr.h"
+#include "linux/audio.h"
+#define DIR_SLASH "/"
+#else
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/stat.h>
+#define DIR_SLASH "\\"
+#endif
+#include "asm_call.h"
+#include "cfg.h"
+#include "input.h"
+#include "zpath.h"
+#include "cpu/memtable.h"
+
+#define NUMCONV_FR4
+#include "numconv.h"
+
+#ifndef __GNUC__
+#define strcasecmp stricmp
+#define strncasecmp strnicmp
+#endif
+
+//C++ style code in C
+#define bool unsigned char
+#define true 1
+#define false 0
+
+//NSRT Goodness
+#define Lo 0x7FC0
+#define Hi 0xFFC0
+#define EHi 0x40FFC0
+
+#define MB_bytes 0x100000
+#define Mbit_bytes 0x20000
+
+//Offsets to add to infoloc start to reach particular variable
+#define BankOffset       21 //Contains Speed as well
+#define TypeOffset       22
+#define ROMSizeOffset    23
+#define SRAMSizeOffset   24
+#define CountryOffset    25
+#define CompanyOffset    26
+#define VersionOffset    27
+#define InvCSLowOffset   28
+#define InvCSHiOffset    29
+#define CSLowOffset      30
+#define CSHiOffset       31
+//Additional defines for the BS header
+#define BSYearOffset     21 //Not sure how to calculate year yet
+#define BSMonthOffset    22
+#define BSDayOffset      23
+#define BSBankOffset     24
+#define BSSizeOffset     25 //Contains Type as well
+//26 - 31 is the same
+#define ResetLoOffset    60
+#define ResetHiOffset    61
+
+
+// Some archaic code from an unfinished Dynarec
+extern unsigned int curexecstate;
+extern unsigned char spcon;
+
+void procexecloop()
+{
+  curexecstate &= 0xFFFFFF00;
+
+  if (spcon)  { curexecstate += 3; }
+  else  { curexecstate += 1; }
+}
+
+void Debug_WriteString(char *str)
+{
+  FILE *fp = 0;
+  fp = fopen_dir(ZCfgPath, "zsnes.dbg", "w");
+  if (!fp) { return; }
+  fputs(str, fp);
+  fclose(fp);
+}
+
+//I want to port over the more complicated
+//functions from init.asm, or replace with
+//better versions from NSRT. -Nach
+
+//init.asm goodness
+extern unsigned int NumofBanks;
+extern unsigned int NumofBytes;
+extern unsigned int *romdata;
+extern unsigned char romtype;
+extern unsigned char Interleaved;
+
+unsigned int maxromspace;
+unsigned int curromspace;
+unsigned int infoloc;
+unsigned int ramsize;
+unsigned int ramsizeand;
+
+bool SplittedROM;
+unsigned int addOnStart;
+unsigned int addOnSize;
+
+
+//Deinterleave functions
+bool validChecksum(unsigned char *ROM, int BankLoc)
+{
+  if (ROM[BankLoc + InvCSLowOffset] + (ROM[BankLoc + InvCSHiOffset] << 8) +
+      ROM[BankLoc + CSLowOffset] + (ROM[BankLoc + CSHiOffset] << 8) == 0xFFFF)
+  {
+    return(true);
+  }
+  return(false);
+}
+
+bool valid_normal_bank(unsigned char bankbyte)
+{
+  switch (bankbyte)
+  {
+    case 32: case 33: case 48: case 49:
+    return(true);
+    break;
+  }
+  return(false);
+}
+
+bool EHiHeader(unsigned char *ROM, int BankLoc)
+{
+  if (validChecksum(ROM, BankLoc) && (ROM[BankLoc+BankOffset] == 53 || ROM[BankLoc+BankOffset] == 37))
+  {
+    return(true);
+  }
+  return(false);
+}
+
+void SwapData(unsigned int *loc1, unsigned int *loc2, unsigned int amount)
+{
+  unsigned int temp;
+  while (amount--)
+  {
+    temp = *loc1;
+    *loc1++ = *loc2;
+    *loc2++ = temp;
+  }
+}
+
+void swapBlocks(char *blocks)
+{
+  unsigned int i, j;
+  for (i = 0; i < NumofBanks; i++)
+  {
+    for (j = 0; j < NumofBanks; j++)
+    {
+      if (blocks[j] == (char)i)
+      {
+        char b;
+        SwapData(romdata + blocks[i]*0x2000, romdata + blocks[j]*0x2000, 0x2000);
+        b = blocks[j];
+        blocks[j] = blocks[i];
+        blocks[i] = b;
+        break;
+      }
+    }
+  }
+}
+
+void deintlv1()
+{
+  char blocks[256];
+  int i, numblocks = NumofBanks/2;
+  for (i = 0; i < numblocks; i++)
+  {
+    blocks[i * 2] = i + numblocks;
+    blocks[i * 2 + 1] = i;
+  }
+  swapBlocks(blocks);
+}
+
+void CheckIntl1(unsigned char *ROM)
+{
+  unsigned int ROMmidPoint = NumofBytes / 2;
+  if (validChecksum(ROM, ROMmidPoint + Lo) &&
+     !validChecksum(ROM, Lo) &&
+      ROM[ROMmidPoint+Lo+CountryOffset] < 14) //Country Code
+  {
+    deintlv1();
+    Interleaved = true;
+  }
+  else if (validChecksum(ROM, Lo) && !validChecksum(ROM, Hi) &&
+           ROM[Lo+CountryOffset] < 14 && //Country code
+           //Rom make up
+          (ROM[Lo+BankOffset] == 33 || ROM[Lo+BankOffset] == 49 ||
+           ROM[Lo+BankOffset] == 53 || ROM[Lo+BankOffset] == 58))
+  {
+    if (ROM[Lo+20] == 32 ||//Check that Header name did not overflow
+      !(ROM[Lo+BankOffset] == ROM[Lo+20] || ROM[Lo+BankOffset] == ROM[Lo+19] ||
+        ROM[Lo+BankOffset] == ROM[Lo+18] || ROM[Lo+BankOffset] == ROM[Lo+17]))
+    {
+      deintlv1();
+      Interleaved = true;
+    }
+  }
+}
+
+void CheckIntlEHi(unsigned char *ROM)
+{
+  if (EHiHeader(ROM, Lo))
+  {
+    unsigned int oldNumBanks = NumofBanks;
+
+    //Swap 4MB ROM with the other one
+    SwapData(romdata, romdata+((NumofBytes-0x400000)/4), 0x100000);
+
+    //Deinterleave the 4MB ROM first
+    NumofBanks = 128;
+    deintlv1();
+
+    //Now the other one
+    NumofBanks = oldNumBanks - 128;
+    romdata += 0x100000; //Ofset pointer
+    deintlv1();
+
+    //Now fix the data and we're done
+    NumofBanks = oldNumBanks;
+    romdata -= 0x100000;
+
+    Interleaved = true;
+  }
+}
+
+//ROM loading functions, which some strangly enough were in guiload.inc
+bool AllASCII(unsigned char *b, int size)
+{
+  int i;
+  for (i = 0; i < size; i++)
+  {
+    if (b[i] && (b[i] < 32 || b[i] > 126))
+    {
+      return(false);
+    }
+  }
+  return(true);
+}
+
+//Code to detect if opcode sequence is a valid and popular one for an SNES ROM
+//Code by Cowering
+static bool valid_start_sequence(unsigned char opcode1, unsigned char opcode2, unsigned char opcode3)
+{
+  switch (opcode1)
+  {
+    case 0x78: case 0x5c: case 0x18: case 0xad:
+      return(true);
+      break;
+    case 0x4b:
+      if (opcode2 == 0xab && (opcode3 == 0x18 || opcode3 == 0x20))
+      {
+        return(true);
+      }
+      break;
+    case 0x4c:
+      if ((opcode2 == 0x00 || opcode2 == 0xc0) && opcode3 == 0x84)
+      {
+        return(true);
+      }
+      if (opcode2 == 0x6d && opcode3 == 0x86)
+      {
+        return(true);
+      }
+      if (opcode2 == 0x00 && opcode3 == 0x80)
+      {
+        return(true);
+      }
+      break;
+    case 0xc2:
+      if (opcode2 == 0x30 && opcode3 == 0xa9)
+      {
+        return(true);
+      }
+      break;
+    case 0x20:
+      if ((opcode2 == 0x16 || opcode2 == 0x06) && opcode3 == 0x80)
+      {
+        return(true);
+      }
+      break;
+    case 0x80:
+      if ((opcode2 == 0x16 && opcode3 == 0x4c) ||
+          (opcode2 == 0x07 && opcode3 == 0x82))
+      {
+        return(true);
+      }
+      break;
+    case 0x9c:
+      if (opcode2 == 0x00 && opcode3 == 0x21)
+      {
+        return(true);
+      }
+      break;
+    case 0xa2:
+      if (opcode2 == 0xff && opcode3 == 0x86)
+      {
+        return(true);
+      }
+      break;
+    case 0xa9:
+      if ((opcode2 == 0x00 && (opcode3 = 0x48 || opcode3  == 0x4b)) ||
+          (opcode2 == 0x8f && opcode3 == 0x8d) ||
+          (opcode2 == 0x20 && opcode3 == 0x4b) ||
+          (opcode2 == 0x1f && opcode3 == 0x4b))
+      {
+        return(true);
+      }
+      break;
+  }
+  return(false);
+}
+
+static int valid_reset(unsigned char *Buffer)
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+  unsigned short Reset = Buffer[ResetLoOffset] | ((unsigned short)Buffer[ResetHiOffset] << 8);
+  if ((Reset != 0xFFFF) && (Reset & 0x8000))
+  {
+    unsigned char opcode1 = ROM[(Reset+0) & 0x7FFF];
+    unsigned char opcode2 = ROM[(Reset+1) & 0x7FFF];
+    unsigned char opcode3 = ROM[(Reset+2) & 0x7FFF];
+
+    if (valid_start_sequence(opcode1, opcode2, opcode3))
+    {
+      return(10);
+    }
+    return(2);
+  }
+  return(-4);
+}
+
+int InfoScore(unsigned char *Buffer)
+{
+  int score = valid_reset(Buffer);
+  if (validChecksum(Buffer, 0))                 { score += 5; }
+  if (Buffer[CompanyOffset] == 0x33)            { score += 3; }
+  if (!Buffer[ROMSizeOffset])                   { score += 2; }
+  if ((1 << (Buffer[ROMSizeOffset] - 7)) > 48)  { score -= 2; }
+  if ((8 << Buffer[SRAMSizeOffset]) > 1024)     { score -= 2; }
+  if (Buffer[CountryOffset] < 14)               { score += 2; }
+  if (!AllASCII(Buffer, 20))                    { score -= 2; }
+  if (valid_normal_bank(Buffer[BSBankOffset]))  { score += 2; }
+  return(score);
+}
+
+extern unsigned char ForceHiLoROM;
+extern unsigned char forceromtype;
+
+void BankCheck()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+  infoloc = 0;
+  Interleaved = false;
+
+  if (NumofBytes < Lo)
+  {
+    romtype = 1;
+    infoloc = 1; //Whatever, we just need a valid location
+  }
+
+  if (NumofBytes < Hi)
+  {
+    romtype = 1;
+    infoloc = Lo;
+  }
+
+  if (NumofBytes >= 0x500000)
+  {
+    //Deinterleave if neccesary
+    CheckIntlEHi(ROM);
+
+    if (EHiHeader(ROM, EHi))
+    {
+      romtype = 2;
+      infoloc = EHi;
+    }
+  }
+
+  if (!infoloc)
+  {
+    static bool CommandLineForce2 = false;
+    int loscore, hiscore;
+
+    //Deinterleave if neccesary
+    CheckIntl1(ROM);
+
+    loscore = InfoScore(ROM+Lo);
+    hiscore = InfoScore(ROM+Hi);
+
+    switch(ROM[Lo + BankOffset])
+    {
+      case 32: case 35: case 48: case 50:
+        loscore += 3;
+        break;
+    }
+    switch(ROM[Hi + BankOffset])
+    {
+      case 33: case 49: case 53: case 58:
+        hiscore += 3;
+        break;
+    }
+
+    /*
+    Force code.
+    ForceHiLoROM is from the GUI.
+    forceromtype is from Command line, we have a static var
+    to prevent forcing a secong game loaded from the GUI when
+    the first was loaded from the command line with forcing.
+    */
+    if (ForceHiLoROM == 1 ||
+        (forceromtype == 1 && !CommandLineForce2))
+    {
+      CommandLineForce2 = true;
+      loscore += 50;
+    }
+    else if (ForceHiLoROM == 2 ||
+             (forceromtype == 2 && !CommandLineForce2))
+    {
+      CommandLineForce2 = true;
+      hiscore += 50;
+    }
+
+    if (hiscore > loscore)
+    {
+      romtype = 2;
+      infoloc = Hi;
+    }
+    else
+    {
+      romtype = 1;
+      infoloc = Lo;
+    }
+  }
+}
+
+//Chip detection functions
+bool CHIPBATT, BSEnable, C4Enable, DSP1Enable, DSP2Enable, DSP3Enable;
+bool DSP4Enable, OBCEnable, RTCEnable, SA1Enable, SDD1Enable, SFXEnable;
+bool SETAEnable; //ST010 & 11
+bool SGBEnable, SPC7110Enable, ST18Enable;
+
+void chip_detect()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+
+  C4Enable = RTCEnable = SA1Enable = SDD1Enable = OBCEnable = CHIPBATT = false;
+  SGBEnable = ST18Enable = DSP1Enable = DSP2Enable = DSP3Enable = false;
+  DSP4Enable = SPC7110Enable = BSEnable = SFXEnable = SETAEnable = false;
+
+  //DSP Family
+  if (ROM[infoloc+TypeOffset] == 3)
+  {
+    if (ROM[infoloc+BankOffset] == 48) { DSP4Enable = true; }
+    else { DSP1Enable = true; }
+    return;
+  }
+
+  if (ROM[infoloc+TypeOffset] == 5)
+  {
+    CHIPBATT = true;
+    if (ROM[infoloc+BankOffset] == 32) { DSP2Enable = true; }
+    else if (ROM[infoloc+BankOffset] == 48 && ROM[infoloc+CompanyOffset] == 0xB2) //Bandai
+    { DSP3Enable = true; }
+    else { DSP1Enable = true; }
+    return;
+  }
+
+  switch((unsigned short)ROM[infoloc+BankOffset] | (ROM[infoloc+TypeOffset] << 8))
+  {
+    case 0x1320:                             //Mario Chip 1
+    case 0x1420:                             //GSU-x
+      SFXEnable = true;
+      return;
+      break;
+
+    case 0x1520:                            //GSU-x + Battery
+    case 0x1A20:                            //GSU-1 + Battery + Start in 21MHz
+      SFXEnable = true;
+      CHIPBATT = true;
+      return;
+      break;
+
+    case 0x2530:
+      OBCEnable = true;
+      CHIPBATT = true;
+      return;
+      break;
+
+    case 0x3423:
+      SA1Enable = true;
+      return;
+      break;
+
+    case 0x3223: //One sample game seems to use this for some reason
+    case 0x3523:
+      SA1Enable = true;
+      CHIPBATT = true;
+      return;
+      break;
+
+    case 0x4332:
+      SDD1Enable = true;
+      return;
+      break;
+
+    case 0x4532:
+      SDD1Enable = true;
+      CHIPBATT = true;
+      return;
+      break;
+
+    case 0x5535:
+      RTCEnable = true;
+      CHIPBATT = true;
+      return;
+      break;
+
+    case 0xE320:
+      SGBEnable = true;
+      return;
+      break;
+
+    case 0xF320:
+      C4Enable = true;
+      return;
+      break;
+
+    case 0xF530:
+      ST18Enable = true;
+      CHIPBATT = true; //Check later if this should be removed
+      return;
+      break;
+
+    case 0xF53A:
+      SPC7110Enable = true;
+      CHIPBATT = true;
+      return;
+      break;
+
+    case 0xF630:
+      SETAEnable = true;
+      CHIPBATT = true;
+      return;
+      break;
+
+    case 0xF93A:
+      SPC7110Enable = true;
+      RTCEnable = true;
+      CHIPBATT = true;
+      return;
+      break;
+  }
+
+  //BS Dump
+  if ((ROM[infoloc+CompanyOffset] == 0x33 || ROM[infoloc+CompanyOffset] == 0xFF) &&
+      (!ROM[infoloc+BSYearOffset] || (ROM[infoloc+BSYearOffset] & 131) == 128) &&
+      valid_normal_bank(ROM[infoloc+BSBankOffset]))
+  {
+    unsigned char m = ROM[infoloc+BSMonthOffset];
+    if (!m && !ROM[infoloc+BSDayOffset])
+    {
+      //BS Add-on cart
+      return;
+    }
+    if ((m == 0xFF && ROM[infoloc+BSDayOffset] == 0xFF) ||
+        (!(m & 0xF) && ((m >> 4) - 1 < 12)))
+    {
+      BSEnable = true;
+      return;
+    }
+  }
+}
+
+//Checksum functions
+unsigned short sum(unsigned char *array, unsigned int size)
+{
+  unsigned short theSum = 0;
+  unsigned int i;
+
+  //Prevent crashing by reading too far (needed for messed up ROMs)
+  if (array + size > (unsigned char *)romdata + maxromspace)
+  {
+    return(0xFFFF);
+  }
+
+  for (i = 0; i < size; i++)
+  {
+    theSum += array[i];
+  }
+  return(theSum);
+}
+
+static unsigned short Checksumvalue;
+void CalcChecksum()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+
+  if (SplittedROM)
+  {
+    Checksumvalue = sum(ROM+addOnStart, addOnSize);
+    Checksumvalue -= sum(ROM+infoloc+addOnStart-16, 48);
+  }
+  else if (SPC7110Enable)
+  {
+    Checksumvalue = sum(ROM, curromspace);
+  }
+  else
+  {
+    Checksumvalue = sum(ROM, curromspace);
+    if (NumofBanks > 128 && maxromspace == 6*MB_bytes)
+    {
+      Checksumvalue += sum(ROM+4*MB_bytes, 2*MB_bytes);
+    }
+    if (BSEnable)
+    {
+      Checksumvalue -= sum(&ROM[infoloc - 16], 48); //Fix for BS Dumps
+    }
+  }
+}
+
+static void rom_memcpy(unsigned char *dest, unsigned char *src, size_t len)
+{
+  unsigned char *endrom = (unsigned char *)romdata+maxromspace;
+  while (len-- && (dest < endrom) && (src < endrom))
+  {
+    *dest++ = *src++;
+  }
+}
+
+//This will mirror up non power of two ROMs to powers of two
+static unsigned int mirror_rom(unsigned char *start, unsigned int length)
+{
+  unsigned int mask = 0x800000;
+  while (!(length & mask)) { mask >>= 1; }
+
+  length -= mask;
+  if (length)
+  {
+    start += mask;
+    length = mirror_rom(start, length);
+
+    while (length != mask)
+    {
+      rom_memcpy(start+length, start, length);
+      length += length;
+    }
+  }
+
+  return(length+mask);
+}
+
+//Misc functions
+void MirrorROM(unsigned char *ROM)
+{
+  unsigned int ROMSize, StartMirror = 0;
+  if (!SPC7110Enable)
+  {
+    curromspace = mirror_rom((unsigned char *)romdata, curromspace);
+  }
+  else if (curromspace == 0x300000)
+  {
+    memcpy((unsigned char *)romdata+curromspace, romdata, curromspace);
+    curromspace += curromspace;
+  }
+
+  if (curromspace > maxromspace)
+  {
+    curromspace = maxromspace;
+  }
+  NumofBanks = curromspace >> 15;
+
+  //This will mirror (now) full sized ROMs through the ROM buffer
+  ROMSize = curromspace;
+  while (ROMSize < maxromspace)
+  {
+    ROM[ROMSize++] = ROM[StartMirror++];
+  }
+
+  //If ROM was too small before, but now decent size with mirroring, adjust location
+  if (infoloc < Lo)
+  {
+    infoloc = Lo;
+  }
+}
+
+
+void SetupSramSize()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+  if (BSEnable)
+  {
+    ramsize = 0;
+  }
+  else if (SFXEnable)
+  {
+    if (ROM[infoloc+CompanyOffset] == 0x33) //Extended header
+    {
+      ramsize = 8 << ((unsigned int)ROM[infoloc-3]);
+    }
+    else
+    {
+      ramsize = 256;
+    }
+  }
+  else if (SETAEnable)
+  {
+    ramsize = 32;
+  }
+  else if (!strncmp((char *)ROM, "BANDAI SFC-ADX", 14))
+  {  // For the Sufami Turbo
+    ramsize = 8 << ((unsigned int)ROM[0x100032]);
+  }
+  else
+  {
+    ramsize = ((ROM[infoloc+SRAMSizeOffset]) ? (8 << ((unsigned int)ROM[infoloc+SRAMSizeOffset])) : 0);
+  }
+
+  //Fix if some ROM goes nuts on size
+  if (ramsize > 1024)
+  {
+    ramsize = 1024;
+  }
+
+  //Convert from Kb to bytes;
+  ramsize *= 128;
+  ramsizeand = ramsize-1;
+}
+
+//File loading code
+bool Header512;
+
+char CSStatus[41], CSStatus2[41], CSStatus3[41], CSStatus4[41];
+
+void DumpROMLoadInfo()
+{
+  FILE *fp = 0;
+
+  if (RomInfo) //rominfo.txt info dumping enabled?
+  {
+    fp = fopen_dir(ZCfgPath, "rominfo.txt", "w");
+    if (!fp) { return; }
+    fputs("This is the info for the last game you ran.\n\nFile: ", fp);
+    fputs(ZCartName, fp);
+    fputs(" Header: ", fp);
+    fputs(Header512 ? "Yes\n" : "No\n", fp);
+    fputs(CSStatus, fp);
+    fputs("\n", fp);
+    fputs(CSStatus2, fp);
+    fputs("\n", fp);
+    fputs(CSStatus3, fp);
+    fputs("\n", fp);
+    fputs(CSStatus4, fp);
+    fputs("\n", fp);
+    fclose(fp);
+  }
+}
+
+void loadFile(char *filename)
+{
+  bool multifile = false;
+  char *incrementer = 0;
+  unsigned char *ROM = (unsigned char *)romdata;
+
+  if (strlen(filename) >= 3) //Char + ".1"
+  {
+    char *ext = filename+strlen(filename)-2;
+    if (!strcmp(ext, ".1") || !strcasecmp(ext, ".A"))
+    {
+      incrementer = ext + 1;
+      multifile = true;
+    }
+  }
+
+  for (;;)
+  {
+    struct stat stat_results;
+    stat_dir(ZRomPath, filename, &stat_results);
+
+    if ((unsigned int)stat_results.st_size <= maxromspace+512-curromspace)
+    {
+      FILE *fp = 0;
+      fp = fopen_dir(ZRomPath, filename, "rb");
+
+      if (!fp) { return; }
+
+      if (curromspace && ((stat_results.st_size & 0x7FFF) == 512))
+      {
+        stat_results.st_size -= 512;
+        fseek(fp, 512, SEEK_SET);
+      }
+
+      fread(ROM+curromspace, stat_results.st_size, 1, fp);
+      fclose(fp);
+
+      curromspace += stat_results.st_size;
+
+      if (!multifile) { return; }
+
+      (*incrementer)++;
+    }
+    else
+    {
+      return;
+    }
+  }
+}
+
+void loadGZipFile(char *filename)
+{
+  //Open file for size reading
+  FILE *fp = fopen_dir(ZRomPath, filename, "rb");
+  if (fp)
+  {
+    int fsize, gzsize;
+    gzFile GZipFile;
+
+    fseek(fp, -4, SEEK_END);
+    gzsize = fread4(fp);
+    fsize = ftell(fp);
+    rewind(fp);
+
+    //Open GZip file for decompression, use existing file handle
+    if ((GZipFile = gzdopen(fileno(fp), "rb")))
+    {
+      int len = gzdirect(GZipFile) ? fsize : gzsize;
+      if (len && ((unsigned int)len <= maxromspace+512) && (gzread(GZipFile, romdata, len) == len))
+      {
+        curromspace = len; //Success
+      }
+      gzclose(GZipFile);
+    }
+    fclose(fp);
+  }
+}
+
+void loadZipFile(char *filename)
+{
+  int err, fileSize;
+  unsigned char *ROM = (unsigned char *)romdata;
+  bool multifile = false, NSS = false;
+  char *incrementer = 0;
+
+  unzFile zipfile = unzopen_dir(ZRomPath, filename); //Open zip file
+  int cFile = unzGoToFirstFile(zipfile); //Set cFile to first compressed file
+  unz_file_info cFileInfo; //Create variable to hold info for a compressed file
+
+  int LargestGoodFile = 0; //To keep track of largest file
+
+  //Variables for the file we pick
+  char ourFile[256];
+  ourFile[0] = '\n';
+
+  while(cFile == UNZ_OK) //While not at end of compressed file list
+  {
+    //Temporary char array for file name
+    char cFileName[256];
+
+    //Gets info on current file, and places it in cFileInfo
+    unzGetCurrentFileInfo(zipfile, &cFileInfo, cFileName, 256, NULL, 0, NULL, 0);
+
+    //Get the file's size
+    fileSize = cFileInfo.uncompressed_size;
+
+    //Find split files
+    if (strlen(cFileName) >= 3) //Char + ".1"
+    {
+      char *ext = cFileName+strlen(cFileName)-2;
+      if (!strcmp(ext, ".1") || !strcasecmp(ext, ".A"))
+      {
+        strcpy(ourFile, cFileName);
+        incrementer = ourFile+strlen(ourFile)-1;
+        multifile = true;
+        break;
+      }
+    }
+
+    //Find Nintendo Super System ROMs
+    if (strlen(cFileName) >= 5) //Char + ".IC2"
+    {
+      char *ext = cFileName+strlen(cFileName)-4;
+      if (!strncasecmp(ext, ".IC", 3))
+      {
+        strcpy(ourFile, cFileName);
+        incrementer = ourFile+strlen(ourFile)-1;
+        *incrementer = '7';
+        NSS = true;
+        break;
+      }
+    }
+
+    //Check for valid ROM based on size
+    if (((unsigned int)fileSize <= maxromspace+512) &&
+        (fileSize > LargestGoodFile))
+    {
+      strcpy(ourFile, cFileName);
+      LargestGoodFile = fileSize;
+    }
+
+    //Go to next file in zip file
+    cFile = unzGoToNextFile(zipfile);
+  }
+
+  //No files found
+  if (ourFile[0] == '\n')
+  {
+    unzClose(zipfile);
+    return;
+  }
+
+  for (;;)
+  {
+    //Sets current file to the file we liked before
+    if (unzLocateFile(zipfile, ourFile, 1) != UNZ_OK)
+    {
+      if (NSS)
+      {
+        (*incrementer)--;
+        continue;
+      }
+      unzClose(zipfile);
+      return;
+    }
+
+    //Gets info on current file, and places it in cFileInfo
+    unzGetCurrentFileInfo(zipfile, &cFileInfo, ourFile, 256, NULL, 0, NULL, 0);
+
+    //Get the file's size
+    fileSize = cFileInfo.uncompressed_size;
+
+    //Too big?
+    if (curromspace + fileSize > maxromspace+512)
+    {
+      unzClose(zipfile);
+      return;
+    }
+
+    //Open file
+    unzOpenCurrentFile(zipfile);
+
+    //Read file into memory
+    err = unzReadCurrentFile(zipfile, ROM+curromspace, fileSize);
+
+    //Close file
+    unzCloseCurrentFile(zipfile);
+
+    //Encountered error?
+    if (err != fileSize)
+    {
+      unzClose(zipfile);
+      return;
+    }
+
+    if (curromspace && ((fileSize & 0x7FFF) == 512))
+    {
+      fileSize -= 512;
+      memmove(ROM+curromspace, ROM+curromspace+512, fileSize);
+    }
+
+    curromspace += fileSize;
+
+    if (NSS)
+    {
+      if (!*incrementer) { return; }
+      (*incrementer)--;
+      continue;
+    }
+
+    if (!multifile)
+    {
+      unzClose(zipfile);
+      return;
+    }
+    (*incrementer)++;
+  }
+}
+
+void load_file_fs(char *path)
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+
+  if (isextension(path, "jma"))
+  {
+    #ifdef NO_JMA
+    puts("This binary was built without JMA support.");
+    #else
+    load_jma_file_dir(ZRomPath, path);
+    #endif
+  }
+  if (isextension(path, "zip"))
+  {
+    loadZipFile(path);
+  }
+  if (isextension(path, "gz"))
+  {
+    loadGZipFile(path);
+  }
+  else
+  {
+    loadFile(path);
+  }
+
+  if ((curromspace & 0x7FFF) == 512)
+  {
+    memmove(ROM, ROM+512, addOnStart);
+    curromspace -= 512;
+  }
+}
+
+char *STCart2 = 0;
+unsigned char *sram2;
+extern unsigned char *sram;
+
+void SplitSetup(char *basepath, char *basefile, unsigned int MirrorSystem)
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+
+  curromspace = 0;
+  if (maxromspace < addOnStart+addOnSize) { return; }
+  memmove(ROM+addOnStart, ROM, addOnSize);
+
+  if (!*basepath)
+  {
+    load_file_fs(basefile);
+  }
+  else
+  {
+    load_file_fs(basepath);
+  }
+
+  if (!curromspace) { return; }
+
+  switch (MirrorSystem)
+  {
+    case 1:
+      memcpy(ROM+0x100000, ROM, 0x100000); //Mirror 8 to 16
+      break;
+
+    case 2:
+      memcpy(ROM+0x180000, ROM+0x100000, 0x80000); //Mirrors 12 to 16
+      memcpy(ROM+0x200000, ROM+0x400000, 0x80000); //Copy base over
+      memset(ROM+0x280000, 0, 0x180000);           //Blank out rest
+      break;
+
+    case 3:
+      memcpy(ROM+0x40000, ROM, 0x40000);
+      memcpy(ROM+0x80000, ROM, 0x80000);
+      break;
+  }
+
+  curromspace = addOnStart+addOnSize;
+  SplittedROM = true;
+}
+
+void SplitSupport()
+{
+  char *ROM = (char *)romdata;
+  SplittedROM = false;
+
+  //Same Game add on
+  if (curromspace == 0x80000 && ROM[Hi+CompanyOffset] == 0x33 &&
+      !ROM[Hi+BankOffset] && !ROM[Hi+BSMonthOffset] && !ROM[Hi+BSDayOffset])
+  {
+    addOnStart = 0x200000;
+    addOnSize = 0x80000;
+    SplitSetup(SGPath, "SAMEGAME.ZIP", 1);
+  }
+
+  //SD Gundam G-Next add on
+  if (curromspace == 0x80000 && ROM[Lo+CompanyOffset] == 0x33 &&
+      !ROM[Lo+BankOffset] && !ROM[Lo+BSMonthOffset] && !ROM[Lo+BSDayOffset] && !strncmp(ROM+Lo, "GNEXT", 5))
+  {
+    addOnStart = 0x400000;
+    addOnSize = 0x80000;
+    SplitSetup(GNextPath, "G-NEXT.ZIP", 2);
+    addOnStart = 0x200000; //Correct for checksum calc
+  }
+
+  //Sufami Turbo
+  if (!strncmp(ROM, "BANDAI SFC-ADX", 14))
+  {
+    if (!STCart2)
+    {
+      addOnStart = 0x100000;
+      addOnSize = curromspace;
+      SplitSetup(STPath, "STBIOS.ZIP", 3);
+    }
+    else if (maxromspace >= (curromspace<<2)+0x100000)
+    {
+      memcpy(ROM+curromspace+curromspace, ROM, curromspace);
+      memcpy(ROM+curromspace*3, ROM, curromspace);
+      curromspace = 0;
+      load_file_fs(STCart2);
+      memcpy(ROM+curromspace, ROM, curromspace);
+      SwapData(romdata, romdata+(curromspace>>1), curromspace>>1);
+      addOnSize = curromspace<<2;
+      addOnStart = 0x100000;
+      SplitSetup(STPath, "STBIOS.ZIP", 3);
+      addOnSize = (curromspace-addOnStart) >> 2; //Correct for checksum calc
+      sram2 = sram+65536;
+    }
+  }
+}
+
+bool NSRTHead(unsigned char *ROM)
+{
+  unsigned char *NSRTHead = ROM + 0x1D0; //NSRT Header Location
+
+  if (!strncmp("NSRT", (char*)&NSRTHead[24],4) && NSRTHead[28] == 22)
+  {
+    if ((sum(NSRTHead, 32) & 0xFF) != NSRTHead[30] ||
+        NSRTHead[30] + NSRTHead[31] !=  255 ||
+        (NSRTHead[0] & 0x0F) > 13 ||
+        ((NSRTHead[0] & 0xF0) >> 4) > 3 ||
+        ((NSRTHead[0] & 0xF0) >> 4) == 0)
+    {
+      return(false); //Corrupt
+    }
+    return(true); //NSRT header
+  }
+  return(false); //None
+}
+
+void calculate_state_sizes(), InitRewindVars(), zst_init();
+bool findZipIPS(char *, char *);
+extern bool EMUPause;
+extern unsigned char device1, device2;
+unsigned char lorommapmode2, curromsize, snesinputdefault1, snesinputdefault2;
+bool input1gp, input1mouse, input2gp, input2mouse, input2scope, input2just;
+
+void loadROM()
+{
+  bool isCompressed = false, isZip = false;
+
+  zst_init();
+
+  EMUPause = false;
+  curromspace = 0;
+
+  if (isextension(ZCartName, "jma"))
+  {
+    #ifdef NO_JMA
+    puts("This binary was built without JMA support.");
+    #else
+    isCompressed = true;
+    load_jma_file_dir(ZRomPath, ZCartName);
+    #endif
+  }
+  else if (isextension(ZCartName, "zip"))
+  {
+    isCompressed = true;
+    isZip = true;
+    loadZipFile(ZCartName);
+  }
+  else if (isextension(ZCartName, "gz"))
+  {
+    isCompressed = true;
+    loadGZipFile(ZCartName);
+  }
+
+  if (!isCompressed) { loadFile(ZCartName); }
+
+  Header512 = false;
+
+  if (!curromspace) { return; }
+
+  if (!strncmp("GAME DOCTOR SF 3", (char *)romdata, 16) ||
+      !strncmp("SUPERUFO", (char *)romdata+8, 8))
+  {
+    Header512 = true;
+  }
+  else
+  {
+    int HeadRemain = (curromspace & 0x7FFF);
+    switch(HeadRemain)
+    {
+      case 0:
+        break;
+
+      case 512:
+        Header512 = true;
+        break;
+
+      default:
+      {
+        unsigned char *ROM = (unsigned char *)romdata;
+
+        //SMC/SWC header
+        if (ROM[8] == 0xAA && ROM[9]==0xBB && ROM[10]== 4)
+        {
+          Header512 = true;
+        }
+        //FIG header
+        else if ((ROM[4] == 0x77 && ROM[5] == 0x83) ||
+                 (ROM[4] == 0xDD && ROM[5] == 0x82) ||
+                 (ROM[4] == 0xDD && ROM[5] == 2) ||
+                 (ROM[4] == 0xF7 && ROM[5] == 0x83) ||
+                 (ROM[4] == 0xFD && ROM[5] == 0x82) ||
+                 (ROM[4] == 0x00 && ROM[5] == 0x80) ||
+                 (ROM[4] == 0x47 && ROM[5] == 0x83) ||
+                 (ROM[4] == 0x11 && ROM[5] == 2))
+        {
+          Header512 = true;
+        }
+        break;
+      }
+    }
+  }
+
+  device1 = 0;
+  device2 = 0;
+  input1gp = true;
+  input1mouse = true;
+  input2gp = true;
+  input2mouse = true;
+  input2scope = true;
+  input2just = true;
+
+  if (Header512)
+  {
+    unsigned char *ROM = (unsigned char *)romdata;
+    if (NSRTHead(ROM))
+    {
+      switch (ROM[0x1ED] & 0xF0) //Port 1
+      {
+        case 0x00: //Gamepad
+          input1mouse = false;
+          break;
+
+        case 0x10: //Mouse port 1
+          device1 = 1;
+          input1gp = false;
+          break;
+
+        case 0x20: //Mouse or Gamepad port 1
+          device1 = 1;
+          break;
+
+        case 0x90: //Lasabirdie - not yet supported
+          input1gp = false;
+          input1mouse = false;
+          break;
+      }
+
+      switch (ROM[0x1ED] & 0x0F) //Port 1
+      {
+        case 0x00: //Gamepad
+          input2mouse = false;
+          input2scope = false;
+          input2just = false;
+          break;
+
+        case 0x01: //Mouse port 2
+          device2 = 1;
+          input2gp = false;
+          input2scope = false;
+          input2just = false;
+          break;
+
+        case 0x02: //Mouse or Gamepad port 2
+          device1 = 2;
+          input2just = false;
+          input2scope = false;
+          break;
+
+        case 0x03: //Super Scope port 2
+          device2 = 2;
+          input2gp = false;
+          input2mouse = false;
+          input2just = false;
+          break;
+
+        case 0x04: //Super Scope or Gamepad port 2
+          device2 = 2;
+          input2mouse = false;
+          input2just = false;
+          break;
+
+        case 0x05: //Justifier (Lethal Enforcer gun) port 2
+          device2 = 3;
+          input2mouse = false;
+          input2scope = false;
+          break;
+
+        case 0x06: //Multitap port 2
+          input2gp = false;
+          input2mouse = false;
+          input2just = false;
+          input2scope = false;
+          break;
+
+        case 0x07: //Mouse or Gamepad port 1, Mouse, Super Scope, or Gamepad port 2
+          input2just = false;
+          break;
+
+        case 0x08: //Mouse or Multitap port 2
+          device2 = 1;
+          input2just = false;
+          input2scope = false;
+          break;
+
+        case 0x09: //Lasabirdie - not yet supported
+          input2gp = false;
+          input2mouse = false;
+          input2just = false;
+          input2scope = false;
+          break;
+
+        case 0x0A: //Barcode Battler - not yet supported
+          input2gp = false;
+          input2mouse = false;
+          input2just = false;
+          input2scope = false;
+          break;
+      }
+    }
+    curromspace -= 512;
+    memmove((unsigned char *)romdata, ((unsigned char *)romdata)+512, curromspace);
+  }
+
+  snesinputdefault1 = device1;
+  snesinputdefault2 = device2;
+
+  SplitSupport();
+
+  if (isZip)
+  {
+    int i;
+    char ext[4];
+
+    strcpy(ext, "ips");
+    for (i = 0; findZipIPS(ZCartName, ext); i++)
+    {
+      if (i > 9) { break; }
+      ext[2] = i+'0';
+    }
+  }
+
+  if (curromspace)
+  {
+    unsigned char *ROM = (unsigned char *)romdata;
+    NumofBytes = curromspace;
+    NumofBanks = curromspace >> 15;
+    BankCheck();
+    curromsize = ROM[infoloc+ROMSizeOffset];
+    chip_detect();
+    SetupSramSize();
+    calculate_state_sizes();
+    InitRewindVars();
+  }
+}
+
+//Memory Setup functions
+extern unsigned char wramdataa[65536];
+extern unsigned char ram7fa[65536];
+extern unsigned char regptra[49152];
+extern unsigned char regptwa[49152];
+extern unsigned char vidmemch2[4096];
+extern unsigned char vidmemch4[4096];
+extern unsigned char vidmemch8[4096];
+extern unsigned char pal16b[1024];
+extern unsigned char pal16bcl[1024];
+extern unsigned char pal16bclha[1024];
+extern unsigned char pal16bxcl[256];
+extern unsigned char SPCRAM[65472];
+
+extern unsigned char *sram;
+extern unsigned char *vidbuffer;
+extern unsigned char *vram;
+extern unsigned char *vcache2b;
+extern unsigned char *vcache4b;
+extern unsigned char *vcache8b;
+#ifdef OLD_DEBUGGER
+extern unsigned char *debugbuf;
+#endif
+extern unsigned char *sram;
+
+void clearSPCRAM()
+{
+  /*
+  SPC RAM is filled with alternating 0x00 and 0xFF for 0x20 bytes.
+
+  Basically the SPCRAM is initialized as follows:
+  xx00 - xx1f: $00
+  xx20 - xx3f: $ff
+  xx40 - xx5f: $00
+  xx60 - xx7f: $ff
+  xx80 - xx9f: $00
+  xxa0 - xxbf: $ff
+  xxc0 - xxdf: $00
+  xxe0 - xxff: $ff
+  */
+  unsigned int i;
+  for (i = 0; i < 65472; i += 0x40)
+  {
+    memset(SPCRAM+i, 0, 0x20);
+    memset(SPCRAM+i+0x20, 0xFF, 0x20);
+  }
+}
+
+void clearmem2()
+{
+  memset(sram, 0xFF, 65536);
+  clearSPCRAM();
+}
+
+void clearmem()
+{
+  int i;
+
+  memset(vidbuffer, 0, 131072);
+  memset(wramdataa, 0, 65536);
+  memset(ram7fa, 0, 65536);
+  memset(vram, 0, 65536);
+  memset(sram, 0, 65536*2);
+#ifdef OLD_DEBUGGER
+  memset(debugbuf, 0, 80000);
+#endif
+  memset(regptra, 0, 49152);
+  memset(regptwa, 0, 49152);
+  memset(vcache2b, 0, 262144+256);
+  memset(vcache4b, 0, 131072+256);
+  memset(vcache8b, 0, 65536+256);
+  memset(vidmemch2, 0, 4096);
+  memset(vidmemch4, 0, 4096);
+  memset(vidmemch8, 0, 4096);
+  memset(pal16b, 0, 1024);
+  memset(pal16bcl, 0, 1024);
+  memset(pal16bclha, 0, 1024);
+  for (i=0 ; i<1024 ; i+=4)
+  {
+    memset(pal16bxcl+i, 255, 2);
+    memset(pal16bxcl+i+2, 0, 2);
+  }
+  memset(romdata, 0xFF, maxromspace+32768);
+  clearmem2();
+}
+
+extern unsigned char BRRBuffer[32];
+extern unsigned char echoon0;
+extern unsigned int PHdspsave;
+extern unsigned int PHdspsave2;
+unsigned char echobuf[90000];
+extern unsigned char *spcBuffera;
+extern unsigned char DSPMem[256];
+
+void clearvidsound()
+{
+  memset(vram, 0, 65536);
+  memset(vidmemch2, 0, 4096);
+  memset(vidmemch4, 0, 4096);
+  memset(vidmemch8, 0, 4096);
+  memset(BRRBuffer, 0, PHdspsave);
+  memset(&echoon0, 0, PHdspsave2);
+  memset(echobuf, 0, 90000);
+  memset(spcBuffera, 0, 65536*4+4096);
+  memset(DSPMem, 0, 256);
+}
+
+/*
+
+--------------Caution Hack City--------------
+
+Would be nice to trash this section in the future
+*/
+
+extern unsigned char ENVDisable, cycpb268, cycpb358, cycpbl2, cycpblt2, cycpbl;
+extern unsigned char cycpblt, opexec268, opexec358, opexec268b, opexec358b;
+extern unsigned char opexec268cph, opexec358cph, opexec268cphb, opexec358cphb;
+bool HacksDisable;
+
+void headerhack()
+{
+  char *RomData = (char *)romdata;
+  ENVDisable = 0;
+
+  if (curromspace < Lo || HacksDisable) { return; }
+
+  //Super Famista (J)
+  //Shows black screen after one screen.
+  if (!strncmp((RomData+Lo),"\xbd\xb0\xca\xdf\xb0\xcc\xa7\xd0\xbd\xc0  ", 12))
+  {
+    RomData[0x2762F] = 0xEA;
+    RomData[0x27630] = 0xEA;
+  }
+
+  //Super Famista 2 (J)
+  //Shows black screen after loading the ROM.
+  if (!strncmp((RomData+Lo),"\xbd\xb0\xca\xdf\xb0\xcc\xa7\xd0\xbd\xc0 2", 12))
+  {
+    //Skip a check for value FF at 2140 when spc not initialized yet?!?
+    RomData[0x6CED] = 0xEA;
+    RomData[0x6CEE] = 0xEA;
+    //Skip a check for value FF at 2140 when spc not initialized yet?!?
+    RomData[0x6CF9] = 0xEA;
+    RomData[0x6CFA] = 0xEA;
+  }
+
+  //Deae Tonosama Appare Ichiban (J)
+  //Shows some screen and hangs there.
+  if (!strncmp((RomData+Lo),"\xc3\xde\xb1\xb4\xc4\xc9\xbb\xcf", 8))
+  {
+    RomData[0x17837C] = 0xEA;
+    RomData[0x17837D] = 0xEA;
+  }
+
+  //Human Grand Prix III - F1 Triple Battle (J)
+  //Shows black screen after loading the ROM.
+  if (!strncmp((RomData+Lo),"HUMAN GRANDPRIX 3   ", 20))
+  {
+    cycpb268 = 135;
+    cycpb358 = 157;
+    cycpbl2  = 125;
+    cycpblt2 = 125;
+    cycpbl   = 125;
+    cycpblt  = 125;
+  }
+
+  //Accele Brid (J)
+  //Hangs after some time in the first level.
+  if (!strncmp((RomData+Lo),"ACCELEBRID  ", 12))
+  {
+    RomData[0x34DA2] = 0;
+    RomData[0x34DA3] = 0;
+  }
+
+  //Home Alone (J/E/U)
+  //Hangs after starting a new game.
+  if (!strncmp((RomData+Lo),"HOME ALONE  ", 12))
+  {
+    RomData[0x666B] = 0xEE;
+    RomData[0x666C] = 0xBC;
+  }
+
+  //Emerald Dragon (J)
+  //Hangs while drawing the logo after loading the ROM.
+  if (!strncmp((RomData+Hi),"EMERALD DRAG", 12))
+  {
+    ENVDisable = true;
+  }
+
+  //Rendering Ranger R2
+  //Shows black screen after loading the ROM.
+  if (!strncmp((RomData+Lo),"REND", 4))
+  {
+    cycpb268 = 157;
+    cycpb358 = 157;
+    cycpbl2  = 157;
+    cycpblt2 = 157;
+    cycpbl   = 157;
+    cycpblt  = 157;
+  }
+
+  //Tuff E Nuff (U/E), Dead Dance (J),
+  //Cyber Knight II - Tikyu Teikoku no Yabou (J)
+  //Shows black screen after loading the ROM. (Tuff E Nuff, Dead Dance)
+  //Shows black screen after two screens. (Cyber Knight II)
+  if (!strncmp((RomData+Lo),"CYBER KNIGHT 2  ", 16) ||
+      !strncmp((RomData+Lo),"DEAD", 4) ||
+      !strncmp((RomData+Lo),"TUFF", 4))
+  {
+    cycpb268 = 75;
+    cycpb358 = 77;
+    cycpbl2  = 75;
+    cycpblt2 = 75;
+    cycpbl   = 75;
+    cycpblt  = 75;
+  }
+
+  //Addams Family Values (U/E)
+  //Restarts or shows a black screen after starting a new game.
+  if (!strncmp((RomData+Lo), "ADDAMS FAMILY VALUES", 20))
+  {
+    opexec268 = 120;
+    opexec358 = 100;
+  }
+
+  //Front Mission
+  //Flickering worldmap and statusbar.
+  if (!strncmp((RomData+Hi), "\xcc\xdb\xdd\xc4\xd0\xaf\xbc\xae", 8) ||
+      !strncmp((RomData+Hi), "FRONT MI", 8))
+  {
+    opexec268 = 226;
+    opexec358 = 226;
+    opexec268cph = 80;
+    opexec358cph = 80;
+  }
+}
+
+void Setper2exec()
+{
+  if (per2exec != 100)
+  { // Decrease standard % of execution by 5% to replace branch and 16bit
+    // cycle deductions
+    opexec268b = (unsigned char)((opexec268 * 95 * per2exec) / 10000);
+    opexec358b = (unsigned char)((opexec358 * 87 * per2exec) / 10000); // 82
+    opexec268cphb = (unsigned char)((opexec268cph * 95 * per2exec) / 10000);
+    opexec358cphb = (unsigned char)((opexec358cph * 87 * per2exec) / 10000); // 82
+  }
+}
+
+extern unsigned int SPC7110TempPosition, SPC7110TempLength, SPCDecmPtr;
+static char *SPC7110path, SPC7110fname[8+1+6+4+1]; //dir / 12345 .bin
+char *SPC7110filep;
+extern unsigned char *SPC7110IndexPtr, *SPC7110PackPtr;
+unsigned int SPC7110IndexSize;
+
+static void SPC7PathSetup(char *PathVar, const char *Default)
+{
+  if (*PathVar)
+  {
+    SPC7110path = PathVar;
+    strcatslash(SPC7110path);
+    *SPC7110fname = 0;
+  }
+  else
+  {
+    SPC7110path = ZSramPath;
+    strcpy(SPC7110fname, Default);
+    strcatslash(SPC7110fname);
+  }
+}
+
+extern unsigned int MsgCount, MessageOn, CRC32;
+extern char *Msgptr;
+unsigned int SPC7110Entries;
+
+void SPC7PackIndexLoad()
+{
+  char *ROM = (char *)romdata;
+  FILE *fp = 0;
+  SPC7110IndexSize = 0;
+
+  //Get correct path for the ROM we just loaded
+  if (!strncmp(ROM+infoloc, "HU TENGAI MAKYO ZERO ", 21))
+  { SPC7PathSetup(FEOEZPath, "FEOEZSP7"); }
+  else if (!strncmp(ROM+infoloc, "JUMP TENGAIMAKYO ZERO", 21))
+  { SPC7PathSetup(SJNSPath, "SJNS-SP7"); }
+  else if (!strncmp(ROM+infoloc, "MOMOTETSU HAPPY      ", 21))
+  { SPC7PathSetup(MDHPath, "MDH-SP7"); }
+  else if (!strncmp(ROM+infoloc, "SUPER POWER LEAG 4   ", 21))
+  { SPC7PathSetup(SPL4Path, "SPL4-SP7"); }
+  else
+  {
+    Msgptr = "DECOMPRESSED PACK NOT FOUND";
+    MessageOn = 360;
+    return;
+  }
+
+  //Set the pointer to after the slash - needed for the case converters
+  SPC7110filep = SPC7110fname+strlen(SPC7110fname);
+
+  //Index file;
+  strcat(SPC7110fname, "index.bin");
+
+  //Load the index
+  fp = fopen_dir(SPC7110path, SPC7110fname, "rb");
+  if (fp)
+  {
+    SPC7110IndexSize = fread(SPC7110IndexPtr, 1, 12*4608, fp);
+    fclose(fp);
+
+    //Get file pointer ready for individual pack files
+    strcpy(SPC7110filep, "123456.bin"); //Extension Lower Case
+  }
+
+  SPC7110Entries = 0;
+
+  if (!SPC7110IndexSize)
+  {
+    Msgptr = "DECOMPRESSED PACK NOT FOUND";
+    MessageOn = 360;
+  }
+}
+
+void SPC7_Convert_Upper()
+{
+  char *i = SPC7110filep;
+  while (*i)
+  {
+    *i = toupper(*i); //To make extension Upper case
+    i++;
+  }
+}
+
+void SPC7_Convert_Lower()
+{
+  char *i = SPC7110filep;
+  while (*i)
+  {
+    *i = tolower(*i); //To make everything Lower case
+    i++;
+  }
+}
+
+void SPC7_Data_Load()
+{
+  FILE *fp = fopen_dir(SPC7110path, SPC7110fname, "rb");
+  if (!fp)
+  {
+    SPC7_Convert_Upper();
+    fp = fopen_dir(SPC7110path, SPC7110fname, "rb");
+
+    if (!fp)
+    {
+      SPC7_Convert_Lower();
+      fp = fopen_dir(SPC7110path, SPC7110fname, "rb");
+    }
+  }
+
+  if (fp)
+  {
+    fseek(fp, SPC7110TempPosition, SEEK_SET);
+    fread(SPC7110PackPtr, 1, SPC7110TempLength, fp);
+    fclose(fp);
+  }
+}
+
+extern unsigned char IPSPatched;
+
+unsigned int showinfogui()
+{
+  unsigned int i;
+  unsigned char *ROM = (unsigned char *)romdata;
+
+  strcpy(CSStatus, "                          TYPE:         ");
+  strcpy(CSStatus2, "INTERLEAVED:                 CHKSUM:    ");
+  strcpy(CSStatus3, "VIDEO:        BANK:       CRC32:        ");
+  strcpy(CSStatus4, "                                        ");
+
+  for (i=0 ; i<21 ; i++)
+  { CSStatus[i] = (ROM[infoloc + i]) ? ROM[infoloc + i] : 32; }
+
+  if (Interleaved)
+  {
+    memcpy(CSStatus2+12, "Yes ", 4);
+    memcpy(CSStatus4+10, "PLEASE DEINTERLEAVE ROM", 23);
+  }
+  else
+  {
+    memcpy(CSStatus2+12, "No  ", 4);
+    memset(CSStatus4+10, ' ', 23);
+  }
+
+  memcpy(CSStatus2+20, (IPSPatched) ? "IPS ":"    ", 4);
+  memcpy(CSStatus3+6, (ROM[infoloc + 25] < 2 || ROM[infoloc + 25] > 12) ? "NTSC":"PAL ", 4);
+
+  if (infoloc == EHi) { memcpy(CSStatus3+19, "EHi ", 4); }
+  else { memcpy(CSStatus3+19, (romtype == 2) ? "Hi  ":"Lo  ", 4); }
+
+  memcpy(CSStatus+31, "NORMAL   ", 9);
+  if (SA1Enable)     { memcpy(CSStatus+31, "SA-1     ", 9); }
+  if (RTCEnable)     { memcpy(CSStatus+31, "RTC      ", 9); }
+  if (SPC7110Enable) { memcpy(CSStatus+31, "SPC7110  ", 9); }
+  if (SFXEnable)     { memcpy(CSStatus+31, "SUPER FX ", 9); }
+  if (C4Enable)      { memcpy(CSStatus+31, "C4       ", 9); }
+  if (DSP1Enable)    { memcpy(CSStatus+31, "DSP-1    ", 9); }
+  if (DSP2Enable)    { memcpy(CSStatus+31, "DSP-2    ", 9); }
+  if (DSP3Enable)    { memcpy(CSStatus+31, "DSP-3    ", 9); }
+  if (DSP4Enable)    { memcpy(CSStatus+31, "DSP-4    ", 9); }
+  if (SDD1Enable)    { memcpy(CSStatus+31, "S-DD1    ", 9); }
+  if (OBCEnable)     { memcpy(CSStatus+31, "OBC1     ", 9); }
+  if (SETAEnable)    { memcpy(CSStatus+31, "SETA DSP ", 9); }
+  if (ST18Enable)    { memcpy(CSStatus+31, "ST018    ", 9); }
+  if (SGBEnable)     { memcpy(CSStatus+31, "SGB      ", 9); }
+  if (BSEnable)      { memcpy(CSStatus+31, "BROADCAST", 9);
+  // dummy out date so CRC32 matches
+    ROM[infoloc+BSMonthOffset] = 0x42;
+    ROM[infoloc+BSDayOffset] = 0x00; }
+  // 42 is the answer, and the uCONSRT standard
+
+  // calculate CRC32 for the whole ROM, or Add-on ROM only
+  CRC32 = (SplittedROM) ? crc32(0, ROM+addOnStart, addOnSize) : crc32(0, ROM, NumofBytes);
+  // place CRC32 on line
+  sprintf(CSStatus3+32, "%08X", CRC32);
+
+  i = (SplittedROM) ? infoloc + 0x1E + addOnStart: infoloc + 0x1E;
+
+  if ((ROM[i] == (Checksumvalue & 0xFF)) && (ROM[i+1] == (Checksumvalue >> 8)))
+  { memcpy(CSStatus2+36, "OK  ", 4); }
+  else
+  {
+    memcpy(CSStatus2+36, "FAIL", 4);
+    if (!IPSPatched) { memcpy(CSStatus4, "BAD ROM ",8); }
+    else { memset(CSStatus4, ' ', 7); }
+  }
+
+  DumpROMLoadInfo();
+
+  MessageOn = 300;
+  Msgptr = CSStatus;
+  return (MsgCount);
+}
+
+extern unsigned int nmiprevaddrl, nmiprevaddrh, nmirept, nmiprevline, nmistatus;
+extern unsigned char spcnumread, yesoutofmemory;
+extern unsigned char NextLineCache, sramsavedis, sndrot, regsbackup[3019];
+extern unsigned int Voice0Freq, Voice1Freq, Voice2Freq, Voice3Freq;
+extern unsigned int Voice4Freq, Voice5Freq, Voice6Freq, Voice7Freq;
+extern unsigned int dspPAdj;
+extern unsigned short Voice0Pitch, Voice1Pitch, Voice2Pitch, Voice3Pitch;
+extern unsigned short Voice4Pitch, Voice5Pitch, Voice6Pitch, Voice7Pitch;
+void outofmemfix(), GUIDoReset();
+
+void initpitch()
+{
+  Voice0Pitch = DSPMem[2+0*0x10];
+  Voice0Freq = ((((Voice0Pitch & 0x3FFF) * dspPAdj) >> 8) & 0xFFFFFFFF);
+  Voice1Pitch = DSPMem[2+1*0x10];
+  Voice1Freq = ((((Voice1Pitch & 0x3FFF) * dspPAdj) >> 8) & 0xFFFFFFFF);
+  Voice2Pitch = DSPMem[2+2*0x10];
+  Voice2Freq = ((((Voice2Pitch & 0x3FFF) * dspPAdj) >> 8) & 0xFFFFFFFF);
+  Voice3Pitch = DSPMem[2+3*0x10];
+  Voice3Freq = ((((Voice3Pitch & 0x3FFF) * dspPAdj) >> 8) & 0xFFFFFFFF);
+  Voice4Pitch = DSPMem[2+4*0x10];
+  Voice4Freq = ((((Voice4Pitch & 0x3FFF) * dspPAdj) >> 8) & 0xFFFFFFFF);
+  Voice5Pitch = DSPMem[2+5*0x10];
+  Voice5Freq = ((((Voice5Pitch & 0x3FFF) * dspPAdj) >> 8) & 0xFFFFFFFF);
+  Voice6Pitch = DSPMem[2+6*0x10];
+  Voice6Freq = ((((Voice6Pitch & 0x3FFF) * dspPAdj) >> 8) & 0xFFFFFFFF);
+  Voice7Pitch = DSPMem[2+7*0x10];
+  Voice7Freq = ((((Voice7Pitch & 0x3FFF) * dspPAdj) >> 8) & 0xFFFFFFFF);
+}
+
+extern unsigned int SfxR1, SfxR2, SetaCmdEnable, SfxSFR, SfxSCMR;
+extern unsigned char disablespcclr, *sfxramdata, SramExists;
+extern unsigned char *setaramdata, *wramdata, *SA1RAMArea, cbitmode;
+extern unsigned char ForcePal, ForceROMTiming, romispal, MovieWaiting, DSP1Type;
+extern unsigned short totlines;
+void SetAddressingModes(), GenerateBank0Table();
+void SetAddressingModesSA1(), GenerateBank0TableSA1();
+void InitDSP(), InitDSP2(), InitDSP3(), InitDSP4(), InitOBC1(), InitFxTables();
+void initregr(), initregw();
+
+#ifdef __MSDOS__
+void dosmakepal();
+#endif
+
+void CheckROMType()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+
+  if (!MovieWaiting)
+  {
+    MirrorROM((unsigned char *)romdata);
+    CalcChecksum();
+  }
+
+  lorommapmode2 = 0;
+  if (!strncmp((char *)ROM+0x207FC0, "DERBY STALLION 96", 17) ||
+      !strncmp((char *)ROM+Lo, "SOUND NOVEL-TCOOL", 17))
+  { lorommapmode2 = 1; }
+
+  // Setup memmapping
+  SetAddressingModes();
+  GenerateBank0Table();
+
+  disablespcclr = (memcmp(ROM+Hi, "BS Z", 4)) ? 0 : 1;
+
+  if (!strncmp((char *)ROM, "BANDAI SFC-ADX", 14))
+  {
+    map_mem(0x60, &stbanka, 0x08);
+    if (STCart2)
+    {
+      map_mem(0x70, &stbankb, 0x08);
+    }
+  }
+  else if (romtype == 1)   // LoROM SRAM mapping
+  {  // banks 70 - 77
+    map_mem(0x70, &srambank, 0x08);
+
+    if (!BSEnable)
+    {  // banks 78 - 7D (not for BS)
+      map_mem(0x78, &srambank, 0x06);
+    }
+
+    if (!SDD1Enable)
+    {  // banks F0 - FF (not for S-DD1)
+      map_mem(0xF0, &srambank, 0x10);
+    }
+  }
+
+  // Setup DSP-X stuff
+  DSP1Type = 0;
+
+  if (DSP1Enable)
+  {
+    InitDSP();
+
+    if (romtype == 1)
+    {
+      DSP1Type = 1;
+      map_mem(0x30, &dsp1bank, 0x10);
+      map_mem(0xB0, &dsp1bank, 0x10);
+      map_mem(0xE0, &dsp1bank, 0x10);
+    }
+    else
+    {
+      DSP1Type = 2;
+    }
+  }
+
+  if (DSP2Enable)
+  {
+    asm_call(InitDSP2);
+    map_mem(0x3F, &dsp2bank, 1);
+  }
+
+  if (DSP3Enable)
+  {
+    InitDSP3();
+
+    // DSP-3 mapping, banks 20 - 3F
+    map_mem(0x20, &dsp3bank, 0x20);
+  }
+
+  if (DSP4Enable)
+  {
+    InitDSP4();
+
+    // DSP-4 mapping, banks 30 - 3F
+    map_mem(0x30, &dsp4bank, 0x10);
+  }
+
+  if (OBCEnable)
+  {
+    InitOBC1();
+
+    map_mem(0x00, &obc1bank, 0x40);
+    map_mem(0x80, &obc1bank, 0x40);
+  }
+
+  if (C4Enable)
+  {
+    map_mem(0x00, &c4bank, 0x40);
+    map_mem(0x80, &c4bank, 0x40);
+  }
+
+  if (SFXEnable)
+  {
+    // Setup SuperFX stuff
+    if (maxromspace >= 0x600000)
+    {
+      //SuperFX mapping, banks 70 - 73
+      map_mem(0x70, &sfxbank, 1);
+      map_mem(0x71, &sfxbankb, 1);
+      map_mem(0x72, &sfxbankc, 1);
+      map_mem(0x73, &sfxbankd, 1);
+
+      //SRAM mapping, banks 78 - 79
+      map_mem(0x78, &sramsbank, 2);
+
+      SfxR1 = 0;
+      SfxR2 = 0;
+      memset(sfxramdata, 0, 262144); // clear 256kB SFX ram
+
+      if (SramExists)
+      {
+        memcpy(sfxramdata, sram, 65536); // proper SFX sram area
+      }
+
+      asm_call(InitFxTables);
+    }
+    else
+    {
+      yesoutofmemory = 1;
+    }
+  }
+
+  if (SETAEnable)
+  {
+    if (strncmp((char *)ROM+Lo, "2DAN MORITA SHOUGI", 18))
+    {
+      //Setup Seta 10 stuff
+
+      //Really banks 68h-6Fh:0000-7FFF are all mapped the same by the chip but
+      //F1 ROC II only uses bank 68h
+      map_mem(0x68, &setabank, 1);
+
+      //Control register (and some status?) is in banks 60h-67h:0000-3FFF
+      map_mem(0x60, &setabanka, 1);
+
+      SetaCmdEnable = 0x00000080; // 60:0000
+    }
+    else
+    {
+      void ST011_Reset();
+      ST011_Reset();
+      map_mem(0x68, &seta11bank, 1);
+      map_mem(0x60, &seta11banka, 1);
+    }
+    memset(setaramdata, 0, 4096); // clear 4kB SETA ram
+
+    // proper SETA sram area
+    if (SramExists)
+    {
+      memcpy(setaramdata, sram, 4096);
+    }
+  }
+
+  // General stuff all mixed together [... wouldn't it be cool to clean that]
+  SfxSFR = 0;
+  SfxSCMR &= 0xFFFFFF00;
+  asm_call(initregr);
+  asm_call(initregw);
+
+  if (SA1Enable)
+  {
+    SA1RAMArea = ROM + 4096*1024;
+
+    GenerateBank0TableSA1();
+    SetAddressingModesSA1();
+
+    if (CHIPBATT) // proper SA-1 sram area
+    {
+      memset(SA1RAMArea, 0, 131072);
+      if (SramExists) { memcpy(SA1RAMArea, sram, 131072); }
+    }
+  }
+
+  wramdata = wramdataa;
+}
+
+extern unsigned short copv, brkv, abortv, nmiv, nmiv2, irqv, irqv2, resetv;
+extern unsigned short copv8, brkv8, abortv8, nmiv8, irqv8;
+
+void SetIRQVectors()
+{ // get vectors (NMI & reset)
+  unsigned char *ROM = (unsigned char *)romdata;
+
+  if (!memcmp(ROM+infoloc+36+24, "\0xFF\0xFF", 2)) // if reset error
+  {
+    memcpy(ROM+infoloc+36+6, "\0x9C\0xFF", 2);
+    memcpy(ROM+infoloc+36+24, "\0x80\0xFF", 2);
+  }
+
+  memcpy(&copv,   ROM+infoloc+0x24, 2);
+  memcpy(&brkv,   ROM+infoloc+0x26, 2);
+  memcpy(&abortv, ROM+infoloc+0x28, 2);
+  memcpy(&nmiv,   ROM+infoloc+0x2A, 2);
+  memcpy(&nmiv2,  ROM+infoloc+0x2A, 2);
+  memcpy(&irqv,   ROM+infoloc+0x2E, 2);
+  memcpy(&irqv2,  ROM+infoloc+0x2E, 2);
+
+  // 8-bit and reset
+  memcpy(&copv8,   ROM+infoloc+0x34, 2);
+  memcpy(&abortv8, ROM+infoloc+0x38, 2);
+  memcpy(&nmiv8,   ROM+infoloc+0x3A, 2);
+  memcpy(&resetv,  ROM+infoloc+0x3C, 2);
+  memcpy(&brkv8,   ROM+infoloc+0x3E, 2);
+  memcpy(&irqv8,   ROM+infoloc+0x3E, 2);
+
+  if (yesoutofmemory) // failed ?
+  {
+    resetv = 0x8000;
+    memcpy(ROM+0x0000, "\0x80\0xFE", 2);
+    memcpy(ROM+0x8000, "\0x80\0xFE", 2);
+  }
+}
+
+void SetupROM()
+{
+  static bool CLforce = false;
+  unsigned char *ROM = (unsigned char *)romdata;
+
+  CheckROMType();
+  SetIRQVectors();
+
+  #ifdef __MSDOS__
+  if (!cbitmode) // 8-bit mode uses a palette
+  {
+    asm_call(dosmakepal);
+  }
+  #endif
+
+  /* get timing (pal/ntsc)
+  ForceROMTiming is from the GUI.
+  ForcePal is from Command line, we have a static var
+  to prevent forcing a secong game loaded from the GUI when
+  the first was loaded from the command line with forcing.
+  */
+  if (ForcePal && !CLforce) { CLforce = true; }
+  else { ForcePal = ForceROMTiming; }
+
+  switch (ForcePal)
+  {
+    case 1:
+      romispal = 0;
+      break;
+    case 2:
+      romispal = (!BSEnable);
+      break;
+    default:
+      romispal = ((!BSEnable) && (ROM[infoloc+CountryOffset] > 1) && (ROM[infoloc+CountryOffset] < 0xD));
+  }
+
+  #ifdef __UNIXSDL__
+  InitSampleControl();
+  #endif
+
+  if (romispal)
+  {
+    totlines = 314;
+    MsgCount = 100;
+  }
+  else
+  {
+    totlines = 263;
+    MsgCount = 120;
+  }
+}
+
+extern int NumComboLocl;
+extern unsigned char ComboHeader[23];
+extern char CombinDataLocl[3300];
+extern bool romloadskip;
+
+void SaveCombFile()
+{
+  if (!romloadskip)
+  {
+    FILE *fp;
+
+    setextension(ZSaveName, "cmb");
+
+    if (NumComboLocl)
+    {
+      ComboHeader[22] = NumComboLocl;
+
+      if ((fp = fopen_dir(ZSramPath, ZSaveName, "wb")))
+      {
+        fwrite(ComboHeader, 1, 23, fp);
+        fwrite(CombinDataLocl, 1, NumComboLocl*66, fp);
+        fclose(fp);
+      }
+    }
+  }
+}
+
+void OpenCombFile()
+{
+  FILE *fp;
+
+  setextension(ZSaveName, "cmb");
+  NumComboLocl = 0;
+
+  if ((fp = fopen_dir(ZSramPath, ZSaveName, "rb")))
+  {
+    fread(ComboHeader, 1, 23, fp);
+    NumComboLocl = ComboHeader[22];
+
+    if (NumComboLocl)
+    {
+      fread(CombinDataLocl, 1, NumComboLocl*66, fp);
+    }
+
+    fclose(fp);
+  }
+}
+
+unsigned char SFXCounter, SfxAC, ForceNewGfxOff;
+
+void preparesfx()
+{
+  char *ROM = (char *)romdata, i;
+
+  SFXCounter = SfxAC = 0;
+
+  if (!strncmp(ROM+Lo, "FX S", 4) ||
+      !strncmp(ROM+Lo, "DIRT", 4))
+  {
+    SFXCounter = 1;
+  }
+  else if (!strncmp(ROM+Lo, "Stun", 4))
+  {
+    ForceNewGfxOff=1;
+  }
+
+  for (i=63;i>=0;i--)
+  {
+    memcpy(romdata+i*0x4000       ,romdata+i*0x2000,0x8000);
+    memcpy(romdata+i*0x4000+0x2000,romdata+i*0x2000,0x8000);
+  }
+}
+
+void map_set(void **dest, unsigned char *src, size_t count, size_t step)
+{
+  while (count--)
+  {
+    *dest = src;
+    dest++;
+    src += step;
+  }
+}
+
+extern unsigned char MultiType;
+extern void *snesmmap[256];
+extern void *snesmap2[256];
+
+unsigned int cromptradd;
+extern unsigned char MultiTap;
+extern unsigned int SfxR0, SfxR1, SfxR2, SfxR3, SfxR4, SfxR5, SfxR6, SfxR7,
+                   SfxR8, SfxR9, SfxR10, SfxR11, SfxR12, SfxR13, SfxR14, SfxR15;
+extern void *ram7f;
+
+void map_lorom()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+  int x;
+
+  // set addresses 8000-FFFF
+  // set banks 00-7F (80h x 32KB ROM banks @ 8000h)
+  map_set(snesmmap,ROM-0x8000,0x80,0x8000);
+
+  // set banks 80-FF (80h x 32KB ROM banks @ 8000h)
+  if (lorommapmode2)
+  {
+    map_set(snesmmap+0x80,ROM+0x1F8000,0x20,0x8000);
+    map_set(snesmmap+0xA0,ROM+0x0F8000,0x60,0x8000);
+  }
+  else
+  {
+    map_set(snesmmap+0x80,ROM-0x8000,0x80,0x8000);
+  }
+
+  // set addresses 0000-7FFF
+  // set banks 00-3F (40h x WRAM)
+  map_set(snesmap2,wramdata,0x40,0);
+
+  // set banks 40-7F (40h x 32KB ROM banks @ 8000h)
+  map_set(snesmap2+0x40,ROM+0x200000,0x40,0x8000);
+
+  // set banks 80-BF (40h x WRAM)
+  map_set(snesmap2+0x80,wramdata,0x40,0);
+
+  // set banks C0-FF (40h x 32KB ROM banks @ 8000h)
+  map_set(snesmap2+0xC0,ROM+0x200000,0x40,0x8000);
+
+  // set banks 70-77 (07h x SRAM)
+  for (x = 0x70; x <= 0x77; x++) { snesmap2[x] = sram; }
+
+  // set banks 7E/7F (WRAM)
+  snesmmap[0x7E] = snesmap2[0x7E] = wramdata;
+  snesmmap[0x7F] = snesmap2[0x7F] = ram7f;
+}
+
+void map_hirom()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+  int x;
+
+  // set addresses 8000-FFFF
+  // set banks 00-3F (40h x 64KB ROM banks @10000h)
+  map_set(snesmmap,ROM,0x40,0x10000);
+
+  // set banks 40-7F (40h x 64KB ROM banks @10000h)
+  map_set(snesmmap+0x40,ROM,0x40,0x10000);
+
+  // set banks 80-BF (40h x 64KB ROM banks @10000h)
+  map_set(snesmmap+0x80,ROM,0x40,0x10000);
+
+  // set banks C0-FF (40h x 64KB ROM banks @10000h)
+  map_set(snesmmap+0xC0,ROM,0x40,0x10000);
+
+  // set addresses 0000-7FFF
+  // set banks 00-3F (40h x WRAM)
+  map_set(snesmap2,wramdata,0x40,0);
+
+  // set banks 40-7F (40h x 64KB ROM banks @10000h)
+  map_set(snesmap2+0x40,ROM,0x40,0x10000);
+
+  // set banks 80-BF (40h x WRAM)
+  map_set(snesmap2+0x80,wramdata,0x40,0);
+
+  // set banks C0-FF (40h x 64KB ROM banks @10000h)
+  map_set(snesmap2+0xC0,ROM,0x40,0x10000);
+
+  // set banks 70-77 (07h x SRAM)
+  for (x = 0x70; x <= 0x77; x++) { snesmap2[x] = sram; }
+
+  // set banks 7E/7F (WRAM)
+  snesmmap[0x7E] = snesmap2[0x7E] = wramdata;
+  snesmmap[0x7F] = snesmap2[0x7F] = ram7f;
+}
+
+void map_ehirom()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+  int x;
+
+  // set addresses 8000-FFFF
+  // set banks 00-3F (40h x 32KB ROM banks @ 10000h)
+  map_set(snesmmap,ROM+0x400000,0x20,0x10000);
+  map_set(snesmmap+0x20,ROM+0x400000,0x20,0x10000);
+
+  // set banks 40-7F (40h x 32KB ROM banks @ 10000h)
+  map_set(snesmmap+0x40,ROM+0x400000,0x20,0x10000);
+  map_set(snesmmap+0x60,ROM+0x400000,0x20,0x10000);
+
+  // set banks 80-BF (40h x 32KB ROM banks @10000h)
+  map_set(snesmmap+0x80,ROM+0x400000,0x20,0x10000);
+  map_set(snesmmap+0xA0,ROM+0x400000,0x20,0x10000);
+
+  // set banks C0-FF (40h x 64KB ROM banks @10000h)
+  map_set(snesmmap+0xC0,ROM,0x40,0x10000);
+
+  // set addresses 0000-7FFF
+  // set banks 00-3F (40h x WRAM)
+  map_set(snesmap2,wramdata,0x40,0);
+
+  // set banks 40-7F (40h x 32KB ROM banks @ 8000h)
+  map_set(snesmap2+0x40,ROM+0x400000,0x20,0x10000);
+  map_set(snesmap2+0x60,ROM+0x400000,0x20,0x10000);
+
+  // set banks 80-BF (40h x WRAM)
+  map_set(snesmap2+0x80,wramdata,0x40,0);
+
+  // set banks C0-FF (40h x 64KB ROM banks @10000h)
+  map_set(snesmap2+0xC0,ROM,0x40,0x10000);
+
+  // set banks 70-77 (07h x SRAM)
+  for(x = 0x70; x <= 0x77; x++) { snesmap2[x] = sram; }
+
+  // set banks 7E/7F (WRAM)
+  snesmmap[0x7E] = snesmap2[0x7E] = wramdata;
+  snesmmap[0x7F] = snesmap2[0x7F] = ram7f;
+}
+
+void map_sfx()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+
+  // Clear SFX registers
+  SfxR0 = SfxR1 = SfxR2 = SfxR3 = SfxR4 = SfxR5 = SfxR6 = SfxR7 = 0;
+  SfxR8 = SfxR9 = SfxR10 = SfxR11 = SfxR12 = SfxR13 = SfxR14 = SfxR15 = 0;
+
+  // set addresses 8000-FFFF
+  // set banks 00-3F (40h x 64KB ROM banks @10000h)
+  map_set(snesmmap,ROM,0x40,0x10000);
+
+  // set banks 40-7F (40h x128KB ROM banks @20000h)
+  map_set(snesmmap+0x40,ROM+0x8000,0x30,0x20000);
+  map_set(snesmmap+0x70,ROM+0x8000,0x10,0x20000);
+
+  // set banks 80-BF (40h x 64KB ROM banks @10000h)
+  map_set(snesmmap+0x80,ROM,0x40,0x10000);
+
+  // set banks C0-FF (40h x128KB ROM banks @20000h)
+  map_set(snesmmap+0xC0,ROM+0x8000,0x30,0x20000);
+  map_set(snesmmap+0xF0,ROM+0x8000,0x10,0x20000);
+
+  // set addresses 0000-7FFF
+  // set banks 00-3F (40h x WRAM)
+  map_set(snesmap2,wramdata,0x40,0);
+
+  // set banks 40-7F (40h x128KB ROM banks @20000h)
+  map_set(snesmap2+0x40,ROM+0x8000,0x30,0x20000);
+  map_set(snesmap2+0x70,ROM+0x8000,0x10,0x20000);
+
+  // set banks 80-BF (40h x WRAM)
+  map_set(snesmap2+0x80,wramdata,0x40,0);
+
+  // set banks C0-FF (40h x128KB ROM banks @20000h)
+  map_set(snesmap2+0xC0,ROM+0x8000,0x30,0x20000);
+  map_set(snesmap2+0xF0,ROM+0x8000,0x10,0x20000);
+
+  // set banks 70-73/78/79 (SFXRAM & SRAM)
+  map_set(snesmap2+0x70,sfxramdata,4,0x10000);
+  snesmap2[0x78] = snesmap2[0x79] = sram;
+
+  // set banks 7E/7F (WRAM)
+  snesmmap[0x7E] = snesmap2[0x7E] = wramdata;
+  snesmmap[0x7F] = snesmap2[0x7F] = ram7f;
+
+  preparesfx();
+}
+
+void map_sa1()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+  unsigned char test[] = { 0xA9, 0x10, 0xCF, 0xAD };
+
+  if(!memcmp(ROM+0xB95, test, 4)) { ROM[0xB96] = 0; }
+
+  // set addresses 8000-FFFF
+  // set banks 00-3F (40h x 32KB ROM banks @ 8000h)
+  map_set(snesmmap,ROM-0x8000,0x40,0x8000);
+
+  // set banks 40-7F (40h x 64KB ROM banks @10000h)
+  map_set(snesmmap+0x40,ROM,0x40,0x10000);
+
+  // set banks 80-BF (40h x 32KB ROM banks @ 8000h)
+  map_set(snesmmap+0x80,ROM+0x1F8000,0x40,0x8000);
+
+  // set banks C0-FF (40h x 64KB ROM banks @10000h)
+  map_set(snesmmap+0xC0,ROM,0x40,0x10000);
+
+  // set addresses 0000-7FFF
+  // set banks 00-3F (40h x WRAM)
+  map_set(snesmap2,wramdata,0x40,0);
+
+  // set banks 40-7F (40h x 64KB ROM banks @10000h)
+  map_set(snesmap2+0x40,ROM,0x40,0x10000);
+
+  // set banks 80-BF (40h x WRAM)
+  map_set(snesmap2+0x80,wramdata,0x40,0);
+
+  // set banks C0-FF (40h x 64KB ROM banks @10000h)
+  map_set(snesmap2+0xC0,ROM,0x40,0x10000);
+
+  // set banks 7E/7F (WRAM)
+  snesmmap[0x7E] = snesmap2[0x7E] = wramdata;
+  snesmmap[0x7F] = snesmap2[0x7F] = ram7f;
+}
+
+void map_sdd1()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+  unsigned char test[] = { 0xA9, 0x10, 0xCF, 0xAD };
+
+  if(!memcmp(ROM+0xB95, test, 4)) { ROM[0xB96] = 0; }
+
+  // set addresses 8000-FFFF
+  // set banks 00-3F (40h x 32KB ROM banks @ 8000h)
+  map_set(snesmmap,ROM-0x8000,0x40,0x8000);
+
+  // set banks 40-7F (40h x 64KB ROM banks @10000h)
+  map_set(snesmmap+0x40,ROM,0x40,0x10000);
+
+  // set banks 80-BF (40h x 32KB ROM banks @ 8000h)
+  map_set(snesmmap+0x80,ROM-0x8000,0x40,0x8000);
+
+  // set banks C0-FF (40h x 64KB ROM banks @10000h)
+  map_set(snesmmap+0xC0,ROM,0x40,0x10000);
+
+  // set addresses 0000-7FFF
+  // set banks 00-3F (40h x WRAM)
+  map_set(snesmap2,wramdata,0x40,0);
+
+  // set banks 40-7F (40h x 64KB ROM banks @10000h)
+  map_set(snesmap2+0x40,ROM,0x40,0x10000);
+
+  // set banks 80-BF (40h x WRAM)
+  map_set(snesmap2+0x80,wramdata,0x40,0);
+
+  // set banks C0-FF (40h x 64KB ROM banks @10000h)
+  map_set(snesmap2+0xC0,ROM,0x40,0x10000);
+
+  // set banks 7E/7F (WRAM)
+  snesmmap[0x7E] = snesmap2[0x7E] = wramdata;
+  snesmmap[0x7F] = snesmap2[0x7F] = ram7f;
+}
+
+void map_bsx()
+{
+  unsigned char *ROM = (unsigned char *)romdata;
+  int x;
+
+  // set addresses 8000-FFFF
+  // set banks 00-7F (80h x 32KB ROM banks @ 8000h)
+  map_set(snesmmap,ROM-0x8000,0x80,0x8000);
+
+  // set banks 80-BF (40h x 32KB ROM banks @ 8000h)
+  map_set(snesmmap+0x80,ROM-0x8000,0x40,0x8000);
+
+  // set banks C0-FF (40h x 32KB ROM banks @ 8000h)
+  map_set(snesmmap+0xC0,ROM+0x8000,0x40,0x8000);
+
+  // set addresses 0000-7FFF
+  // set banks 00-3F (40h x WRAM)
+  map_set(snesmap2,wramdata,0x40,0);
+
+  // set banks 40-7F (40h x 32KB ROM banks @ 8000h)
+  map_set(snesmap2+0x40,ROM+0x200000,0x40,0x8000);
+
+  // set banks 80-BF (40h x WRAM)
+  map_set(snesmap2+0x80,wramdata,0x40,0);
+
+  // set banks C0-FF (40h x 32KB ROM banks @ 8000h)
+  map_set(snesmap2+0xC0,ROM+0x8000,0x40,0x8000);
+
+  // set banks 70-77 (07h x SRAM)
+  for (x = 0x70; x <= 0x77; x++) { snesmap2[x] = sram; }
+
+  // set banks 7E/7F (WRAM)
+  snesmmap[0x7E] = snesmap2[0x7E] = wramdata;
+  snesmmap[0x7F] = snesmap2[0x7F] = ram7f;
+}
+
+void initsnes()
+{
+  ForceNewGfxOff = 0;
+
+  if (!BSEnable)
+  {
+    MultiTap = pl12s34 ? 0 : (pl3contrl || pl4contrl || pl5contrl);
+
+    if (SFXEnable) { map_sfx(); }
+    else if (SA1Enable) { map_sa1(); }
+    else if (SDD1Enable) { map_sdd1(); }
+    else if (SPC7110Enable) { map_hirom(); }
+    else if (curromsize == 13) { map_ehirom(); }
+    else if (romtype == 2) { map_hirom(); }
+    else { map_lorom(); }
+  }
+  else
+  {
+    map_bsx();
+  }
+}
+
+bool PatchUsingIPS(char *);
+void DosExit(), OpenSramFile(), CheatCodeLoad(), LoadSecondState(), LoadGameSpecificInput();
+extern unsigned char GUIOn, GUIOn2;
+
+bool loadfileGUI()
+{
+  bool result = true;
+
+  spcon = !SPCDisable;
+  MessageOn = yesoutofmemory = IPSPatched = 0;
+
+  loadROM();
+
+  if (curromspace)
+  {
+    SramExists = 0;
+    OpenSramFile();
+    OpenCombFile();
+    LoadGameSpecificInput();
+
+    if (!(GUIOn || GUIOn2))
+    {
+      puts("File opened successfully !");
+    }
+    if (!IPSPatched)
+    {
+      int i;
+      char ext[4];
+
+      strcpy(ext, "ips");
+      for (i = 0; PatchUsingIPS(ext); i++)
+      {
+        if (i > 9) { break; }
+        ext[2] = i+'0';
+      }
+    }
+  }
+  else
+  {
+    if (GUIOn || GUIOn2) { result = false; }
+    else
+    {
+      puts("Error opening file!\n");
+      asm_call(DosExit);
+    }
+  }
+
+  return (result);
+}
+
+extern unsigned int CheatOn, NumCheats;
+extern unsigned char CheatWinMode, CheatSearchStatus;
+void GUIQuickLoadUpdate();
+
+void powercycle(bool sramload, bool romload)
+{
+  clearmem2();
+
+  nmiprevaddrl = 0;
+  nmiprevaddrh = 0;
+  nmirept = 0;
+  nmiprevline = 224;
+  nmistatus = 0;
+  spcnumread = 0;
+  NextLineCache = 0;
+  curexecstate = 1;
+
+  if (sramload) { OpenSramFile(); }
+  if (romload) { romloadskip = 1; }
+
+  if (!romload || (loadfileGUI()))
+  {
+    if (romload)
+    { CheatOn = NumCheats = CheatWinMode = CheatSearchStatus = 0; }
+
+    SetupROM();
+
+    if (romload)
+    {
+      if (DisplayInfo) { showinfogui(); }
+      initsnes();
+    }
+
+    sramsavedis = 0;
+    memcpy(&sndrot, regsbackup, 3019);
+
+    if (yesoutofmemory) { asm_call(outofmemfix); }
+    asm_call(GUIDoReset);
+
+    if (romload)
+    {
+      GUIQuickLoadUpdate();
+
+      if (AutoLoadCht) { CheatCodeLoad(); }
+      if (AutoState) { LoadSecondState(); }
+    }
+  }
+}
+
+extern unsigned char osm2dis, ReturnFromSPCStall, SPCStallSetting, prevoamptr;
+extern unsigned char reg1read, reg2read, reg3read, reg4read, NMIEnab, INTEnab;
+extern unsigned char doirqnext, vidbright, forceblnk, timeron, spcP, JoyAPos, JoyBPos;
+extern unsigned char coladdr, coladdg, coladdb;
+extern unsigned char SDD1BankA,SDD1BankB, SDD1BankC, SDD1BankD;
+extern unsigned char intrset, curcyc, cycpl, GUIReset;
+extern unsigned int numspcvblleft, SPC700read, SPC700write, spc700idle;
+extern unsigned int FIRTAPVal0, FIRTAPVal1, FIRTAPVal2, FIRTAPVal3, FIRTAPVal4, FIRTAPVal5, FIRTAPVal6, FIRTAPVal7;
+extern unsigned int xa, xdb, xpb, xs, xd, xx, xy, scrndis;
+extern unsigned short VIRQLoc, resolutn, xpc;
+extern unsigned char spcextraram[64], SPCROM[64];
+extern unsigned int tableD[256];
+unsigned char SPCSkipXtraROM, bgfixer2 = 0, disableeffects = 0;
+//This is saved in states
+unsigned char cycpl = 0;   // cycles per scanline
+unsigned char cycphb = 0;    // cycles per hblank
+unsigned char intrset = 0;   // interrupt set
+unsigned short curypos = 0;    // current y position
+unsigned short stackand = 0x01FF; // value to and stack to keep it from going to the wrong area
+unsigned short stackor = 0x0100; // value to or stack to keep it from going to the wrong area
+
+// 65816 registers
+unsigned char xp = 0;
+unsigned char xe = 0;
+unsigned char xirqb = 0;           // which bank the irqs start at
+unsigned int Curtableaddr = 0;     // Current table address
+
+void SA1Reset();
+void InitC4();
+void RTCinit();
+void SPC7110init();
+
+void init65816()
+{
+    unsigned int i;
+    osm2dis = 0;
+    bgfixer2 = 0;
+    if(SA1Enable)
+    {
+      SA1Reset();
+      SetAddressingModesSA1();
+    }
+
+    if(C4Enable)
+    {
+      osm2dis = 1;
+      bgfixer2 = 1;
+      InitC4();
+    }
+
+    if(RTCEnable)
+      RTCinit();
+
+    if(SPC7110Enable)
+    {
+      if (!SPC7110IndexPtr) SPC7110IndexPtr = malloc(12*4608);
+      if (!SPC7110PackPtr) SPC7110PackPtr = malloc(65536);
+
+      if (SPC7110IndexPtr && SPC7110PackPtr)
+      {
+        SPC7PackIndexLoad();
+
+        SPC7110init();
+        map_mem(0x50, &SPC7110bank, 1);
+        map_mem(0x00, &SPC7110SRAMBank, 1);
+        map_mem(0x30, &SPC7110SRAMBank, 1);
+        snesmmap[0x50] = SPC7110PackPtr;
+        snesmap2[0x50] = SPC7110PackPtr;
+        memset(SPC7110PackPtr, 0, 0x10000);
+      }
+      else
+      {
+        puts("You don't have enough memory to run SPC7110 games!");
+        Msgptr = "MEMORY ERROR!";
+        MessageOn = 360;
+        return;
+      }
+    }
+    else
+    {
+      if (SPC7110IndexPtr) free(SPC7110IndexPtr);
+      if (SPC7110PackPtr) free(SPC7110PackPtr);
+    }
+
+    cycpb268 = 117;
+    cycpb358 = 127;
+    cycpbl2 = 117;
+    cycpblt2 = 117;
+    cycpbl = 117;
+    cycpblt = 117;
+
+    SPCSkipXtraROM = 0;
+    if(ReturnFromSPCStall)
+    {
+      cycpb268 = 69;
+      cycpb358 = 81;
+      cycpbl2 = 69;
+      cycpblt2 = 69;
+      cycpbl = 69;
+      cycpblt = 69;
+      SPCSkipXtraROM = 1;
+      if(SPCStallSetting == 2)
+      {
+        cycpb268 = 240;
+        cycpb358 = 240;
+        cycpbl = 240;
+        cycpblt = 240;
+        cycpbl2 = 240;
+        cycpblt2 = 240;
+        SPCSkipXtraROM = 0;
+      }
+    }
+    else
+    {
+      SPCStallSetting = 0;
+    }
+
+    numspcvblleft = 480;
+    SPC700write = 0;
+    SPC700read = 0;
+    spc700idle = 0;
+
+    for(i = 0;i<0x40;i++)
+    {
+      spcextraram[i] = 0xFF;
+      SPCRAM[0xFFC0+i] = SPCROM[i];
+    }
+
+    // Clear SPC Memory
+    clearSPCRAM();
+    clearvidsound();
+
+    prevoamptr = 0xFF;
+    disableeffects = 0;
+    opexec268 = opexec268b;
+    opexec358 = opexec358b;
+    opexec268cph = opexec268cphb;
+    opexec358cph = opexec358cphb;
+
+    if (!(((unsigned char *)romdata)[infoloc+BankOffset] & 0xF0)) // if not fastrom
+    {
+      opexec358 = opexec268;
+      opexec358cph = opexec268cph;
+      cycpb358 = cycpb268;
+    }
+
+    FIRTAPVal0 = 0x7F;
+    FIRTAPVal1 = 0;
+    FIRTAPVal2 = 0;
+    FIRTAPVal3 = 0;
+    FIRTAPVal4 = 0;
+    FIRTAPVal5 = 0;
+    FIRTAPVal6 = 0;
+    FIRTAPVal7 = 0;
+
+    // Check Headers
+    headerhack();
+
+    SPCRAM[0xF4] = 0;
+    SPCRAM[0xF5] = 0;
+    SPCRAM[0xF6] = 0;
+    SPCRAM[0xF7] = 0;
+    reg1read = 0;
+    reg2read = 0;
+    reg3read = 0;
+    reg4read = 0;
+    cycpbl = 0;
+    spcnumread = 0;
+    NMIEnab = 1;
+    VIRQLoc = 0;
+    doirqnext = 0;
+    resolutn = 224;
+    vidbright = 0;
+    forceblnk = 0;
+    spcP = 0;
+    timeron = 0;
+    JoyAPos = 0;
+    JoyBPos = 0;
+    coladdr = 0;
+    coladdg = 0;
+    coladdb = 0;
+    INTEnab = 0;
+    xa = 0;
+    xdb = 0;
+    xpb = 0;
+    xs = 0x01FF;
+    xd = 0;
+    xx = 0;
+    xy = 0;
+    SDD1BankA = 0;
+    SDD1BankB = 0x01;
+    SDD1BankC = 0x02;
+    SDD1BankD = 0x03;
+    xirqb = 0;
+    xp = 52;         // NVMXDIZC
+    xe = 1;          // E
+    xpc = resetv;
+
+    intrset = 0;
+
+    if (xpc < 0x8000)
+    {
+      xpc += 0x8000;
+      //xpb = 0x40;
+    }
+
+    // 2.68 Mhz  / 3.58 Mhz = 228
+    curcyc = cycpl = opexec268;
+    cycphb = opexec268cph;     // 2.68 Mhz  / 3.58 Mhz = 56
+    cycpbl = 110;              // 3.58Mhz = 175
+    cycpblt = 110;
+    curypos = 0;
+    Curtableaddr = *tableD;
+    scrndis = 0;
+    stackand = 0x01FF;
+    stackor = 0x0100;
+
+    nmiprevaddrl = 0;
+    nmiprevaddrh = 0;
+    nmirept = 0;
+    nmiprevline = 224;
+    nmistatus = 0;
+
+    if(GUIReset)
+    {
+      GUIReset = 0;
+    }
+
+    else
+    {
+      memset(wramdataa,0x55,0x10000);
+      memset(ram7fa, 0x55,0x10000);
+    }
+
+    if(BSEnable)
+    {
+      memset(wramdataa,0xFF,0x10000);
+      memset(ram7fa,0xFF,0x10000);
+      if(romtype == 1)
+        memset(ram7fa+65528, 0x01, 8);
+    }
+}
+
+void zexit()
+{
+  exit(0);
+}
+
diff --speed-large-files --minimal -Nru tmp/zsnes_1_51/src/zloader.c work/main.d/zsnes_1_51/src/zloader.c
--- tmp/zsnes_1_51/src/zloader.c	2007-01-24 18:30:18.000000000 -0300
+++ work/main.d/zsnes_1_51/src/zloader.c	2007-03-03 14:32:54.000000000 -0300
@@ -55,6 +55,7 @@
 extern unsigned char romtype, MouseDis, ZMVZClose, ZMVRawDump, debugger, debugdisble;
 extern unsigned char gammalevel, spcon, ForcePal, DSPDisable, V8Mode;
 extern unsigned char autoloadstate, autoloadmovie, MovieForcedLengthEnabled;
+extern char *cfgpath;
 extern char *STCart2;
 extern unsigned int NumInputDevices, MovieForcedLength;
 void zstart();
@@ -87,6 +88,7 @@
   put_line("Usage : zsnes [-d,-f #, ... ] <filename.sfc>");
   put_line("   Eg : zsnes -s -r 2 game.sfc");
   put_line("");
+  put_line("  -q      change default cfg path");
 #ifdef __MSDOS__
   put_line("  -0      Force black blackground in 8-bit modes");
 #endif
@@ -738,6 +740,12 @@
           case 'z': //Disable stereo sound
             StereoSound = 0;
             break;
+	 
+          case 'q': //Disable stereo sound
+            i++;
+		cfgpath = argv[i];
+		init_paths(*argv);
+            break;
 
           default:
             display_help();
diff --speed-large-files --minimal -Nru tmp/zsnes_1_51/src/zloader.c~ work/main.d/zsnes_1_51/src/zloader.c~
--- tmp/zsnes_1_51/src/zloader.c~	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/zsnes_1_51/src/zloader.c~	2007-03-03 14:31:11.000000000 -0300
@@ -0,0 +1,978 @@
+/*
+Copyright (C) 1997-2007 ZSNES Team ( zsKnight, _Demo_, pagefault, Nach )
+
+http://www.zsnes.com
+http://sourceforge.net/projects/zsnes
+https://zsnes.bountysource.com
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+version 2 as published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifdef __UNIXSDL__
+#include "gblhdr.h"
+#ifdef __LIBAO__
+#include <ao/ao.h>
+#endif
+#else
+#define _POSIX_
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <limits.h>
+#include <time.h>
+#ifdef __WIN32__
+#include <windows.h>
+#include <direct.h>
+#undef _POSIX_
+#include <io.h>
+#else
+#include <unistd.h>
+#endif
+#endif
+#include "asm_call.h"
+#include "cfg.h"
+#include "input.h"
+#include "zpath.h"
+#include "zloader.h"
+
+#ifdef __WIN32__
+void ImportDirectX();
+#endif
+
+
+extern unsigned char romtype, MouseDis, ZMVZClose, ZMVRawDump, debugger, debugdisble;
+extern unsigned char gammalevel, spcon, ForcePal, DSPDisable, V8Mode;
+extern unsigned char autoloadstate, autoloadmovie, MovieForcedLengthEnabled;
+extern char *STCart2;
+extern unsigned int NumInputDevices, MovieForcedLength;
+void zstart();
+#ifdef __WIN32__
+void InitDebugger();
+#endif
+
+#define put_line(x)                          \
+  if (tty && (lines_out == 22))              \
+  {                                          \
+    puts("  -- Press Enter to Continue --"); \
+    getchar();                               \
+    lines_out = 0;                           \
+  }                                          \
+  puts(x);                                   \
+  lines_out++;
+
+static void display_help()
+{
+  size_t lines_out = 0;
+  bool tty = isatty(fileno(stdout));
+#ifdef __UNIXSDL__
+#ifdef __LIBAO__
+  int driver_count;
+  ao_info **driver_info;
+#endif
+  char line[75];
+#endif
+
+  put_line("Usage : zsnes [-d,-f #, ... ] <filename.sfc>");
+  put_line("   Eg : zsnes -s -r 2 game.sfc");
+  put_line("");
+  put_line("  -q      change default cfg path");
+#ifdef __MSDOS__
+  put_line("  -0      Force black blackground in 8-bit modes");
+#endif
+  put_line("  -1 #/-2 #   Select Player 1/2 Input :");
+#ifdef __MSDOS__
+  put_line("                0 = None             1 = Keyboard         2 = 2 button pad");
+  put_line("                3 = 4 button pad     4 = 6 button pad     5 = 8 button pad");
+  put_line("                6 = Sidewinder #1    7 = Sidewinder #2    8 = Sidewinder #3");
+  put_line("                9 = Sidewinder #4   10 = Gamepad Pro #0  11 = Gamepad Pro #1");
+  put_line("               12 = LPT1 #1         13 = LPT1 #2         14 = LPT1 #3");
+  put_line("               15 = LPT1 #4         16 = LPT1 #5");
+#else
+  put_line("                0 = None       1 = Keyboard/Gamepad");
+#endif
+#ifndef __UNIXSDL__
+  put_line("  -3      Enable triple buffering (replaces vsync)");
+#endif
+#ifdef __WIN32__
+  put_line("  -6 #    Force a user-specified refresh rate for fullscreen modes [50..180]");
+#endif
+#ifdef __UNIXSDL__
+  put_line("  -ad <>  Select Audio Driver :");
+  snprintf(line, sizeof(line), "%22s = Automatically select output", "auto");
+  put_line(line);
+#ifdef __LIBAO__
+  driver_info = ao_driver_info_list(&driver_count);
+  while (driver_count--)
+  {
+    if (driver_info[driver_count]->type == AO_TYPE_LIVE)
+    {
+      snprintf(line, sizeof(line), "%22s = %s", driver_info[driver_count]->short_name, driver_info[driver_count]->name);
+      put_line(line);
+    }
+  }
+#endif
+  snprintf(line, sizeof(line), "%22s = Simple DirectMedia Layer output", "sdl");
+  put_line(line);
+#endif
+#ifdef __MSDOS__
+  put_line("  -8      Force 8-bit sound");
+  put_line("  -c      Enable full/wide screen (when available)");
+  put_line("  -cc     Enable small screen (when available)");
+#endif
+#ifndef NO_DEBUGGER
+  put_line("  -d      Start with debugger enabled");
+#endif
+  put_line("  -dd     Disable sound SPC700/DSP emulation which also disables sound output");
+  put_line("  -ds     Disable sound output");
+  put_line("  -dh     Disable ROM-specific hacks");
+  put_line("  -f #    Enable fixed frame rate [0..9]");
+  put_line("  -g #    Specify gamma correction value [0..15]");
+  put_line("  -h      Force HiROM");
+  put_line("  -j      Disable mouse (Automatically turns off right mouse click)");
+#ifndef __MSDOS__
+  put_line("  -js #   Set joystick sensitivity [0..32767]");
+#endif
+  put_line("  -k #    Set volume level [0..100]");
+#ifdef __WIN32__
+  put_line("  -kp     Enable the KitchenSync for PAL only");
+  put_line("  -ks     Enable the KitchenSync");
+#endif
+  put_line("  -l      Force LoROM");
+  put_line("  -m      Disable GUI (Must specify ROM filename)");
+  put_line("  -mc     Exit ZSNES when closing a movie (use with -zm)");
+  put_line("  -md #   Dump Video (use with -zm)");
+  put_line("             1 = Raw  2 = FFV1 3 = x264");
+  put_line("             4 = XviD 5 = Custom");
+  put_line("  -ml #   Define movie dump length in amount of frames (use with -md)");
+  put_line("  -n #    Enable scanlines (when available)");
+  put_line("             0 = None, 1 = Full, 2 = 25%, 3 = 50%");
+  put_line("  -o      Disable MMX support");
+  put_line("  -p #    Percentage of instructions to execute [50..150]");
+  put_line("  -r #    Set sound sampling rate:");
+  put_line("             0 = 8000Hz  1 = 11025Hz 2 = 22050Hz 3 = 44100Hz");
+  put_line("             4 = 16000Hz 5 = 32000Hz 6 = 48000Hz");
+  put_line("  -s      Enable sound output and enable SPC700/DSP emulation");
+  put_line("  -sa     Show all files in GUI (*.*)");
+#ifdef __MSDOS__
+  put_line("  -sp     Display sound information");
+#endif
+  put_line("  -t      Force NTSC timing");
+  put_line("  -u      Force PAL timing");
+  put_line("  -v #    Select video mode :");
+#ifdef __WIN32__
+#define VIDEO_MODE_COUNT 42
+  put_line("             0 = 256x224      R WIN     1 = 256x224      R FULL");
+  put_line("             2 = 512x448      R WIN     3 = 512x448     DR WIN");
+  put_line("             4 = 640x480      S WIN     5 = 640x480     DS WIN");
+  put_line("             6 = 640x480     DR FULL    7 = 640x480     DS FULL");
+  put_line("             8 = 640x480      S FULL    9 = 768x672      R WIN");
+  put_line("            10 = 768x672     DR WIN    11 = 800x600      S WIN");
+  put_line("            12 = 800x600     DS WIN    13 = 800x600      S FULL");
+  put_line("            14 = 800x600     DR FULL   15 = 800x600     DS FULL");
+  put_line("            16 = 1024x768     S WIN    17 = 1024x768    DS WIN");
+  put_line("            18 = 1024x768     S FULL   19 = 1024x768    DR FULL");
+  put_line("            20 = 1024x768    DS FULL   21 = 1024x896     R WIN");
+  put_line("            22 = 1024x896    DR WIN    23 = 1280x960     S WIN");
+  put_line("            24 = 1280x960    DS WIN    25 = 1280x960     S FULL");
+  put_line("            26 = 1280x960    DR FULL   27 = 1280x960    DS FULL");
+  put_line("            28 = 1280x1024    S WIN    29 = 1280x1024   DS WIN");
+  put_line("            30 = 1280x1024    S FULL   31 = 1280x1024   DR FULL");
+  put_line("            32 = 1280x1024   DS FULL   33 = 1600x1200    S WIN");
+  put_line("            34 = 1600x1200   DS WIN    35 = 1600x1200   DR FULL");
+  put_line("            36 = 1600x1200   DS FULL   37 = 1600x1200    S FULL");
+  put_line("            38 = CUSTOM      D  WIN    39 = CUSTOM      DS FULL");
+  put_line("            40 = CUSTOM         WIN    41 = CUSTOM       S FULL");
+  put_line("            42 = CUSTOM      DR FULL");
+#endif
+#ifdef __UNIXSDL__
+  put_line("             0 = 256x224      R WIN     1 = 256x224      R FULL");
+  put_line("             2 = 512x448     DR WIN     3 = 512x448     DR FULL");
+  put_line("             4 = 640x480     DR FULL");
+#ifndef __OPENGL__
+#define VIDEO_MODE_COUNT 4
+#else
+#define VIDEO_MODE_COUNT 22
+  put_line("             5 = 256x224    O R WIN     6 = 512x448    ODR WIN");
+  put_line("             7 = 640x480    ODS FULL    8 = 640x480    ODS WIN");
+  put_line("             9 = 640x560    ODR WIN    10 = 768x672    ODR WIN");
+  put_line("            11 = 800x600    ODS FULL   12 = 800x600    ODS WIN");
+  put_line("            13 = 896x784    ODR WIN    14 = 1024x768   ODS FULL");
+  put_line("            15 = 1024x768   ODS WIN    16 = 1024x896   ODR WIN");
+  put_line("            17 = 1280x960   ODS FULL   18 = 1280x1024  ODS FULL");
+  put_line("            19 = 1600x1200  ODS FULL   20 = VARIABLE   ODR WIN");
+  put_line("            21 = VARIABLE   ODS WIN    22 = CUSTOM     OD  FULL");
+#endif
+#endif
+#ifdef __MSDOS__
+#define VIDEO_MODE_COUNT 18
+  put_line("             0 = 256x224x8B   MODEQ     1 = 256x240x8B  MODEQ");
+  put_line("             2 = 256x256x8B   MODEQ     3 = 320x224x8B  MODEX");
+  put_line("             4 = 320x240x8B   MODEX     5 = 320x256x8B  MODEX");
+  put_line("             6 = 640x480x16B  VESA1     7 = 320x240x8B  VESA2");
+  put_line("             8 = 320x240x16B  VESA2     9 = 320x480x8B  VESA2");
+  put_line("            10 = 320x480x16B  VESA2    11 = 512x384x8B  VESA2");
+  put_line("            12 = 512x384x16B  VESA2    13 = 640x400x8B  VESA2");
+  put_line("            14 = 640x400x16B  VESA2    15 = 640x480x8B  VESA2");
+  put_line("            16 = 640x480x16B  VESA2    17 = 800x600x8B  VESA2");
+  put_line("            18 = 800x600x16B  VESA2");
+#endif
+  put_line("  -v8     Grayscale mode");
+#ifndef __UNIXSDL__
+  put_line("  -w      Enable vsync (disables triple buffering)");
+#endif
+  put_line("  -y      Enable anti-aliasing (video interpolation)");
+  put_line("  -z      Disable stereo sound");
+  put_line("  -zm #   Auto load specified movie slot on startup [0..9]");
+  put_line("  -zs #   Auto load specified save state slot on startup [0..99]");
+  put_line("");
+  put_line("  File Formats Supported by GUI : SMC,SFC,SWC,FIG,MGD,MGH,UFO,BIN,");
+  put_line("                                  GD3,GD7,USA,EUR,JAP,AUS,ST,BS,");
+  put_line("                                  DX2,048,058,078,1,A,GZ,ZIP,JMA");
+  put_line("");
+#ifndef __UNIXSDL__
+  put_line("  Microsoft-style options (/option) are also accepted");
+#endif
+/*
+#ifndef __MSDOS__
+  put_line("               --Netplay Parameters--");
+  put_line(" Commandline: /ABCDE <nickname> <fname> <IP Addy>");
+  put_line("   nickname = user nickname");
+  put_line("   fname = filename w/ full path (if L) or path name (if C)");
+  put_line("   IP Addy = IP Address (Client Only)");
+  put_line(" A = U (UDP - Recommended if works), T (TCP/IP)");
+  put_line(" B = S (Server), C (Client)");
+  put_line(" C = C (Chat first), L (load game first)");
+  put_line(" D = N (Stay in ZSNES after disconnect), Q (Quit after disconnect)");
+  put_line(" E = # of connections (Keep it 2 for now)");
+#ifdef __WIN32__
+  put_line("   eg: ZSNESW /UCCN2 nickname d:\\snesroms 202.36.124.28");
+#else
+  put_line("   eg: zsnes /UCCN2 nickname /home/zuser/snesroms 202.36.124.28");
+#endif
+#endif
+*/
+
+  exit(1);
+}
+
+#define ConvertJoyMapHelp(a,b) if (b && (a == b)) { b += 0x81; }
+
+void ConvertJoyMap1()
+{
+  unsigned int bl;
+  // Convert if 2,4,6, or sidewinder
+  if (pl1contrl == 2)
+  {
+    pl1Bk = 0x83;
+    pl1Yk = 0x82;
+    pl1upk = 0xCC;
+    pl1downk = 0xCD;
+    pl1leftk = 0xCE;
+    pl1rightk = 0xCF;
+  }
+
+  bl = (pl1contrl == 3 || pl1contrl == 4) ? 4 : 0;
+  if (pl1contrl == 5) { bl = 6; }
+
+  if (bl)
+  {
+    // Convert button data
+    pl1upk = 0xCC;
+    pl1downk = 0xCD;
+    pl1leftk = 0xCE;
+    pl1rightk = 0xCF;
+    ConvertJoyMapHelp(bl, pl1startk);
+    ConvertJoyMapHelp(bl, pl1selk);
+    ConvertJoyMapHelp(bl, pl1Yk);
+    ConvertJoyMapHelp(bl, pl1Xk);
+    ConvertJoyMapHelp(bl, pl1Bk);
+    ConvertJoyMapHelp(bl, pl1Ak);
+    ConvertJoyMapHelp(bl, pl1Lk);
+    ConvertJoyMapHelp(bl, pl1Rk);
+  }
+
+  if (pl1contrl == 6)
+  {
+    pl1upk = 0xD4;
+    pl1downk = 0xD5;
+    pl1leftk = 0xD6;
+    pl1rightk = 0xD7;
+    pl1startk = 0xC8;
+    pl1selk = 0xC9;
+    pl1Ak = 0x89;
+    pl1Bk = 0x88;
+    pl1Xk = 0x8C;
+    pl1Yk = 0x8B;
+    pl1Lk = 0x8E;
+    pl1Rk = 0x8F;
+  }
+  return;
+}
+
+void ConvertJoyMap2()
+{
+  unsigned int bl;
+  //If pl1contrl=2 and pl2contrl=2, then set pl2 buttons to 3 & 4
+  if (pl2contrl == 2)
+  {
+    if (pl1contrl != 2)
+    {
+      pl2Bk = 0x83;
+      pl2Yk = 0x82;
+      pl2upk = 0xCC;
+      pl2downk = 0xCD;
+      pl2leftk = 0xCE;
+      pl2rightk = 0xCF;
+    }
+    else
+    {
+      pl2Bk = 0x85;
+      pl2Yk = 0x84;
+      pl2upk = 0xE8;
+      pl2downk = 0xE9;
+      pl2leftk = 0xEA;
+      pl2rightk = 0xEB;
+    }
+  }
+
+  bl = (pl2contrl == 3 || pl2contrl == 4) ? 4 : 0;
+  if (pl2contrl == 5) { bl = 6; }
+
+  if (bl)
+  {
+    //Convert button data
+    pl2upk = 0xCC;
+    pl2downk = 0xCD;
+    pl2leftk = 0xCE;
+    pl2rightk = 0xCF;
+    ConvertJoyMapHelp(bl, pl2startk);
+    ConvertJoyMapHelp(bl, pl2selk);
+    ConvertJoyMapHelp(bl, pl2Yk);
+    ConvertJoyMapHelp(bl, pl2Xk);
+    ConvertJoyMapHelp(bl, pl2Bk);
+    ConvertJoyMapHelp(bl, pl2Ak);
+    ConvertJoyMapHelp(bl, pl2Lk);
+    ConvertJoyMapHelp(bl, pl2Rk);
+  }
+
+  //If both sidewinder, set pl2 buttons to sw2
+  if (pl2contrl == 6)
+  {
+    if (pl1contrl != 6)
+    {
+      pl2upk = 0xD4;
+      pl2downk = 0xD5;
+      pl2leftk = 0xD6;
+      pl2rightk = 0xD7;
+      pl2startk = 0xC8;
+      pl2selk = 0xC9;
+      pl2Ak = 0x89;
+      pl2Bk = 0x88;
+      pl2Xk = 0x8C;
+      pl2Yk = 0x8B;
+      pl2Lk = 0x8E;
+      pl2Rk = 0x8F;
+    }
+    else
+    {
+      pl2contrl = 7;
+      pl2upk = 0xDC;
+      pl2downk = 0xDD;
+      pl2leftk = 0xDE;
+      pl2rightk = 0xDF;
+      pl2startk = 0xD0;
+      pl2selk = 0xD1;
+      pl2Ak = 0x91;
+      pl2Bk = 0x90;
+      pl2Xk = 0x94;
+      pl2Yk = 0x93;
+      pl2Lk = 0x96;
+      pl2Rk = 0x97;
+    }
+  }
+  return;
+}
+
+struct backup_cmdline_vars saved_cmdline_vars;
+
+#ifdef __MSDOS__
+#define BACKUP_HELP_DOS(func) \
+  func(Palette0); \
+
+#else
+#define BACKUP_HELP_DOS(func)
+#endif
+
+#ifdef __WIN32__
+#define BACKUP_HELP_WIN(func) \
+  func(KitchenSync); \
+  func(KitchenSyncPAL); \
+  func(ForceRefreshRate); \
+  func(SetRefreshRate); \
+  func(joy_sensitivity); \
+
+#else
+#define BACKUP_HELP_WIN(func)
+#endif
+
+#ifdef __UNIXSDL__
+#define BACKUP_HELP_SDL(func) \
+func(joy_sensitivity); \
+
+#else
+#define BACKUP_HELP_SDL(func)
+#endif
+
+
+#define BACKUP_HELP(func) \
+  func(guioff) \
+  func(per2exec) \
+  func(HacksDisable) \
+  func(AllowMMX) \
+  BACKUP_HELP_DOS(func) \
+  BACKUP_HELP_WIN(func) \
+  BACKUP_HELP_SDL(func)
+
+#define BACKUP_VAR(var) saved_cmdline_vars._ ## var = var;
+static void backup_all_vars()
+{
+  BACKUP_HELP(BACKUP_VAR)
+}
+
+#define SWAP_BACKUP_VAR(var) \
+  saved_cmdline_vars._ ## var ^= var; \
+  var ^= saved_cmdline_vars._ ## var; \
+  saved_cmdline_vars._ ## var ^= var;
+void swap_backup_vars()
+{
+  BACKUP_HELP(SWAP_BACKUP_VAR)
+}
+
+static size_t zatoi(const char *str)
+{
+  const char *orig_str = str;
+  if (str)
+  {
+    while (*str)
+    {
+      if (!isdigit(*str++)) { return(~0); }
+    }
+    return((size_t)atoi(orig_str));
+  }
+  return(~0);
+}
+
+static void handle_params(int argc, char *argv[])
+{
+  int i;
+
+  backup_all_vars();
+
+  #ifndef __MSDOS__
+
+  /*
+  if (argc >= 5 && argv[1][0] == '/' && strlen(argv[1]) == 6)
+  {
+    size_t i = 0, j = 0;
+    char *strp;
+
+    if (toupper(argv[1][1]) == 'T') UDPConfig=0;
+
+    //Next should be # of connections
+
+    while (argv[2][i]!=0)
+    {
+      switch (argv[2][i])
+      {
+        case '_':
+        case '-':
+        case '^':
+        case '=':
+        case '+':
+        case '[':
+        case ']':
+        if ( j < 10)
+        {
+          strp[j] = argv[2][i];
+          j++;
+        }
+        break;
+
+        default:
+          if (((toupper(argv[2][i]) >= 'A') && (toupper(argv[2][i]) <= 'Z')) ||
+              ((argv[2][i] >= '0') && (argv[2][i] <= '9')))
+          {
+            if (j < 10)
+            {
+              strp[j] = argv[2][i];
+              j++;
+            }
+          }
+          break;
+      }
+      i++;
+    }
+    strp[j] = 0;
+
+  }
+  */
+  #endif
+
+  for (i = 1; i < argc; i++)
+  {
+    #ifndef __UNIXSDL__
+    if (argv[i][0] == '-' || argv[i][0] == '/')
+    #else
+    if (argv[i][0] == '-')
+    #endif
+    {
+      if (!argv[i][1]) //Nothing but a - or /
+      {
+        display_help();
+      }
+      else if (!argv[i][2]) //- followed by a single letter
+      {
+        switch (tolower(argv[i][1]))
+        {
+          #ifdef __MSDOS__
+          case '0': //Palette color 0 disable
+            Palette0 = 1;
+            break;
+          #endif
+
+          case '1': //Player 1 Input
+            i++;
+
+            if ((pl1contrl = zatoi(argv[i])) >= NumInputDevices)
+            {
+              printf("Player 1 Input must be a value from 0 to %u!\n", NumInputDevices);
+              exit(1);
+            }
+
+            ConvertJoyMap1();
+            break;
+
+          case '2': //Player 2 Input
+            i++;
+
+            if ((pl2contrl = zatoi(argv[i])) > NumInputDevices)
+            {
+              printf("Player 2 Input must be a value from 0 to %u!\n", NumInputDevices);
+              exit(1);
+            }
+
+            ConvertJoyMap2();
+            break;
+
+          #ifndef __UNIXSDL__
+          case '3': //Enable triple buffering for DOS/Windows
+            vsyncon = 0;
+          #ifdef __MSDOS__
+            Triplebufen = 1;
+          #elif __WIN32__
+            TripleBufferWin = 1;
+          #endif
+            break;
+          #endif
+
+          #ifdef __WIN32__
+          case '6': //Force Refresh Rate
+            i++;
+            SetRefreshRate = zatoi(argv[i]);
+            if((SetRefreshRate < 50) || (SetRefreshRate > 180))
+            {
+              ForceRefreshRate = 0;
+              puts("Refresh Rate must be a value 50 to 180!");
+              exit(1);
+            }
+            else
+            {
+              ForceRefreshRate = 1;
+            }
+            break;
+          #endif
+
+          #ifdef __MSDOS__
+          case '8': //Force 8-bit sound
+            Force8b = 1;
+            break;
+
+          case 'c': //Enable full screen (when available)
+            ScreenScale = 1;
+            break;
+          #endif
+
+          #ifndef NO_DEBUGGER
+          case 'd': //Start with debugger enabled
+            debugger = 1;
+            debugdisble = 0;
+          #ifdef __WIN32__
+            InitDebugger();
+          #endif
+            break;
+          #endif
+
+          case 'f': //Enable fixed frame rate
+            i++;
+            if ((frameskip = zatoi(argv[i])+1) > 10)
+            {
+              puts("Frame Skip must be a value of 0 to 9!");
+              exit(1);
+            }
+            break;
+
+          case 'g': //Specify gamma correction value
+            i++;
+            if ((gammalevel = zatoi(argv[i])) > 15)
+            {
+              puts("Gamma Correction Level must be a value of 0 to 15!");
+              exit(1);
+            }
+            break;
+
+          case 'h': //Force HiROM
+            romtype = 2;
+            break;
+
+          case 'j': //Disable mouse
+            MouseDis = 1;
+            break;
+
+          case 'k': //Set volume level
+            i++;
+            if ((MusicRelVol = zatoi(argv[i])) > 100)
+            {
+              puts("Volume must be a value from 0 to 100!");
+              exit(1);
+            }
+            break;
+
+          case 'l': //Force LoROM
+            romtype = 1;
+            break;
+
+          case 'm': //Disable GUI
+            guioff = 1;
+            break;
+
+          case 'n': //Enable scanlines (when available)
+            i++;
+            if ((scanlines = zatoi(argv[i])) > 3)
+            {
+              puts("Scanlines must be a value 0 to 3!");
+              exit(1);
+            }
+            break;
+
+          case 'o': //Disable MMX support
+            AllowMMX = 0;
+            break;
+
+          case 'p': //Percentage of instructions to execute
+            i++;
+            per2exec = zatoi(argv[i]);
+            if (per2exec > 150 || per2exec < 50)
+            {
+              puts("Percentage of instructions to execute must be a value from 50 to 150!");
+              exit(1);
+            }
+            break;
+
+          case 'r': //Set sampling rate
+            i++;
+            if ((SoundQuality = zatoi(argv[i])) > 6)
+            {
+              puts("Sound Sampling Rate must be a value of 0 to 6!");
+              exit(1);
+            }
+            break;
+
+          case 's': //Enable sound output, and SPC700/DSP emulation
+            spcon = 1;
+            soundon = 1;
+            break;
+
+          case 't': //Force NTSC
+            ForcePal = 1;
+            break;
+
+          case 'u': //Force PAL
+            ForcePal = 2;
+            break;
+
+          case 'v': //Select video mode
+            i++;
+            if ((cvidmode = zatoi(argv[i])) > VIDEO_MODE_COUNT)
+            {
+              puts("Invalid Video Mode!");
+              exit(1);
+            }
+            break;
+
+          #ifndef __UNIXSDL__
+          case 'w': //Enable vsync for DOS/Windows
+            vsyncon = 1;
+          #ifdef __MSDOS__
+            Triplebufen = 0;
+          #elif __WIN32__
+            TripleBufferWin = 0;
+          #endif
+            break;
+          #endif
+
+          case 'y': //Enable anti-aliasing
+            antienab = 1;
+            break;
+
+          case 'z': //Disable stereo sound
+            StereoSound = 0;
+            break;
+	 
+          case 'q': //Disable stereo sound
+            i++;
+		cfgpath = argv[i];
+		init_paths(*argv);
+            break;
+
+          default:
+            display_help();
+            break;
+        }
+      }
+      else if (!argv[i][3]) //- followed by two letters
+      {
+        if (tolower(argv[i][1]) == 'd' && tolower(argv[i][2]) == 'd') //Disable sound DSP emulation
+        {
+          DSPDisable = 1;
+        }
+
+        #ifdef __UNIXSDL__
+        else if (tolower(argv[i][1]) == 'a' && tolower(argv[i][2]) == 'd') //Disable sound DSP emulation
+        {
+          i++;
+          if (!argv[i])
+          {
+            display_help();
+          }
+
+          #ifdef __LIBAO__
+          if (!strcmp(argv[i], "auto") || !strcmp(argv[i], "sdl") || (ao_driver_id(argv[i]) >= 0))
+          #else
+          if (!strcmp(argv[i], "auto") || !strcmp(argv[i], "sdl"))
+          #endif
+          {
+            strcpy(libAoDriver, argv[i]);
+          }
+          else
+          {
+            puts("Audio driver selection invalid.");
+            exit(1);
+          }
+        }
+        #endif
+
+        else if (tolower(argv[i][1]) == 'd' && tolower(argv[i][2]) == 's') //Disable sound output
+        {
+          soundon = 0;
+        }
+
+        #ifdef __MSDOS__
+        else if (tolower(argv[i][1]) == 'c' && tolower(argv[i][2]) == 'c') //Enable small screen (when available)
+        {
+          smallscreenon = 1;
+        }
+        #endif
+
+        else if (tolower(argv[i][1]) == 'd' && tolower(argv[i][2]) == 'h') //Disable hacks
+        {
+          HacksDisable = 1;
+        }
+
+        #ifndef __MSDOS__
+        else if (tolower(argv[i][1]) == 'j' && tolower(argv[i][2]) == 's') //Set joystick sensitivity
+        {
+          i++;
+          if ((joy_sensitivity = zatoi(argv[i])+1) > 32767)
+          {
+            puts("Joystick sensitivity must be a value of 0 to 32767!");
+            exit(1);
+          }
+        }
+        #endif
+
+        #ifdef __WIN32__
+        else if (tolower(argv[i][1]) == 'k' && tolower(argv[i][2]) == 's') //Enable KitchenSync
+        {
+          KitchenSync = 1;
+        }
+        #endif
+
+        #ifdef __WIN32__
+        else if (tolower(argv[i][1]) == 'k' && tolower(argv[i][2]) == 'p') //Enable KitchenSync for PAL only
+        {
+          KitchenSyncPAL = 1;
+          KitchenSync = 0;
+        }
+        #endif
+
+        else if (tolower(argv[i][1]) == 'm' && tolower(argv[i][2]) == 'c') //Close ZSNES when ZMV closes
+        {
+          ZMVZClose = 1;
+        }
+
+        else if (tolower(argv[i][1]) == 'm' && tolower(argv[i][2]) == 'd') //Dump raw vid with ZMV
+        {
+          i++;
+          if ((ZMVRawDump = zatoi(argv[i])) > 5)
+          {
+            puts("Movie mode must be a number 1 to 5");
+            exit(1);
+          }
+        }
+
+        else if (tolower(argv[i][1]) == 'm' && tolower(argv[i][2]) == 'l') //Force ZMV length
+        {
+          i++;
+          MovieForcedLengthEnabled = true;
+          MovieForcedLength = zatoi(argv[i]);
+        }
+
+        #ifdef __MSDOS__
+        else if (tolower(argv[i][1]) == 's' && tolower(argv[i][2]) == 'p') //Display sound information
+        {
+          DisplayS = 1;
+        }
+        #endif
+
+        else if (tolower(argv[i][1]) == 's' && tolower(argv[i][2]) == 'a') //Show all extensions in GUI
+        {
+          showallext = 1;
+        }
+
+        else if (tolower(argv[i][1]) == 'v' && argv[i][2] == '8') //V8 Mode
+        {
+          V8Mode = 1;
+        }
+
+        else if (tolower(argv[i][1]) == 'z' && tolower(argv[i][2]) == 's') //Autoload save state
+        {
+          i++;
+          if ((autoloadstate = zatoi(argv[i])+1) > 100)
+          {
+            puts("State load position must be a value of 0 to 99!");
+            exit(1);
+          }
+        }
+
+        else if (tolower(argv[i][1]) == 'z' && tolower(argv[i][2]) == 'm') //Autoload movie
+        {
+          i++;
+          if ((autoloadmovie = zatoi(argv[i])+1) > 10)
+          {
+            puts("Movie load position must be a value of 0 to 9!");
+            exit(1);
+          }
+        }
+
+        else
+        {
+          display_help();
+          break;
+        }
+      }
+      else //- followed by more than 2 letters
+      {
+        display_help();
+      }
+    }
+    else //Param with no - or / prefix
+    {
+      if (argv[i] && !init_rom_path(argv[i]))
+      {
+        printf("Could not load: %s\n", argv[i]);
+      }
+
+      if ((STCart2 = argv[i+1])) //Sufami Turbo second cart
+      {
+        char *p;
+
+        natify_slashes(STCart2);
+        p = strrchr(STCart2, DIR_SLASH_C);
+        if (!p) { p = STCart2; }
+        else { p++; }
+        strcpy(ZSaveST2Name, p);
+        setextension(ZSaveST2Name, "srm");
+      }
+      break;
+    }
+  }
+}
+
+static void ZCleanup(void)
+{
+  void deinit_paths();
+  void deallocmem();
+  void DeallocRewindBuffer();
+  void DeallocPauseFrame();
+  void DeallocSystemVars();
+  void free_all_file_lists();
+#ifdef __UNIXSDL__
+  void UnloadSDL();
+#endif
+
+  deinit_paths();
+  deallocmem();
+  DeallocRewindBuffer();
+  DeallocPauseFrame();
+  DeallocSystemVars();
+  free_all_file_lists();
+#ifdef __UNIXSDL__
+  UnloadSDL();
+#endif
+
+}
+
+void zmain(int zargc, char *zargv[])
+{
+  if (init_paths(*zargv))
+  {
+    #ifdef __LIBAO__
+    ao_initialize();
+    atexit(ao_shutdown);
+    #endif
+    handle_params(zargc, zargv);
+
+    atexit(ZCleanup);
+    srand(time(0));
+    zstart();
+  }
+}
+
+#ifdef __WIN32__
+extern HINSTANCE hInst;
+int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
+{
+  hInst=hInstance;
+  ImportDirectX();
+  zmain(__argc, __argv);
+  return(0);
+}
+#else
+int main(int zargc, char *zargv[])
+{
+  zmain(zargc, zargv);
+  return(0);
+}
+#endif
diff --speed-large-files --minimal -Nru tmp/zsnes_1_51/src/zloader.c.rej work/main.d/zsnes_1_51/src/zloader.c.rej
--- tmp/zsnes_1_51/src/zloader.c.rej	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/zsnes_1_51/src/zloader.c.rej	2007-03-03 14:31:11.000000000 -0300
@@ -0,0 +1,16 @@
+***************
+*** 50,55 ****
+  extern unsigned char romtype, MouseDis, ZMVZClose, ZMVRawDump, debugger, debugdisble;
+  extern unsigned char gammalevel, spcon, ForcePal, DSPDisable, V8Mode;
+  extern unsigned char autoloadstate, autoloadmovie;
+  extern char *STCart2;
+  extern unsigned int NumInputDevices;
+  void zstart();
+--- 50,56 ----
+  extern unsigned char romtype, MouseDis, ZMVZClose, ZMVRawDump, debugger, debugdisble;
+  extern unsigned char gammalevel, spcon, ForcePal, DSPDisable, V8Mode;
+  extern unsigned char autoloadstate, autoloadmovie;
++ extern char *cfgpath;
+  extern char *STCart2;
+  extern unsigned int NumInputDevices;
+  void zstart();
diff --speed-large-files --minimal -Nru tmp/zsnes_1_51/src/zpath.c work/main.d/zsnes_1_51/src/zpath.c
--- tmp/zsnes_1_51/src/zpath.c	2007-01-15 17:47:53.000000000 -0300
+++ work/main.d/zsnes_1_51/src/zpath.c	2007-03-03 14:31:11.000000000 -0300
@@ -62,6 +62,8 @@
 static bool ZStartAlloc = false, ZCfgAlloc = false, ZSramAlloc = false, ZRomAlloc = false;
 static bool ZCartAlloc = false, ZSaveAlloc = false, ZStateAlloc = false, ZSaveST2Alloc = false;
 
+extern char *cfgpath;
+
 #ifdef __UNIXSDL__
 
 void cfgpath_ensure(const char *launch_command)
@@ -91,7 +93,10 @@
     struct stat stat_buffer;
 
     ZCfgAlloc = true;
-    strcpy(ZCfgPath, userinfo->pw_dir);
+    if (cfgpath)
+	strcpy(ZCfgPath, cfgpath); 
+    else
+	strcpy(ZCfgPath, userinfo->pw_dir);
     strcatslash(ZCfgPath);
     strcat(ZCfgPath, zpath);
 
diff --speed-large-files --minimal -Nru tmp/zsnes_1_51/src/zpath.c~ work/main.d/zsnes_1_51/src/zpath.c~
--- tmp/zsnes_1_51/src/zpath.c~	1969-12-31 21:00:00.000000000 -0300
+++ work/main.d/zsnes_1_51/src/zpath.c~	2007-01-15 17:47:53.000000000 -0300
@@ -0,0 +1,710 @@
+/*
+Copyright (C) 1997-2007 ZSNES Team ( zsKnight, _Demo_, pagefault, Nach )
+
+http://www.zsnes.com
+http://sourceforge.net/projects/zsnes
+https://zsnes.bountysource.com
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+version 2 as published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifdef __UNIXSDL__
+#include "gblhdr.h"
+#include "linux/safelib.h"
+#include <pwd.h>
+#else
+#ifdef __WIN32__
+#include <io.h>
+#include <direct.h>
+#include "win/safelib.h"
+#include "win/lib.h"
+#else
+#include "dos/lib.h"
+#include <unistd.h>
+#endif
+#include <string.h>
+#include <stdlib.h>
+#endif
+#include <errno.h>
+
+#include "zpath.h"
+#include "cfg.h"
+
+#ifdef __WIN32__
+#define mkdir_p(path) mkdir(path)
+#else
+#define mkdir_p(path) mkdir(path, mmode)
+#endif
+
+#ifdef __MSDOS__
+char ZCfgFile[] = "zsnes.cfg";
+#elif defined(__WIN32__)
+char ZCfgFile[] = "zsnesw.cfg";
+#else
+char ZCfgFile[] = "zsnesl.cfg";
+#endif
+
+char *ZStartPath = 0, *ZCfgPath = 0, *ZSramPath = 0, *ZRomPath = 0;
+char *ZSnapPath = 0, *ZSpcPath = 0;
+char *ZCartName = 0, *ZSaveName = 0, *ZStateName = 0, *ZSaveST2Name = 0;
+
+static bool ZStartAlloc = false, ZCfgAlloc = false, ZSramAlloc = false, ZRomAlloc = false;
+static bool ZCartAlloc = false, ZSaveAlloc = false, ZStateAlloc = false, ZSaveST2Alloc = false;
+
+#ifdef __UNIXSDL__
+
+void cfgpath_ensure(const char *launch_command)
+{
+  struct passwd *userinfo;
+#ifdef ZCONF
+  const char *const zpath = ZCONF;
+#else
+#ifndef __MACOSX__
+  const char *const zpath = ".zsnes";
+#else
+  const char *const zpath = "Library/Application Support/ZSNES";
+#endif
+#endif
+
+  if ((userinfo = getpwuid(getuid())))
+  {
+    ZCfgPath = malloc(PATH_SIZE);
+  }
+  else
+  {
+    puts("Error obtaining info about your user.");
+  }
+
+  if (ZCfgPath)
+  {
+    struct stat stat_buffer;
+
+    ZCfgAlloc = true;
+    strcpy(ZCfgPath, userinfo->pw_dir);
+    strcatslash(ZCfgPath);
+    strcat(ZCfgPath, zpath);
+
+    if (mkpath(ZCfgPath, 0755) && !stat(ZCfgPath, &stat_buffer) && S_ISDIR(stat_buffer.st_mode) && !access(ZCfgPath, W_OK))
+    {
+      strcatslash(ZCfgPath);
+    }
+    else
+    {
+      printf("Error creating: %s\n", ZCfgPath);
+      free(ZCfgPath);
+      ZCfgAlloc = false;
+
+      ZCfgPath = ZStartPath;
+    }
+  }
+  else
+  {
+    ZCfgPath = ZStartPath;
+  }
+}
+
+#else
+
+void cfgpath_ensure(const char *launch_command)
+{
+  ZCfgPath = malloc(PATH_SIZE);
+  if (ZCfgPath)
+  {
+    char *p = 0;
+    ZCfgAlloc = true;
+
+    if (isextension(launch_command, "exe"))
+    {
+      p = realpath(launch_command, ZCfgPath);
+    }
+    else
+    {
+      char buff[PATH_SIZE];
+      strcpy(buff, launch_command);
+      setextension(buff, "exe");
+      p = realpath(buff, ZCfgPath);
+    }
+
+    if (p)
+    {
+      strdirname(ZCfgPath);
+      strcatslash(ZCfgPath);
+    }
+    else
+    {
+      free(ZCfgPath);
+      ZCfgAlloc = false;
+      ZCfgPath = ZStartPath;
+    }
+  }
+  else
+  {
+    ZCfgPath = ZStartPath;
+  }
+}
+
+#endif
+
+void SaveGameSpecificInput();
+
+void deinit_paths()
+{
+  //Save data that depends on paths before deinit of them
+  void SaveSramData();
+  void GUISaveVars();
+
+  strcpy(ROMPath, ZRomPath);
+
+  SaveSramData();
+  GUISaveVars();
+  SaveGameSpecificInput();
+
+  //Now deallocate the paths
+  if (ZStartAlloc && ZStartPath) { free(ZStartPath); }
+  if (ZCfgAlloc && ZCfgPath) { free(ZCfgPath); }
+  if (ZSramAlloc && ZSramPath) { free(ZSramPath); }
+  if (ZRomAlloc && ZRomPath) { free(ZRomPath); }
+
+  if (ZCartAlloc && ZCartName) { free(ZCartName); }
+  if (ZSaveAlloc && ZSaveName) { free(ZSaveName); }
+  if (ZStateAlloc && ZStateName) { free(ZStateName); }
+  if (ZSaveST2Alloc && ZSaveST2Name) { free(ZSaveST2Name); }
+}
+
+#define INIT_PATH_HELPER(x) if ((x##Path = malloc(PATH_SIZE))) { x##Alloc = true; } else { return(false); }
+#define INIT_NAME_HELPER(x) if ((x##Name = malloc(NAME_SIZE))) { x##Alloc = true; *x##Name = 0; } else { return(false); }
+
+bool init_paths(char *launch_command)
+{
+  void GUIRestoreVars();
+
+  INIT_PATH_HELPER(ZStart);
+  INIT_PATH_HELPER(ZRom);
+  INIT_NAME_HELPER(ZCart);
+  INIT_NAME_HELPER(ZSave);
+  INIT_NAME_HELPER(ZState);
+  INIT_NAME_HELPER(ZSaveST2);
+
+  if (getcwd(ZStartPath, PATH_SIZE))
+  {
+    strcatslash(ZStartPath);
+
+    cfgpath_ensure(launch_command);
+
+    GUIRestoreVars();
+
+    if (*ROMPath && !access(strcutslash(ROMPath), DIR_R_ACCESS))
+    {
+      strcpy(ZRomPath, ROMPath);
+    }
+    else
+    {
+      strcpy(ZRomPath, ZStartPath);
+    }
+    strcatslash(ZRomPath);
+
+    init_save_paths();
+
+#ifdef DEBUG
+#ifndef __UNIXSDL__
+    fdreopen_dir(ZCfgPath, "stderr.txt", "w", STDERR_FILENO);
+    fdreopen_dir(ZCfgPath, "stdout.txt", "w", STDOUT_FILENO);
+#endif
+
+    printf("ZStartPath: %s\n", ZStartPath);
+    printf("ZCfgPath: %s\n", ZCfgPath);
+    printf("ZRomPath: %s\n", ZRomPath);
+    printf("ZSramPath: %s\n", ZSramPath);
+    printf("ZSnapPath: %s\n", ZSnapPath);
+    printf("ZSpcPath: %s\n", ZSpcPath);
+#endif
+    return(true);
+  }
+  return(false);
+}
+
+void init_save_paths()
+{
+  if (*SRAMPath)
+  {
+    ZSramPath = SRAMPath;
+  }
+  else
+  {
+    #ifdef __UNIXSDL__
+    ZSramPath = ZCfgPath;
+    #else
+    ZSramPath = ZRomPath;
+    #endif
+  }
+  strcatslash(ZSramPath);
+
+  if (*SnapPath)
+  {
+    ZSnapPath = SnapPath;
+  }
+  else
+  {
+    ZSnapPath = ZSramPath;
+  }
+  strcatslash(ZSnapPath);
+
+  if (*SPCPath)
+  {
+    ZSpcPath = SPCPath;
+  }
+  else
+  {
+    ZSpcPath = ZSramPath;
+  }
+  strcatslash(ZSpcPath);
+}
+
+bool init_rom_path(char *path)
+{
+  if (realpath_link(path, ZRomPath))
+  {
+    char *p;
+    SaveGameSpecificInput();
+
+    natify_slashes(ZRomPath);
+    p = strrchr(ZRomPath, DIR_SLASH_C);
+    strcpy(ZCartName, (p) ? p+1 : ZRomPath);
+    strcpy(ZSaveName, ZCartName);
+    strcpy(ZStateName, ZCartName);
+    setextension(ZStateName, "zst");
+
+    strdirname(ZRomPath);
+    strcatslash(ZRomPath);
+
+#ifdef DEBUG
+    printf("ZRomPath: %s\n", ZRomPath);
+    printf("ZCartName: %s\n", ZCartName);
+    printf("ZStateName: %s\n", ZStateName);
+#endif
+
+    return(true);
+  }
+  return(false);
+}
+
+char *strdupcat(const char *str1, const char *str2)
+{
+  char *strnew = malloc(strlen(str1)+strlen(str2)+1);
+  if (strnew)
+  {
+    strcpy(strnew, str1);
+    strcat(strnew, str2);
+    return(strnew);
+  }
+  return(0);
+}
+
+#ifndef DEBUG
+//This function is only for this file, and it uses an internal buffer, and is intended for path file merging
+static const char *strdupcat_internal(const char *path, const char *file)
+{
+  static char buffer_dir[PATH_SIZE*2];
+  if (!IS_ABSOLUTE(file))
+  {
+    strcpy(buffer_dir, path);
+  }
+  else
+  {
+    *buffer_dir = 0;
+  }
+  strcat(buffer_dir, file);
+  return(buffer_dir);
+}
+
+#define chdir_dir(path) chdir(path);
+
+#else
+
+static const char *strdupcat_internal(const char *path, const char *file, const char *func, const char *mode)
+{
+  static char buffer_dir[PATH_SIZE*2];
+  if (!IS_ABSOLUTE(file))
+  {
+    strcpy(buffer_dir, path);
+  }
+  else
+  {
+    *buffer_dir = 0;
+  }
+  strcat(buffer_dir, file);
+
+#ifndef NO_DEBUGGER
+  // maybe checking isendwin() would be better anyway, but only after we scrap
+  // the old debugger, because that won't work when not actually using curses
+  if (!debuggeron) {
+#endif
+  if (mode)
+  {
+    printf("%s_%s: %s\n", func, mode, buffer_dir);
+  }
+  else
+  {
+    printf("%s: %s\n", func, buffer_dir);
+  }
+#ifndef NO_DEBUGGER
+  }
+#endif
+
+  return(buffer_dir);
+}
+
+//This is to keep the modeless functions working right
+static const char *mode = 0;
+static const char *mode_text = 0;
+
+#define strdupcat_internal(x, y) strdupcat_internal(x, y, __func__, mode ? mode : mode_text)
+
+int chdir_internal(const char *path, const char *func, const char *command)
+{
+  printf("%s: %s: %s\n", func, path, command);
+  return(chdir(path));
+}
+
+#define chdir_dir(path) chdir_internal(path, __func__, command);
+
+#endif
+
+
+int access_dir(const char *path, const char *file, int amode)
+{
+#ifdef DEBUG
+  char mode_text[5];
+  strcpy(mode_text, "f");
+  if (amode & R_OK) { strcat(mode_text, "r"); }
+  if (amode & W_OK) { strcat(mode_text, "w"); }
+  if (amode & X_OK) { strcat(mode_text, "x"); }
+#endif
+
+  return(access(strdupcat_internal(path, file), amode));
+}
+
+int stat_dir(const char *path, const char *file, struct stat *buf)
+{
+  return(stat(strdupcat_internal(path, file), buf));
+}
+
+FILE *fopen_dir(const char *path, const char *file, const char *mode)
+{
+  return(fopen(strdupcat_internal(path, file), mode));
+}
+
+gzFile gzopen_dir(const char *path, const char *file, const char *mode)
+{
+  return(gzopen(strdupcat_internal(path, file), mode));
+}
+
+unzFile unzopen_dir(const char *path, const char *file)
+{
+  return(unzOpen(strdupcat_internal(path, file)));
+}
+
+#ifndef NO_JMA
+void load_jma_file_dir(const char *path, const char *file)
+{
+  load_jma_file(strdupcat_internal(path, file));
+}
+#endif
+
+int remove_dir(const char *path, const char *file)
+{
+  return(remove(strdupcat_internal(path, file)));
+}
+
+int mkdir_dir(const char *path, const char *dir)
+{
+  mode_t mmode = 0755;
+  return(mkdir_p(strdupcat_internal(path, dir)));
+}
+
+char *realpath_dir(const char *path, const char *file, char *buf)
+{
+#ifdef __UNIXSDL__
+  return(realpath_tilde(strdupcat_internal(path, file), buf));
+#else
+  return(realpath(strdupcat_internal(path, file), buf));
+#endif
+}
+
+#ifdef __MSDOS__
+char *realpath_sfn_dir(const char *path, const char *file, char *buf)
+{
+  return(realpath_sfn(strdupcat_internal(path, file), buf));
+}
+#endif
+
+FILE *fdreopen_dir(const char *path, const char *file, const char *mode, int fd)
+{
+  //Because DOSBox and Windows is stupid, we're implementing this manually;
+  FILE *fp = fopen(strdupcat_internal(path, file), mode);
+  if (fp)
+  {
+    dup2(fileno(fp), fd);
+  }
+  return(fp);
+}
+
+int system_dir(const char *path, const char *command)
+{
+  int ret_val;
+  chdir_dir(path);
+  ret_val = system(command);
+  chdir(ZStartPath);
+  return(ret_val);
+}
+
+FILE *popen_dir(const char *path, char *command, const char *type)
+{
+  FILE *ret_val;
+  chdir_dir(path);
+  ret_val = popen(command, type);
+  chdir(ZStartPath);
+  return(ret_val);
+}
+
+void natify_slashes(char *str)
+{
+  while (*str)
+  {
+    if (*str == DIR_SLASH_C_OTHER)
+    {
+      *str = DIR_SLASH_C;
+    }
+    str++;
+  }
+}
+
+char *strcutslash(char *str)
+{
+  char *last_char = str+(strlen(str)-1);
+
+  natify_slashes(str);
+  if (*last_char == DIR_SLASH_C)
+  {
+    *last_char = 0;
+  }
+  return(str);
+}
+
+char *strcatslash(char *str)
+{
+  natify_slashes(str);
+  if (str[strlen(str)-1] != DIR_SLASH_C)
+  {
+    strcat(str, DIR_SLASH);
+  }
+  return(str);
+}
+
+void setextension(char *base, const char *ext)
+{
+  char *p = strrchr(base, '.');
+
+  if(p)
+  {
+    strcpy(p+1, ext);
+  }
+  else
+  {
+    strcat(base, ".");
+    strcat(base, ext);
+  }
+}
+
+bool isextension(const char *fname, const char *ext)
+{
+  size_t fname_len = strlen(fname),
+         ext_len = strlen(ext);
+  return((fname[fname_len-(ext_len+1)] == '.') && !strcasecmp(fname+fname_len-ext_len, ext));
+}
+
+void strdirname(char *str)
+{
+  char *p;
+  size_t str_len = strlen(str);
+
+  natify_slashes(str);
+
+  do
+  {
+    str_len--;
+  } while (str_len && (str[str_len] == DIR_SLASH_C));
+  str[str_len+1] = 0;
+
+  p = strrchr(str, DIR_SLASH_C);
+  if (p > str)
+  {
+    *p = 0;
+  }
+  else if (p == str)
+  {
+    str[1] = 0;
+  }
+}
+
+void strbasename(char *str)
+{
+  char *p;
+
+  natify_slashes(str);
+
+  if ((p = strrchr(str, DIR_SLASH_C)))
+  {
+    memmove(str, p+1, strlen(p));
+  }
+}
+
+static bool mkpath_help(char *path, char *element, mode_t mmode)
+{
+  bool success = true;
+  if (*path)
+  {
+    char *p;
+    bool created;
+
+    while (*element == DIR_SLASH_C) { element++; }
+
+    if (*element)
+    {
+      p = strchr(element, DIR_SLASH_C);
+      if (p) { *p = 0; }
+      if ((created = !mkdir_p(path)) || (errno == EEXIST)) //Current path fragment created or already exists
+      {
+        if (p)
+        {
+          *p = DIR_SLASH_C;
+          if (!mkpath_help(path, p+1, mmode)) //If creation of next fragment fails
+          {
+            if (created)
+            {
+              *p = 0;
+              rmdir(path);
+            }
+            success = false;
+          }
+        }
+      }
+      else { success = false; }
+    }
+  }
+  return(success);
+}
+
+bool mkpath(const char *path, mode_t mode)
+{
+  bool success = true;
+  if (path && *path)
+  {
+    char *p = strdup(path);
+    if (p)
+    {
+      natify_slashes(p);
+      success = mkpath_help(p, p, mode);
+      free(p);
+    }
+    else { success = false; }
+  }
+  return(success);
+}
+
+#ifdef __UNIXSDL__
+
+//Like realpath(), but will return the last element as the link it is
+char *realpath_link(const char *path, char *resolved_path)
+{
+  char buffer[PATH_SIZE], *p, *base, *last_element;
+  strcpy(buffer, path);
+  natify_slashes(buffer);
+  p = strrchr(buffer, DIR_SLASH_C);
+  if (p)
+  {
+    *p = 0;
+    base = buffer;
+    last_element = p+1;
+  }
+  else
+  {
+    base = ".";
+    last_element = buffer;
+  }
+
+  p = realpath(base, resolved_path);
+  if (p)
+  {
+    strcatslash(resolved_path);
+    strcat(resolved_path, last_element);
+    return(resolved_path);
+  }
+  return(0);
+}
+
+//realpath() with ~ support
+char *realpath_tilde(const char *path, char *resolved_path)
+{
+  if (*path == '~')
+  {
+    char buffer[PATH_SIZE];
+    struct passwd *userinfo;
+
+    strcpy(buffer, "~");
+    path++;
+
+    if (isalpha(*path))
+    {
+      char *p = buffer+1;
+      while (isalnum(*path))
+      {
+        *p++ = *path++;
+      }
+      *p = 0;
+      if ((userinfo = getpwnam(buffer+1)))
+      {
+        strcpy(buffer, userinfo->pw_dir);
+      }
+    }
+    else
+    {
+      if ((userinfo = getpwuid(getuid())))
+      {
+        strcpy(buffer, userinfo->pw_dir);
+      }
+    }
+    strcat(buffer, path);
+
+    return(realpath(buffer, resolved_path));
+  }
+  return(realpath(path, resolved_path));
+}
+
+#endif
+
+void psr_cfg_run(unsigned char (*psr_func)(const char *), const char *dir, const char *fname)
+{
+  char *path = strdupcat(dir, fname);
+  if (path)
+  {
+    psr_func(path);
+    free(path);
+  }
+  else
+  {
+    psr_func(fname);
+  }
+}
+
